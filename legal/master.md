[What is TuskLang?]


TuskLang is a revolutionary configuration and scripting language that unifies the simplicity of key-value pairs with the power of dynamic runtime operations. Designed as an alternative to JSON and environment files, TuskLang brings grace to configuration management.

## Core Concept

TuskLang treats configuration as code, allowing you to:
- Define static configuration with clean key-value syntax
- Execute dynamic operations using the @ operator
- Seamlessly integrate with web servers and applications
- Handle complex data structures without verbose syntax

## Why TuskLang?

### Simplicity First
```tusk
# Instead of complex JSON
name: "MyApp"
version: "1.0.0"
debug: true
```

### Dynamic When Needed
```tusk
# Runtime values with @ operator
hostname: @http.host
timestamp: @request.timestamp
user_data: @query("SELECT * FROM users WHERE id = ?", @request.query.id)
```

### Human-Readable
Unlike JSON's strict syntax or YAML's whitespace sensitivity, TuskLang prioritizes readability:
```tusk
# Comments are first-class citizens
server_config:
    host: "localhost"  # Development server
    port: 8080        # Default port
    ssl: false        # Enable in production
```

## Key Features

1. **Dual Assignment Operators**: Use `:` for static values, `=` for dynamic expressions
2. **Native @ Operations**: Built-in functions for common tasks
3. **Type Safety**: Optional type hints for better validation
4. **Heredoc Support**: Clean multiline strings
5. **Reference System**: Link values without duplication
6. **Extensible**: Custom operators and functions

## Use Cases

- **Web Applications**: Dynamic configuration based on requests
- **API Servers**: Route definitions with embedded logic
- **Microservices**: Service discovery and configuration
- **Build Tools**: Project configuration files
- **Container Orchestration**: Dynamic environment setup

## Design Philosophy

TuskLang embodies "digital grace" - making the complex simple without sacrificing power. It believes configuration should be:
- Readable by humans
- Writable without documentation
- Powerful when complexity is needed
- Forgiving of common mistakes

## Example: Complete Application Config

```tusk
# Application metadata
app:
    name: "TuskApp"
    version: "2.0.0"
    environment: @env.APP_ENV || "development"

# Database configuration
database:
    driver: "postgresql"
    host: @env.DB_HOST || "localhost"
    port: @env.DB_PORT || 5432
    name: @env.DB_NAME || "tuskapp_dev"
    
    # Dynamic connection string
    connection_string = "postgresql://${username}:${password}@${host}:${port}/${name}"

# Server configuration
server:
    host: "0.0.0.0"
    port: @env.PORT || 3000
    
    # SSL configuration based on environment
    ssl: @if(@env.APP_ENV == "production", {
        enabled: true
        cert: "/etc/ssl/certs/server.crt"
        key: "/etc/ssl/private/server.key"
    }, {
        enabled: false
    })

# Feature flags
features:
    new_ui: @cache("feature_new_ui", @query("SELECT enabled FROM features WHERE name = 'new_ui'"))
    analytics: true
    debug_mode: @env.APP_ENV != "production"
```

## Getting Started

TuskLang files use the `.tsk` extension and can be:
- Parsed as configuration files
- Executed as scripts
- Embedded in web applications
- Used as templates

Continue to the next section to understand TuskLang's philosophy and design principles.
---

[TuskLang Philosophy]


TuskLang is built on the principle of "digital grace" - technology that transcends mere functionality to become an instrument of deeper purpose. This philosophy shapes every aspect of the language.

## Core Principles

### 1. Grace Over Complexity
Configuration should be a blessing, not a burden. TuskLang makes the simple things simple and the complex things possible.

```tusk
# Simple stays simple
name: "MyApp"

# Complex becomes manageable
dynamic_config = @optimize({
    cache_ttl: 3600
    strategy: "adaptive"
})
```

### 2. Human-First Design
Code is read far more often than it's written. TuskLang prioritizes human comprehension:

```tusk
# Self-documenting syntax
user_settings:
    theme: "dark"              # Visual preference
    notifications: enabled     # Push notifications
    language: "en-US"         # Locale setting
```

### 3. Forgiveness by Default
Errors should guide, not punish. TuskLang provides graceful fallbacks:

```tusk
# Fallback values prevent crashes
api_key: @env.API_KEY || "development-key"
timeout: @env.TIMEOUT || 30
```

### 4. Power Through Simplicity
Complex operations shouldn't require complex syntax:

```tusk
# One line does what would take many in other languages
user_data: @cache("user_${id}", @query("SELECT * FROM users WHERE id = ?", @request.query.id))
```

## Design Decisions

### Why Not JSON?
JSON lacks:
- Comments for documentation
- Dynamic values
- Readable multiline strings
- Type flexibility
- Runtime operations

### Why Not YAML?
YAML suffers from:
- Whitespace sensitivity
- Complex specification
- Security vulnerabilities
- Ambiguous syntax

### Why Not TOML?
TOML limitations:
- Verbose table syntax
- Limited nesting
- No dynamic operations
- Rigid structure

## The @ Operator Philosophy

The @ symbol represents "at runtime" - operations that happen when needed, not when defined:

```tusk
# Static definition
static_port: 8080

# Dynamic resolution
dynamic_port = @env.PORT || 8080

# The @ signifies "reach out and get this when needed"
current_time: @request.timestamp
user_locale: @request.headers.accept-language
```

## Configuration as Code

TuskLang treats configuration as first-class code:

```tusk
# Not just data, but logic
rate_limit:
    enabled: @env.RATE_LIMIT_ENABLED
    max_requests = @if(@env.APP_ENV == "production", 100, 1000)
    window_seconds: 60
    
    # Embedded business logic
    check = @learn({
        pattern: "rate_limit_${ip}"
        threshold: @self.max_requests
        window: @self.window_seconds
    })
```

## Principle of Least Surprise

TuskLang behaves as developers expect:

```tusk
# Strings don't need quotes (but can have them)
name: MyApplication
name: "MyApplication"  # Both work

# Numbers are numbers
port: 8080
pi: 3.14159

# Booleans are obvious
enabled: true
disabled: false

# Objects nest naturally
database:
    primary:
        host: "db1.example.com"
    replica:
        host: "db2.example.com"
```

## Progressive Enhancement

Start simple, add complexity only when needed:

```tusk
# Level 1: Static configuration
app_name: "MyApp"

# Level 2: Environment variables
app_name: @env.APP_NAME || "MyApp"

# Level 3: Conditional logic
app_name = @if(@env.DEPLOY_ENV == "staging", 
    "MyApp (Staging)", 
    @env.APP_NAME || "MyApp"
)

# Level 4: Dynamic computation
app_name = @optimize({
    base: @env.APP_NAME || "MyApp"
    suffix: @if(@env.DEPLOY_ENV != "production", " (${@env.DEPLOY_ENV})", "")
    cache: true
})
```

## Error Philosophy

Errors in TuskLang are:
1. **Descriptive**: Clear about what went wrong
2. **Helpful**: Suggest fixes
3. **Contextual**: Show where the error occurred
4. **Graceful**: Provide fallback behavior when possible

```tusk
# This error:
port: @env.PORT

# Produces: "Warning: @env.PORT is undefined. Consider adding a fallback: @env.PORT || 8080"

# Better:
port: @env.PORT || 8080
```

## Community Values

TuskLang development follows these values:

1. **Inclusivity**: Welcome all skill levels
2. **Clarity**: Prefer explicit over implicit
3. **Pragmatism**: Real-world use cases drive features
4. **Stability**: Breaking changes are rare and well-communicated
5. **Joy**: Using TuskLang should spark joy, not frustration

## The Future

TuskLang evolves based on:
- Real-world usage patterns
- Community feedback
- Performance requirements
- Security considerations

But always maintaining the core philosophy: Configuration with grace.

## Summary

TuskLang isn't just another configuration language - it's a philosophy of making software configuration a source of clarity rather than confusion, power rather than problems, and ultimately, grace rather than grief.
---

[Installing TuskLang on Ubuntu]


This guide covers installing TuskLang on Ubuntu and Debian-based distributions.

## System Requirements

- Ubuntu 20.04 LTS or newer (18.04 with backports)
- 64-bit architecture (x86_64 or ARM64)
- 50MB free disk space
- Internet connection for package download

## Quick Install (Recommended)

### Using the Official Script

```bash
# Download and run the installer
curl -fsSL https://get.tusklang.org | bash

# Or with wget
wget -qO- https://get.tusklang.org | bash
```

### Verify Installation

```bash
tusk --version
# Output: TuskLang 1.0.0
```

## Package Manager Installation

### Using APT Repository

1. Add the TuskLang repository key:
```bash
curl -fsSL https://packages.tusklang.org/tusklang.gpg | sudo gpg --dearmor -o /usr/share/keyrings/tusklang-archive-keyring.gpg
```

2. Add the repository:
```bash
echo "deb [signed-by=/usr/share/keyrings/tusklang-archive-keyring.gpg] https://packages.tusklang.org/ubuntu $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/tusklang.list
```

3. Update and install:
```bash
sudo apt update
sudo apt install tusklang
```

### Using Snap

```bash
sudo snap install tusklang --classic
```

## Manual Installation

### Download Binary

1. Download the latest release:
```bash
wget https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-linux-amd64.tar.gz
```

2. Extract the archive:
```bash
tar -xzf tusklang-linux-amd64.tar.gz
```

3. Move to system path:
```bash
sudo mv tusk /usr/local/bin/
sudo chmod +x /usr/local/bin/tusk
```

## Building from Source

### Prerequisites

```bash
# Install build dependencies
sudo apt update
sudo apt install -y build-essential git golang-go
```

### Build Steps

1. Clone the repository:
```bash
git clone https://github.com/cyber-boost/tusk.git
cd tusk
```

2. Build the binary:
```bash
make build
```

3. Install system-wide:
```bash
sudo make install
```

## Post-Installation Setup

### Shell Integration

Add TuskLang to your shell:

**Bash:**
```bash
echo 'eval "$(tusk --shell-init bash)"' >> ~/.bashrc
source ~/.bashrc
```

**Zsh:**
```bash
echo 'eval "$(tusk --shell-init zsh)"' >> ~/.zshrc
source ~/.zshrc
```

### System Service Integration

For server applications, create a systemd service:

```ini
# /etc/systemd/system/tuskapp.service
[Unit]
Description=TuskLang Application
After=network.target

[Service]
Type=simple
User=tuskapp
WorkingDirectory=/opt/tuskapp
ExecStart=/usr/local/bin/tusk run app.tsk
Restart=always

[Install]
WantedBy=multi-user.target
```

Enable the service:
```bash
sudo systemctl enable tuskapp
sudo systemctl start tuskapp
```

## Configuration

### Global Configuration

Create system-wide configuration:

```bash
sudo mkdir -p /etc/tusklang
sudo tusk init --global > /etc/tusklang/config.tsk
```

### User Configuration

Create user-specific configuration:

```bash
mkdir -p ~/.config/tusklang
tusk init > ~/.config/tusklang/config.tsk
```

## Development Tools

### VSCode Extension

```bash
code --install-extension tusklang.vscode-tusk
```

### Vim Plugin

```vim
" Add to ~/.vimrc
Plug 'tusklang/vim-tusk'
```

### Syntax Highlighting

Install syntax highlighting for various editors:

```bash
# Nano
sudo cp /usr/share/tusklang/nano/tusk.nanorc /usr/share/nano/
echo "include /usr/share/nano/tusk.nanorc" >> ~/.nanorc

# Gedit
sudo cp /usr/share/tusklang/gtksourceview/tusk.lang /usr/share/gtksourceview-4/language-specs/
```

## Troubleshooting

### Permission Denied

If you get permission errors:
```bash
# Fix permissions
sudo chmod +x /usr/local/bin/tusk

# Or reinstall with proper permissions
sudo apt reinstall tusklang
```

### Command Not Found

If `tusk` command is not found:
```bash
# Check if installed
which tusk

# Add to PATH if needed
echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc
```

### Library Dependencies

If you encounter library errors:
```bash
# Install runtime dependencies
sudo apt install -y libssl1.1 libcurl4
```

### Ubuntu-Specific Issues

**Ubuntu 18.04:**
```bash
# Enable backports
sudo add-apt-repository "deb http://archive.ubuntu.com/ubuntu $(lsb_release -sc)-backports main universe"
sudo apt update
```

**ARM64 (Raspberry Pi):**
```bash
# Download ARM64 version
wget https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-linux-arm64.tar.gz
```

## Uninstallation

### Package Manager

```bash
# APT
sudo apt remove tusklang
sudo apt autoremove

# Snap
sudo snap remove tusklang
```

### Manual Removal

```bash
sudo rm /usr/local/bin/tusk
rm -rf ~/.config/tusklang
```

## Next Steps

- Verify your installation: [007-verify-installation.md](007-verify-installation.md)
- Create your first TuskLang file: [008-hello-world.md](008-hello-world.md)
- Learn the CLI: [010-cli-overview.md](010-cli-overview.md)
---

[Installing TuskLang with Docker]


Docker provides a consistent, isolated environment for running TuskLang across any platform.

## Prerequisites

- Docker 20.10+ installed
- Docker Compose 2.0+ (optional, for multi-container setups)
- Basic understanding of Docker concepts

## Official Docker Image

### Quick Start

Pull and run the official TuskLang image:

```bash
# Pull the latest image
docker pull tusklang/tusk:latest

# Run interactive shell
docker run -it tusklang/tusk:latest

# Run a specific .tsk file
docker run -v $(pwd):/app tusklang/tusk:latest tusk run /app/config.tsk
```

### Available Tags

- `latest` - Latest stable release
- `1.0.0` - Specific version
- `alpine` - Minimal Alpine Linux base
- `ubuntu` - Ubuntu-based image
- `dev` - Development builds (unstable)

## Using TuskLang in Docker

### Basic Dockerfile

Create a `Dockerfile` for your TuskLang application:

```dockerfile
# Use official TuskLang base image
FROM tusklang/tusk:latest

# Set working directory
WORKDIR /app

# Copy your .tsk files
COPY . /app

# Run your application
CMD ["tusk", "run", "app.tsk"]
```

### Multi-Stage Build

For production deployments with minimal image size:

```dockerfile
# Build stage
FROM tusklang/tusk:latest AS builder
WORKDIR /build
COPY . .
RUN tusk compile app.tsk -o app

# Runtime stage
FROM alpine:latest
RUN apk add --no-cache ca-certificates
COPY --from=builder /build/app /usr/local/bin/
CMD ["app"]
```

### Alpine-Based Image

For the smallest possible image:

```dockerfile
FROM tusklang/tusk:alpine

# Install additional dependencies if needed
RUN apk add --no-cache curl jq

WORKDIR /app
COPY config.tsk .

# Health check
HEALTHCHECK --interval=30s --timeout=3s \
  CMD tusk check config.tsk || exit 1

CMD ["tusk", "serve", "config.tsk"]
```

## Docker Compose Integration

### Basic Compose File

Create `docker-compose.yml`:

```yaml
version: '3.8'

services:
  tuskapp:
    image: tusklang/tusk:latest
    volumes:
      - ./app:/app
    environment:
      - TUSK_ENV=production
      - DB_HOST=postgres
    command: tusk run /app/server.tsk
    ports:
      - "8080:8080"
    depends_on:
      - postgres

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: tuskapp
      POSTGRES_USER: tusk
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### Development Compose

For development with hot reload:

```yaml
version: '3.8'

services:
  tuskdev:
    image: tusklang/tusk:latest
    volumes:
      - .:/app
      - tusk_cache:/tmp/tusk
    environment:
      - TUSK_ENV=development
      - TUSK_HOT_RELOAD=true
    command: tusk dev /app/server.tsk
    ports:
      - "3000:3000"
    networks:
      - tusknet

  redis:
    image: redis:alpine
    networks:
      - tusknet

networks:
  tusknet:
    driver: bridge

volumes:
  tusk_cache:
```

## Volume Management

### Persistent Configuration

```bash
# Create named volume for configuration
docker volume create tusk-config

# Run with persistent config
docker run -v tusk-config:/etc/tusklang tusklang/tusk:latest
```

### Development Workflow

```bash
# Mount current directory
docker run -it -v $(pwd):/workspace -w /workspace tusklang/tusk:latest bash

# Inside container
tusk init
tusk run app.tsk
```

## Environment Variables

### Pass Environment Variables

```bash
# Single variable
docker run -e API_KEY=secret tusklang/tusk:latest

# Multiple variables
docker run \
  -e DB_HOST=localhost \
  -e DB_PORT=5432 \
  -e APP_ENV=production \
  tusklang/tusk:latest

# From .env file
docker run --env-file .env tusklang/tusk:latest
```

### TuskLang-Specific Variables

```bash
# Configure TuskLang runtime
docker run \
  -e TUSK_LOG_LEVEL=debug \
  -e TUSK_CACHE_DIR=/tmp/tusk \
  -e TUSK_PLUGINS_DIR=/opt/tusk/plugins \
  tusklang/tusk:latest
```

## Networking

### Container Communication

```yaml
# docker-compose.yml
services:
  api:
    image: tusklang/tusk:latest
    environment:
      - BACKEND_URL=http://backend:8080
    networks:
      - app-network

  backend:
    image: tusklang/tusk:latest
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
```

### Host Networking

```bash
# Use host network (Linux only)
docker run --network host tusklang/tusk:latest
```

## Building Custom Images

### Extended Functionality

```dockerfile
FROM tusklang/tusk:latest

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    git \
    && rm -rf /var/lib/apt/lists/*

# Install TuskLang plugins
RUN tusk plugin install database http cache

# Copy custom operators
COPY operators/ /usr/local/lib/tusk/operators/

# Set up application
WORKDIR /app
COPY . .

# Compile if needed
RUN tusk compile server.tsk

EXPOSE 8080
CMD ["tusk", "serve", "server.tsk"]
```

### Security Hardening

```dockerfile
FROM tusklang/tusk:alpine

# Create non-root user
RUN addgroup -g 1001 -S tusk && \
    adduser -u 1001 -S tusk -G tusk

# Copy files with correct ownership
COPY --chown=tusk:tusk . /app

# Switch to non-root user
USER tusk

WORKDIR /app
CMD ["tusk", "run", "app.tsk"]
```

## Debugging in Docker

### Interactive Debugging

```bash
# Start with debug mode
docker run -it -e TUSK_DEBUG=true tusklang/tusk:latest

# Attach to running container
docker exec -it <container_id> tusk repl
```

### Logging

```yaml
# docker-compose.yml with logging
services:
  app:
    image: tusklang/tusk:latest
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    environment:
      - TUSK_LOG_FORMAT=json
      - TUSK_LOG_LEVEL=info
```

## Performance Optimization

### Caching Layers

```dockerfile
FROM tusklang/tusk:latest

# Cache dependencies first
COPY requirements.tsk .
RUN tusk install

# Then copy application code
COPY . .
RUN tusk build
```

### Resource Limits

```yaml
# docker-compose.yml
services:
  tuskapp:
    image: tusklang/tusk:latest
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M
```

## CI/CD Integration

### GitHub Actions

```yaml
# .github/workflows/docker.yml
name: Docker Build

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .
      
      - name: Test with TuskLang
        run: docker run myapp:${{ github.sha }} tusk test
```

### GitLab CI

```yaml
# .gitlab-ci.yml
test:
  image: tusklang/tusk:latest
  script:
    - tusk test
    - tusk lint

build:
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

## Troubleshooting

### Common Issues

**Permission Denied:**
```bash
# Fix file permissions
docker run --user $(id -u):$(id -g) -v $(pwd):/app tusklang/tusk:latest
```

**Cannot Find File:**
```bash
# Use absolute paths in container
docker run -v $(pwd):/data tusklang/tusk:latest tusk run /data/app.tsk
```

**Memory Issues:**
```bash
# Increase memory limit
docker run -m 2g tusklang/tusk:latest
```

## Next Steps

- Learn Docker-specific TuskLang patterns
- Set up development environment: [009-file-structure.md](009-file-structure.md)
- Deploy to Kubernetes with TuskLang configs
---

[Installing TuskLang on macOS]


This guide covers installing TuskLang on macOS systems (Intel and Apple Silicon).

## System Requirements

- macOS 10.15 (Catalina) or newer
- 64-bit processor (Intel x86_64 or Apple Silicon ARM64)
- 50MB free disk space
- Xcode Command Line Tools (for building from source)

## Quick Install (Recommended)

### Using Homebrew

The easiest way to install TuskLang on macOS:

```bash
# Install Homebrew if you haven't already
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Add TuskLang tap
brew tap tusklang/tusk

# Install TuskLang
brew install tusklang
```

### Using the Official Installer

```bash
# Download and run the installer
curl -fsSL https://get.tusklang.org | bash

# The installer automatically detects your architecture (Intel/M1)
```

## Architecture-Specific Installation

### Apple Silicon (M1/M2/M3)

```bash
# Download ARM64 binary directly
curl -L https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-darwin-arm64.tar.gz -o tusklang.tar.gz

# Extract and install
tar -xzf tusklang.tar.gz
sudo mv tusk /usr/local/bin/
sudo chmod +x /usr/local/bin/tusk
```

### Intel Macs

```bash
# Download x86_64 binary
curl -L https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-darwin-amd64.tar.gz -o tusklang.tar.gz

# Extract and install
tar -xzf tusklang.tar.gz
sudo mv tusk /usr/local/bin/
sudo chmod +x /usr/local/bin/tusk
```

## Package Managers

### MacPorts

```bash
# Install via MacPorts
sudo port install tusklang
```

### Nix

```bash
# Install via Nix
nix-env -iA nixpkgs.tusklang
```

## Building from Source

### Prerequisites

Install Xcode Command Line Tools:
```bash
xcode-select --install
```

Install build dependencies:
```bash
# Using Homebrew
brew install go git

# Or download Go directly
curl -L https://go.dev/dl/go1.21.darwin-amd64.pkg -o go.pkg
sudo installer -pkg go.pkg -target /
```

### Build Steps

1. Clone the repository:
```bash
git clone https://github.com/cyber-boost/tusk.git
cd tusk
```

2. Build for your architecture:
```bash
# Auto-detect architecture
make build

# Or specify architecture
make build-darwin-arm64  # For M1/M2/M3
make build-darwin-amd64  # For Intel
```

3. Install system-wide:
```bash
sudo make install
```

## Shell Integration

### Zsh (Default on macOS)

Add to your `~/.zshrc`:
```bash
# TuskLang completion and aliases
eval "$(tusk --shell-init zsh)"

# Add to PATH if installed manually
export PATH="/usr/local/bin:$PATH"
```

Reload your shell:
```bash
source ~/.zshrc
```

### Bash

If you use bash, add to `~/.bash_profile`:
```bash
# TuskLang completion
eval "$(tusk --shell-init bash)"

# Add to PATH
export PATH="/usr/local/bin:$PATH"
```

### Fish

Add to `~/.config/fish/config.fish`:
```fish
# TuskLang initialization
tusk --shell-init fish | source
```

## macOS-Specific Configuration

### Gatekeeper and Security

If macOS blocks the binary:

```bash
# Remove quarantine attribute
xattr -d com.apple.quarantine /usr/local/bin/tusk

# Or allow in System Preferences
# System Preferences > Security & Privacy > General > "Allow apps downloaded from"
```

### Launch Agents

Create a launch agent for TuskLang services:

```xml
<!-- ~/Library/LaunchAgents/org.tusklang.agent.plist -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>org.tusklang.agent</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/tusk</string>
        <string>serve</string>
        <string>/Users/YOUR_USERNAME/tuskapp/server.tsk</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>/tmp/tusklang.log</string>
    <key>StandardErrorPath</key>
    <string>/tmp/tusklang.error.log</string>
</dict>
</plist>
```

Load the agent:
```bash
launchctl load ~/Library/LaunchAgents/org.tusklang.agent.plist
```

## Development Tools

### VSCode

```bash
# Install VSCode if needed
brew install --cask visual-studio-code

# Install TuskLang extension
code --install-extension tusklang.vscode-tusk
```

### Sublime Text

```bash
# Install Package Control first, then:
# Cmd+Shift+P > Package Control: Install Package > TuskLang
```

### Vim/Neovim

```bash
# Using vim-plug
# Add to ~/.vimrc or ~/.config/nvim/init.vim
Plug 'tusklang/vim-tusk'

# Using Homebrew
brew install neovim
```

### JetBrains IDEs

Install the TuskLang plugin from the JetBrains Marketplace.

## Environment Setup

### Global Configuration

```bash
# Create config directory
mkdir -p ~/.config/tusklang

# Initialize global config
tusk init --global > ~/.config/tusklang/config.tsk
```

### Project Templates

```bash
# Create project templates directory
mkdir -p ~/Library/Application\ Support/TuskLang/templates

# Add custom template
cat > ~/Library/Application\ Support/TuskLang/templates/webapp.tsk << 'EOF'
# Web Application Template
app:
    name: @project.name
    version: "1.0.0"
    
server:
    port: @env.PORT || 3000
    host: "localhost"
EOF
```

## Troubleshooting

### Command Not Found

If `tusk` is not found after installation:

```bash
# Check installation location
which tusk

# Add to PATH in ~/.zshrc
echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc

# For Homebrew on M1 Macs
echo 'export PATH="/opt/homebrew/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc
```

### Permission Issues

```bash
# Fix permissions
sudo chmod +x /usr/local/bin/tusk

# Fix ownership
sudo chown $(whoami) /usr/local/bin/tusk
```

### Rosetta 2 (M1 Macs running Intel binaries)

```bash
# Install Rosetta 2 if needed
softwareupdate --install-rosetta

# Force Intel mode (not recommended)
arch -x86_64 tusk run app.tsk
```

### SSL Certificate Issues

```bash
# Update certificates
brew install ca-certificates

# Or update macOS
softwareupdate --all --install --force
```

## Performance Optimization

### File System Events

For better performance with file watching:

```bash
# Increase file descriptor limit
echo "ulimit -n 10240" >> ~/.zshrc

# For system-wide changes, create:
# /Library/LaunchDaemons/limit.maxfiles.plist
```

### Memory Management

```bash
# Set TuskLang memory limits
export TUSK_MAX_MEMORY=4G
export TUSK_GC_INTERVAL=1000
```

## Uninstallation

### Homebrew

```bash
brew uninstall tusklang
brew untap tusklang/tusk
```

### Manual Removal

```bash
# Remove binary
sudo rm /usr/local/bin/tusk

# Remove configuration
rm -rf ~/.config/tusklang
rm -rf ~/Library/Application\ Support/TuskLang

# Remove launch agents
launchctl unload ~/Library/LaunchAgents/org.tusklang.agent.plist
rm ~/Library/LaunchAgents/org.tusklang.agent.plist
```

## Integration with macOS Features

### Spotlight Integration

Create a Spotlight importer for .tsk files:

```bash
# Install importer
cp -r /usr/local/share/tusklang/TuskLangImporter.mdimporter ~/Library/Spotlight/
```

### Quick Look Plugin

```bash
# Install Quick Look plugin for .tsk files
cp -r /usr/local/share/tusklang/TuskLangQL.qlgenerator ~/Library/QuickLook/
qlmanage -r
```

## Next Steps

- Verify your installation: [007-verify-installation.md](007-verify-installation.md)
- Create your first TuskLang project: [008-hello-world.md](008-hello-world.md)
- Set up your development environment: [009-file-structure.md](009-file-structure.md)
---

[Installing TuskLang on Windows]


This guide covers installing TuskLang on Windows systems (Windows 10 and later).

## System Requirements

- Windows 10 version 1903 or newer (64-bit)
- Windows 11 (all versions)
- 50MB free disk space
- Administrator privileges for system-wide installation

## Quick Install Methods

### Using Winget (Windows Package Manager)

The recommended method for Windows 11 and updated Windows 10:

```powershell
# Install via winget
winget install TuskLang.Tusk

# Verify installation
tusk --version
```

### Using Chocolatey

If you have Chocolatey installed:

```powershell
# Run as Administrator
choco install tusklang

# Or with specific version
choco install tusklang --version=1.0.0
```

### Using Scoop

For user-level installation without admin rights:

```powershell
# Add the TuskLang bucket
scoop bucket add tusklang https://github.com/cyber-boost/scoop-bucket

# Install TuskLang
scoop install tusklang
```

## Manual Installation

### Download and Install

1. Download the installer:
   - 64-bit: [tusklang-windows-amd64.msi](https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-windows-amd64.msi)
   - ARM64: [tusklang-windows-arm64.msi](https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-windows-arm64.msi)

2. Run the MSI installer:
   - Double-click the downloaded file
   - Follow the installation wizard
   - Choose installation directory (default: `C:\Program Files\TuskLang`)

### Portable Installation

For a portable installation without installer:

```powershell
# Create directory
New-Item -ItemType Directory -Force -Path C:\Tools\TuskLang

# Download portable version
Invoke-WebRequest -Uri "https://github.com/cyber-boost/tusk/releases/latest/download/tusklang-windows-amd64.zip" -OutFile "tusklang.zip"

# Extract
Expand-Archive -Path "tusklang.zip" -DestinationPath "C:\Tools\TuskLang"

# Add to PATH manually (see below)
```

## Setting up PATH

### Automatic (Installer)

The MSI installer automatically adds TuskLang to your PATH.

### Manual PATH Configuration

1. **Via PowerShell (Administrator):**
```powershell
# Add to system PATH
[Environment]::SetEnvironmentVariable(
    "Path",
    [Environment]::GetEnvironmentVariable("Path", [EnvironmentVariableTarget]::Machine) + ";C:\Tools\TuskLang",
    [EnvironmentVariableTarget]::Machine
)
```

2. **Via GUI:**
   - Right-click "This PC" → Properties
   - Click "Advanced system settings"
   - Click "Environment Variables"
   - Under "System variables", select "Path" and click "Edit"
   - Click "New" and add `C:\Tools\TuskLang`
   - Click "OK" to save

3. **Verify PATH:**
```powershell
# Restart PowerShell/Command Prompt first
tusk --version
```

## Windows Terminal Integration

### PowerShell Profile

Add to your PowerShell profile (`$PROFILE`):

```powershell
# Create profile if it doesn't exist
if (!(Test-Path -Path $PROFILE)) {
    New-Item -ItemType File -Path $PROFILE -Force
}

# Add TuskLang initialization
Add-Content $PROFILE @"
# TuskLang shell integration
if (Get-Command tusk -ErrorAction SilentlyContinue) {
    Invoke-Expression (tusk --shell-init powershell)
}
"@
```

### Command Prompt

Create a batch file for Command Prompt integration:

```batch
REM Save as C:\Users\%USERNAME%\tusklang-init.cmd
@echo off
tusk --shell-init cmd > %TEMP%\tusk-init.cmd
call %TEMP%\tusk-init.cmd
del %TEMP%\tusk-init.cmd
```

### Windows Terminal Settings

Add a custom profile for TuskLang REPL:

```json
{
    "profiles": {
        "list": [
            {
                "name": "TuskLang REPL",
                "commandline": "tusk repl",
                "icon": "C:\\Program Files\\TuskLang\\tusk-icon.ico",
                "startingDirectory": "%USERPROFILE%\\Documents\\TuskProjects"
            }
        ]
    }
}
```

## Building from Source

### Prerequisites

1. Install Git:
```powershell
winget install Git.Git
```

2. Install Go:
```powershell
winget install GoLang.Go
```

3. Install Build Tools:
```powershell
# Visual Studio Build Tools
winget install Microsoft.VisualStudio.2022.BuildTools
```

### Build Steps

```powershell
# Clone repository
git clone https://github.com/cyber-boost/tusk.git
cd tusk

# Build
go build -o tusk.exe cmd/tusk/main.go

# Install
Copy-Item tusk.exe "C:\Program Files\TuskLang\" -Force
```

## Windows-Specific Features

### File Associations

Associate .tsk files with TuskLang:

```powershell
# Run as Administrator
cmd /c assoc .tsk=TuskLangFile
cmd /c ftype TuskLangFile="C:\Program Files\TuskLang\tusk.exe" "%1" %*
```

### Context Menu Integration

Add "Run with TuskLang" to context menu:

```powershell
# Create registry entry
New-Item -Path "HKCR:\TuskLangFile\shell\Run with TuskLang\command" -Force
Set-ItemProperty -Path "HKCR:\TuskLangFile\shell\Run with TuskLang\command" -Name "(Default)" -Value '"C:\Program Files\TuskLang\tusk.exe" run "%1"'
```

### Windows Service

Create a Windows service for TuskLang applications:

```powershell
# Using NSSM (Non-Sucking Service Manager)
choco install nssm

# Install service
nssm install TuskLangApp "C:\Program Files\TuskLang\tusk.exe" "serve C:\MyApp\server.tsk"

# Configure service
nssm set TuskLangApp AppDirectory C:\MyApp
nssm set TuskLangApp DisplayName "TuskLang Application"
nssm set TuskLangApp Description "My TuskLang Web Application"

# Start service
nssm start TuskLangApp
```

## Development Environment

### Visual Studio Code

```powershell
# Install VS Code
winget install Microsoft.VisualStudioCode

# Install TuskLang extension
code --install-extension tusklang.vscode-tusk
```

### Visual Studio

Install the TuskLang extension from Visual Studio Marketplace.

### Notepad++

1. Download TuskLang syntax highlighter
2. Copy to `%APPDATA%\Notepad++\userDefineLangs\`
3. Restart Notepad++

## WSL Integration

### Using TuskLang in WSL2

```bash
# Inside WSL2
curl -fsSL https://get.tusklang.org | bash

# Or use Windows binary from WSL
alias tusk='/mnt/c/Program\ Files/TuskLang/tusk.exe'
```

### Sharing Files

```powershell
# Access WSL files from Windows TuskLang
tusk run "\\wsl$\Ubuntu\home\user\project.tsk"

# Access Windows files from WSL TuskLang
tusk run /mnt/c/Users/YourName/project.tsk
```

## Troubleshooting

### Antivirus Issues

Some antivirus software may flag TuskLang. To resolve:

1. Add exclusion for `C:\Program Files\TuskLang\`
2. Or download from official sources only
3. Submit false positive report to your AV vendor

### Permission Errors

```powershell
# Run as Administrator
Start-Process powershell -Verb RunAs

# Then retry installation
```

### Path Not Updated

```powershell
# Force PATH refresh
$env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")

# Or restart your terminal
```

### Windows Defender SmartScreen

If SmartScreen blocks the installer:

1. Right-click the file
2. Select Properties
3. Check "Unblock"
4. Click Apply and OK

## Performance Optimization

### Windows Defender Exclusions

Add TuskLang to Defender exclusions for better performance:

```powershell
# Run as Administrator
Add-MpPreference -ExclusionPath "C:\Program Files\TuskLang"
Add-MpPreference -ExclusionProcess "tusk.exe"
```

### File System Performance

```powershell
# Enable long path support
New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled" -Value 1 -PropertyType DWORD -Force
```

## Uninstallation

### Package Managers

```powershell
# Winget
winget uninstall TuskLang.Tusk

# Chocolatey
choco uninstall tusklang

# Scoop
scoop uninstall tusklang
```

### Manual Uninstallation

1. Remove from Control Panel → Programs
2. Or manually delete:

```powershell
# Remove program files
Remove-Item -Recurse -Force "C:\Program Files\TuskLang"

# Remove user data
Remove-Item -Recurse -Force "$env:APPDATA\TuskLang"

# Remove from PATH (manually edit Environment Variables)
```

## Integration with Windows Features

### Task Scheduler

Create scheduled tasks for TuskLang scripts:

```powershell
# Create scheduled task
$action = New-ScheduledTaskAction -Execute "C:\Program Files\TuskLang\tusk.exe" -Argument "run C:\Scripts\daily-task.tsk"
$trigger = New-ScheduledTaskTrigger -Daily -At 9am
Register-ScheduledTask -TaskName "TuskLangDaily" -Action $action -Trigger $trigger
```

### PowerShell Module

```powershell
# Install TuskLang PowerShell module
Install-Module -Name TuskLang -Scope CurrentUser

# Use in scripts
Import-Module TuskLang
Invoke-TuskScript -Path ".\config.tsk"
```

## Next Steps

- Verify installation: [007-verify-installation.md](007-verify-installation.md)
- Create first project: [008-hello-world.md](008-hello-world.md)
- Learn Windows-specific patterns: [009-file-structure.md](009-file-structure.md)
---

[Verifying Your TuskLang Installation]


After installing TuskLang, it's important to verify that everything is working correctly. This guide will walk you through comprehensive verification steps.

## Basic Verification

### Check Version

The simplest verification is checking the installed version:

```bash
tusk --version
# Expected output: TuskLang 1.0.0 (or your installed version)
```

### Check Installation Path

Verify where TuskLang is installed:

```bash
# Unix/Linux/macOS
which tusk
# Expected: /usr/local/bin/tusk or similar

# Windows PowerShell
Get-Command tusk
# Expected: C:\Program Files\TuskLang\tusk.exe or similar
```

## Command Line Interface

### Help Command

Verify the CLI is responsive:

```bash
tusk --help
```

Expected output should show:
```
TuskLang - Configuration with Grace

Usage:
  tusk [command] [flags]

Commands:
  run       Execute a TuskLang file
  serve     Start a TuskLang server
  compile   Compile TuskLang to binary
  repl      Start interactive REPL
  check     Validate TuskLang syntax
  format    Format TuskLang files
  init      Initialize new project
  test      Run tests
  version   Show version information

Flags:
  -h, --help     Show help
  -v, --verbose  Verbose output
  --debug        Debug mode
```

### REPL Test

Start the interactive REPL:

```bash
tusk repl
```

You should see:
```
TuskLang REPL v1.0.0
Type 'help' for commands, 'exit' to quit
tusk>
```

Try some basic commands:
```tusk
tusk> name: "Test"
tusk> @print(name)
Test
tusk> exit
```

## Feature Verification

### Create Test File

Create a test file to verify file operations:

```bash
# Create test directory
mkdir tusk-test
cd tusk-test

# Create test file
cat > test.tsk << 'EOF'
# Test TuskLang file
app_name: "Verification Test"
version: "1.0.0"

# Test @ operator
timestamp: @request.timestamp
platform: @tusk.platform

# Test computation
result = 2 + 2

# Test object
config:
    debug: true
    port: 8080
EOF
```

### Run Test File

```bash
tusk run test.tsk
```

Expected output:
```
Running test.tsk...
✓ File parsed successfully
✓ All operations completed
```

### Syntax Check

Verify the syntax checker:

```bash
tusk check test.tsk
```

Expected output:
```
✓ test.tsk: Valid TuskLang syntax
  - 0 errors
  - 0 warnings
```

## Environment Verification

### Check Environment Variables

```bash
# Create env test file
cat > env-test.tsk << 'EOF'
# Environment test
home: @env.HOME || "not set"
path: @env.PATH || "not set"
tusk_home: @env.TUSK_HOME || "default"

# Print results
@print("Home: ${home}")
@print("Path exists: ${@if(path != 'not set', 'yes', 'no')}")
@print("TuskLang Home: ${tusk_home}")
EOF

tusk run env-test.tsk
```

### Shell Integration

Verify shell completion:

```bash
# Type 'tusk ' and press TAB
tusk [TAB]
# Should show available commands
```

## Plugin System

### List Installed Plugins

```bash
tusk plugin list
```

Expected output:
```
Installed plugins:
  - core (built-in)
  - http (built-in)
  - database (optional)
  - cache (optional)
```

### Install Test Plugin

```bash
tusk plugin install example
```

## Performance Test

### Create Performance Test

```bash
cat > perf-test.tsk << 'EOF'
# Performance test
start_time: @request.timestamp

# Create large array
data = @range(1, 10000)

# Process data
result = @map(data, @lambda(x, x * 2))

# Calculate execution time
end_time: @request.timestamp
duration = end_time - start_time

@print("Processed ${@len(result)} items in ${duration}ms")
EOF

tusk run perf-test.tsk
```

## Integration Tests

### HTTP Server Test

```bash
cat > server-test.tsk << 'EOF'
# Simple HTTP server
server:
    port: 8080
    host: "localhost"

routes:
    "/":
        response: "TuskLang server is running!"
    
    "/api/status":
        response: @json({
            status: "ok"
            version: @tusk.version
            timestamp: @request.timestamp
        })
EOF

# Start server in background
tusk serve server-test.tsk &
SERVER_PID=$!

# Wait for server to start
sleep 2

# Test server
curl http://localhost:8080/
curl http://localhost:8080/api/status

# Stop server
kill $SERVER_PID
```

## Debugging Verification

### Enable Debug Mode

```bash
# Run with debug output
tusk --debug run test.tsk
```

Expected debug output:
```
[DEBUG] Loading file: test.tsk
[DEBUG] Parsing TuskLang syntax
[DEBUG] Resolving @ operators
[DEBUG] Executing runtime operations
[DEBUG] Completed successfully
```

### Verbose Mode

```bash
tusk -v run test.tsk
```

## Common Issues and Solutions

### Command Not Found

If `tusk` command is not found:

**Linux/macOS:**
```bash
# Check PATH
echo $PATH

# Add to PATH if missing
export PATH="/usr/local/bin:$PATH"
echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.bashrc
```

**Windows:**
```powershell
# Check PATH
$env:Path

# Restart terminal or run
refreshenv
```

### Permission Denied

```bash
# Fix permissions
chmod +x $(which tusk)

# Or reinstall with proper permissions
sudo tusk repair
```

### Missing Dependencies

```bash
# Check dependencies
tusk doctor
```

Expected output:
```
TuskLang Doctor
==============
✓ TuskLang binary: OK
✓ Configuration directory: OK
✓ Plugin directory: OK
✓ Cache directory: OK
✓ SSL certificates: OK
✓ Network connectivity: OK

All systems operational!
```

## Platform-Specific Verification

### Linux

```bash
# Check systemd integration
systemctl --user status tusklang

# Check package info
dpkg -l | grep tusklang  # Debian/Ubuntu
rpm -qa | grep tusklang  # RedHat/Fedora
```

### macOS

```bash
# Check Homebrew installation
brew list tusklang

# Check code signing
codesign -v $(which tusk)
```

### Windows

```powershell
# Check Windows service
Get-Service -Name "TuskLang*"

# Check registry
Get-ItemProperty HKLM:\Software\TuskLang
```

## Configuration Verification

### Global Configuration

```bash
# Check global config
tusk config show

# Test configuration loading
cat > config-test.tsk << 'EOF'
# Load global config
global_setting: @config.global_setting || "not set"

@print("Global setting: ${global_setting}")
EOF

tusk run config-test.tsk
```

## Advanced Verification

### Compile Test

```bash
# Test compilation
tusk compile test.tsk -o test-binary

# Run compiled binary
./test-binary  # Unix/Linux/macOS
test-binary.exe  # Windows
```

### Format Test

```bash
# Test formatter
tusk format test.tsk --check
```

### Benchmark

```bash
# Run built-in benchmark
tusk benchmark
```

Expected output:
```
TuskLang Benchmark Results
=========================
Parse simple file: 0.5ms
Parse complex file: 2.3ms
Execute @ operators: 1.2ms
HTTP server response: 0.8ms
Database query simulation: 3.1ms

Overall performance: Excellent
```

## Verification Checklist

Run through this checklist to ensure full functionality:

- [ ] `tusk --version` shows correct version
- [ ] `tusk --help` displays help information
- [ ] `tusk repl` starts interactive mode
- [ ] Can create and run .tsk files
- [ ] @ operators work correctly
- [ ] Environment variables are accessible
- [ ] Shell completion works
- [ ] Debug mode provides detailed output
- [ ] HTTP server can start and respond
- [ ] Syntax checking identifies errors
- [ ] Formatting works correctly
- [ ] Compilation produces working binaries

## Getting Help

If verification fails:

1. Check the [troubleshooting guide](https://tusklang.org/docs/troubleshooting)
2. Run `tusk doctor` for diagnostics
3. Check GitHub issues: https://github.com/cyber-boost/tusk/issues
4. Join the community: https://discord.gg/tusklang

## Next Steps

Now that you've verified your installation:
- Create your first project: [008-hello-world.md](008-hello-world.md)
- Learn the file structure: [009-file-structure.md](009-file-structure.md)
- Master the CLI: [010-cli-overview.md](010-cli-overview.md)
---

[Hello World in TuskLang]


Let's create your first TuskLang program! This guide will walk you through several "Hello World" examples, from simple to advanced.

## The Simplest Hello World

Create a file named `hello.tsk`:

```tusk
# My first TuskLang program
message: "Hello, World!"
@print(message)
```

Run it:
```bash
tusk run hello.tsk
```

Output:
```
Hello, World!
```

## Understanding the Code

Let's break down what happened:

1. `# My first TuskLang program` - A comment for documentation
2. `message: "Hello, World!"` - Static assignment using `:`
3. `@print(message)` - The @ operator calls the print function

## Alternative Approaches

### Direct Print

```tusk
# Direct printing without variable
@print("Hello, World!")
```

### Using String Interpolation

```tusk
# String interpolation
name: "World"
@print("Hello, ${name}!")
```

### Dynamic Assignment

```tusk
# Using = for dynamic assignment
greeting = "Hello"
target = "World"
message = "${greeting}, ${target}!"
@print(message)
```

## Interactive Hello World

### Getting User Input

```tusk
# Interactive greeting
@print("What's your name?")
name: @input()
@print("Hello, ${name}!")
```

### With Default Value

```tusk
# Greeting with fallback
name: @input("Enter your name: ") || "World"
greeting = "Hello, ${name}!"
@print(greeting)
```

## Web-Based Hello World

### Simple HTTP Server

Create `hello-server.tsk`:

```tusk
# Hello World web server
server:
    port: 8080
    host: "localhost"

routes:
    "/":
        response: "Hello, World!"
    
    "/greet":
        response = "Hello, ${@request.query.name || 'World'}!"
    
    "/json":
        response: @json({
            message: "Hello, World!"
            timestamp: @request.timestamp
            platform: @tusk.platform
        })
```

Run the server:
```bash
tusk serve hello-server.tsk
```

Test it:
```bash
# Plain text response
curl http://localhost:8080/

# With query parameter
curl http://localhost:8080/greet?name=TuskLang

# JSON response
curl http://localhost:8080/json
```

## Conditional Hello World

### Time-Based Greeting

```tusk
# Time-aware greeting
hour = @time.hour

greeting = @if(hour < 12, "Good morning", 
           @if(hour < 18, "Good afternoon", "Good evening"))

@print("${greeting}, World!")
```

### Language-Based Greeting

```tusk
# Multilingual greeting
greetings:
    en: "Hello"
    es: "Hola"
    fr: "Bonjour"
    de: "Hallo"
    jp: "こんにちは"

# Get language from environment or default to English
lang: @env.LANG || "en"
greeting: @greetings[lang] || @greetings.en

@print("${greeting}, World!")
```

## Hello World with Functions

### Custom Greeting Function

```tusk
# Define a greeting function
greet = @lambda(name, {
    prefix: @if(@time.hour < 12, "Good morning", "Hello")
    return: "${prefix}, ${name}!"
})

# Use the function
@print(@greet("World"))
@print(@greet("TuskLang"))
```

## Styled Hello World

### With Colors (Terminal)

```tusk
# Colored output
colors:
    red: "\033[31m"
    green: "\033[32m"
    blue: "\033[34m"
    reset: "\033[0m"

@print("${colors.red}Hello${colors.reset}, ${colors.blue}World${colors.reset}!")
```

### With ASCII Art

```tusk
# ASCII art greeting
banner: """
 _   _      _ _        __        __         _     _ _ 
| | | | ___| | | ___   \ \      / /__  _ __| | __| | |
| |_| |/ _ \ | |/ _ \   \ \ /\ / / _ \| '__| |/ _` | |
|  _  |  __/ | | (_) |   \ V  V / (_) | |  | | (_| |_|
|_| |_|\___|_|_|\___/     \_/\_/ \___/|_|  |_|\__,_(_)
"""

@print(banner)
```

## Hello World with Data

### From Configuration

```tusk
# Load from config
config:
    app_name: "TuskLang Demo"
    version: "1.0.0"
    author: "Your Name"

@print("Hello from ${config.app_name} v${config.version}!")
@print("Created by ${config.author}")
```

### From External File

Create `names.tsk`:
```tusk
names: ["Alice", "Bob", "Charlie", "Diana"]
```

Main file:
```tusk
# Import names
@import("names.tsk")

# Greet everyone
@each(names, @lambda(name, {
    @print("Hello, ${name}!")
}))
```

## Hello World API Client

### Fetching External Data

```tusk
# Fetch greeting from API
api_response: @http.get("https://api.example.com/greeting")
greeting: @api_response.data.message || "Hello"

@print("${greeting}, World!")
```

## Hello World with Error Handling

### Graceful Failures

```tusk
# Robust greeting
try_greeting = @try({
    # Attempt to read name from file
    name: @file.read("name.txt")
    return: "Hello, ${name}!"
}, {
    # Fallback if file doesn't exist
    return: "Hello, World!"
})

@print(try_greeting)
```

## Hello World Generator

### Dynamic Content

```tusk
# Generate multiple greetings
languages: ["English", "Spanish", "French", "German", "Japanese"]
greetings: ["Hello", "Hola", "Bonjour", "Hallo", "こんにちは"]

# Create greeting pairs
greeting_pairs = @zip(languages, greetings)

# Generate all greetings
@each(greeting_pairs, @lambda(pair, {
    @print("${pair[1]}, World! (${pair[0]})")
}))
```

## Hello World with Persistence

### Saving State

```tusk
# Track greeting count
count: @cache.get("greeting_count") || 0
count = count + 1
@cache.set("greeting_count", count)

@print("Hello, World! (Greeting #${count})")
```

## Advanced Hello World

### Full Application

Create `hello-app.tsk`:

```tusk
# Complete Hello World application
app:
    name: "Hello World Pro"
    version: "2.0.0"
    debug: @env.DEBUG || false

# Configuration
config:
    default_name: "World"
    greeting_prefix: "Hello"
    
# Custom greeting function
create_greeting = @lambda(name, {
    prefix: @config.greeting_prefix
    suffix: @if(@app.debug, " [DEBUG]", "")
    return: "${prefix}, ${name}!${suffix}"
})

# Main logic
main = {
    # Get name from various sources
    name: @request.query.name || 
          @env.USER_NAME || 
          @cache.get("last_name") || 
          @config.default_name
    
    # Save for next time
    @cache.set("last_name", name)
    
    # Create and return greeting
    greeting: @create_greeting(name)
    
    # Log if in debug mode
    @if(@app.debug, @log("Greeted: ${name}"))
    
    return: greeting
}

# Execute based on context
result = @if(@tusk.is_server, {
    # Server mode - return as HTTP response
    routes:
        "/": @main
        "/health": "OK"
}, {
    # CLI mode - print to console
    @print(@main)
})
```

## Testing Your Hello World

Create `hello-test.tsk`:

```tusk
# Test file for hello world
tests:
    "should greet world by default":
        expected: "Hello, World!"
        actual: @import("hello.tsk").message
    
    "should greet custom name":
        name: "TuskLang"
        expected: "Hello, TuskLang!"
        actual = "Hello, ${name}!"

# Run tests
@test.run(tests)
```

## Debugging Tips

### Add Debug Output

```tusk
# Debug mode
debug: @env.DEBUG || false

@if(debug, @print("[DEBUG] Starting Hello World"))

message: "Hello, World!"

@if(debug, @print("[DEBUG] Message created: ${message}"))

@print(message)

@if(debug, @print("[DEBUG] Program complete"))
```

## Best Practices

1. **Start Simple**: Begin with basic examples and add complexity gradually
2. **Use Comments**: Document your code for future reference
3. **Handle Errors**: Add fallbacks for missing data
4. **Test Thoroughly**: Verify your code works in different scenarios
5. **Keep It Readable**: Use meaningful variable names

## Common Mistakes to Avoid

```tusk
# DON'T: Forget quotes in direct strings
message: Hello, World!  # This might parse incorrectly

# DO: Use quotes for string literals
message: "Hello, World!"

# DON'T: Mix assignment operators incorrectly
static = @dynamic.value  # Wrong operator

# DO: Use = for dynamic assignments
dynamic = @dynamic.value
```

## Next Steps

Now that you've created your first TuskLang programs:

1. Explore [File Structure](009-file-structure.md) to organize larger projects
2. Learn the [CLI Overview](010-cli-overview.md) for more commands
3. Dive into [Basic Syntax](011-comments.md) for language details
4. Master [@ Operators](031-at-operator-intro.md) for dynamic features

## Exercises

Try these modifications to practice:

1. Create a greeting that includes the current date
2. Make a hello world that greets in a random language
3. Build a web service that tracks visitor count
4. Write a hello world that reads names from a database
5. Create an animated hello world in the terminal

Remember: Every expert was once a beginner. Happy coding with TuskLang!
---

[TuskLang File Structure]


Understanding how to organize TuskLang files is crucial for building maintainable applications. This guide covers file organization, naming conventions, and project structures.

## File Extensions

### Primary Extension: .tsk

All TuskLang files use the `.tsk` extension:

```
config.tsk          # Configuration file
server.tsk          # Server definition
routes.tsk          # Route definitions
database.tsk        # Database configuration
```

### Special Files

```
.tuskignore         # Files to ignore in TuskLang operations
tusk.config.tsk     # Project configuration
tusk.lock           # Dependency lock file
```

## Basic File Structure

### Single File Application

For simple applications, one file is sufficient:

```tusk
# app.tsk - Complete application
metadata:
    name: "Simple App"
    version: "1.0.0"

config:
    port: 8080
    debug: true

routes:
    "/": "Welcome!"
    "/api": @import("api.tsk")

# Run with: tusk serve app.tsk
```

### Multi-File Structure

Larger applications benefit from separation:

```
myapp/
├── tusk.config.tsk    # Project configuration
├── main.tsk           # Entry point
├── config/
│   ├── app.tsk        # Application config
│   ├── database.tsk   # Database config
│   └── cache.tsk      # Cache config
├── routes/
│   ├── index.tsk      # Route definitions
│   ├── api.tsk        # API routes
│   └── admin.tsk      # Admin routes
├── models/
│   ├── user.tsk       # User model
│   └── product.tsk    # Product model
├── lib/
│   ├── auth.tsk       # Authentication
│   └── utils.tsk      # Utilities
└── tests/
    ├── unit.tsk       # Unit tests
    └── integration.tsk # Integration tests
```

## Project Configuration

### tusk.config.tsk

The main project configuration file:

```tusk
# tusk.config.tsk
project:
    name: "MyTuskApp"
    version: "1.0.0"
    author: "Your Name"
    license: "MIT"

# Entry point
main: "main.tsk"

# Dependencies
dependencies:
    "tusklang/http": "^1.0.0"
    "tusklang/database": "^2.1.0"
    "community/auth": "^0.5.0"

# Scripts
scripts:
    start: "tusk serve main.tsk"
    test: "tusk test tests/"
    build: "tusk compile main.tsk -o dist/app"
    dev: "tusk serve main.tsk --watch"

# Environment-specific configs
environments:
    development:
        debug: true
        port: 3000
    
    production:
        debug: false
        port: 80
        ssl: true
```

## Import System

### Basic Imports

```tusk
# Import entire file
config: @import("config/app.tsk")

# Import specific values
database_config: @import("config/database.tsk").connection

# Import with alias
db: @import("lib/database.tsk") as database
```

### Relative vs Absolute Imports

```tusk
# Relative imports (from current file location)
local_config: @import("./config.tsk")
parent_config: @import("../shared/config.tsk")

# Absolute imports (from project root)
root_config: @import("/config/main.tsk")

# Package imports
http: @import("tusklang/http")
```

### Circular Import Prevention

TuskLang automatically detects and prevents circular imports:

```tusk
# file1.tsk
data: @import("file2.tsk").value  # OK first time

# file2.tsk
other: @import("file1.tsk").data  # Error: Circular import detected
```

## Organization Patterns

### MVC Pattern

```
mvc-app/
├── main.tsk
├── models/
│   ├── index.tsk
│   ├── user.tsk
│   └── product.tsk
├── views/
│   ├── layouts/
│   │   └── main.tsk
│   ├── users/
│   │   ├── list.tsk
│   │   └── detail.tsk
│   └── products/
│       ├── list.tsk
│       └── detail.tsk
└── controllers/
    ├── user_controller.tsk
    └── product_controller.tsk
```

### Microservices Pattern

```
microservices/
├── gateway/
│   ├── main.tsk
│   ├── routes.tsk
│   └── middleware.tsk
├── auth-service/
│   ├── main.tsk
│   ├── handlers.tsk
│   └── tokens.tsk
├── user-service/
│   ├── main.tsk
│   ├── models.tsk
│   └── handlers.tsk
└── shared/
    ├── config.tsk
    ├── database.tsk
    └── utils.tsk
```

### API-First Pattern

```
api-project/
├── main.tsk
├── api/
│   ├── v1/
│   │   ├── routes.tsk
│   │   ├── users.tsk
│   │   └── products.tsk
│   └── v2/
│       ├── routes.tsk
│       └── users.tsk
├── middleware/
│   ├── auth.tsk
│   ├── cors.tsk
│   └── ratelimit.tsk
└── schemas/
    ├── user.tsk
    └── product.tsk
```

## Naming Conventions

### File Names

```
# Use lowercase with underscores
user_controller.tsk     # Good
UserController.tsk      # Avoid
user-controller.tsk     # Avoid

# Be descriptive
authentication.tsk      # Good
auth.tsk               # OK for common abbreviations
a.tsk                  # Too vague

# Group related files
database_config.tsk
database_connection.tsk
database_migrations.tsk
```

### Directory Names

```
# Use lowercase, plural for collections
models/            # Good
Model/            # Avoid
model/            # Avoid for collections

# Be consistent
controllers/
views/
routes/
```

## Configuration Management

### Environment-Based Files

```
config/
├── base.tsk           # Shared configuration
├── development.tsk    # Development overrides
├── staging.tsk        # Staging overrides
├── production.tsk     # Production overrides
└── test.tsk          # Test configuration
```

Loading configuration:

```tusk
# main.tsk
base_config: @import("config/base.tsk")
env: @env.APP_ENV || "development"
env_config: @import("config/${env}.tsk")

# Merge configurations
config = @merge(base_config, env_config)
```

### Secrets Management

```
# secrets.tsk (DO NOT commit to version control)
secrets:
    api_key: "your-secret-key"
    database_password: "secure-password"
    jwt_secret: "jwt-secret-key"

# .tuskignore
secrets.tsk
*.key
*.pem
```

Loading secrets:

```tusk
# Load secrets safely
secrets: @import("secrets.tsk") || {
    api_key: @env.API_KEY
    database_password: @env.DB_PASSWORD
    jwt_secret: @env.JWT_SECRET
}
```

## Module System

### Creating Modules

```tusk
# lib/email.tsk - Email module
module:
    name: "email"
    version: "1.0.0"

# Private variables (not exported)
_smtp_config:
    host: @env.SMTP_HOST || "localhost"
    port: @env.SMTP_PORT || 587

# Public interface
send = @lambda(to, subject, body, {
    # Implementation
    @smtp.send(_smtp_config, {
        to: to
        subject: subject
        body: body
    })
})

# Export public API
export:
    send: @send
```

### Using Modules

```tusk
# Import and use module
email: @import("lib/email.tsk")

# Send email
@email.send("user@example.com", "Welcome!", "Thanks for signing up!")
```

## Build and Distribution

### Build Configuration

```tusk
# build.tsk
build:
    input: "main.tsk"
    output: "dist/app"
    target: @env.BUILD_TARGET || "linux-amd64"
    
    # Optimization settings
    optimize: true
    minify: true
    tree_shake: true
    
    # Include assets
    assets:
        - "public/**/*"
        - "templates/**/*.tsk"
    
    # Exclude files
    exclude:
        - "tests/**/*"
        - "*.test.tsk"
        - ".tuskignore"
```

### Package Structure

```
dist/
├── app                 # Compiled binary
├── config/
│   └── default.tsk    # Default configuration
├── assets/            # Static assets
│   ├── css/
│   ├── js/
│   └── images/
└── README.md          # Distribution readme
```

## Testing Structure

### Test Files

```
tests/
├── unit/
│   ├── models/
│   │   ├── user.test.tsk
│   │   └── product.test.tsk
│   └── utils/
│       └── helpers.test.tsk
├── integration/
│   ├── api.test.tsk
│   └── database.test.tsk
├── e2e/
│   └── flows.test.tsk
└── fixtures/
    ├── users.tsk
    └── products.tsk
```

### Test File Format

```tusk
# user.test.tsk
tests:
    "User model":
        "should create user":
            user: @import("../../models/user.tsk").create({
                name: "Test User"
                email: "test@example.com"
            })
            assert: @user.id != null
        
        "should validate email":
            result: @import("../../models/user.tsk").validateEmail("invalid")
            assert: @result == false
```

## Documentation Structure

### Inline Documentation

```tusk
# models/user.tsk

###
# User Model
# Handles user data and authentication
# @version 1.0.0
# @author Your Name
###

# Create a new user
# @param data Object containing user data
# @returns User object with generated ID
create = @lambda(data, {
    # Validate required fields
    @assert(data.email, "Email is required")
    @assert(data.name, "Name is required")
    
    # Create user
    user: @merge(data, {
        id: @uuid()
        created_at: @timestamp()
    })
    
    return: user
})
```

### Documentation Files

```
docs/
├── README.tsk         # Project documentation
├── API.tsk           # API documentation
├── SETUP.tsk         # Setup instructions
└── examples/         # Example usage
    ├── basic.tsk
    └── advanced.tsk
```

## Best Practices

### 1. Consistent Structure

- Use the same structure across projects
- Follow team conventions
- Document non-standard structures

### 2. Logical Organization

- Group related files together
- Separate concerns clearly
- Keep files focused and small

### 3. Clear Naming

- Use descriptive file names
- Avoid abbreviations unless common
- Be consistent with naming patterns

### 4. Import Management

- Use relative imports within modules
- Use absolute imports for cross-module
- Avoid deep nesting of imports

### 5. Configuration Hierarchy

- Base → Environment → Local
- Never commit secrets
- Use environment variables for deployment

## Common Patterns

### Factory Pattern

```tusk
# factories/user_factory.tsk
create = @lambda(type, data, {
    types:
        admin: @import("../models/admin.tsk")
        customer: @import("../models/customer.tsk")
        guest: @import("../models/guest.tsk")
    
    model: @types[type]
    return: @model.create(data)
})
```

### Repository Pattern

```tusk
# repositories/user_repository.tsk
_db: @import("../lib/database.tsk")

find = @lambda(id, {
    @_db.query("SELECT * FROM users WHERE id = ?", id)
})

create = @lambda(data, {
    @_db.insert("users", data)
})

update = @lambda(id, data, {
    @_db.update("users", data, "id = ?", id)
})
```

## Migration Guide

### From JSON/YAML

```
# Before (config.json)
{
  "app": {
    "name": "MyApp",
    "port": 8080
  }
}

# After (config.tsk)
app:
    name: "MyApp"
    port: 8080
```

### From Environment Files

```
# Before (.env)
APP_NAME=MyApp
APP_PORT=8080
DEBUG=true

# After (config.tsk)
app:
    name: @env.APP_NAME || "MyApp"
    port: @env.APP_PORT || 8080
    debug: @env.DEBUG == "true"
```

## Next Steps

- Learn the [CLI Overview](010-cli-overview.md) for project management
- Understand [Comments](011-comments.md) for documentation
- Master [Import System](026-references.md) for modular code
---

[TuskLang CLI Overview]


The TuskLang command-line interface (CLI) provides powerful tools for development, testing, and deployment. This guide covers all CLI commands and their usage.

## Basic Usage

```bash
tusk [command] [options] [arguments]
```

### Global Options

```bash
-h, --help              Show help for any command
-v, --version           Display version information
--verbose              Enable verbose output
--debug                Enable debug mode
--quiet                Suppress non-error output
--no-color             Disable colored output
--config <path>        Use specific config file
--env <environment>    Set environment (dev, staging, prod)
```

## Core Commands

### run - Execute TuskLang Files

Execute a TuskLang file:

```bash
# Basic execution
tusk run app.tsk

# With arguments
tusk run script.tsk --arg1 value1 --arg2 value2

# With environment
tusk run app.tsk --env production

# Watch mode (auto-reload on changes)
tusk run app.tsk --watch

# Dry run (parse without executing)
tusk run app.tsk --dry-run
```

Options:
- `--watch, -w` - Watch for file changes
- `--env, -e` - Set environment
- `--vars` - Pass variables as JSON
- `--timeout` - Set execution timeout
- `--dry-run` - Parse without executing

### serve - Start HTTP Server

Run a TuskLang file as an HTTP server:

```bash
# Start server
tusk serve server.tsk

# Custom port
tusk serve server.tsk --port 3000

# With HTTPS
tusk serve server.tsk --ssl --cert server.crt --key server.key

# Development mode with hot reload
tusk serve server.tsk --dev

# Production mode
tusk serve server.tsk --env production --workers 4
```

Options:
- `--port, -p` - Port number (default: 8080)
- `--host, -h` - Host address (default: localhost)
- `--ssl` - Enable HTTPS
- `--cert` - SSL certificate file
- `--key` - SSL key file
- `--dev` - Development mode
- `--workers` - Number of worker processes

### repl - Interactive Shell

Start an interactive TuskLang session:

```bash
# Start REPL
tusk repl

# With preloaded file
tusk repl --load config.tsk

# With specific environment
tusk repl --env development

# With history file
tusk repl --history ~/.tusk_history
```

REPL Commands:
- `.help` - Show REPL commands
- `.exit` - Exit REPL
- `.clear` - Clear screen
- `.load <file>` - Load a file
- `.save <file>` - Save session
- `.vars` - Show variables
- `.env` - Show environment

### init - Initialize Project

Create a new TuskLang project:

```bash
# Interactive initialization
tusk init

# With template
tusk init --template webapp

# In specific directory
tusk init myproject

# Non-interactive with options
tusk init --name "MyApp" --author "John Doe" --license MIT
```

Templates:
- `minimal` - Bare minimum setup
- `webapp` - Web application
- `api` - REST API
- `cli` - Command-line tool
- `library` - Reusable library

### compile - Compile to Binary

Compile TuskLang files to standalone executables:

```bash
# Basic compilation
tusk compile app.tsk

# Specify output
tusk compile app.tsk -o myapp

# Cross-compilation
tusk compile app.tsk --target linux-arm64

# Optimization levels
tusk compile app.tsk --optimize 3

# Include assets
tusk compile app.tsk --assets ./public
```

Targets:
- `linux-amd64`
- `linux-arm64`
- `darwin-amd64` (macOS Intel)
- `darwin-arm64` (macOS M1)
- `windows-amd64`
- `windows-arm64`

## Development Commands

### test - Run Tests

Execute test files:

```bash
# Run all tests
tusk test

# Specific test file
tusk test user.test.tsk

# Test directory
tusk test ./tests

# With coverage
tusk test --coverage

# Watch mode
tusk test --watch

# Parallel execution
tusk test --parallel 4
```

Options:
- `--coverage` - Generate coverage report
- `--watch` - Re-run on changes
- `--fail-fast` - Stop on first failure
- `--parallel` - Number of parallel tests
- `--filter` - Run specific test patterns

### check - Validate Syntax

Check TuskLang files for syntax errors:

```bash
# Check single file
tusk check app.tsk

# Check directory
tusk check ./src

# With auto-fix
tusk check app.tsk --fix

# Strict mode
tusk check app.tsk --strict

# Output format
tusk check app.tsk --format json
```

### format - Code Formatting

Format TuskLang files:

```bash
# Format file
tusk format app.tsk

# Format directory
tusk format ./src

# Check formatting without changes
tusk format app.tsk --check

# Custom style
tusk format app.tsk --style compact

# Write changes
tusk format app.tsk --write
```

Styles:
- `standard` - Default style
- `compact` - Minimal whitespace
- `expanded` - Maximum readability

### lint - Code Quality

Analyze code quality and patterns:

```bash
# Lint file
tusk lint app.tsk

# With specific rules
tusk lint app.tsk --rules strict

# Ignore patterns
tusk lint ./src --ignore "*.test.tsk"

# Custom config
tusk lint --config .tusklint.tsk

# Fix issues
tusk lint app.tsk --fix
```

## Package Management

### install - Install Dependencies

Install project dependencies:

```bash
# Install from tusk.config.tsk
tusk install

# Install specific package
tusk install tusklang/http

# Install with version
tusk install tusklang/http@1.2.0

# Dev dependency
tusk install --dev tusklang/test

# Global installation
tusk install -g tusklang/cli-tools
```

### publish - Publish Package

Publish a package to the registry:

```bash
# Publish current package
tusk publish

# Dry run
tusk publish --dry-run

# With tag
tusk publish --tag beta

# Skip tests
tusk publish --skip-tests
```

### search - Search Packages

Search the package registry:

```bash
# Search by name
tusk search http

# Search with filters
tusk search database --author tusklang

# Show details
tusk search redis --detail
```

## Utility Commands

### docs - Generate Documentation

Generate documentation from TuskLang files:

```bash
# Generate docs
tusk docs

# Specify output
tusk docs --output ./documentation

# Format options
tusk docs --format html
tusk docs --format markdown

# Include private items
tusk docs --private
```

### config - Configuration Management

Manage TuskLang configuration:

```bash
# Show current config
tusk config show

# Get specific value
tusk config get author

# Set value
tusk config set author "John Doe"

# Edit config
tusk config edit

# Reset to defaults
tusk config reset
```

### cache - Cache Management

Manage TuskLang cache:

```bash
# Show cache info
tusk cache info

# Clear all cache
tusk cache clear

# Clear specific cache
tusk cache clear --type compiled

# Set cache directory
tusk cache set-dir /tmp/tusk-cache
```

### plugin - Plugin Management

Manage TuskLang plugins:

```bash
# List plugins
tusk plugin list

# Install plugin
tusk plugin install auth-jwt

# Remove plugin
tusk plugin remove auth-jwt

# Update plugins
tusk plugin update

# Create plugin
tusk plugin create my-plugin
```

## Advanced Commands

### debug - Debugging Tools

Debug TuskLang applications:

```bash
# Start debugger
tusk debug app.tsk

# Set breakpoint
tusk debug app.tsk --break 10

# Remote debugging
tusk debug --remote :9229

# Memory profiling
tusk debug app.tsk --profile memory
```

### benchmark - Performance Testing

Benchmark TuskLang code:

```bash
# Run benchmark
tusk benchmark app.tsk

# Specific functions
tusk benchmark app.tsk --function processData

# Compare versions
tusk benchmark --compare old.tsk new.tsk

# Output format
tusk benchmark app.tsk --format csv
```

### migrate - Data Migration

Run data migrations:

```bash
# Run pending migrations
tusk migrate up

# Rollback last migration
tusk migrate down

# Create migration
tusk migrate create add_users_table

# Check status
tusk migrate status
```

## Environment Variables

TuskLang CLI respects these environment variables:

```bash
TUSK_HOME          # TuskLang installation directory
TUSK_CONFIG        # Default config file path
TUSK_ENV           # Default environment
TUSK_DEBUG         # Enable debug mode
TUSK_NO_COLOR      # Disable colors
TUSK_CACHE_DIR     # Cache directory
TUSK_LOG_LEVEL     # Log level (debug, info, warn, error)
```

## Configuration Files

### .tuskrc

Global configuration in home directory:

```tusk
# ~/.tuskrc
defaults:
    author: "Your Name"
    license: "MIT"
    environment: "development"

aliases:
    dev: "run --watch --env development"
    prod: "serve --env production --workers 4"
    t: "test"
```

### Project Configuration

Project-specific configuration:

```tusk
# .tusk/config.tsk
cli:
    aliases:
        start: "serve main.tsk --dev"
        build: "compile main.tsk -o dist/app"
        deploy: "run deploy.tsk --env production"
```

## Command Combinations

### Development Workflow

```bash
# Start development server with watching and debugging
tusk serve app.tsk --dev --watch --debug

# Run tests in watch mode with coverage
tusk test --watch --coverage --parallel 4

# Format, lint, and check before commit
tusk format . --write && tusk lint --fix && tusk check
```

### Production Deployment

```bash
# Build optimized binary
tusk compile app.tsk -o app --optimize 3 --target linux-amd64

# Run production server
tusk serve app.tsk --env production --workers auto --port 80
```

### CI/CD Pipeline

```bash
# CI testing script
tusk check --strict && \
tusk lint && \
tusk test --coverage --fail-fast && \
tusk compile --target multi
```

## Shell Completion

### Bash

```bash
# Add to ~/.bashrc
eval "$(tusk completion bash)"
```

### Zsh

```bash
# Add to ~/.zshrc
eval "$(tusk completion zsh)"
```

### Fish

```bash
# Add to ~/.config/fish/config.fish
tusk completion fish | source
```

### PowerShell

```powershell
# Add to $PROFILE
tusk completion powershell | Out-String | Invoke-Expression
```

## Troubleshooting CLI

### Common Issues

**Command not found:**
```bash
# Check PATH
echo $PATH
which tusk

# Add to PATH if missing
export PATH="/usr/local/bin:$PATH"
```

**Permission denied:**
```bash
# Check file permissions
ls -la $(which tusk)

# Fix permissions
chmod +x $(which tusk)
```

**Version mismatch:**
```bash
# Check version
tusk --version

# Update TuskLang
tusk self-update
```

### Debug Output

```bash
# Maximum verbosity
tusk --debug --verbose run app.tsk

# Log to file
tusk run app.tsk --debug 2> debug.log

# Trace execution
TUSK_TRACE=1 tusk run app.tsk
```

## Best Practices

1. **Use aliases** for common commands
2. **Enable shell completion** for efficiency
3. **Use watch mode** during development
4. **Run checks** before committing
5. **Document custom scripts** in tusk.config.tsk
6. **Use environment variables** for configuration
7. **Leverage parallel execution** for tests
8. **Profile performance** regularly

## Next Steps

- Start with [Basic Syntax](011-comments.md)
- Learn about [Key-Value Basics](012-key-value-basics.md)
- Master [@ Operators](031-at-operator-intro.md)
- Explore [Advanced Features](050-at-http-host.md)
---

[Comments in TuskLang]


Comments are essential for documenting your code and making it maintainable. TuskLang provides flexible commenting options that prioritize readability and clarity.

## Single-Line Comments

The most common form of commenting uses the `#` symbol:

```tusk
# This is a single-line comment
name: "TuskLang"  # This is an inline comment

# Comments can appear anywhere on their own line
port: 8080
# And they explain the code below or above
```

## Inline Comments

Comments can appear at the end of any line:

```tusk
server:
    host: "localhost"  # Development server
    port: 3000        # Default port for dev
    ssl: false        # SSL disabled in development
```

## Multi-Line Comments

For longer explanations, use multiple single-line comments:

```tusk
# This is a multi-line comment that explains
# the purpose of the following configuration.
# Each line starts with a # symbol.
# 
# You can include blank comment lines for readability.
database:
    host: "localhost"
    port: 5432
```

## Documentation Comments

TuskLang supports special documentation comments using `###`:

```tusk
###
# User Authentication Module
# 
# This module handles user authentication including:
# - Login/logout functionality  
# - Session management
# - Password hashing
# 
# @author John Doe
# @version 1.0.0
# @since 2024-01-01
###

auth:
    session_timeout: 3600  # 1 hour in seconds
    max_attempts: 5        # Maximum login attempts
```

## Function Documentation

Document functions and complex operations:

```tusk
###
# Calculate the total price including tax
# 
# @param price The base price
# @param tax_rate The tax rate as a decimal (e.g., 0.08 for 8%)
# @returns The total price including tax
###
calculate_total = @lambda(price, tax_rate, {
    # Calculate tax amount
    tax: price * tax_rate
    
    # Return total
    return: price + tax
})
```

## Section Headers

Use comments to organize your code into sections:

```tusk
# ===========================================
# Application Configuration
# ===========================================

app:
    name: "MyApp"
    version: "1.0.0"

# ===========================================
# Database Configuration  
# ===========================================

database:
    driver: "postgresql"
    host: "localhost"

# ===========================================
# Server Configuration
# ===========================================

server:
    port: 8080
    workers: 4
```

## TODO and FIXME Comments

Mark areas that need attention:

```tusk
# TODO: Implement user authentication
auth:
    enabled: false  # FIXME: Enable before production
    
# TODO: Add rate limiting
# TODO: Implement CSRF protection
# HACK: Temporary workaround for issue #123
temporary_fix: true

# NOTE: This requires PostgreSQL 14+
database_version: "14.0"

# WARNING: Do not change without updating documentation
magic_number: 42

# DEPRECATED: Use new_feature instead
old_feature: false
```

## Conditional Comments

Comment out code conditionally:

```tusk
# Development-only configuration
# Uncomment for debugging
# debug:
#     verbose: true
#     log_sql: true
#     profile: true

# Production configuration
cache:
    enabled: true
    ttl: 3600
```

## Comment Best Practices

### 1. Explain Why, Not What

```tusk
# Bad: Increment counter by 1
counter = counter + 1

# Good: Track number of retry attempts for rate limiting
counter = counter + 1
```

### 2. Keep Comments Updated

```tusk
# Configuration for AWS S3 bucket
storage:
    # Update this comment if you change providers!
    provider: "s3"
    bucket: "my-app-uploads"
```

### 3. Use Meaningful Section Dividers

```tusk
# ===== CONSTANTS =====
MAX_UPLOAD_SIZE: 10485760  # 10MB in bytes
TIMEOUT_SECONDS: 30

# ===== HELPERS =====
is_valid_email = @lambda(email, {
    # Email validation logic
})

# ===== MAIN LOGIC =====
process_request = @lambda(request, {
    # Request processing
})
```

### 4. Document Complex Logic

```tusk
# Calculate fibonacci number using memoization
# This implementation caches results to improve
# performance for recursive calls
fibonacci = @lambda(n, {
    # Base cases
    @if(n <= 1, return: n)
    
    # Check cache first
    cached: @cache.get("fib_${n}")
    @if(cached, return: cached)
    
    # Calculate and cache result
    result: @fibonacci(n - 1) + @fibonacci(n - 2)
    @cache.set("fib_${n}", result)
    
    return: result
})
```

## API Documentation

Document your APIs and interfaces:

```tusk
###
# User API Endpoints
# 
# All endpoints require authentication token in header:
# Authorization: Bearer <token>
###

api:
    routes:
        ###
        # Get user by ID
        # GET /api/users/:id
        # 
        # Response:
        # {
        #   "id": "123",
        #   "name": "John Doe",
        #   "email": "john@example.com"
        # }
        ###
        "/api/users/:id":
            method: "GET"
            handler: @handlers.get_user
```

## Configuration Documentation

Document configuration options:

```tusk
# Application Settings
# These can be overridden via environment variables
settings:
    # Application name (env: APP_NAME)
    # Used in emails and UI
    name: @env.APP_NAME || "MyApp"
    
    # Debug mode (env: DEBUG)
    # Enables verbose logging and stack traces
    # WARNING: Never enable in production!
    debug: @env.DEBUG == "true"
    
    # Session timeout in seconds (env: SESSION_TIMEOUT)
    # Default: 1 hour (3600 seconds)
    # Minimum: 300 (5 minutes)
    # Maximum: 86400 (24 hours)
    session_timeout: @env.SESSION_TIMEOUT || 3600
```

## Type Annotations in Comments

Document expected types:

```tusk
user:
    # string: User's full name
    name: "John Doe"
    
    # number: Age in years
    age: 30
    
    # boolean: Account active status
    active: true
    
    # string[]: List of user roles
    roles: ["user", "admin"]
    
    # object: Address information
    address:
        # string: Street address
        street: "123 Main St"
        # string: City name
        city: "Springfield"
        # string: 2-letter state code
        state: "IL"
```

## Comment Extraction

TuskLang tools can extract comments for documentation:

```tusk
# @doc-group: Authentication
# @doc-priority: high

###
# @api public
# @param {string} username - User's username
# @param {string} password - User's password  
# @returns {object} Authentication token and user info
# @throws {AuthError} If credentials are invalid
###
login = @lambda(username, password, {
    # Implementation
})
```

## Commenting Out Code

Temporarily disable code:

```tusk
active_features:
    search: true
    # notifications: true  # Disabled pending bug fix
    analytics: true
    # beta_features: true  # Not ready for production
```

## Language-Specific Comments

Support for internationalization:

```tusk
messages:
    # English
    welcome_en: "Welcome to TuskLang!"
    
    # Español  
    welcome_es: "¡Bienvenido a TuskLang!"
    
    # 日本語
    welcome_ja: "TuskLangへようこそ！"
    
    # Emoji comments work too! 🎉
    celebration: "🎊 Success! 🎊"
```

## Performance Notes

Document performance considerations:

```tusk
# PERFORMANCE: This operation is O(n²)
# Consider using a more efficient algorithm
# for large datasets
nested_loop_operation = @lambda(data, {
    # Implementation
})

# OPTIMIZATION: Results are cached for 5 minutes
# Cache key: "expensive_op_${param}"
expensive_operation = @cache("expensive_op_${param}", 300, {
    # Heavy computation
})
```

## Security Comments

Highlight security concerns:

```tusk
# SECURITY: Never log sensitive data
# SECURITY: Always validate user input
# SECURITY: Use prepared statements for SQL

database:
    # SECURITY: Store encrypted in environment
    password: @env.DB_PASSWORD
    
    # SECURITY: Minimum TLS 1.2 required
    ssl:
        enabled: true
        min_version: "TLSv1.2"
```

## Comment Anti-Patterns

Avoid these commenting mistakes:

```tusk
# Don't state the obvious
count: 0  # Set count to 0  (unnecessary)

# Don't leave outdated comments
# Initialize with 100 items
items: []  # Code changed but comment didn't

# Don't comment out code without explanation
# old_method: "deprecated"  # Why is this here?

# Don't use comments for version control
# Changed by John on 2024-01-01  # Use git instead
```

## Best Practices Summary

1. **Write comments for your future self** - Assume you'll forget the context
2. **Update comments when code changes** - Outdated comments are worse than none
3. **Use consistent formatting** - Pick a style and stick to it
4. **Document the why, not the what** - Code shows what, comments explain why
5. **Keep comments concise** - Get to the point quickly
6. **Use documentation comments** for public APIs
7. **Mark todos and issues** clearly
8. **Organize with section headers** for long files

## Next Steps

- Learn about [Key-Value Basics](012-key-value-basics.md)
- Understand [Assignment Operators](013-colon-vs-equals.md)
- Explore [Data Types](014-strings.md)
---

[Key-Value Basics in TuskLang]


At its core, TuskLang is built on key-value pairs, making configuration simple and intuitive. This guide covers the fundamentals of working with keys and values.

## Basic Syntax

The simplest TuskLang statement is a key-value pair:

```tusk
key: value
```

Examples:
```tusk
name: "TuskLang"
version: "1.0.0"
port: 8080
enabled: true
```

## Key Rules

### Valid Key Names

Keys follow these rules:
- Start with a letter or underscore
- Contain letters, numbers, underscores
- Case-sensitive
- No spaces (use underscores)

```tusk
# Valid keys
user_name: "John"
firstName: "Jane"
_private: true
api2_key: "secret"
PORT: 8080

# Invalid keys (won't parse)
# 2factor: true        # Can't start with number
# user-name: "John"    # Hyphens not allowed
# user name: "John"    # Spaces not allowed
```

### Reserved Keywords

Avoid using these reserved words as keys:
- `true`, `false`, `null`
- `if`, `else`, `return`
- Built-in function names

```tusk
# Avoid this
# true: "value"  # Reserved word

# Use this instead
is_true: "value"
true_value: "value"
```

## Value Types

TuskLang automatically infers value types:

```tusk
# String values
name: "TuskLang"
message: 'Hello, World!'
unquoted: Hello    # Also a string

# Numeric values
integer: 42
float: 3.14
negative: -10
scientific: 1.5e10

# Boolean values
enabled: true
disabled: false

# Null value
optional: null
```

## Simple Objects

Create nested structures with indentation:

```tusk
user:
    name: "John Doe"
    age: 30
    active: true
```

## Lists and Arrays

Define arrays using square brackets:

```tusk
# Inline array
colors: ["red", "green", "blue"]

# Multiline array
fruits: [
    "apple",
    "banana",
    "orange"
]

# Array of objects
users: [
    { name: "Alice", age: 30 },
    { name: "Bob", age: 25 }
]
```

## Key Naming Conventions

### Snake Case (Recommended)

```tusk
# Preferred for most keys
user_name: "John"
api_key: "secret"
max_retry_count: 3
database_url: "postgres://..."
```

### Camel Case

```tusk
# Common for JavaScript-style configs
userName: "John"
apiKey: "secret"
maxRetryCount: 3
databaseUrl: "postgres://..."
```

### Pascal Case

```tusk
# Sometimes used for type-like structures
UserModel:
    Name: "string"
    Age: "number"
    Active: "boolean"
```

### Constant Case

```tusk
# For constants and environment mappings
MAX_CONNECTIONS: 100
API_VERSION: "v1"
DEBUG_MODE: false
```

## Accessing Values

### Direct Access

```tusk
# Define values
config:
    app_name: "MyApp"
    version: "1.0.0"

# Access in same file
title = "${config.app_name} ${config.version}"
```

### Nested Access

```tusk
# Deep nesting
database:
    primary:
        host: "db1.example.com"
        port: 5432
    replica:
        host: "db2.example.com"
        port: 5432

# Access nested values
primary_host: @database.primary.host
replica_url = "postgres://${database.replica.host}:${database.replica.port}"
```

## Value Modification

### Overriding Values

```tusk
# Initial value
port: 8080

# Override later in file
port: 3000  # This wins

# Conditional override
port: @env.PORT || 8080
```

### Merging Objects

```tusk
# Base configuration
defaults:
    timeout: 30
    retries: 3
    debug: false

# Environment overrides
overrides:
    debug: true
    retries: 5

# Merged configuration
config = @merge(defaults, overrides)
# Result: { timeout: 30, retries: 5, debug: true }
```

## Special Keys

### Metadata Keys

```tusk
# These keys have special meaning in some contexts
_version: "1.0.0"      # Internal version
_schema: "config/v1"   # Schema identifier
_comment: "Generated file, do not edit"
```

### System Keys

```tusk
# Keys starting with @ are typically computed
@timestamp: @request.timestamp
@computed = someValue + 10
```

## Key Patterns

### Grouping Related Keys

```tusk
# Group by prefix
db_host: "localhost"
db_port: 5432
db_name: "myapp"
db_user: "admin"

# Or use nested object
database:
    host: "localhost"
    port: 5432
    name: "myapp"
    user: "admin"
```

### Feature Flags

```tusk
features:
    new_ui: true
    beta_api: false
    analytics: true
    debug_mode: @env.DEBUG == "true"
```

### Configuration Variants

```tusk
# Environment-specific configs
development:
    api_url: "http://localhost:3000"
    debug: true

staging:
    api_url: "https://staging.example.com"
    debug: true

production:
    api_url: "https://api.example.com"
    debug: false
```

## Dynamic Keys

### Computed Key Names

```tusk
# Using template literals for keys
env_name: "production"
"config_${env_name}":
    api_url: "https://api.example.com"
    
# Results in: config_production
```

### Conditional Keys

```tusk
base_config:
    always_present: true

# Add keys conditionally
@if(@env.ENABLE_CACHE, {
    base_config.cache_enabled: true
    base_config.cache_ttl: 3600
})
```

## Value Validation

### Type Checking

```tusk
# Ensure correct types
port: @assert.number(@env.PORT || 8080)
name: @assert.string(@env.APP_NAME || "MyApp")
debug: @assert.boolean(@env.DEBUG || false)
```

### Range Validation

```tusk
# Validate numeric ranges
port = @env.PORT || 8080
@assert(port >= 1024 && port <= 65535, "Port must be between 1024 and 65535")

# Validate string patterns
email: @env.ADMIN_EMAIL
@assert(@regex.match(email, "^[^@]+@[^@]+$"), "Invalid email format")
```

## Common Patterns

### Configuration with Defaults

```tusk
# Define defaults
defaults:
    host: "localhost"
    port: 8080
    timeout: 30
    retries: 3

# Override with environment
config:
    host: @env.HOST || @defaults.host
    port: @env.PORT || @defaults.port
    timeout: @env.TIMEOUT || @defaults.timeout
    retries: @env.RETRIES || @defaults.retries
```

### Building Connection Strings

```tusk
# Database components
db:
    driver: "postgresql"
    user: "admin"
    password: @env.DB_PASSWORD
    host: "localhost"
    port: 5432
    name: "myapp"

# Build connection string
connection_string = "${db.driver}://${db.user}:${db.password}@${db.host}:${db.port}/${db.name}"
```

### API Endpoints

```tusk
# API configuration
api:
    base_url: "https://api.example.com"
    version: "v1"
    
    endpoints:
        users: "${base_url}/${version}/users"
        posts: "${base_url}/${version}/posts"
        auth: "${base_url}/${version}/auth"
```

## Best Practices

### 1. Use Descriptive Keys

```tusk
# Bad
t: 30
mc: 100

# Good
timeout_seconds: 30
max_connections: 100
```

### 2. Group Related Data

```tusk
# Bad - scattered
user_name: "John"
user_email: "john@example.com"
user_role: "admin"

# Good - grouped
user:
    name: "John"
    email: "john@example.com"
    role: "admin"
```

### 3. Be Consistent

```tusk
# Pick one style and stick to it
database_config:  # If using snake_case
    connection_timeout: 30
    max_pool_size: 10
    # Not: maxPoolSize or ConnectionTimeout
```

### 4. Document Complex Values

```tusk
# Maximum time to wait for a response (in seconds)
# Default: 30s, Min: 1s, Max: 300s
timeout: 30

# Number of worker threads
# Set to 0 for auto-detection based on CPU cores
workers: 0
```

### 5. Use Meaningful Defaults

```tusk
# Provide sensible defaults
config:
    port: @env.PORT || 8080              # Common default port
    host: @env.HOST || "0.0.0.0"        # Listen on all interfaces
    env: @env.NODE_ENV || "development"  # Safe default
```

## Common Mistakes

### Forgetting Quotes

```tusk
# Wrong - might parse incorrectly
message: Hello World  # Might only capture "Hello"

# Right
message: "Hello World"
```

### Inconsistent Nesting

```tusk
# Wrong - mixed nesting
config:
api_key: "secret"
    port: 8080

# Right - consistent nesting
config:
    api_key: "secret"
    port: 8080
```

### Circular References

```tusk
# This creates a circular reference
a: @b
b: @a  # Error: circular reference
```

## Migration Examples

### From JSON

```json
// Before (JSON)
{
  "name": "MyApp",
  "config": {
    "port": 8080,
    "debug": true
  }
}
```

```tusk
# After (TuskLang)
name: "MyApp"
config:
    port: 8080
    debug: true
```

### From YAML

```yaml
# Before (YAML)
database:
  host: localhost
  credentials:
    username: admin
    password: secret
```

```tusk
# After (TuskLang)
database:
    host: "localhost"
    credentials:
        username: "admin"
        password: "secret"
```

## Next Steps

- Understand [Colon vs Equals](013-colon-vs-equals.md) operators
- Learn about [String handling](014-strings.md)
- Explore [Complex data structures](019-nested-objects.md)
---

[Colon vs Equals: Understanding TuskLang Assignment Operators]


TuskLang features two assignment operators that serve different purposes: `:` for static assignment and `=` for dynamic assignment. Understanding when to use each is crucial for writing effective TuskLang code.

## The Colon (:) Operator - Static Assignment

The colon operator assigns static, literal values that are determined at parse time.

### Basic Usage

```tusk
# Static string assignment
name: "TuskLang"

# Static number assignment  
port: 8080

# Static boolean assignment
debug: true

# Static object assignment
config:
    host: "localhost"
    timeout: 30
```

### Characteristics of Colon Assignment

1. **Parse-time evaluation** - Values are set when the file is parsed
2. **Literal values only** - Cannot contain expressions or function calls
3. **Immutable intent** - Suggests the value won't change
4. **Configuration-friendly** - Perfect for static settings

### When to Use Colon

```tusk
# Application metadata - won't change at runtime
app:
    name: "MyApplication"
    version: "1.0.0"
    author: "Jane Doe"

# Static configuration
database:
    driver: "postgresql"
    charset: "utf8"
    
# Constant values
constants:
    MAX_UPLOAD_SIZE: 10485760  # 10MB
    API_VERSION: "v1"
    DEFAULT_TIMEOUT: 30
```

## The Equals (=) Operator - Dynamic Assignment

The equals operator assigns values that are computed at runtime, including expressions and function calls.

### Basic Usage

```tusk
# Dynamic expression
total = price + tax

# Function call result
timestamp = @time.now()

# Conditional assignment
port = @env.PORT || 8080

# Computed value
greeting = "Hello, ${user_name}!"
```

### Characteristics of Equals Assignment

1. **Runtime evaluation** - Values computed when accessed
2. **Expressions allowed** - Can include calculations and function calls
3. **Dynamic nature** - Values can depend on runtime state
4. **Re-evaluation** - May produce different results each time

### When to Use Equals

```tusk
# Environment-dependent values
api_url = @env.API_URL || "http://localhost:3000"

# Computed values
full_name = "${first_name} ${last_name}"

# Conditional logic
theme = @if(user_preference == "dark", "dark-theme", "light-theme")

# Function results
current_user = @auth.get_user()
```

## Side-by-Side Comparison

```tusk
# Static (colon) - Always "Hello, World!"
static_greeting: "Hello, World!"

# Dynamic (equals) - Changes based on time
dynamic_greeting = @if(@time.hour < 12, "Good morning!", "Good afternoon!")

# Static object
server_config:
    host: "localhost"
    port: 8080

# Dynamic object
runtime_config = {
    host: @env.HOST || "localhost"
    port: @env.PORT || 8080
    ssl: @env.NODE_ENV == "production"
}
```

## Common Patterns

### Configuration with Overrides

```tusk
# Static defaults
defaults:
    host: "localhost"
    port: 8080
    timeout: 30

# Dynamic overrides
config = @merge(defaults, {
    host: @env.HOST || @defaults.host
    port: @env.PORT || @defaults.port
})
```

### Building Complex Values

```tusk
# Static components
protocol: "https"
domain: "api.example.com"
version: "v1"

# Dynamic composition
base_url = "${protocol}://${domain}/${version}"
```

### Conditional Configuration

```tusk
# Static environment name
environment: "production"

# Dynamic configuration based on environment
debug_mode = @environment != "production"
log_level = @if(@environment == "production", "error", "debug")
```

## Mixed Usage in Objects

You can mix both operators within objects:

```tusk
user:
    # Static properties
    id: "user123"
    type: "standard"
    
    # Dynamic properties
    created_at = @time.now()
    session_token = @uuid.generate()
    is_admin = @roles.includes("admin")
```

## Function Definitions

Both operators work with function definitions:

```tusk
# Static function assignment (preferred for lambdas)
calculate_tax: @lambda(price, rate, {
    return: price * rate
})

# Dynamic function assignment (when needed)
get_handler = @if(@env.USE_CACHE, @cached_handler, @direct_handler)
```

## Arrays and Dynamic Values

```tusk
# Static array
colors: ["red", "green", "blue"]

# Dynamic array
active_users = @users.filter(@lambda(user, user.active))

# Mixed approach
menu_items: [
    { name: "Home", url: "/" },
    { name: "Dashboard", url = @auth.dashboard_url() },
    { name: "Profile", url = "/users/${@auth.user_id}" }
]
```

## Re-evaluation Behavior

Understanding when values are re-evaluated is crucial:

```tusk
# Static - evaluated once at parse time
static_time: "2024-01-01 00:00:00"

# Dynamic - MAY be re-evaluated
current_time = @time.now()

# Force single evaluation with caching
cached_time = @cache.get_or_set("app_start_time", @time.now())
```

## Performance Considerations

### Static is Faster

```tusk
# Faster - no runtime computation
config:
    max_connections: 100
    timeout: 30

# Slower - requires runtime evaluation
config = {
    max_connections: @env.MAX_CONN || 100
    timeout: @env.TIMEOUT || 30
}
```

### Use Static When Possible

```tusk
# Unnecessary dynamic assignment
message = "Welcome to TuskLang"  # Could be static

# Better
message: "Welcome to TuskLang"

# Dynamic when needed
personalized_message = "Welcome, ${user_name}!"
```

## Error Handling

### Static Errors (Parse Time)

```tusk
# This fails at parse time
# invalid: "unterminated string

# This is caught immediately
port: "not a number"  # Type mismatch warning
```

### Dynamic Errors (Runtime)

```tusk
# This might fail at runtime
result = @database.query("SELECT * FROM users")

# Better with error handling
result = @try({
    data: @database.query("SELECT * FROM users")
}, {
    data: []
    error: "Database query failed"
})
```

## Best Practices

### 1. Default to Static

Use `:` unless you specifically need dynamic behavior:

```tusk
# Good - static for fixed values
app_name: "MyApp"
max_retries: 3

# Only use = when necessary
current_time = @time.now()
```

### 2. Be Consistent

Don't mix operators arbitrarily:

```tusk
# Confusing
server:
    host: "localhost"
    port = 8080  # Why dynamic here?

# Clear
server:
    host: "localhost"
    port: 8080
```

### 3. Document Dynamic Behavior

```tusk
# This value changes based on server load
worker_count = @system.cpu_count * 2

# Cached for 5 minutes
user_count = @cache("user_count", 300, @database.count("users"))
```

### 4. Group by Type

```tusk
# Static configuration
constants:
    APP_NAME: "MyApp"
    VERSION: "1.0.0"
    MAX_FILE_SIZE: 10485760

# Dynamic runtime values
runtime = {
    start_time: @time.now()
    memory_usage: @system.memory.used
    active_connections: @server.connections.length
}
```

## Common Mistakes

### Using = for Static Values

```tusk
# Wrong - unnecessary dynamic assignment
name = "John Doe"

# Right - use static assignment
name: "John Doe"
```

### Using : for Dynamic Values

```tusk
# Wrong - won't work
timestamp: @time.now()  # Error: @ not allowed with :

# Right - use dynamic assignment
timestamp = @time.now()
```

### Forgetting Runtime Context

```tusk
# This might not work as expected
config:
    # This is evaluated at parse time, not when accessed
    token: @env.API_TOKEN  # Error if @ operators not allowed

# Better
config:
    token = @env.API_TOKEN  # Evaluated when accessed
```

## Advanced Patterns

### Lazy Evaluation

```tusk
# Define expensive operations with =
expensive_data = @database.fetch_all_records()

# Better - use a function for lazy evaluation
get_expensive_data = @lambda({
    @cache.get_or_set("expensive_data", 3600, {
        @database.fetch_all_records()
    })
})
```

### Configuration Builders

```tusk
# Static base
base_config:
    app: "MyApp"
    version: "1.0.0"

# Dynamic builder
build_config = @lambda(env, {
    config = @merge(@base_config, {
        environment: env
        debug: env != "production"
        api_url: @if(env == "production",
            "https://api.example.com",
            "http://localhost:3000"
        )
    })
    return: config
})

# Use the builder
dev_config = @build_config("development")
prod_config = @build_config("production")
```

## Summary

- Use `:` for static, literal values that won't change
- Use `=` for dynamic values, expressions, and function calls
- Static assignment is faster and clearer for configuration
- Dynamic assignment enables runtime flexibility
- Choose based on whether the value needs runtime evaluation

## Next Steps

- Learn about [String handling](014-strings.md)
- Explore [Numbers](015-numbers.md) in TuskLang
- Understand [Boolean values](016-booleans.md)
---

[Strings in TuskLang]


Strings are one of the most common data types in TuskLang. This guide covers everything you need to know about working with text data.

## Basic String Syntax

### Quoted Strings

TuskLang supports both single and double quotes:

```tusk
# Double quotes (preferred)
message: "Hello, World!"

# Single quotes (also valid)
greeting: 'Welcome to TuskLang'

# They're functionally identical
name1: "Alice"
name2: 'Alice'  # Same as above
```

### Unquoted Strings

Simple strings without spaces can be unquoted:

```tusk
# Valid unquoted strings
environment: production
protocol: https
status: active

# Must use quotes for:
message: "Hello World"      # Contains space
path: "C:\\Program Files"   # Contains backslash
url: "https://example.com"  # Contains special characters
```

## String Interpolation

### Basic Interpolation

Use `${}` for variable substitution in double-quoted strings:

```tusk
name: "TuskLang"
version: "1.0.0"

# String interpolation
message: "Welcome to ${name} version ${version}!"
# Result: "Welcome to TuskLang version 1.0.0!"

# Single quotes don't interpolate
literal: '${name} is literal'
# Result: "${name} is literal"
```

### Expression Interpolation

```tusk
count: 42
price: 19.99

# Expressions in interpolation
summary: "You have ${count} items totaling $${price * count}"

# Function calls
greeting: "Hello, ${@user.name.toUpperCase()}!"

# Conditional interpolation
status: "Server is ${@if(is_running, 'up', 'down')}"
```

### Nested Interpolation

```tusk
user:
    first_name: "John"
    last_name: "Doe"
    
# Accessing nested values
full_name: "${user.first_name} ${user.last_name}"

# Complex expressions
profile_url: "/users/${user.id}/profile?v=${@time.now()}"
```

## Escape Sequences

### Common Escapes

```tusk
# Newline
multiline: "Line 1\nLine 2"

# Tab
tabbed: "Name:\tJohn"

# Quotes
quoted: "She said, \"Hello!\""
apostrophe: 'It\'s working'

# Backslash
path: "C:\\Users\\John"

# Unicode
emoji: "Hello \u{1F44B}"  # 👋
```

### Escape Reference

```tusk
escapes:
    newline: "First\nSecond"          # Line break
    tab: "Col1\tCol2"                 # Tab character
    carriage: "Text\rOverwrite"       # Carriage return
    backslash: "Path\\to\\file"       # Literal backslash
    quote: "Say \"Hi\""               # Double quote
    single: 'Don\'t'                  # Single quote
    unicode: "\u{1F600}"              # 😀
    hex: "\x48\x65\x6C\x6C\x6F"      # Hello
```

## Multiline Strings

### Using Quotes

```tusk
# Multiline with quotes
description: "This is a long description that
spans multiple lines. The line breaks
are preserved in the string."

# With explicit line breaks
formatted: "Line 1\n\
            Line 2\n\
            Line 3"
```

### Heredoc Syntax

For large text blocks, use heredoc:

```tusk
# Basic heredoc
html: """
<!DOCTYPE html>
<html>
    <head>
        <title>Welcome</title>
    </head>
    <body>
        <h1>Hello, World!</h1>
    </body>
</html>
"""

# Heredoc with interpolation
email_template: """
Dear ${customer_name},

Thank you for your order #${order_id}.

Your items will be shipped to:
${shipping_address}

Best regards,
${company_name}
"""
```

### Indented Heredoc

```tusk
# Heredoc preserves indentation
yaml_content: """
    version: '3'
    services:
      web:
        image: nginx
        ports:
          - "80:80"
"""

# Strip leading whitespace with <<<
stripped: <<<
    This text has
    no leading spaces
    despite indentation
>>>
```

## String Operations

### Concatenation

```tusk
# Using interpolation
first: "Hello"
second: "World"
combined: "${first}, ${second}!"

# Using the concat operator
full_path = @concat("/home/", username, "/documents")

# Building strings dynamically
parts: ["Hello", "World"]
message = @join(parts, " ")  # "Hello World"
```

### String Methods

```tusk
text: "Hello, World!"

# Length
length = @len(text)  # 13

# Case conversion
upper = @upper(text)      # "HELLO, WORLD!"
lower = @lower(text)      # "hello, world!"
title = @title(text)      # "Hello, World!"

# Trimming
padded: "  Hello  "
trimmed = @trim(padded)   # "Hello"
```

### Searching and Replacing

```tusk
text: "The quick brown fox"

# Check if contains
has_quick = @contains(text, "quick")  # true

# Find position
position = @index(text, "brown")      # 10

# Replace
updated = @replace(text, "brown", "red")  # "The quick red fox"

# Replace all occurrences
template: "Hello, {name}. Welcome, {name}!"
filled = @replace_all(template, "{name}", "Alice")
```

### Splitting and Joining

```tusk
# Split string
csv: "apple,banana,orange"
fruits = @split(csv, ",")  # ["apple", "banana", "orange"]

# Split with limit
limited = @split("a-b-c-d", "-", 2)  # ["a", "b-c-d"]

# Join array
words: ["Hello", "World"]
sentence = @join(words, " ")  # "Hello World"

# Join with custom separator
path_parts: ["home", "user", "documents"]
path = @join(path_parts, "/")  # "home/user/documents"
```

## Regular Expressions

### Pattern Matching

```tusk
email: "user@example.com"

# Basic match
is_email = @regex.match(email, "^[^@]+@[^@]+\\.[^@]+$")

# Extract matches
text: "Order #12345 confirmed"
order_match = @regex.find(text, "#(\\d+)")
order_number = @order_match[1]  # "12345"

# Find all matches
urls: "Visit https://example.com and https://test.com"
all_urls = @regex.find_all(urls, "https://[^\\s]+")
```

### Pattern Replacement

```tusk
# Simple regex replace
phone: "123-456-7890"
clean_phone = @regex.replace(phone, "[^0-9]", "")  # "1234567890"

# Complex replacements
markdown: "**bold** and *italic*"
html = @regex.replace_all(markdown, {
    "\\*\\*(.+?)\\*\\*": "<strong>$1</strong>",
    "\\*(.+?)\\*": "<em>$1</em>"
})
```

## String Formatting

### Printf-style Formatting

```tusk
# Basic formatting
formatted = @format("Hello, %s!", "World")

# Multiple values
message = @format("%s has %d items", username, item_count)

# Number formatting
price_text = @format("Price: $%.2f", 19.99)  # "Price: $19.99"
```

### Template Strings

```tusk
# Define template
template: "Dear {{name}}, your order {{order_id}} is {{status}}."

# Fill template
message = @template.fill(template, {
    name: "John",
    order_id: "12345",
    status: "shipped"
})
```

## String Validation

### Built-in Validators

```tusk
# Email validation
email: "user@example.com"
is_valid_email = @validate.email(email)

# URL validation
url: "https://example.com"
is_valid_url = @validate.url(url)

# Custom validation
username: "john_doe123"
is_valid_username = @regex.match(username, "^[a-zA-Z0-9_]{3,20}$")
```

### Length Validation

```tusk
password: "secretpass"

# Check length
is_valid_length = @len(password) >= 8 && @len(password) <= 128

# Validate with message
validate_password = @lambda(pwd, {
    @if(@len(pwd) < 8, 
        @error("Password must be at least 8 characters"),
        true
    )
})
```

## Unicode and Encoding

### Unicode Support

```tusk
# Full Unicode support
greeting_english: "Hello"
greeting_japanese: "こんにちは"
greeting_arabic: "مرحبا"
greeting_emoji: "👋 Hello!"

# Character counting
emoji_text: "Hello 👋 World 🌍"
char_count = @len(emoji_text)  # Counts properly
```

### Encoding Operations

```tusk
# Base64 encoding
original: "Hello, World!"
encoded = @base64.encode(original)
decoded = @base64.decode(encoded)

# URL encoding
url_param: "hello world & more"
safe_param = @url.encode(url_param)  # "hello%20world%20%26%20more"
```

## String Comparison

### Basic Comparison

```tusk
str1: "Hello"
str2: "hello"

# Case-sensitive comparison
equal = str1 == str2  # false

# Case-insensitive comparison
equal_ignore_case = @lower(str1) == @lower(str2)  # true

# Comparison operators
result = "apple" < "banana"  # true (alphabetical)
```

### Advanced Comparison

```tusk
# Natural sort comparison
files: ["file10.txt", "file2.txt", "file1.txt"]
sorted = @sort.natural(files)  # ["file1.txt", "file2.txt", "file10.txt"]

# Locale-aware comparison
names: ["Åke", "Zebra", "Adam"]
sorted_locale = @sort.locale(names, "sv-SE")  # Swedish sorting
```

## Performance Tips

### String Building

```tusk
# Inefficient - multiple concatenations
result = ""
@each(items, @lambda(item, {
    result = result + item + ", "  # Creates new string each time
}))

# Efficient - use join
result = @join(items, ", ")

# Or use string builder
builder = @string.builder()
@each(items, @lambda(item, {
    @builder.append(item)
    @builder.append(", ")
}))
result = @builder.toString()
```

### String Pooling

```tusk
# Reuse common strings
status_active: "active"
status_inactive: "inactive"

users: [
    { name: "John", status: @status_active },
    { name: "Jane", status: @status_active },
    { name: "Bob", status: @status_inactive }
]
```

## Common Patterns

### SQL Query Building

```tusk
# Safe query building
table: "users"
conditions: ["active = true", "age > 18"]
query = "SELECT * FROM ${table} WHERE ${@join(conditions, ' AND ')}"

# With parameters
user_id: 123
safe_query = @sql.prepare("SELECT * FROM users WHERE id = ?", user_id)
```

### Path Manipulation

```tusk
# Building file paths
base_dir: "/home/user"
filename: "document.txt"
full_path = @path.join(base_dir, "documents", filename)

# Extract components
path: "/home/user/file.txt"
dir = @path.dirname(path)     # "/home/user"
base = @path.basename(path)   # "file.txt"
ext = @path.extension(path)   # ".txt"
```

### String Sanitization

```tusk
# HTML escaping
user_input: "<script>alert('XSS')</script>"
safe_html = @html.escape(user_input)

# SQL escaping
search_term: "O'Brien"
safe_sql = @sql.escape(search_term)

# General sanitization
filename: "my file (2).txt"
safe_filename = @regex.replace(filename, "[^a-zA-Z0-9.-]", "_")
```

## Best Practices

1. **Use double quotes** for strings that might need interpolation
2. **Use heredoc** for multi-line strings
3. **Escape special characters** properly
4. **Validate user input** before using in strings
5. **Use appropriate encoding** for different contexts
6. **Consider performance** when building large strings
7. **Be mindful of Unicode** in string operations

## Next Steps

- Learn about [Numbers](015-numbers.md) in TuskLang
- Explore [Boolean values](016-booleans.md)
- Master [Arrays](018-arrays.md) for string collections
---

[Numbers in TuskLang]


TuskLang provides comprehensive support for numeric values, including integers, floating-point numbers, and various mathematical operations. This guide covers everything you need to know about working with numbers.

## Number Types

### Integers

```tusk
# Basic integers
count: 42
negative: -17
zero: 0

# Large numbers
population: 7800000000
debt: -1000000

# Binary, octal, and hex literals
binary: 0b1010      # 10 in decimal
octal: 0o755        # 493 in decimal
hexadecimal: 0xFF   # 255 in decimal
```

### Floating-Point Numbers

```tusk
# Basic decimals
price: 19.99
temperature: -40.5
pi: 3.14159265359

# Scientific notation
avogadro: 6.022e23
planck: 6.626e-34
million: 1e6        # 1,000,000
tiny: 1e-9          # 0.000000001
```

### Special Values

```tusk
# Infinity
positive_infinity: Infinity
negative_infinity: -Infinity

# Not a Number
not_a_number: NaN

# Checking special values
is_finite = @isFinite(value)
is_nan = @isNaN(value)
```

## Basic Arithmetic

### Standard Operations

```tusk
a: 10
b: 3

# Basic arithmetic
sum = a + b          # 13
difference = a - b   # 7
product = a * b      # 30
quotient = a / b     # 3.333...
remainder = a % b    # 1

# Power operations
squared = a ** 2     # 100
cubed = a ** 3      # 1000
root = 16 ** 0.5    # 4 (square root)
```

### Order of Operations

```tusk
# Standard mathematical order (PEMDAS)
result1 = 2 + 3 * 4      # 14 (not 20)
result2 = (2 + 3) * 4    # 20
result3 = 10 / 2 * 3     # 15 (left to right)
result4 = 2 ** 3 ** 2    # 512 (right to left for exponents)
```

## Number Functions

### Math Functions

```tusk
# Rounding functions
rounded = @round(3.7)        # 4
floored = @floor(3.7)        # 3
ceiled = @ceil(3.2)          # 4
truncated = @trunc(3.7)      # 3

# Precision rounding
price = @round(19.995, 2)    # 19.99
pi_short = @round(3.14159, 3) # 3.142

# Absolute value
distance = @abs(-42)         # 42

# Min/Max
smallest = @min(5, 3, 8, 1)  # 1
largest = @max(5, 3, 8, 1)   # 8
```

### Advanced Math

```tusk
# Trigonometry (radians)
angle: 45
radians = angle * @PI / 180
sine = @sin(radians)
cosine = @cos(radians)
tangent = @tan(radians)

# Inverse trig
asin_val = @asin(0.5)  # π/6
acos_val = @acos(0.5)  # π/3
atan_val = @atan(1)    # π/4

# Logarithms
natural_log = @ln(10)       # 2.302...
log_base_10 = @log10(100)   # 2
log_base_2 = @log2(8)       # 3

# Exponentials
e_squared = @exp(2)         # e²
sqrt_2 = @sqrt(2)          # 1.414...
```

### Statistical Functions

```tusk
numbers: [1, 2, 3, 4, 5]

# Basic statistics
sum = @sum(numbers)         # 15
average = @avg(numbers)     # 3
median = @median(numbers)   # 3
std_dev = @stddev(numbers)  # 1.58...

# Range and bounds
min_val = @min(numbers)     # 1
max_val = @max(numbers)     # 5
range = max_val - min_val   # 4
```

## Number Conversion

### Type Conversion

```tusk
# String to number
str_num: "42"
num = @number(str_num)      # 42
float = @float("3.14")      # 3.14
int = @int("42.7")          # 42 (truncates)

# With validation
safe_convert = @lambda(str, {
    @if(@isNumeric(str),
        @number(str),
        @error("Invalid number: ${str}")
    )
})

# Number to string
num: 42
str = @string(num)          # "42"
formatted = @format("%.2f", 3.14159)  # "3.14"
```

### Base Conversion

```tusk
decimal: 255

# Convert to different bases
binary = @toBinary(decimal)      # "11111111"
octal = @toOctal(decimal)        # "377"
hex = @toHex(decimal)            # "FF"

# Parse from different bases
from_binary = @parseInt("1010", 2)    # 10
from_octal = @parseInt("755", 8)      # 493
from_hex = @parseInt("FF", 16)        # 255
```

## Number Formatting

### Locale Formatting

```tusk
number: 1234567.89

# Default formatting
formatted = @format.number(number)  # "1,234,567.89"

# Locale-specific
us_format = @format.number(number, "en-US")    # "1,234,567.89"
de_format = @format.number(number, "de-DE")    # "1.234.567,89"
in_format = @format.number(number, "en-IN")    # "12,34,567.89"
```

### Currency Formatting

```tusk
price: 1234.56

# Currency formatting
usd = @format.currency(price, "USD")     # "$1,234.56"
eur = @format.currency(price, "EUR")     # "€1,234.56"
jpy = @format.currency(price, "JPY")     # "¥1,235" (no decimals)

# Custom currency
custom = @format.currency(price, {
    symbol: "₹",
    decimals: 2,
    position: "before"
})
```

### Percentage Formatting

```tusk
ratio: 0.1234

# Basic percentage
percent = @format.percent(ratio)         # "12.34%"
precise = @format.percent(ratio, 1)      # "12.3%"
integer = @format.percent(ratio, 0)      # "12%"
```

## Numeric Ranges

### Creating Ranges

```tusk
# Simple range
numbers = @range(1, 5)      # [1, 2, 3, 4, 5]

# With step
evens = @range(0, 10, 2)    # [0, 2, 4, 6, 8, 10]
odds = @range(1, 10, 2)     # [1, 3, 5, 7, 9]

# Reverse range
countdown = @range(10, 1, -1)  # [10, 9, 8, ..., 1]
```

### Range Operations

```tusk
# Check if in range
age: 25
is_adult = age >= 18 && age <= 65

# Using helper functions
in_range = @inRange(age, 18, 65)

# Clamp to range
clamped = @clamp(value, 0, 100)  # Ensures 0 <= value <= 100
```

## Random Numbers

### Basic Random

```tusk
# Random float between 0 and 1
random_float = @random()

# Random integer in range
dice_roll = @randomInt(1, 6)

# Random from array
colors: ["red", "green", "blue"]
random_color = @randomChoice(colors)
```

### Seeded Random

```tusk
# Create seeded generator
rng = @random.seed(12345)

# Generate consistent sequences
value1 = @rng.next()         # Always same sequence
value2 = @rng.nextInt(1, 100)
```

## Precision and Accuracy

### Floating Point Precision

```tusk
# Floating point issues
result = 0.1 + 0.2          # 0.30000000000000004

# Safe comparison
epsilon: 0.00001
are_equal = @abs(result - 0.3) < epsilon

# Using decimal precision
precise = @decimal("0.1") + @decimal("0.2")  # Exactly 0.3
```

### Working with Money

```tusk
# Don't use floats for money
# price: 19.99  # Can have precision issues

# Use integers (cents) or decimal type
price_cents: 1999
price_dollars = price_cents / 100

# Or use decimal arithmetic
price = @decimal("19.99")
tax = @decimal("0.08")
total = @decimal.multiply(price, @decimal.add(1, tax))
```

## Bitwise Operations

```tusk
a: 0b1010  # 10
b: 0b1100  # 12

# Bitwise operations
and_result = a & b      # 0b1000 (8)
or_result = a | b       # 0b1110 (14)
xor_result = a ^ b      # 0b0110 (6)
not_result = ~a         # -11 (two's complement)

# Bit shifting
left_shift = a << 1     # 0b10100 (20)
right_shift = a >> 1    # 0b0101 (5)
```

## Number Validation

### Type Checking

```tusk
# Check if value is numeric
is_number = @isNumber(value)
is_integer = @isInteger(value)
is_float = @isFloat(value)

# Safe parsing
parse_safe = @lambda(str, {
    @if(@isNumeric(str), {
        value: @number(str)
        error: null
    }, {
        value: null
        error: "Invalid number format"
    })
})
```

### Range Validation

```tusk
# Validate numeric ranges
validate_age = @lambda(age, {
    @assert(@isInteger(age), "Age must be an integer")
    @assert(age >= 0, "Age cannot be negative")
    @assert(age <= 150, "Age seems unrealistic")
    return: true
})

# Validate decimal places
validate_price = @lambda(price, {
    decimals = @string(price).split(".")[1]?.length || 0
    @assert(decimals <= 2, "Price cannot have more than 2 decimal places")
})
```

## Common Patterns

### Financial Calculations

```tusk
# Compound interest
principal: 1000
rate: 0.05  # 5% annual
years: 10
compound_interest = principal * (1 + rate) ** years

# Percentage calculations
original: 100
increase: 20  # 20%
new_value = original * (1 + increase / 100)

# Discount calculation
price: 50
discount_percent: 15
discount_amount = price * (discount_percent / 100)
final_price = price - discount_amount
```

### Statistical Analysis

```tusk
data: [23, 45, 67, 89, 12, 34, 56, 78, 90, 43]

# Calculate statistics
stats: {
    count: @len(data)
    sum: @sum(data)
    mean: @avg(data)
    median: @median(data)
    mode: @mode(data)
    std_dev: @stddev(data)
    variance: @variance(data)
    min: @min(data)
    max: @max(data)
    range: @max(data) - @min(data)
}

# Percentiles
percentile_25 = @percentile(data, 25)
percentile_75 = @percentile(data, 75)
iqr = percentile_75 - percentile_25
```

### Unit Conversion

```tusk
# Temperature conversion
celsius_to_fahrenheit = @lambda(c, c * 9/5 + 32)
fahrenheit_to_celsius = @lambda(f, (f - 32) * 5/9)

# Distance conversion
conversions: {
    km_to_miles: @lambda(km, km * 0.621371)
    miles_to_km: @lambda(mi, mi * 1.60934)
    meters_to_feet: @lambda(m, m * 3.28084)
    feet_to_meters: @lambda(ft, ft * 0.3048)
}

# Usage
distance_km: 10
distance_miles = @conversions.km_to_miles(distance_km)
```

## Performance Tips

### Avoid Repeated Calculations

```tusk
# Inefficient
@each(items, @lambda(item, {
    # Math.PI / 180 calculated each time
    radians = item.degrees * @PI / 180
}))

# Efficient
deg_to_rad = @PI / 180
@each(items, @lambda(item, {
    radians = item.degrees * deg_to_rad
}))
```

### Use Appropriate Types

```tusk
# For whole numbers, use integers
count: 42        # Not 42.0

# For money, use proper precision
price: 1999      # Cents as integer
# Or
price: @decimal("19.99")

# For IDs, consider strings
user_id: "12345"  # Not numeric if not doing math
```

## Best Practices

1. **Use appropriate number types** - integers for counts, decimals for money
2. **Be aware of floating-point precision** - use epsilon for comparisons
3. **Validate numeric inputs** - check ranges and types
4. **Format numbers for display** - use locale-appropriate formatting
5. **Handle special values** - check for NaN and Infinity
6. **Use constants** for mathematical values
7. **Document units** in comments (seconds, bytes, etc.)

## Next Steps

- Learn about [Booleans](016-booleans.md) and logical operations
- Explore [Arrays](018-arrays.md) for number collections
- Master [Type System](025-typed-values.md) for type safety
---

[Booleans in TuskLang]


Booleans represent true/false values and are fundamental for conditional logic in TuskLang. This guide covers boolean values, operations, and best practices.

## Boolean Literals

### Basic Boolean Values

```tusk
# Boolean literals
is_active: true
is_disabled: false

# Case-sensitive - only lowercase works
# TRUE, True, FALSE, False are NOT valid boolean literals
```

### Boolean-like Values

```tusk
# These are strings, not booleans
not_bool1: "true"   # String
not_bool2: 'false'  # String
not_bool3: True     # Undefined variable
not_bool4: 1        # Number

# Convert strings to booleans
bool1 = @boolean("true")   # true
bool2 = @boolean("false")  # false
bool3 = @boolean("yes")    # true
bool4 = @boolean("no")     # false
```

## Boolean Operations

### Logical Operators

```tusk
a: true
b: false

# AND operator (&&)
result1 = a && b        # false
result2 = true && true  # true

# OR operator (||)
result3 = a || b        # true
result4 = false || false # false

# NOT operator (!)
result5 = !a            # false
result6 = !b            # true

# Combining operators
complex = (a || b) && !c
```

### Comparison Operators

```tusk
x: 5
y: 10

# Equality
equal = x == y          # false
not_equal = x != y      # true

# Comparison
less_than = x < y       # true
greater_than = x > y    # false
less_equal = x <= y     # true
greater_equal = x >= y  # false

# String comparison
str1: "apple"
str2: "banana"
alphabetical = str1 < str2  # true
```

## Truthiness and Falsiness

### Truthy Values

```tusk
# These evaluate to true in boolean context
truthy_values:
    non_empty_string: "hello"   # Any non-empty string
    positive_number: 42         # Any non-zero number
    negative_number: -1         # Including negative
    array: [1, 2, 3]           # Non-empty arrays
    object: { key: "value" }   # Non-empty objects

# Testing truthiness
@if("hello", "truthy", "falsy")     # "truthy"
@if(42, "truthy", "falsy")           # "truthy"
@if([1], "truthy", "falsy")          # "truthy"
```

### Falsy Values

```tusk
# These evaluate to false in boolean context
falsy_values:
    boolean_false: false
    null_value: null
    zero: 0
    empty_string: ""
    empty_array: []
    empty_object: {}

# Testing falsiness
@if(false, "truthy", "falsy")       # "falsy"
@if(null, "truthy", "falsy")        # "falsy"
@if(0, "truthy", "falsy")           # "falsy"
@if("", "truthy", "falsy")          # "falsy"
```

## Boolean Conversion

### Explicit Conversion

```tusk
# Convert various types to boolean
bool_from_string = @boolean("yes")     # true
bool_from_number = @boolean(1)          # true
bool_from_null = @boolean(null)         # false

# String conversion rules
string_bools:
    from_true: @boolean("true")         # true
    from_yes: @boolean("yes")           # true
    from_1: @boolean("1")               # true
    from_on: @boolean("on")             # true
    
    from_false: @boolean("false")       # false
    from_no: @boolean("no")             # false
    from_0: @boolean("0")               # false
    from_off: @boolean("off")           # false
    
    from_other: @boolean("hello")       # true (non-empty)
```

### Implicit Conversion

```tusk
# Automatic conversion in boolean context
value: "hello"

# If statement
@if(value, {
    # Executes because "hello" is truthy
    result: "Value is truthy"
})

# Logical operations force boolean context
has_value = value && true    # true
is_empty = !value           # false
```

## Conditional Logic

### If Expressions

```tusk
# Basic if expression
age: 18
can_vote = @if(age >= 18, true, false)

# Without explicit boolean
status = @if(user.active, "Active", "Inactive")

# Nested conditions
category = @if(age < 13, "child",
           @if(age < 20, "teen",
           @if(age < 60, "adult", "senior")))
```

### Boolean Guards

```tusk
# Early return pattern
validate_user = @lambda(user, {
    # Guard clauses
    @if(!user, return: false)
    @if(!user.email, return: false)
    @if(!user.active, return: false)
    
    # All checks passed
    return: true
})

# Chained validations
is_valid = user && user.email && user.active
```

## Short-Circuit Evaluation

### AND Short-Circuit

```tusk
# AND stops at first false
result = false && @expensive_operation()  # expensive_operation never runs

# Practical use
user && user.profile && user.profile.settings

# Safe property access
has_permission = user && user.roles && user.roles.includes("admin")
```

### OR Short-Circuit

```tusk
# OR stops at first true
result = true || @expensive_operation()  # expensive_operation never runs

# Default values using OR
port = @env.PORT || 8080
name = user.name || "Anonymous"

# First truthy value wins
display_name = user.nickname || user.fullname || user.email || "User"
```

## Boolean Arrays

### Array of Booleans

```tusk
# Define boolean array
permissions: [true, false, true, true, false]

# Check if all true
all_granted = @all(permissions)        # false

# Check if any true
some_granted = @any(permissions)       # true

# Count true values
granted_count = @filter(permissions, @lambda(p, p)).length
```

### Boolean Mapping

```tusk
# Transform to booleans
ages: [15, 18, 21, 16, 25]
can_vote = @map(ages, @lambda(age, age >= 18))
# Result: [false, true, true, false, true]

# Filter based on boolean condition
adults = @filter(ages, @lambda(age, age >= 18))
# Result: [18, 21, 25]
```

## Complex Boolean Logic

### Boolean Algebra

```tusk
# De Morgan's Laws
a: true
b: false

# !(a && b) == !a || !b
law1_left = !(a && b)
law1_right = !a || !b
law1_valid = law1_left == law1_right  # true

# !(a || b) == !a && !b
law2_left = !(a || b)
law2_right = !a && !b
law2_valid = law2_left == law2_right  # true
```

### Boolean Functions

```tusk
# XOR (exclusive OR)
xor = @lambda(a, b, (a || b) && !(a && b))

# NAND
nand = @lambda(a, b, !(a && b))

# NOR
nor = @lambda(a, b, !(a || b))

# Usage
result1 = @xor(true, false)   # true
result2 = @xor(true, true)    # false
```

## Boolean Flags and Configuration

### Feature Flags

```tusk
features:
    new_ui: @env.FEATURE_NEW_UI == "true"
    beta_api: @env.FEATURE_BETA_API == "true"
    analytics: true
    debug_mode: @env.NODE_ENV != "production"

# Conditional feature loading
@if(features.analytics, {
    @import("analytics.tsk")
})
```

### Configuration Validation

```tusk
config:
    ssl_enabled: true
    ssl_cert: "/path/to/cert"
    ssl_key: "/path/to/key"

# Validate boolean dependencies
validate_ssl = @lambda({
    @if(config.ssl_enabled, {
        @assert(config.ssl_cert, "SSL cert required when SSL enabled")
        @assert(config.ssl_key, "SSL key required when SSL enabled")
    })
})
```

## Boolean Patterns

### Toggle Pattern

```tusk
# Simple toggle
is_visible: true
toggle_visibility = @lambda({
    is_visible = !is_visible
})

# State-based toggle
state:
    dark_mode: false
    
toggle_dark_mode = @lambda({
    state.dark_mode = !state.dark_mode
    @emit("theme_changed", state.dark_mode)
})
```

### Boolean Accumulator

```tusk
# Check multiple conditions
validations: {
    has_name: user.name != ""
    has_email: user.email != ""
    valid_email: @regex.match(user.email, "^[^@]+@[^@]+$")
    has_password: user.password.length >= 8
}

# All must be true
is_valid = @all(@values(validations))

# Get failed validations
failed = @filter(@entries(validations), @lambda(entry, !entry[1]))
```

### Permission Checking

```tusk
# Role-based permissions
user:
    roles: ["user", "editor"]

permissions:
    read: true
    write: @user.roles.includes("editor") || @user.roles.includes("admin")
    delete: @user.roles.includes("admin")
    
can_perform = @lambda(action, @permissions[action] || false)
```

## Error Handling with Booleans

### Success/Failure Pattern

```tusk
# Operation result
result: {
    success: false
    data: null
    error: "Connection failed"
}

# Check and handle
@if(result.success, {
    # Handle success
    @process(result.data)
}, {
    # Handle failure
    @log.error(result.error)
})
```

### Validation Results

```tusk
validate_input = @lambda(input, {
    errors: []
    
    @if(!input.name, {
        errors.push("Name is required")
    })
    
    @if(!input.email || !@validate.email(input.email), {
        errors.push("Valid email is required")
    })
    
    return: {
        valid: @len(errors) == 0
        errors: errors
    }
})
```

## Performance Considerations

### Lazy Evaluation

```tusk
# Expensive operations with booleans
should_process: false

# This won't execute expensive_check if should_process is false
result = should_process && @expensive_check()

# Better than
@if(should_process, {
    result = @expensive_check()
})
```

### Boolean Caching

```tusk
# Cache expensive boolean calculations
_is_premium_cached: null

is_premium_user = @lambda({
    @if(_is_premium_cached != null, {
        return: _is_premium_cached
    })
    
    # Expensive check
    _is_premium_cached = @database.check_premium_status(user.id)
    return: _is_premium_cached
})
```

## Best Practices

1. **Use explicit boolean values** - Avoid relying on truthiness when clarity matters
2. **Name boolean variables clearly** - Use `is_`, `has_`, `can_` prefixes
3. **Leverage short-circuit evaluation** for performance
4. **Validate boolean conversions** from user input
5. **Document complex boolean logic** with comments
6. **Use consistent patterns** for similar checks
7. **Avoid double negatives** - `!is_not_valid` is confusing

## Common Mistakes

### String vs Boolean

```tusk
# Wrong
is_active: "true"  # This is a string
@if(is_active == true, ...)  # Will be false!

# Right
is_active: true
# Or
is_active = @boolean("true")
```

### Unnecessary Boolean Conversion

```tusk
# Redundant
is_valid = @if(value > 0, true, false)

# Better
is_valid = value > 0
```

### Forgetting Short-Circuit

```tusk
# Might cause error if user is null
has_name = user.name != ""  # Error if user is null

# Safe version
has_name = user && user.name != ""
```

## Next Steps

- Learn about [Null Values](017-null-values.md) and handling absence
- Explore [Arrays](018-arrays.md) for collections
- Master [Conditional Logic](031-at-operator-intro.md) with @ operators
---

[Null Values in TuskLang]


Null represents the absence of a value in TuskLang. Understanding how to work with null is crucial for writing robust applications that handle missing data gracefully.

## The Null Literal

### Basic Null Assignment

```tusk
# Explicit null assignment
value: null
missing_data: null
not_yet_loaded: null

# Null is a reserved keyword (lowercase only)
# These are NOT null:
# Null     # Undefined variable
# NULL     # Undefined variable
# "null"   # String
```

### When Null Appears

```tusk
# Uninitialized optional values
user:
    name: "John"
    email: "john@example.com"
    phone: null  # Optional field

# Failed operations
result = @database.find_user(999)  # Returns null if not found

# Cleared values
cache_value = null  # Explicitly cleared
```

## Null Checking

### Direct Comparison

```tusk
value: null

# Check for null
is_null = value == null        # true
is_not_null = value != null    # false

# Null is only equal to null
null == null          # true
null == false         # false
null == 0            # false
null == ""           # false
null == undefined    # false
```

### Null Testing Functions

```tusk
# Built-in null checking
@isNull(null)        # true
@isNull(0)           # false
@isNull("")          # false
@isNull(false)       # false

# Check for null or undefined
@isNullOrUndefined(null)      # true
@isNullOrUndefined(undefined) # true
@isNullOrUndefined(0)         # false

# Check if value exists (not null/undefined)
@exists(null)        # false
@exists(0)           # true
@exists("")          # true
```

## Null Coalescing

### Using OR Operator

```tusk
# Fallback values with ||
name = user.name || "Anonymous"
port = @env.PORT || 8080

# Be careful with falsy values
count = user.count || 0  # Problem if count could be 0

# Null coalescing operator (only checks null/undefined)
count = user.count ?? 0  # Preserves 0 as valid value
```

### Null Coalescing Patterns

```tusk
# Chain multiple fallbacks
display_name = user.nickname ?? user.fullname ?? user.email ?? "User"

# With functions
get_config = @lambda(key, default_value, {
    value: @env[key] ?? @config[key] ?? default_value
    return: value
})

# Safe navigation
city = user?.address?.city ?? "Unknown"
```

## Optional Chaining

### Safe Property Access

```tusk
# Traditional null checking
city = null
@if(user != null && user.address != null, {
    city = user.address.city
})

# Optional chaining
city = user?.address?.city

# With array access
first_phone = user?.phones?.[0]

# With function calls
result = api?.getData?.()
```

### Combining with Null Coalescing

```tusk
# Safe access with default
user_city = user?.address?.city ?? "No city specified"

# Multiple levels
company_name = employee?.department?.company?.name ?? "Unknown Company"

# With array methods
first_tag = post?.tags?.[0]?.name ?? "Untagged"
```

## Null in Conditionals

### Truthiness of Null

```tusk
# Null is falsy
value: null

@if(value, {
    # This won't execute
    @print("Value exists")
}, {
    # This executes
    @print("Value is null or falsy")
})

# Explicit null check
@if(value == null, {
    @print("Value is specifically null")
})
```

### Guard Clauses

```tusk
process_user = @lambda(user, {
    # Early return for null
    @if(user == null, {
        return: { error: "User is null" }
    })
    
    # Process valid user
    return: {
        name: user.name
        email: user.email
    }
})
```

## Null Handling Patterns

### Default Object Pattern

```tusk
# Define defaults
default_user: {
    name: "Guest"
    email: ""
    role: "visitor"
    preferences: {}
}

# Merge with possible null
safe_user = @merge(default_user, user ?? {})
```

### Null Object Pattern

```tusk
# Instead of returning null, return a null object
null_user: {
    id: null
    name: "Unknown User"
    email: "no-email@example.com"
    is_null: true
    
    # Methods that do nothing
    save: @lambda({ return: false })
    delete: @lambda({ return: false })
}

find_user = @lambda(id, {
    user = @database.get_user(id)
    return: user ?? @null_user
})
```

### Maybe/Option Pattern

```tusk
# Wrap nullable values
maybe = @lambda(value, {
    is_null: value == null
    value: value
    
    map: @lambda(fn, {
        @if(@is_null, @maybe(null), @maybe(fn(@value)))
    })
    
    or_else: @lambda(default, {
        @if(@is_null, default, @value)
    })
})

# Usage
user_maybe = @maybe(@find_user(id))
user_name = @user_maybe.map(@lambda(u, u.name)).or_else("Unknown")
```

## Null in Data Structures

### Arrays with Null

```tusk
# Arrays can contain null
data: [1, null, 3, null, 5]

# Filter out nulls
clean_data = @filter(data, @lambda(x, x != null))
# Result: [1, 3, 5]

# Count non-null values
non_null_count = @filter(data, @exists).length

# Replace nulls
filled_data = @map(data, @lambda(x, x ?? 0))
# Result: [1, 0, 3, 0, 5]
```

### Objects with Null Values

```tusk
user: {
    name: "John"
    email: null
    phone: null
    address: {
        street: "123 Main St"
        city: "Springfield"
        zip: null
    }
}

# Remove null properties
clean_user = @filter_object(user, @lambda(key, value, value != null))

# Get all null fields
null_fields = @filter(@entries(user), @lambda(entry, entry[1] == null))
```

## Database and Null

### Query Results

```tusk
# Database queries often return null
user = @db.query_one("SELECT * FROM users WHERE id = ?", user_id)

@if(user == null, {
    @response.status(404)
    @response.json({ error: "User not found" })
}, {
    @response.json(user)
})
```

### Null in SQL

```tusk
# Handle SQL NULL values
users_with_email = @db.query("""
    SELECT * FROM users 
    WHERE email IS NOT NULL
""")

# Insert with null
@db.execute("""
    INSERT INTO users (name, email, phone) 
    VALUES (?, ?, ?)
""", name, email ?? null, phone ?? null)
```

## JSON and Null

### JSON Serialization

```tusk
data: {
    name: "Product"
    description: null
    price: 19.99
}

# Null is preserved in JSON
json = @json.stringify(data)
# {"name":"Product","description":null,"price":19.99}

# Option to remove nulls
json_clean = @json.stringify(data, { exclude_null: true })
# {"name":"Product","price":19.99}
```

### JSON Parsing

```tusk
json_string: '{"name":"John","age":null}'
parsed = @json.parse(json_string)

# Check parsed values
has_age = parsed.age != null  # false
age = parsed.age ?? 0          # 0
```

## Null Safety Best Practices

### 1. Explicit Null Handling

```tusk
# Bad - assumes value exists
username = user.name.toUpperCase()

# Good - handles null
username = user?.name?.toUpperCase() ?? "ANONYMOUS"
```

### 2. Document Nullable Fields

```tusk
# User type definition
user_schema: {
    id: "string"          # Required
    name: "string"        # Required
    email: "string"       # Required
    phone: "string?"      # Optional (nullable)
    bio: "string?"        # Optional (nullable)
}
```

### 3. Validate Input

```tusk
validate_user = @lambda(data, {
    errors: []
    
    # Required fields cannot be null
    @if(data.name == null, {
        errors.push("Name is required")
    })
    
    # Optional fields can be null but validate if present
    @if(data.phone != null && !@validate.phone(data.phone), {
        errors.push("Invalid phone number")
    })
    
    return: {
        valid: @len(errors) == 0
        errors: errors
    }
})
```

### 4. Use Type Guards

```tusk
# Type guard function
is_valid_user = @lambda(obj, {
    return: obj != null && 
            obj.id != null && 
            obj.name != null &&
            obj.email != null
})

# Usage
@if(@is_valid_user(data), {
    # Safe to use data.id, data.name, data.email
    @process_user(data)
})
```

## Error Handling with Null

### Try-Catch Pattern

```tusk
safe_divide = @lambda(a, b, {
    @if(b == 0, {
        return: null  # Return null for invalid operation
    })
    return: a / b
})

result = @safe_divide(10, 0)
@if(result == null, {
    @print("Division by zero")
})
```

### Result Type Pattern

```tusk
# Return structured results instead of null
find_user_safe = @lambda(id, {
    user = @db.find_user(id)
    
    @if(user == null, {
        return: { success: false, error: "User not found" }
    })
    
    return: { success: true, data: user }
})

# Usage
result = @find_user_safe(123)
@if(result.success, {
    @print("Found user: ${result.data.name}")
}, {
    @print("Error: ${result.error}")
})
```

## Performance Considerations

### Null Check Ordering

```tusk
# Check null first (fast)
@if(value != null && @expensive_validation(value), {
    # Process
})

# Not this (expensive_validation might run on null)
@if(@expensive_validation(value) && value != null, {
    # Process
})
```

### Caching Null Results

```tusk
# Cache null results to avoid repeated lookups
user_cache: {}

get_user = @lambda(id, {
    # Check cache (including null values)
    @if(@has_key(user_cache, id), {
        return: user_cache[id]
    })
    
    # Fetch and cache (even if null)
    user = @db.find_user(id)
    user_cache[id] = user
    return: user
})
```

## Common Mistakes

### Comparing with Undefined

```tusk
# Wrong - undefined is not null
value = undefined
is_null = value == null  # false

# Right - check both
is_null_or_undefined = value == null || value == undefined
```

### Forgetting Null in Chains

```tusk
# Dangerous
length = user.name.length  # Error if user or name is null

# Safe
length = user?.name?.length ?? 0
```

### Null vs Empty

```tusk
# Don't confuse null with empty values
@if(user.bio == null, {
    # Bio was never set
})

@if(user.bio == "", {
    # Bio was set to empty string
})

# Check both if needed
@if(user.bio == null || user.bio == "", {
    # Bio is missing or empty
})
```

## Next Steps

- Learn about [Arrays](018-arrays.md) and null handling in collections
- Explore [Nested Objects](019-nested-objects.md) with nullable fields
- Master [Error Handling](029-syntax-errors.md) for null safety
---

[Arrays in TuskLang]


Arrays are ordered collections of values in TuskLang. They can contain any type of data, including other arrays and objects. This guide covers everything you need to know about working with arrays.

## Creating Arrays

### Array Literals

```tusk
# Empty array
empty: []

# Array of strings
fruits: ["apple", "banana", "orange"]

# Array of numbers
numbers: [1, 2, 3, 4, 5]

# Mixed types
mixed: ["string", 42, true, null, { key: "value" }]

# Nested arrays
matrix: [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

### Multiline Arrays

```tusk
# Cleaner for long arrays
users: [
    "Alice",
    "Bob",
    "Charlie",
    "David",
    "Eve"
]

# Array of objects
products: [
    {
        id: 1
        name: "Laptop"
        price: 999.99
    },
    {
        id: 2
        name: "Mouse"
        price: 29.99
    }
]
```

## Accessing Array Elements

### Index Access

```tusk
colors: ["red", "green", "blue", "yellow"]

# Access by index (0-based)
first = colors[0]        # "red"
second = colors[1]       # "green"
last = colors[3]         # "yellow"

# Negative indices (from end)
last_item = colors[-1]   # "yellow"
second_last = colors[-2] # "blue"

# Out of bounds returns null
invalid = colors[10]     # null
```

### Safe Access

```tusk
# Optional chaining for safe access
data: null
safe_access = data?.[0]  # null (no error)

# With nested arrays
matrix: [[1, 2], [3, 4]]
value = matrix?.[0]?.[1]  # 2

# With default values
item = array?.[index] ?? "default"
```

## Array Properties

### Length

```tusk
fruits: ["apple", "banana", "orange"]

# Get array length
count = @len(fruits)     # 3
count2 = fruits.length   # 3

# Check if empty
is_empty = @len(fruits) == 0
has_items = @len(fruits) > 0
```

### Type Checking

```tusk
# Check if value is array
data1: [1, 2, 3]
data2: "not an array"

is_array1 = @isArray(data1)  # true
is_array2 = @isArray(data2)  # false

# Check array contents
all_numbers = @all(data1, @isNumber)
has_string = @any(data1, @isString)
```

## Array Methods

### Adding Elements

```tusk
numbers: [1, 2, 3]

# Push (add to end)
@push(numbers, 4)         # [1, 2, 3, 4]

# Unshift (add to beginning)
@unshift(numbers, 0)      # [0, 1, 2, 3, 4]

# Insert at index
@insert(numbers, 2, 1.5)  # [0, 1, 1.5, 2, 3, 4]

# Concatenate arrays
more_numbers: [5, 6, 7]
combined = @concat(numbers, more_numbers)
```

### Removing Elements

```tusk
letters: ["a", "b", "c", "d", "e"]

# Pop (remove from end)
last = @pop(letters)      # "e", array is now ["a", "b", "c", "d"]

# Shift (remove from beginning)
first = @shift(letters)   # "a", array is now ["b", "c", "d"]

# Remove at index
@removeAt(letters, 1)     # Removes "c", array is now ["b", "d"]

# Remove by value
@remove(letters, "b")     # Array is now ["d"]
```

### Slicing and Splicing

```tusk
numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Slice (extract portion)
subset = @slice(numbers, 2, 5)    # [2, 3, 4]
from_index = @slice(numbers, 5)   # [5, 6, 7, 8, 9]
last_three = @slice(numbers, -3)  # [7, 8, 9]

# Splice (modify array)
removed = @splice(numbers, 2, 3)  # Removes 3 items at index 2
# numbers is now [0, 1, 5, 6, 7, 8, 9]

# Splice with replacement
@splice(numbers, 1, 2, ["a", "b", "c"])
# Replaces 2 items at index 1 with new items
```

## Array Transformation

### Map

```tusk
numbers: [1, 2, 3, 4, 5]

# Transform each element
doubled = @map(numbers, @lambda(n, n * 2))
# Result: [2, 4, 6, 8, 10]

# With index
indexed = @map(numbers, @lambda(n, i, "${i}: ${n}"))
# Result: ["0: 1", "1: 2", "2: 3", "3: 4", "4: 5"]

# Object transformation
users: [
    { name: "Alice", age: 30 },
    { name: "Bob", age: 25 }
]
names = @map(users, @lambda(user, user.name))
# Result: ["Alice", "Bob"]
```

### Filter

```tusk
numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Filter by condition
evens = @filter(numbers, @lambda(n, n % 2 == 0))
# Result: [2, 4, 6, 8, 10]

# Complex filtering
products: [
    { name: "Laptop", price: 999, inStock: true },
    { name: "Mouse", price: 29, inStock: false },
    { name: "Keyboard", price: 79, inStock: true }
]

available = @filter(products, @lambda(p, p.inStock && p.price < 100))
# Result: [{ name: "Keyboard", price: 79, inStock: true }]
```

### Reduce

```tusk
numbers: [1, 2, 3, 4, 5]

# Sum all numbers
sum = @reduce(numbers, @lambda(acc, n, acc + n), 0)
# Result: 15

# Find maximum
max = @reduce(numbers, @lambda(acc, n, @max(acc, n)), -Infinity)
# Result: 5

# Build object from array
pairs: [["a", 1], ["b", 2], ["c", 3]]
object = @reduce(pairs, @lambda(acc, pair, {
    acc[pair[0]] = pair[1]
    return: acc
}), {})
# Result: { a: 1, b: 2, c: 3 }
```

## Array Search

### Finding Elements

```tusk
fruits: ["apple", "banana", "orange", "banana"]

# Find index
index = @indexOf(fruits, "banana")      # 1
last_index = @lastIndexOf(fruits, "banana")  # 3
not_found = @indexOf(fruits, "grape")   # -1

# Check if includes
has_apple = @includes(fruits, "apple")  # true
has_grape = @includes(fruits, "grape")  # false

# Find with predicate
numbers: [1, 5, 10, 15, 20]
first_large = @find(numbers, @lambda(n, n > 10))      # 15
index_large = @findIndex(numbers, @lambda(n, n > 10)) # 3
```

### Array Testing

```tusk
numbers: [2, 4, 6, 8, 10]

# Test if all match condition
all_even = @all(numbers, @lambda(n, n % 2 == 0))  # true

# Test if any match condition
has_large = @any(numbers, @lambda(n, n > 7))      # true

# Count matching elements
even_count = @count(numbers, @lambda(n, n % 2 == 0))  # 5
```

## Array Sorting

### Basic Sorting

```tusk
# Sort numbers
numbers: [3, 1, 4, 1, 5, 9]
sorted = @sort(numbers)           # [1, 1, 3, 4, 5, 9]
descending = @sort(numbers, "desc")  # [9, 5, 4, 3, 1, 1]

# Sort strings
words: ["banana", "apple", "cherry"]
alphabetical = @sort(words)       # ["apple", "banana", "cherry"]

# Natural sort (handles numbers in strings)
files: ["file10.txt", "file2.txt", "file1.txt"]
natural = @sort.natural(files)    # ["file1.txt", "file2.txt", "file10.txt"]
```

### Custom Sorting

```tusk
# Sort objects
users: [
    { name: "Alice", age: 30 },
    { name: "Bob", age: 25 },
    { name: "Charlie", age: 35 }
]

# Sort by age
by_age = @sort(users, @lambda(a, b, a.age - b.age))

# Sort by multiple criteria
sorted_users = @sort(users, @lambda(a, b, {
    # First by age, then by name
    @if(a.age != b.age,
        a.age - b.age,
        @compare(a.name, b.name)
    )
}))
```

## Array Manipulation

### Reverse

```tusk
original: [1, 2, 3, 4, 5]
reversed = @reverse(original)  # [5, 4, 3, 2, 1]

# Original unchanged
# Use @reverse! for in-place reversal
```

### Unique Values

```tusk
numbers: [1, 2, 2, 3, 3, 3, 4]
unique = @unique(numbers)      # [1, 2, 3, 4]

# Unique by property
users: [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 1, name: "Alice Duplicate" }
]
unique_users = @uniqueBy(users, @lambda(u, u.id))
```

### Flatten

```tusk
nested: [[1, 2], [3, 4], [5, 6]]
flat = @flatten(nested)        # [1, 2, 3, 4, 5, 6]

# Deep flatten
deep_nested: [1, [2, [3, [4, 5]]]]
deep_flat = @flatten(deep_nested, Infinity)  # [1, 2, 3, 4, 5]

# Flatten one level
one_level = @flatten(deep_nested, 1)  # [1, 2, [3, [4, 5]]]
```

## Array Grouping

### Group By

```tusk
people: [
    { name: "Alice", department: "Engineering" },
    { name: "Bob", department: "Sales" },
    { name: "Charlie", department: "Engineering" },
    { name: "David", department: "Sales" }
]

# Group by department
by_dept = @groupBy(people, @lambda(p, p.department))
# Result: {
#   "Engineering": [Alice, Charlie],
#   "Sales": [Bob, David]
# }

# Group with custom key
by_name_length = @groupBy(people, @lambda(p, @len(p.name)))
```

### Partition

```tusk
numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Split into two groups
[evens, odds] = @partition(numbers, @lambda(n, n % 2 == 0))
# evens: [2, 4, 6, 8, 10]
# odds: [1, 3, 5, 7, 9]

# Chunk into groups of size
chunks = @chunk(numbers, 3)
# Result: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
```

## Array Operations

### Set Operations

```tusk
set1: [1, 2, 3, 4, 5]
set2: [4, 5, 6, 7, 8]

# Union (all unique elements)
union = @union(set1, set2)           # [1, 2, 3, 4, 5, 6, 7, 8]

# Intersection (common elements)
intersection = @intersection(set1, set2)  # [4, 5]

# Difference (in first but not second)
difference = @difference(set1, set2)      # [1, 2, 3]

# Symmetric difference (in either but not both)
sym_diff = @symmetricDifference(set1, set2)  # [1, 2, 3, 6, 7, 8]
```

### Zip and Unzip

```tusk
names: ["Alice", "Bob", "Charlie"]
ages: [30, 25, 35]
cities: ["NYC", "LA", "Chicago"]

# Zip arrays together
zipped = @zip(names, ages, cities)
# Result: [
#   ["Alice", 30, "NYC"],
#   ["Bob", 25, "LA"],
#   ["Charlie", 35, "Chicago"]
# ]

# Unzip
[names2, ages2, cities2] = @unzip(zipped)
```

## Array Patterns

### Array Destructuring

```tusk
# Basic destructuring
point: [10, 20]
[x, y] = point  # x: 10, y: 20

# With rest
numbers: [1, 2, 3, 4, 5]
[first, second, ...rest] = numbers
# first: 1, second: 2, rest: [3, 4, 5]

# Skip elements
[a, , c] = ["A", "B", "C"]  # a: "A", c: "C"
```

### Array Builders

```tusk
# Range function
range = @range(1, 10)        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = @range(0, 10, 2)     # [0, 2, 4, 6, 8, 10]

# Array from repeated value
repeated = @repeat("x", 5)    # ["x", "x", "x", "x", "x"]

# Array from function
generated = @generate(5, @lambda(i, i * i))  # [0, 1, 4, 9, 16]
```

## Performance Considerations

### Efficient Operations

```tusk
# Avoid multiple passes
# Inefficient
filtered = @filter(array, condition)
mapped = @map(filtered, transform)

# Efficient - single pass
result = @reduce(array, @lambda(acc, item, {
    @if(condition(item), {
        @push(acc, transform(item))
    })
    return: acc
}), [])
```

### Array vs Object

```tusk
# Use arrays for ordered collections
items: ["first", "second", "third"]

# Use objects for keyed access
lookup: {
    "key1": "value1"
    "key2": "value2"
}

# Don't use arrays as maps
# Bad
user_array: [["id", 123], ["name", "John"]]

# Good
user_object: { id: 123, name: "John" }
```

## Common Mistakes

### Modifying During Iteration

```tusk
# Wrong - modifying array while iterating
@each(array, @lambda(item, i, {
    @if(condition, {
        @removeAt(array, i)  # Dangerous!
    })
}))

# Right - filter instead
filtered = @filter(array, @lambda(item, !condition))
```

### Reference vs Copy

```tusk
# Arrays are passed by reference
original: [1, 2, 3]
reference = original
@push(reference, 4)  # Modifies original!

# Create a copy
copy = [...original]  # Spread operator
copy2 = @slice(original)  # Full slice
copy3 = @concat([], original)  # Concatenate with empty
```

## Best Practices

1. **Use descriptive array names** - plural nouns for collections
2. **Check bounds** before accessing indices
3. **Prefer immutable operations** - don't modify original arrays
4. **Use appropriate methods** - filter instead of manual loops
5. **Handle empty arrays** gracefully
6. **Document array structure** for complex data
7. **Consider performance** for large arrays

## Next Steps

- Learn about [Nested Objects](019-nested-objects.md) in arrays
- Explore [Array Methods](031-at-operator-intro.md) with @ operators
- Master [Best Practices](030-best-practices.md) for data structures
---

[Nested Objects in TuskLang]


Nested objects allow you to create complex, hierarchical data structures in TuskLang. This guide covers creating, accessing, and manipulating nested objects effectively.

## Creating Nested Objects

### Basic Nesting

```tusk
# Simple nested object
user:
    name: "John Doe"
    age: 30
    address:
        street: "123 Main St"
        city: "Springfield"
        country: "USA"
```

### Deep Nesting

```tusk
# Multiple levels of nesting
company:
    name: "Tech Corp"
    founded: 2010
    headquarters:
        address:
            street: "456 Tech Ave"
            city: "San Francisco"
            state: "CA"
            coordinates:
                lat: 37.7749
                lng: -122.4194
        building:
            floors: 10
            parking: true
    departments:
        engineering:
            head: "Alice Johnson"
            employees: 50
            teams:
                frontend:
                    lead: "Bob Smith"
                    members: 12
                backend:
                    lead: "Carol White"
                    members: 15
```

## Accessing Nested Values

### Dot Notation

```tusk
company:
    name: "Tech Corp"
    location:
        city: "San Francisco"
        state: "CA"

# Access nested values
company_name: company.name
city: company.location.city
state: company.location.state

# Deep access
building_floors: company.headquarters.building.floors
```

### Bracket Notation

```tusk
# Useful for dynamic keys
key: "location"
location = company[key]

# Accessing with variables
property: "city"
city = company.location[property]

# Mixed notation
value = company["location"].city
```

### Optional Chaining

```tusk
# Safe access to nested properties
user:
    profile:
        settings: null

# Without optional chaining (might error)
# theme = user.profile.settings.theme  # Error!

# With optional chaining
theme = user?.profile?.settings?.theme ?? "default"

# Check deeply nested values
has_premium = user?.subscription?.type == "premium"
```

## Modifying Nested Objects

### Direct Assignment

```tusk
user:
    name: "John"
    preferences:
        theme: "light"
        language: "en"

# Modify nested value
user.preferences.theme = "dark"

# Add new nested property
user.preferences.notifications = true

# Create nested structure on the fly
user.social = {
    twitter: "@john"
    github: "john-doe"
}
```

### Dynamic Path Assignment

```tusk
# Set value at dynamic path
set_nested = @lambda(obj, path, value, {
    keys = @split(path, ".")
    current = obj
    
    @each(keys, @lambda(key, index, {
        @if(index == @len(keys) - 1, {
            current[key] = value
        }, {
            current[key] = current[key] || {}
            current = current[key]
        })
    }))
})

# Usage
config: {}
@set_nested(config, "database.host", "localhost")
@set_nested(config, "database.port", 5432)
# Result: { database: { host: "localhost", port: 5432 } }
```

## Merging Nested Objects

### Shallow Merge

```tusk
defaults:
    theme: "light"
    language: "en"
    features:
        autoSave: true
        spellCheck: true

user_prefs:
    theme: "dark"
    features:
        autoSave: false

# Shallow merge (features object replaced entirely)
merged = @merge(defaults, user_prefs)
# Result: features only has autoSave: false
```

### Deep Merge

```tusk
# Deep merge function
deep_merge = @lambda(target, source, {
    @each(@keys(source), @lambda(key, {
        @if(@isObject(source[key]) && @isObject(target[key]), {
            target[key] = @deep_merge(target[key], source[key])
        }, {
            target[key] = source[key]
        })
    }))
    return: target
})

# Usage
result = @deep_merge(@clone(defaults), user_prefs)
# Result: features has both autoSave: false and spellCheck: true
```

## Working with Complex Structures

### Mixed Arrays and Objects

```tusk
data:
    users: [
        {
            id: 1
            name: "Alice"
            roles: ["admin", "user"]
            permissions:
                read: true
                write: true
                delete: true
        },
        {
            id: 2
            name: "Bob"
            roles: ["user"]
            permissions:
                read: true
                write: false
                delete: false
        }
    ]
    settings:
        max_users: 100
        features: ["chat", "video", "screen-share"]

# Access mixed structures
first_user_name: data.users[0].name
admin_can_delete: data.users[0].permissions.delete
available_features: data.settings.features
```

### Recursive Structures

```tusk
# Tree structure
file_system:
    name: "root"
    type: "directory"
    children: [
        {
            name: "home"
            type: "directory"
            children: [
                {
                    name: "user"
                    type: "directory"
                    children: [
                        {
                            name: "document.txt"
                            type: "file"
                            size: 1024
                        }
                    ]
                }
            ]
        },
        {
            name: "etc"
            type: "directory"
            children: []
        }
    ]

# Recursive function to find files
find_files = @lambda(node, files = [], {
    @if(node.type == "file", {
        @push(files, node)
    }, {
        @each(node.children || [], @lambda(child, {
            @find_files(child, files)
        }))
    })
    return: files
})
```

## Validation and Type Checking

### Schema Validation

```tusk
# Define schema
user_schema:
    name: { type: "string", required: true }
    age: { type: "number", min: 0, max: 150 }
    email: { type: "string", pattern: "^[^@]+@[^@]+$" }
    address: {
        type: "object"
        properties: {
            street: { type: "string" }
            city: { type: "string", required: true }
            zip: { type: "string", pattern: "^\\d{5}$" }
        }
    }

# Validation function
validate_object = @lambda(obj, schema, path = "", {
    errors: []
    
    @each(@keys(schema), @lambda(key, {
        field_schema = schema[key]
        value = obj[key]
        field_path = path ? "${path}.${key}" : key
        
        # Check required
        @if(field_schema.required && value == null, {
            @push(errors, "${field_path} is required")
            return
        })
        
        # Type checking
        @if(value != null && field_schema.type, {
            @if(field_schema.type == "object" && field_schema.properties, {
                # Recursive validation
                nested_errors = @validate_object(value, field_schema.properties, field_path)
                errors = @concat(errors, nested_errors.errors)
            }, {
                # Simple type check
                @if(!@checkType(value, field_schema.type), {
                    @push(errors, "${field_path} must be ${field_schema.type}")
                })
            })
        })
    }))
    
    return: { valid: @len(errors) == 0, errors: errors }
})
```

## Transformation Patterns

### Object Mapping

```tusk
# Transform nested structure
transform_user = @lambda(user, {
    return: {
        id: user.id
        displayName: "${user.firstName} ${user.lastName}"
        contact: {
            email: user.emailAddress
            phone: user.phoneNumber
        }
        location: "${user.address.city}, ${user.address.state}"
        isActive: user.status == "active"
    }
})

# Batch transformation
users: [/* array of users */]
transformed = @map(users, transform_user)
```

### Flattening Objects

```tusk
# Flatten nested object to dot notation
flatten_object = @lambda(obj, prefix = "", result = {}, {
    @each(@keys(obj), @lambda(key, {
        new_key = prefix ? "${prefix}.${key}" : key
        
        @if(@isObject(obj[key]) && !@isArray(obj[key]), {
            @flatten_object(obj[key], new_key, result)
        }, {
            result[new_key] = obj[key]
        })
    }))
    
    return: result
})

# Example
nested:
    user:
        name: "John"
        address:
            city: "NYC"
            zip: "10001"

flat = @flatten_object(nested)
# Result: {
#   "user.name": "John",
#   "user.address.city": "NYC",
#   "user.address.zip": "10001"
# }
```

### Unflattening Objects

```tusk
# Convert dot notation back to nested
unflatten_object = @lambda(obj, {
    result: {}
    
    @each(@keys(obj), @lambda(key, {
        @set_nested(result, key, obj[key])
    }))
    
    return: result
})
```

## Query and Filter Patterns

### Deep Search

```tusk
# Search nested objects
find_in_object = @lambda(obj, predicate, results = [], path = "", {
    @if(@predicate(obj, path), {
        @push(results, { value: obj, path: path })
    })
    
    @if(@isObject(obj), {
        @each(@keys(obj), @lambda(key, {
            new_path = path ? "${path}.${key}" : key
            @find_in_object(obj[key], predicate, results, new_path)
        }))
    })
    
    return: results
})

# Find all email fields
emails = @find_in_object(data, @lambda(value, path, {
    @isString(value) && @includes(path, "email")
}))
```

### Path-based Access

```tusk
# Get value by path
get_by_path = @lambda(obj, path, {
    keys = @split(path, ".")
    return: @reduce(keys, @lambda(current, key, current?.[key]), obj)
})

# Set value by path
set_by_path = @lambda(obj, path, value, {
    keys = @split(path, ".")
    last_key = @pop(keys)
    target = @reduce(keys, @lambda(current, key, {
        current[key] = current[key] || {}
        return: current[key]
    }), obj)
    target[last_key] = value
})

# Usage
value = @get_by_path(company, "departments.engineering.head")
@set_by_path(company, "departments.engineering.budget", 1000000)
```

## Performance Considerations

### Avoid Deep Cloning

```tusk
# Expensive for large objects
deep_clone = @lambda(obj, {
    @JSON.parse(@JSON.stringify(obj))
})

# Better - clone only what you need
partial_clone = {
    id: original.id
    name: original.name
    settings: { ...original.settings }  # Shallow clone settings
}
```

### Lazy Evaluation

```tusk
# Don't compute all properties upfront
user_view:
    basic: user.basic_info
    
    # Compute expensive properties only when accessed
    detailed = @lazy({
        posts_count: @db.count("posts", { user_id: user.id })
        followers: @db.count("followers", { user_id: user.id })
        last_activity: @db.last_activity(user.id)
    })
```

## Best Practices

### 1. Keep Nesting Reasonable

```tusk
# Too deep (hard to work with)
data.users[0].profile.settings.preferences.ui.theme.color.primary

# Better - flatten where sensible
data.users[0].theme_primary_color
```

### 2. Use Consistent Structure

```tusk
# Consistent nested structure
api_response:
    success: true
    data: { /* actual data */ }
    error: null
    metadata: {
        timestamp: @time.now()
        version: "1.0"
    }
```

### 3. Document Complex Structures

```tusk
###
# User object structure:
# {
#   id: string
#   profile: {
#     name: string
#     email: string
#     preferences: {
#       theme: "light" | "dark"
#       language: string
#     }
#   }
#   permissions: string[]
# }
###
```

### 4. Handle Missing Properties

```tusk
# Defensive programming
safe_access = user?.profile?.email ?? "no-email@example.com"

# With defaults
user_settings = @merge(default_settings, user?.settings ?? {})
```

## Common Patterns

### Configuration Objects

```tusk
app_config:
    server:
        host: @env.HOST || "localhost"
        port: @env.PORT || 3000
        ssl:
            enabled: @env.NODE_ENV == "production"
            cert: "/path/to/cert"
            key: "/path/to/key"
    
    database:
        primary:
            host: @env.DB_HOST
            port: 5432
            name: @env.DB_NAME
        
        replica:
            host: @env.DB_REPLICA_HOST
            port: 5432
            name: @env.DB_NAME
    
    features:
        cache:
            enabled: true
            ttl: 3600
            driver: "redis"
```

### State Management

```tusk
app_state:
    user: {
        id: null
        authenticated: false
        profile: null
    }
    
    ui: {
        theme: "light"
        sidebar: {
            visible: true
            width: 250
        }
        modals: {
            login: false
            settings: false
        }
    }
    
    data: {
        posts: []
        comments: {}
        loading: {
            posts: false
            comments: false
        }
    }
```

## Next Steps

- Learn about [Inline Objects](020-inline-objects.md) for compact syntax
- Explore [References](026-references.md) for object relationships
- Master [Best Practices](030-best-practices.md) for data modeling
---

[Inline Objects in TuskLang]


Inline objects provide a compact syntax for creating objects within a single line or expression. This guide covers the syntax, use cases, and best practices for inline objects.

## Basic Inline Object Syntax

### Single Line Objects

```tusk
# Basic inline object
point: { x: 10, y: 20 }

# With different value types
person: { name: "John", age: 30, active: true }

# Empty object
empty: {}

# Nested inline
user: { id: 1, address: { city: "NYC", zip: "10001" } }
```

### Inline Objects in Arrays

```tusk
# Array of inline objects
users: [
    { id: 1, name: "Alice", role: "admin" },
    { id: 2, name: "Bob", role: "user" },
    { id: 3, name: "Charlie", role: "user" }
]

# Mixed array
data: [
    "string",
    123,
    { type: "object", value: true },
    ["nested", "array"]
]
```

## Property Syntax

### Key-Value Pairs

```tusk
# Standard property syntax
config: { host: "localhost", port: 8080, ssl: false }

# With quotes (when needed)
special: { "key-with-dash": "value", "123": "numeric key" }

# Computed property names
key: "dynamic"
obj: { [key]: "value", ["computed_" + key]: "another value" }
```

### Property Shorthand

```tusk
# When variable name matches property name
name: "John"
age: 30

# Longhand
person1: { name: name, age: age }

# Shorthand
person2: { name, age }  # Same as above

# Mixed
email: "john@example.com"
user: { name, age, email: email, active: true }
```

## Dynamic Values in Inline Objects

### Expressions as Values

```tusk
# Computed values
stats: {
    total: 100,
    completed: 75,
    percentage: 75 / 100 * 100,
    status: 75 >= 70 ? "passing" : "failing"
}

# Function calls
metadata: {
    timestamp: @time.now(),
    uuid: @uuid.generate(),
    hash: @crypto.hash("data")
}
```

### Conditional Properties

```tusk
# Using ternary operator
user: {
    name: "John",
    role: is_admin ? "admin" : "user",
    permissions: is_admin ? ["read", "write", "delete"] : ["read"]
}

# Spread with conditions
base: { name: "Product", price: 100 }
product = {
    ...base,
    ...(on_sale ? { discount: 20, sale_price: 80 } : {})
}
```

## Spread Operator

### Object Spreading

```tusk
# Spread existing object
defaults: { theme: "light", language: "en" }
settings: { ...defaults, theme: "dark" }
# Result: { theme: "dark", language: "en" }

# Multiple spreads
obj1: { a: 1, b: 2 }
obj2: { b: 3, c: 4 }
combined: { ...obj1, ...obj2, d: 5 }
# Result: { a: 1, b: 3, c: 4, d: 5 }
```

### Conditional Spreading

```tusk
# Conditionally include properties
include_debug: true
config: {
    host: "localhost",
    port: 8080,
    ...(include_debug ? { debug: true, verbose: true } : {})
}

# Pattern for optional properties
create_user = @lambda(name, options = {}, {
    return: {
        id: @uuid.generate(),
        name: name,
        created: @time.now(),
        ...options  # Spread any additional options
    }
})
```

## Inline Objects in Functions

### As Function Arguments

```tusk
# Direct inline object as argument
@http.post("/api/users", { name: "John", email: "john@example.com" })

# With variables
user_data: { name: "Jane", role: "admin" }
@database.insert("users", { ...user_data, created_at: @time.now() })

# Multiple inline objects
@merge(
    { a: 1, b: 2 },
    { b: 3, c: 4 },
    { d: 5 }
)
```

### As Return Values

```tusk
# Return inline object
get_user_summary = @lambda(user, {
    return: {
        id: user.id,
        display_name: "${user.first_name} ${user.last_name}",
        avatar: user.avatar || "/default-avatar.png"
    }
})

# Conditional return
check_status = @lambda(value, {
    return: value > 0 
        ? { success: true, value: value }
        : { success: false, error: "Invalid value" }
})
```

## Method Syntax in Inline Objects

### Methods as Properties

```tusk
# Object with methods
calculator: {
    add: @lambda(a, b, a + b),
    subtract: @lambda(a, b, a - b),
    multiply: @lambda(a, b, a * b),
    divide: @lambda(a, b, {
        @assert(b != 0, "Division by zero")
        return: a / b
    })
}

# Usage
result = calculator.add(5, 3)  # 8
```

### Method Chaining Pattern

```tusk
# Fluent interface
query_builder: {
    _conditions: [],
    
    where: @lambda(condition, {
        @push(_conditions, condition)
        return: @self  # Return self for chaining
    }),
    
    and: @lambda(condition, {
        @push(_conditions, "AND ${condition}")
        return: @self
    }),
    
    build: @lambda({
        return: @join(_conditions, " ")
    })
}

# Usage
query = query_builder
    .where("age > 18")
    .and("status = 'active'")
    .build()
```

## Nested Inline Objects

### Deep Nesting

```tusk
# Complex nested structure
api_response: {
    status: "success",
    data: {
        user: { id: 1, name: "John" },
        posts: [
            { id: 101, title: "First Post", meta: { views: 100 } },
            { id: 102, title: "Second Post", meta: { views: 200 } }
        ]
    },
    metadata: { timestamp: @time.now(), version: "1.0" }
}
```

### Formatting Nested Inline Objects

```tusk
# More readable formatting
config: {
    server: { host: "localhost", port: 8080 },
    database: { 
        host: "db.example.com", 
        port: 5432,
        credentials: { user: "admin", pass: @env.DB_PASS }
    },
    cache: { enabled: true, ttl: 3600 }
}
```

## Type Annotations in Inline Objects

### Inline Type Hints

```tusk
# With type annotations
typed_object: {
    name: string = "John",
    age: number = 30,
    active: boolean = true,
    tags: string[] = ["user", "premium"]
}

# Function with typed inline return
get_point = @lambda(x: number, y: number, {
    return: { x: number = x, y: number = y }
})
```

## Common Patterns

### Options Objects

```tusk
# Function with inline options
fetch_data = @lambda(url, options = {}, {
    defaults: {
        method: "GET",
        headers: {},
        timeout: 30000
    }
    
    config = { ...defaults, ...options }
    return: @http.request(url, config)
})

# Usage
@fetch_data("/api/users", { 
    method: "POST", 
    headers: { "Content-Type": "application/json" } 
})
```

### Factory Functions

```tusk
# Create objects with inline syntax
create_user = @lambda(data, {
    return: {
        id: @uuid.generate(),
        ...data,
        created_at: @time.now(),
        updated_at: @time.now(),
        status: "active"
    }
})

# Usage
new_user = @create_user({ name: "Alice", email: "alice@example.com" })
```

### State Updates

```tusk
# Immutable state update pattern
state: { count: 0, items: [] }

# Update with inline object
new_state = { 
    ...state, 
    count: state.count + 1,
    items: [...state.items, { id: 1, name: "New Item" }]
}
```

## Performance Considerations

### Object Creation Cost

```tusk
# Avoid creating objects in loops
# Inefficient
results = @map(items, @lambda(item, {
    return: { ...defaults, value: item }  # New object each time
}))

# Better - reuse structure
template: { ...defaults }
results = @map(items, @lambda(item, {
    template.value = item
    return: { ...template }  # Clone only when needed
}))
```

### Spread Performance

```tusk
# Multiple spreads can be costly
# Avoid deep spreading in hot paths
result = { ...obj1, ...obj2, ...obj3, ...obj4 }

# Consider Object.assign for many objects
result = @Object.assign({}, obj1, obj2, obj3, obj4)
```

## Best Practices

### 1. Keep Inline Objects Simple

```tusk
# Good - simple and readable
point: { x: 10, y: 20 }

# Too complex for inline
# Better to use multi-line format
complex: { a: { b: { c: { d: { e: "too deep" } } } } }
```

### 2. Use Meaningful Property Names

```tusk
# Bad
data: { a: 1, b: "test", c: true }

# Good
data: { id: 1, name: "test", active: true }
```

### 3. Format for Readability

```tusk
# Single line for simple objects
point: { x: 10, y: 20 }

# Multi-line for clarity when needed
user: {
    id: 1,
    name: "John",
    email: "john@example.com",
    roles: ["user", "editor"]
}
```

### 4. Avoid Side Effects

```tusk
# Bad - side effect in inline object
obj: { 
    value: counter++,  # Modifies external state
    timestamp: @log("Creating object")  # Side effect
}

# Good - pure inline object
obj: {
    value: counter,
    timestamp: @time.now()
}
```

## Common Mistakes

### Missing Commas

```tusk
# Wrong - missing comma
obj: { a: 1 b: 2 }  # Syntax error

# Right
obj: { a: 1, b: 2 }
```

### Trailing Commas

```tusk
# Valid in TuskLang
obj: { 
    a: 1, 
    b: 2,  # Trailing comma OK
}
```

### Quote Confusion

```tusk
# Property names usually don't need quotes
good: { name: "John", age: 30 }

# Only use quotes when necessary
special: { "key-with-dash": "value", "123": "numeric string key" }
```

## Next Steps

- Learn about [Heredoc Strings](021-heredoc-strings.md) for multi-line text
- Explore [References](026-references.md) for object relationships
- Master [Best Practices](030-best-practices.md) for object design
---

[Heredoc Strings in TuskLang]


Heredoc strings provide a clean way to define multi-line text content in TuskLang. They're perfect for templates, documentation, SQL queries, and any other multi-line string content.

## Basic Heredoc Syntax

### Triple Quotes

```tusk
# Basic heredoc with """
message: """
Hello World!
This is a multi-line string.
It preserves line breaks and formatting.
"""

# The string includes the line breaks
# Result: "Hello World!\nThis is a multi-line string.\nIt preserves line breaks and formatting."
```

### Indentation Handling

```tusk
# Heredoc preserves indentation
yaml_content: """
    version: '3'
    services:
      web:
        image: nginx
        ports:
          - "80:80"
"""

# Leading spaces are preserved in the output
```

## Heredoc with Interpolation

### Variable Substitution

```tusk
name: "John"
age: 30

# Heredoc with interpolation
profile: """
Name: ${name}
Age: ${age}
Status: Active
"""

# Complex interpolation
user_data: {
    email: "john@example.com"
    role: "admin"
}

details: """
User Profile
============
Name: ${name}
Email: ${user_data.email}
Role: ${user_data.role}
Account Created: ${@time.now()}
"""
```

### Expressions in Heredoc

```tusk
items: ["apple", "banana", "orange"]
tax_rate: 0.08

receipt: """
Shopping Receipt
================
Items: ${@join(items, ", ")}
Subtotal: $${subtotal}
Tax (${tax_rate * 100}%): $${subtotal * tax_rate}
Total: $${subtotal * (1 + tax_rate)}

Thank you for shopping!
"""
```

## Special Heredoc Markers

### Custom Delimiters

```tusk
# Using custom end markers
sql_query: <<SQL
SELECT u.id, u.name, u.email
FROM users u
WHERE u.active = true
  AND u.created_at > '2024-01-01'
ORDER BY u.name
SQL

# HTML content
html_template: <<HTML
<!DOCTYPE html>
<html>
    <head>
        <title>${page_title}</title>
    </head>
    <body>
        <h1>${heading}</h1>
        <p>${content}</p>
    </body>
</html>
HTML
```

### Indented Heredoc Markers

```tusk
# Strip common leading whitespace with <<<
formatted_text: <<<
    This text has
    consistent indentation
    that will be stripped
>>>

# Result has no leading spaces:
# "This text has\nconsistent indentation\nthat will be stripped"
```

## Practical Use Cases

### Configuration Files

```tusk
# Generate configuration files
nginx_config: """
server {
    listen ${port};
    server_name ${server_name};
    
    location / {
        proxy_pass http://${backend_host}:${backend_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    location /static {
        alias ${static_path};
        expires 30d;
    }
}
"""

# Write to file
@file.write("/etc/nginx/sites-available/${site_name}", nginx_config)
```

### Email Templates

```tusk
# Email template with heredoc
welcome_email: """
Subject: Welcome to ${app_name}!

Dear ${user_name},

Welcome to ${app_name}! We're excited to have you on board.

Your account has been created with the following details:
- Username: ${username}
- Email: ${email}
- Account Type: ${account_type}

To get started:
1. Log in at ${login_url}
2. Complete your profile
3. Explore our features

If you have any questions, feel free to contact us at ${support_email}.

Best regards,
The ${app_name} Team

--
This is an automated message. Please do not reply to this email.
"""
```

### SQL Queries

```tusk
# Complex SQL with heredoc
report_query: """
WITH monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', order_date) as month,
        SUM(total_amount) as revenue,
        COUNT(DISTINCT customer_id) as customers
    FROM orders
    WHERE order_date >= '${start_date}'
      AND order_date <= '${end_date}'
      AND status = 'completed'
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT 
    TO_CHAR(month, 'YYYY-MM') as period,
    revenue,
    customers,
    revenue / NULLIF(customers, 0) as avg_order_value
FROM monthly_sales
ORDER BY month DESC
"""

# Execute query
results = @db.query(report_query)
```

### Code Generation

```tusk
# Generate code with heredoc
generate_class = @lambda(class_name, properties, {
    code: """
class ${class_name} {
    constructor(${@join(@map(properties, @lambda(p, p.name)), ", ")}) {
${@join(@map(properties, @lambda(p, "        this.${p.name} = ${p.name};")), "\n")}
    }
    
${@join(@map(properties, @lambda(p, """
    get${@capitalize(p.name)}() {
        return this.${p.name};
    }
    
    set${@capitalize(p.name)}(value) {
        this.${p.name} = value;
    }""")), "\n\n")}
}

module.exports = ${class_name};
"""
    
    return: code
})
```

## Heredoc Best Practices

### 1. Choose Appropriate Delimiters

```tusk
# Use meaningful delimiters for content type
json_data: <<JSON
{
    "name": "${name}",
    "version": "${version}"
}
JSON

xml_data: <<XML
<config>
    <name>${name}</name>
    <version>${version}</version>
</config>
XML

shell_script: <<BASH
#!/bin/bash
echo "Installing ${app_name}..."
mkdir -p ${install_dir}
cp -r ./files/* ${install_dir}/
BASH
```

### 2. Handle Escaping

```tusk
# Escape special characters when needed
regex_pattern: """
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$
"""

# Or use raw heredoc (no interpolation)
raw_text: '''
This ${variable} won't be interpolated.
Special characters like \ and " are preserved as-is.
'''
```

### 3. Format for Readability

```tusk
# Well-formatted heredoc
markdown: """
# ${title}

## Introduction

${introduction_text}

## Features

${@join(@map(features, @lambda(f, "- ${f}")), "\n")}

## Installation

\`\`\`bash
${installation_commands}
\`\`\`

## Usage

${usage_instructions}

---

*Generated on ${@time.format(@time.now(), "YYYY-MM-DD")}*
"""
```

## Advanced Heredoc Patterns

### Conditional Content

```tusk
# Include content conditionally
email_body: """
Hi ${name},

${@if(is_new_user, """
Welcome to our platform! As a new user, here are some tips to get started:
- Complete your profile
- Explore our tutorials
- Join our community forum
""", """
Welcome back! Here's what's new since your last visit:
- New features added
- Performance improvements
- Bug fixes
""")}

Best regards,
The Team
"""
```

### Dynamic Indentation

```tusk
# Generate indented code
generate_nested = @lambda(items, level = 0, {
    indent = @repeat("  ", level)
    
    content: """
${@join(@map(items, @lambda(item, {
    @if(item.children, """
${indent}${item.name}:
${@generate_nested(item.children, level + 1)}""", 
    "${indent}${item.name}: ${item.value}")
})), "\n")}
"""
    
    return: @trim(content)
})
```

### Template Composition

```tusk
# Compose templates from parts
header_template: """
<!DOCTYPE html>
<html>
<head>
    <title>${title}</title>
    <meta charset="UTF-8">
</head>
<body>
"""

footer_template: """
    <footer>
        <p>&copy; ${year} ${company_name}</p>
    </footer>
</body>
</html>
"""

# Combine templates
full_page = @lambda(title, content, {
    return: """
${header_template}
    <main>
        ${content}
    </main>
${footer_template}
"""
})
```

## Heredoc with Functions

### Processing Heredoc Content

```tusk
# Process heredoc content
csv_data: """
name,age,city
John,30,New York
Jane,25,Los Angeles
Bob,35,Chicago
"""

# Parse CSV from heredoc
rows = @csv.parse(csv_data)

# Minify heredoc content
minified_js: @minify("""
    function hello(name) {
        console.log('Hello, ' + name);
        return true;
    }
""")
```

### Heredoc in Lambdas

```tusk
# Return heredoc from function
generate_report = @lambda(data, {
    return: """
    Sales Report
    ============
    
    Period: ${data.start_date} to ${data.end_date}
    
    Summary:
    - Total Sales: $${data.total_sales}
    - Number of Orders: ${data.order_count}
    - Average Order Value: $${data.avg_order_value}
    
    Top Products:
    ${@join(@map(data.top_products, @lambda(p, "- ${p.name}: $${p.revenue}")), "\n")}
    """
})
```

## Common Pitfalls

### Unintended Whitespace

```tusk
# Be careful with trailing spaces
text: """
Line with trailing spaces    
Another line
"""  # The spaces after "spaces" are preserved

# Use trim if needed
clean_text = @trim(text)
```

### Quote Confusion

```tusk
# Triple quotes must be on their own line
# Wrong:
# text: """Hello
# World"""

# Right:
text: """
Hello
World
"""
```

### Interpolation Issues

```tusk
# Escape $ if you don't want interpolation
price_template: """
The price is \$${price}
"""  # Results in "The price is $19.99"

# Or use single-quote heredoc
literal: '''
The ${variable} syntax is preserved literally
'''
```

## Performance Considerations

### Large Heredocs

```tusk
# For very large static content, consider external files
# Instead of:
huge_template: """
[10,000 lines of content]
"""

# Better:
huge_template: @file.read("templates/huge_template.txt")
```

### Repeated Interpolation

```tusk
# Cache interpolated results if used multiple times
email_template: """
Dear ${customer_name},
[rest of template]
"""

# If sending many emails, cache the base template
base_template: @template.compile(email_template)
final_email = @base_template.render({ customer_name: "John" })
```

## Best Practices Summary

1. **Use heredoc for multi-line strings** - Much cleaner than concatenation
2. **Choose meaningful delimiters** - SQL, HTML, JSON, etc.
3. **Be mindful of whitespace** - Heredocs preserve formatting
4. **Use interpolation wisely** - Escape when needed
5. **Consider external files** for very large content
6. **Strip common indentation** with <<< when appropriate
7. **Document heredoc purpose** with comments

## Next Steps

- Learn about [Escaping Characters](022-escaping-characters.md)
- Master [String Interpolation](014-strings.md)
- Explore [Template Patterns](030-best-practices.md)
---

[Escaping Characters in TuskLang]


Understanding character escaping is essential for handling special characters, preventing syntax errors, and ensuring your strings contain exactly what you intend. This guide covers all aspects of character escaping in TuskLang.

## Basic Escape Sequences

### Common Escape Characters

```tusk
# Newline
line_break: "First line\nSecond line"

# Tab
tabbed: "Column1\tColumn2\tColumn3"

# Carriage return
cr_text: "Overwrite\rText"

# Backslash
path: "C:\\Users\\Documents"

# Quotes in strings
single_in_double: "It's working"
double_in_double: "She said, \"Hello!\""
single_in_single: 'It\'s working'
double_in_single: 'She said, "Hello!"'
```

### Complete Escape Reference

```tusk
escapes:
    newline: "\n"          # Line feed (LF)
    carriage: "\r"         # Carriage return (CR)
    tab: "\t"              # Horizontal tab
    backslash: "\\"        # Backslash
    double_quote: "\""     # Double quote
    single_quote: "\'"     # Single quote
    null_char: "\0"        # Null character
    bell: "\a"             # Alert/Bell
    backspace: "\b"        # Backspace
    form_feed: "\f"        # Form feed
    vertical_tab: "\v"     # Vertical tab
```

## Unicode Escapes

### Unicode Code Points

```tusk
# Unicode escape sequences
unicode_chars:
    # Basic unicode escape (4 digits)
    heart: "\u2764"        # ❤
    star: "\u2605"         # ★
    check: "\u2713"        # ✓
    
    # Extended unicode (with braces)
    emoji_smile: "\u{1F600}"    # 😀
    emoji_rocket: "\u{1F680}"   # 🚀
    emoji_wave: "\u{1F44B}"     # 👋
    
    # Combining characters
    accented: "e\u0301"    # é (e + combining acute accent)
```

### Hexadecimal Escapes

```tusk
# Hex escape sequences
hex_chars:
    space: "\x20"          # Space character
    uppercase_a: "\x41"    # 'A'
    delete: "\x7F"         # DEL character
    
# Building strings with hex
ascii_art: "\x2A\x2A\x2A\x20\x48\x65\x6C\x6C\x6F\x20\x2A\x2A\x2A"
# Result: "*** Hello ***"
```

## Escaping in Different Contexts

### String Interpolation

```tusk
name: "World"

# Escape the dollar sign to prevent interpolation
literal_dollar: "The price is \$100"           # Result: "The price is $100"
interpolated: "Hello, ${name}!"                # Result: "Hello, World!"
escaped_interp: "The syntax is \${variable}"   # Result: "The syntax is ${variable}"

# Complex escaping
template: "Use \${var} for interpolation, \\n for newline"
```

### Regular Expressions

```tusk
# Regex patterns need proper escaping
patterns:
    # Escape regex special characters
    literal_dot: "\\."              # Matches literal period
    literal_star: "\\*"             # Matches literal asterisk
    backslash: "\\\\"               # Matches single backslash
    
    # Common regex patterns
    email: "^[^@]+@[^@]+\\.[^@]+$"
    phone: "\\+?\\d{1,3}[-.\\s]?\\d{3,4}[-.\\s]?\\d{4}"
    
    # Character classes
    whitespace: "\\s+"              # One or more whitespace
    word_boundary: "\\bword\\b"     # Word boundaries
    digit: "\\d{3}"                 # Three digits
```

### JSON Strings

```tusk
# Escaping for JSON
json_data: """
{
    "message": "Hello \"World\"",
    "path": "C:\\\\Users\\\\file.txt",
    "special": "Line 1\\nLine 2\\tTabbed"
}
"""

# Or use a function to auto-escape
safe_json = @json.stringify({
    message: 'Hello "World"'
    path: "C:\\Users\\file.txt"
    special: "Line 1\nLine 2\tTabbed"
})
```

### SQL Queries

```tusk
# Escape single quotes in SQL
user_input: "O'Brien"
safe_input = @replace(user_input, "'", "''")

query: "SELECT * FROM users WHERE name = '${safe_input}'"

# Better: Use parameterized queries
@db.query("SELECT * FROM users WHERE name = ?", user_input)
```

## Special String Syntax

### Raw Strings

```tusk
# Use single quotes to reduce escaping needs
raw_regex: '\\d{3}-\\d{3}-\\d{4}'  # Phone pattern
raw_path: 'C:\Users\Documents'      # Windows path

# Triple single quotes for raw heredoc
raw_heredoc: '''
This text contains ${variables} and \n escape sequences
that are NOT processed. What you see is what you get.
'''
```

### Verbatim Strings

```tusk
# For paths and patterns
windows_path: @raw("C:\Users\John\Documents\file.txt")
regex_pattern: @raw("\d{3}-\d{3}-\d{4}")

# Alternative syntax with backticks (if supported)
verbatim: `This is a \raw\ string with no \n processing`
```

## Escaping in URLs and URIs

### URL Encoding

```tusk
# Manual URL encoding
search_term: "hello world & more"
encoded: @replace_all(search_term, {
    " ": "%20",
    "&": "%26",
    "=": "%3D",
    "?": "%3F",
    "#": "%23"
})

# Better: Use built-in encoding
safe_url = "https://example.com/search?q=${@url.encode(search_term)}"

# Decode URL parameters
encoded_param: "hello%20world%20%26%20more"
decoded = @url.decode(encoded_param)  # "hello world & more"
```

### Path Escaping

```tusk
# File system paths
filename: "my file (2023).txt"
safe_filename = @replace_all(filename, {
    " ": "_",
    "(": "",
    ")": "",
    "&": "and"
})

# URL path segments
segment: "user/profile"
escaped_segment = @url.encode_path(segment)  # "user%2Fprofile"
```

## HTML and XML Escaping

### HTML Entities

```tusk
# HTML escape mapping
html_escapes:
    "&": "&amp;"
    "<": "&lt;"
    ">": "&gt;"
    '"': "&quot;"
    "'": "&#39;"

# Manual HTML escaping
user_content: "<script>alert('XSS')</script>"
safe_html = @replace_all(user_content, html_escapes)

# Built-in HTML escaping
escaped = @html.escape(user_content)
# Result: "&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;"

# Unescape HTML
unescaped = @html.unescape("&lt;div&gt;Hello&lt;/div&gt;")
# Result: "<div>Hello</div>"
```

### XML CDATA

```tusk
# When you need to include raw content in XML
xml_content: """
<data>
    <![CDATA[
    This can contain <tags> and & ampersands
    without escaping!
    ]]>
</data>
"""
```

## Shell Command Escaping

### Command Line Arguments

```tusk
# Escape shell arguments
user_file: "my file.txt"
safe_file = @shell.quote(user_file)  # 'my file.txt'

command = "cat ${safe_file}"

# Or use array form (safer)
@exec(["cat", user_file])  # No escaping needed

# Windows command escaping
windows_arg: 'path with "quotes"'
escaped_arg = @replace_all(windows_arg, {
    '"': '""',
    "^": "^^",
    "&": "^&",
    "|": "^|"
})
```

## Common Escaping Patterns

### Building Safe Strings

```tusk
# Function to escape for different contexts
escape_for_context = @lambda(text, context, {
    @switch(context, {
        "html": @html.escape(text),
        "url": @url.encode(text),
        "sql": @sql.escape(text),
        "regex": @regex.escape(text),
        "shell": @shell.quote(text),
        default: text
    })
})

# Usage
user_input: "dangerous <script> & 'quotes'"
safe_for_html = @escape_for_context(user_input, "html")
safe_for_sql = @escape_for_context(user_input, "sql")
```

### Template Literal Escaping

```tusk
# Escape template literals
template: "Hello, \${name}! Your balance is \$${balance}."
# Result: "Hello, ${name}! Your balance is $100."

# Function to escape template syntax
escape_template = @lambda(str, {
    @replace_all(str, {
        "$": "\\$",
        "{": "\\{",
        "}": "\\}"
    })
})
```

### CSV Field Escaping

```tusk
# CSV field escaping rules
escape_csv_field = @lambda(field, {
    # Fields with comma, quote, or newline need quoting
    @if(@contains(field, ",") || @contains(field, '"') || @contains(field, "\n"), {
        # Escape quotes by doubling them
        escaped = @replace(field, '"', '""')
        return: '"${escaped}"'
    }, field)
})

# Example
fields: ["Normal", 'With "quotes"', "With, comma", "With\nnewline"]
csv_line = @join(@map(fields, escape_csv_field), ",")
```

## Error Prevention

### Validation Before Escaping

```tusk
# Validate input before processing
safe_process = @lambda(input, {
    # Check for null/undefined
    @if(!input, return: "")
    
    # Convert to string if needed
    str_input = @string(input)
    
    # Apply appropriate escaping
    return: @html.escape(str_input)
})
```

### Context-Aware Escaping

```tusk
# Different contexts need different escaping
render_user_content = @lambda(content, context, {
    @switch(context, {
        "html_body": @html.escape(content),
        "html_attribute": @html.escape(content, { quotes: true }),
        "javascript": @json.stringify(content),
        "url_param": @url.encode(content),
        "css": @css.escape(content),
        default: @error("Unknown context: ${context}")
    })
})
```

## Best Practices

### 1. Know Your Context

```tusk
# Always escape based on where the string will be used
user_name: "Alice <admin>"

# Different contexts need different escaping
html_context: @html.escape(user_name)         # "Alice &lt;admin&gt;"
url_context: @url.encode(user_name)           # "Alice%20%3Cadmin%3E"
js_context: @json.stringify(user_name)        # "\"Alice <admin>\""
```

### 2. Use Built-in Functions

```tusk
# Prefer built-in escaping functions
# Good
safe_html = @html.escape(user_input)
safe_url = @url.encode(user_input)

# Avoid manual escaping when possible
# Not ideal
manual_html = @replace_all(user_input, {"<": "&lt;", ">": "&gt;"})
```

### 3. Escape Late

```tusk
# Store raw data, escape on output
user:
    name: "O'Brien"  # Store raw
    bio: "I <3 coding"  # Store raw

# Escape when rendering
html_output: """
<div>
    <h1>${@html.escape(user.name)}</h1>
    <p>${@html.escape(user.bio)}</p>
</div>
"""
```

### 4. Document Escaping Requirements

```tusk
###
# Renders user comment
# @param comment Raw user input (unescaped)
# @param format Output format: "html", "text", "markdown"
# @returns Properly escaped string for the target format
###
render_comment = @lambda(comment, format, {
    # Implementation
})
```

## Common Mistakes

### Double Escaping

```tusk
# Wrong - double escaping
user_input: "<script>"
escaped_once = @html.escape(user_input)      # "&lt;script&gt;"
escaped_twice = @html.escape(escaped_once)   # "&amp;lt;script&amp;gt;"

# Right - escape once at output
raw_data: "<script>"
output = @html.escape(raw_data)
```

### Wrong Context Escaping

```tusk
# Wrong - HTML escaping for URLs
url = "https://example.com/search?q=${@html.escape(search_term)}"

# Right - URL encoding for URLs
url = "https://example.com/search?q=${@url.encode(search_term)}"
```

### Forgetting to Escape

```tusk
# Dangerous - no escaping
html = "<div>${user_input}</div>"  # XSS vulnerability!

# Safe - proper escaping
html = "<div>${@html.escape(user_input)}</div>"
```

## Next Steps

- Master [String Interpolation](014-strings.md)
- Learn about [Regular Expressions](014-strings.md#regular-expressions)
- Understand [Security Best Practices](060-at-operator-security.md)
---

[Indentation in TuskLang]


Proper indentation is crucial in TuskLang for creating nested structures and maintaining readable code. This guide covers indentation rules, best practices, and common patterns.

## Indentation Basics

### Spaces vs Tabs

```tusk
# TuskLang accepts both spaces and tabs, but consistency is key
# Recommended: 4 spaces per level

# Good - consistent spaces
server:
    host: "localhost"
    port: 8080
    ssl:
        enabled: true
        cert: "/path/to/cert"

# Also valid - consistent tabs
database:
	host: "localhost"
	port: 5432
	credentials:
		username: "admin"
		password: "secret"
```

### Indentation Levels

```tusk
# Each nested level should have consistent indentation
app:                      # Level 0
    name: "MyApp"        # Level 1 (4 spaces)
    version: "1.0.0"     # Level 1
    
    server:              # Level 1
        host: "0.0.0.0"  # Level 2 (8 spaces)
        port: 8080       # Level 2
        
        ssl:             # Level 2
            enabled: true     # Level 3 (12 spaces)
            cert: "cert.pem"  # Level 3
```

## Nested Objects

### Creating Hierarchy

```tusk
# Indentation creates object hierarchy
company:
    name: "Tech Corp"
    employees:
        engineering:
            frontend:
                count: 10
                lead: "Alice"
            backend:
                count: 15
                lead: "Bob"
        sales:
            count: 5
            lead: "Charlie"

# Accessing nested values
frontend_lead: company.employees.engineering.frontend.lead
```

### Mixed Content

```tusk
# Objects can contain various types
user:
    id: 123
    name: "John Doe"
    
    # Nested object
    profile:
        bio: "Software developer"
        avatar: "/images/john.jpg"
    
    # Array with proper indentation
    skills: [
        "JavaScript",
        "Python",
        "TuskLang"
    ]
    
    # Inline object (no indentation needed)
    location: { city: "NYC", country: "USA" }
```

## Arrays and Indentation

### Multiline Arrays

```tusk
# Arrays can be formatted with indentation
colors: [
    "red",
    "green",
    "blue"
]

# Array of objects with indentation
users: [
    {
        id: 1
        name: "Alice"
        role: "admin"
    },
    {
        id: 2
        name: "Bob"
        role: "user"
    }
]

# Deeply nested arrays
matrix: [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

### Complex Array Structures

```tusk
# API endpoints with proper indentation
api:
    endpoints: [
        {
            path: "/users"
            method: "GET"
            auth: true
            params: {
                page: "number"
                limit: "number"
            }
        },
        {
            path: "/users/:id"
            method: "GET"
            auth: true
            params: {
                id: "required"
            }
        }
    ]
```

## Indentation in Different Contexts

### Configuration Files

```tusk
# Well-indented configuration
config:
    development:
        database:
            host: "localhost"
            port: 5432
            name: "dev_db"
        
        cache:
            enabled: false
        
        logging:
            level: "debug"
            output: "console"
    
    production:
        database:
            host: @env.DB_HOST
            port: @env.DB_PORT
            name: @env.DB_NAME
        
        cache:
            enabled: true
            ttl: 3600
        
        logging:
            level: "error"
            output: "file"
```

### Function Definitions

```tusk
# Indentation in lambda functions
api:
    routes:
        get_user: @lambda(id, {
            # Function body is indented
            user = @db.find("users", id)
            
            @if(user == null, {
                # Nested blocks maintain indentation
                return: {
                    error: "User not found"
                    status: 404
                }
            })
            
            # Return statement
            return: {
                data: user
                status: 200
            }
        })
```

## Indentation Patterns

### Consistent Nesting

```tusk
# Maintain consistent indentation throughout
application:
    metadata:
        name: "MyApp"
        version: "1.0.0"
        author:
            name: "John Doe"
            email: "john@example.com"
    
    features:
        authentication:
            enabled: true
            providers:
                local: true
                oauth:
                    google: true
                    github: true
        
        analytics:
            enabled: false
```

### Alignment for Readability

```tusk
# Align values for better readability
database_config:
    host:       "localhost"
    port:       5432
    username:   "admin"
    password:   @env.DB_PASSWORD
    database:   "myapp"
    
    # Or without alignment (also valid)
    pool:
        min: 5
        max: 20
        idle_timeout: 30000
```

### Conditional Indentation

```tusk
# Indentation with conditional content
server:
    base_config:
        host: "0.0.0.0"
        port: 8080
    
    # Conditional nested content
    @if(@env.NODE_ENV == "production", {
        ssl:
            enabled: true
            cert: @env.SSL_CERT
            key: @env.SSL_KEY
    })
```

## Common Indentation Errors

### Inconsistent Indentation

```tusk
# Wrong - mixed indentation
server:
    host: "localhost"  # 4 spaces
  port: 8080          # 2 spaces - WRONG!
        ssl:          # 8 spaces - WRONG!
    enabled: true     # 4 spaces

# Right - consistent indentation
server:
    host: "localhost"
    port: 8080
    ssl:
        enabled: true
```

### Tab/Space Mixing

```tusk
# Wrong - mixing tabs and spaces
config:
    name: "app"      # spaces
	version: "1.0"   # tab - WRONG!
    
# Configure your editor to show whitespace characters
# to catch these issues
```

### Incorrect Hierarchy

```tusk
# Wrong - indentation doesn't match structure
app:
name: "MyApp"        # Should be indented
    version: "1.0"   # Correct
settings:            # Should not be indented
    debug: true      # Correct

# Right
app:
    name: "MyApp"
    version: "1.0"
settings:
    debug: true
```

## Editor Configuration

### VS Code Settings

```json
// .vscode/settings.json
{
    "editor.tabSize": 4,
    "editor.insertSpaces": true,
    "editor.detectIndentation": false,
    "editor.renderWhitespace": "boundary",
    "[tusklang]": {
        "editor.tabSize": 4,
        "editor.insertSpaces": true
    }
}
```

### EditorConfig

```ini
# .editorconfig
[*.tsk]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
```

## Indentation Best Practices

### 1. Be Consistent

```tusk
# Pick one style and stick to it throughout your project
# Good - all 4 spaces
config:
    server:
        host: "localhost"
        port: 8080
    database:
        host: "localhost"
        port: 5432
```

### 2. Use Clear Hierarchy

```tusk
# Clear parent-child relationships through indentation
organization:
    departments:
        engineering:
            teams:
                frontend:
                    members: 5
                backend:
                    members: 8
        marketing:
            teams:
                digital:
                    members: 3
```

### 3. Avoid Deep Nesting

```tusk
# Too deep - hard to read and maintain
config:
    app:
        server:
            http:
                routes:
                    api:
                        v1:
                            users:
                                endpoints:
                                    get: "/users"

# Better - flatten where possible
config:
    server_host: "localhost"
    server_port: 8080
    
api_routes:
    v1_users_get: "/api/v1/users"
    v1_users_post: "/api/v1/users"
```

### 4. Format Long Lines

```tusk
# Break long lines with proper indentation
error_message: @format(
    "Failed to process request: %s at %s with params: %s",
    error_type,
    timestamp,
    @json.stringify(params)
)

# Long array with indentation
supported_formats: [
    "application/json",
    "application/xml",
    "text/plain",
    "text/html",
    "application/x-www-form-urlencoded"
]
```

## Special Cases

### Heredoc Indentation

```tusk
# Heredoc preserves internal indentation
template: """
    <div class="container">
        <h1>${title}</h1>
        <p>${content}</p>
    </div>
"""

# Strip common leading whitespace
stripped: <<<
    This text will have
    leading whitespace removed
    but internal indentation preserved
>>>
```

### Inline Comments

```tusk
# Comments should follow indentation
server:
    # Main server configuration
    host: "localhost"
    port: 8080
    
    # SSL configuration
    ssl:
        # Enable HTTPS
        enabled: true
        # Certificate paths
        cert: "/etc/ssl/cert.pem"
        key: "/etc/ssl/key.pem"
```

## Indentation Tools

### Auto-formatting

```tusk
# Use TuskLang formatter
# Command line:
# tusk format myfile.tsk

# Before formatting
server:
  host:"localhost"
    port:8080

# After formatting
server:
    host: "localhost"
    port: 8080
```

### Validation

```tusk
# TuskLang can validate indentation
# tusk check --strict myfile.tsk

# Will report:
# - Inconsistent indentation
# - Mixed tabs/spaces
# - Incorrect nesting
```

## Performance Notes

```tusk
# Indentation has no runtime performance impact
# It's purely for organization and readability

# These are equivalent at runtime:
compact: {a: 1, b: {c: 2, d: 3}}

expanded:
    a: 1
    b:
        c: 2
        d: 3
```

## Summary

1. **Use consistent indentation** (recommend 4 spaces)
2. **Don't mix tabs and spaces**
3. **Align child elements** under their parents
4. **Keep nesting depth** reasonable
5. **Configure your editor** for TuskLang
6. **Use formatting tools** to maintain consistency
7. **Follow project conventions** if they exist

## Next Steps

- Learn about [Multiline Values](024-multiline-values.md)
- Explore [Nested Objects](019-nested-objects.md)
- Master [Best Practices](030-best-practices.md)
---

[Multiline Values in TuskLang]


TuskLang provides several ways to work with multiline values, from simple string continuations to complex heredoc syntax. This guide covers all methods for handling multiline content effectively.

## String Continuation

### Basic Line Continuation

```tusk
# Using backslash for continuation
long_string: "This is a very long string that \
continues on the next line without adding \
a newline character to the string content."

# Result: "This is a very long string that continues on the next line without adding a newline character to the string content."
```

### Preserving Line Breaks

```tusk
# Using quotes with actual line breaks
multiline: "First line
Second line
Third line"

# The line breaks are preserved in the string
# Result: "First line\nSecond line\nThird line"
```

## Heredoc Syntax

### Basic Heredoc

```tusk
# Triple quotes for heredoc
message: """
Welcome to our application!

This message spans multiple lines
and preserves all formatting including:
  - Indentation
  - Line breaks
  - Special characters

Thank you for using our service.
"""
```

### Heredoc with Custom Delimiters

```tusk
# SQL query with custom delimiter
query: <<SQL
SELECT 
    u.id,
    u.name,
    u.email,
    COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at > '2024-01-01'
GROUP BY u.id, u.name, u.email
ORDER BY order_count DESC
SQL

# HTML template
html_template: <<HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <title>${page_title}</title>
    <meta charset="UTF-8">
</head>
<body>
    <h1>${heading}</h1>
    <div class="content">
        ${content}
    </div>
</body>
</html>
HTML
```

### Indented Heredoc

```tusk
# Strip common leading whitespace with <<<
function_code: <<<
    function processData(data) {
        // This indentation will be removed
        const result = data.map(item => {
            return item * 2;
        });
        return result;
    }
>>>

# The function will start at column 0 after processing
```

## Multiline Arrays

### Vertical Arrays

```tusk
# Each element on its own line
fruits: [
    "apple",
    "banana",
    "cherry",
    "date",
    "elderberry"
]

# With trailing comma (recommended)
colors: [
    "red",
    "green", 
    "blue",
]
```

### Complex Array Elements

```tusk
# Array of objects with multiline formatting
users: [
    {
        id: 1
        name: "Alice Johnson"
        email: "alice@example.com"
        roles: ["admin", "user"]
        address: {
            street: "123 Main St"
            city: "Springfield"
            state: "IL"
        }
    },
    {
        id: 2
        name: "Bob Smith"
        email: "bob@example.com"
        roles: ["user"]
        address: {
            street: "456 Oak Ave"
            city: "Portland"
            state: "OR"
        }
    }
]
```

## Multiline Objects

### Nested Object Structure

```tusk
# Well-formatted nested object
application:
    metadata:
        name: "Enterprise App"
        version: "2.1.0"
        description: """
        A comprehensive enterprise application
        that handles multiple business processes
        including inventory, sales, and reporting.
        """
    
    modules:
        inventory:
            enabled: true
            features: [
                "stock_tracking",
                "reorder_alerts",
                "barcode_scanning"
            ]
        
        sales:
            enabled: true
            features: [
                "point_of_sale",
                "online_orders",
                "customer_management"
            ]
```

### Method Definitions

```tusk
# Object with multiline method definitions
string_utils:
    # Multiline method with proper formatting
    word_wrap: @lambda(text, width, {
        words = @split(text, " ")
        lines: []
        current_line: ""
        
        @each(words, @lambda(word, {
            @if(@len(current_line + " " + word) > width, {
                @push(lines, current_line)
                current_line = word
            }, {
                current_line = @if(current_line == "", 
                    word, 
                    current_line + " " + word
                )
            })
        }))
        
        @if(current_line != "", {
            @push(lines, current_line)
        })
        
        return: @join(lines, "\n")
    })
```

## Multiline Function Calls

### Breaking Long Function Calls

```tusk
# Function call with many parameters
result = @database.query(
    "SELECT * FROM users WHERE status = ? AND created_at > ?",
    "active",
    "2024-01-01",
    {
        timeout: 30000,
        cache: true,
        retry_count: 3
    }
)

# Method chaining across lines
processed_data = @data
    .filter(@lambda(item, item.active))
    .map(@lambda(item, {
        id: item.id,
        name: item.name,
        value: item.value * 1.1
    }))
    .sort(@lambda(a, b, b.value - a.value))
    .slice(0, 10)
```

## Multiline Conditionals

### Complex If Statements

```tusk
# Multiline conditional logic
user_status = @if(
    user.active && 
    user.email_verified && 
    user.subscription_status == "active",
    {
        # True branch
        status: "active"
        access_level: "full"
        features: ["all"]
    },
    {
        # False branch
        status: "restricted"
        access_level: "limited"
        features: ["basic"]
    }
)

# Nested conditionals with formatting
category = @if(score >= 90, {
    grade: "A"
    message: "Excellent!"
}, @if(score >= 80, {
    grade: "B" 
    message: "Good job!"
}, @if(score >= 70, {
    grade: "C"
    message: "Satisfactory"
}, {
    grade: "F"
    message: "Needs improvement"
})))
```

## Multiline Comments

### Block Documentation

```tusk
###
# User Management Module
# 
# This module handles all user-related operations including:
# - User registration and authentication
# - Profile management
# - Permission and role assignment
# - Session management
# 
# Dependencies:
# - Database module
# - Encryption module
# - Email module
# 
# @author: Development Team
# @version: 1.0.0
# @since: 2024-01-01
###

# Regular comments can also span
# multiple lines by using multiple
# single-line comments
```

## Multiline String Operations

### String Building

```tusk
# Building complex strings
email_body = @string.build({
    lines: [
        "Dear ${customer_name},",
        "",
        "Thank you for your recent purchase.",
        "Your order details are as follows:",
        "",
        "Order ID: ${order_id}",
        "Date: ${order_date}",
        "Total: $${order_total}",
        "",
        "Best regards,",
        "The Sales Team"
    ]
    separator: "\n"
})

# Or using array join
report = @join([
    "Monthly Sales Report",
    @repeat("=", 50),
    "",
    "Period: ${start_date} to ${end_date}",
    "Total Sales: $${total_sales}",
    "Total Orders: ${order_count}",
    "",
    "Top Products:",
    ...@map(top_products, @lambda(p, "  - ${p.name}: $${p.revenue}"))
], "\n")
```

### Template Strings

```tusk
# Complex template with multiline content
email_template: """
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; }
        .header { background: #007bff; color: white; padding: 20px; }
        .content { padding: 20px; }
        .footer { background: #f8f9fa; padding: 10px; text-align: center; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${company_name}</h1>
    </div>
    <div class="content">
        ${email_content}
    </div>
    <div class="footer">
        <p>&copy; ${current_year} ${company_name}. All rights reserved.</p>
    </div>
</body>
</html>
"""
```

## Multiline Regular Expressions

### Complex Patterns

```tusk
# Regex with comments and formatting
email_pattern: @regex.compile("""
    ^                      # Start of string
    [a-zA-Z0-9._%+-]+     # Local part
    @                      # At symbol
    [a-zA-Z0-9.-]+        # Domain name
    \.                     # Dot
    [a-zA-Z]{2,}          # Top-level domain
    $                      # End of string
""", "x")  # x flag for extended/verbose mode

# URL pattern with multiline definition
url_pattern: @regex.compile(
    "^(https?://)?" +                    # Protocol (optional)
    "([a-zA-Z0-9-]+\\.)*" +              # Subdomains
    "[a-zA-Z0-9-]+" +                    # Domain name
    "\\.[a-zA-Z]{2,}" +                  # TLD
    "(:[0-9]+)?" +                       # Port (optional)
    "(/[^\\s]*)?" +                      # Path (optional)
    "$",
    "i"  # Case insensitive
)
```

## Best Practices

### 1. Choose the Right Method

```tusk
# Short multiline - use quotes
short_message: "Line 1
Line 2"

# Long multiline - use heredoc
long_message: """
This is a much longer message
that spans many lines and includes
various formatting and structure.
"""

# Code or structured text - use custom delimiter
code_block: <<CODE
function example() {
    return "Use delimiter that matches content type";
}
CODE
```

### 2. Maintain Readability

```tusk
# Good - clear structure
config:
    database:
        primary:
            host: "db1.example.com"
            port: 5432
            connection_string: """
            postgresql://username:password@db1.example.com:5432/mydb
            ?sslmode=require&connect_timeout=10
            """

# Avoid - hard to read
config: { database: { primary: { host: "db1.example.com", port: 5432, connection_string: "postgresql://username:password@db1.example.com:5432/mydb?sslmode=require&connect_timeout=10" } } }
```

### 3. Consider Line Length

```tusk
# Break long lines appropriately
long_condition = 
    user.is_active && 
    user.email_verified && 
    user.age >= 18 && 
    user.country_code == "US" &&
    user.agreed_to_terms == true

# Format for scanning
api_endpoints: [
    "/api/v1/users",
    "/api/v1/products", 
    "/api/v1/orders",
    "/api/v1/customers",
    "/api/v1/reports"
]
```

### 4. Use Consistent Formatting

```tusk
# Consistent multiline style throughout project
# If using heredoc for SQL, use it for all SQL
query1: <<SQL
SELECT * FROM users
SQL

query2: <<SQL  
SELECT * FROM products
SQL

# Not mixed styles
query3: "SELECT * FROM orders"  # Inconsistent!
```

## Common Pitfalls

### Indentation in Heredocs

```tusk
# Remember heredocs preserve indentation
template: """
    This line has 4 spaces at the start
"""

# Use <<< to strip common indentation
template_stripped: <<<
    This line will start at column 0
>>>
```

### Line Ending Differences

```tusk
# Be aware of platform differences
# Unix/Linux/Mac: \n
# Windows: \r\n

# Normalize if needed
normalized = @replace(text, "\r\n", "\n")
```

### Escaping in Multiline

```tusk
# Quotes still need escaping in multiline strings
message: """
He said, "Hello!"
But she replied, \"Goodbye!\"
"""

# Or use different quotes
message2: '''
He said, "Hello!"
No escaping needed here.
'''
```

## Next Steps

- Learn about [Typed Values](025-typed-values.md)
- Explore [References](026-references.md)
- Master [String Handling](014-strings.md)
---

[Typed Values in TuskLang]


While TuskLang is dynamically typed by default, it supports optional type annotations and runtime type checking for better code reliability and documentation. This guide covers TuskLang's type system.

## Basic Type Annotations

### Simple Type Hints

```tusk
# Basic type annotations using : type syntax
name: string = "John Doe"
age: number = 30
is_active: boolean = true
data: object = { key: "value" }
items: array = [1, 2, 3]

# Type annotations without initial values
username: string
user_id: number
settings: object
```

### Type Inference

```tusk
# TuskLang can infer types from values
message: "Hello"        # Inferred as string
count: 42              # Inferred as number
enabled: true          # Inferred as boolean

# Explicit typing overrides inference
id: string = 123       # Will convert to "123"
```

## Built-in Types

### Primitive Types

```tusk
# String type
first_name: string = "Jane"
last_name: string = "Doe"
email: string       # Declared but not initialized

# Number type (integers and floats)
age: number = 25
price: number = 19.99
quantity: number

# Boolean type
is_verified: boolean = true
has_subscription: boolean = false
is_admin: boolean

# Null type
optional_value: null = null
empty_field: null
```

### Composite Types

```tusk
# Object type
user: object = {
    name: "John"
    age: 30
}

# Array type
numbers: array = [1, 2, 3, 4, 5]
mixed: array = ["string", 123, true]

# Function type
calculate: function = @lambda(a, b, a + b)
```

## Advanced Type Syntax

### Union Types

```tusk
# Value can be one of multiple types
status: string | number = "active"    # Can be string
status = 1                            # Or number

# Common union patterns
result: object | null = @database.find(id)
port: string | number = @env.PORT || 3000

# Multiple unions
value: string | number | boolean | null
```

### Array Type Syntax

```tusk
# Array of specific type
names: string[] = ["Alice", "Bob", "Charlie"]
scores: number[] = [95, 87, 92]

# Nested array types
matrix: number[][] = [
    [1, 2, 3],
    [4, 5, 6]
]

# Mixed array (any type)
mixed: any[] = ["text", 123, true, { key: "value" }]
```

### Object Type Definitions

```tusk
# Inline object type
person: { name: string, age: number } = {
    name: "John"
    age: 30
}

# Type definition
type User = {
    id: number
    name: string
    email: string
    roles: string[]
}

# Using type definition
current_user: User = {
    id: 1
    name: "Admin"
    email: "admin@example.com"
    roles: ["admin", "user"]
}
```

## Optional and Nullable Types

### Optional Properties

```tusk
# Optional properties with ?
type Profile = {
    name: string
    bio?: string          # Optional
    avatar?: string       # Optional
    website?: string      # Optional
}

user_profile: Profile = {
    name: "John"          # Required
    # bio, avatar, website are optional
}
```

### Nullable Types

```tusk
# Explicitly nullable
middle_name: string? = null      # Can be string or null
phone: string? = "+1234567890"   # Currently string

# Nullable in objects
type Contact = {
    email: string
    phone: string?        # Can be null
    fax: string?         # Can be null
}
```

## Type Validation

### Runtime Type Checking

```tusk
# Validate types at runtime
validate_user = @lambda(data: any, {
    # Check required types
    @assert(@isString(data.name), "Name must be a string")
    @assert(@isNumber(data.age), "Age must be a number")
    @assert(data.age >= 0, "Age must be positive")
    
    # Check optional types
    @if(data.email != null, {
        @assert(@isString(data.email), "Email must be a string")
        @assert(@includes(data.email, "@"), "Invalid email format")
    })
    
    return: true
})
```

### Type Guards

```tusk
# Type guard functions
is_valid_user = @lambda(obj: any): boolean, {
    return: @isObject(obj) && 
            @isString(obj.name) && 
            @isNumber(obj.age) &&
            @isArray(obj.roles)
})

# Using type guards
process_data = @lambda(data: any, {
    @if(@is_valid_user(data), {
        # Safe to use as User type
        welcome_message: "Hello, ${data.name}!"
    }, {
        @error("Invalid user data")
    })
})
```

## Generic Types

### Generic Functions

```tusk
# Generic type parameters
map_array = @lambda<T, U>(
    arr: T[], 
    fn: function(T): U
): U[], {
    result: U[] = []
    @each(arr, @lambda(item, {
        @push(result, fn(item))
    }))
    return: result
})

# Using generics
numbers: number[] = [1, 2, 3]
strings: string[] = @map_array(numbers, @lambda(n, @string(n)))
```

### Generic Type Definitions

```tusk
# Generic container type
type Container<T> = {
    value: T
    timestamp: number
}

# Using generic type
string_container: Container<string> = {
    value: "Hello"
    timestamp: @time.now()
}

number_container: Container<number> = {
    value: 42
    timestamp: @time.now()
}
```

## Type Conversion

### Explicit Casting

```tusk
# String to number
str_value: string = "123"
num_value: number = @number(str_value)  # 123

# Number to string
num: number = 456
str: string = @string(num)  # "456"

# To boolean
bool_from_string: boolean = @boolean("true")  # true
bool_from_number: boolean = @boolean(1)        # true

# Safe casting with validation
safe_to_number = @lambda(value: any): number?, {
    @if(@isNumeric(value), {
        return: @number(value)
    }, {
        return: null
    })
})
```

### Type Coercion

```tusk
# Automatic coercion in operations
result1: string = "Number: " + 123     # "Number: 123"
result2: number = "5" * 2              # 10 (string coerced to number)

# Prevent coercion with strict typing
strict_add = @lambda(a: number, b: number): number, {
    @assert(@isNumber(a) && @isNumber(b), "Both arguments must be numbers")
    return: a + b
})
```

## Custom Types

### Type Aliases

```tusk
# Create type aliases
type ID = string | number
type Email = string
type Timestamp = number

# Using aliases
user_id: ID = "user_123"
user_email: Email = "user@example.com"
created_at: Timestamp = @time.now()
```

### Complex Type Definitions

```tusk
# Enum-like types
type Status = "active" | "inactive" | "pending" | "deleted"

# Structured types
type Address = {
    street: string
    city: string
    state: string
    zip: string
    country?: string
}

type User = {
    id: ID
    name: string
    email: Email
    status: Status
    address?: Address
    metadata?: object
}

# Nested type usage
new_user: User = {
    id: 123
    name: "John Doe"
    email: "john@example.com"
    status: "active"
    address: {
        street: "123 Main St"
        city: "Anytown"
        state: "CA"
        zip: "12345"
    }
}
```

## Type Inference Patterns

### Const Assertions

```tusk
# Literal types
STATUS_ACTIVE: "active" = "active"      # Type is literal "active", not string
PORT: 8080 = 8080                       # Type is literal 8080, not number

# Object const
CONFIG: const = {
    host: "localhost"
    port: 3000
    ssl: false
}
# Properties are readonly
```

### Type Narrowing

```tusk
# Type narrowing in conditionals
process_value = @lambda(value: string | number | null, {
    @if(value == null, {
        return: "No value"
    })
    
    # value is string | number here
    @if(@isString(value), {
        # value is string here
        return: "String: ${value.toUpperCase()}"
    })
    
    # value is number here
    return: "Number: ${value * 2}"
})
```

## Type Documentation

### JSDoc-style Comments

```tusk
###
# Calculate the total price including tax
# @param {number} price - Base price
# @param {number} tax_rate - Tax rate as decimal
# @returns {number} Total price with tax
###
calculate_total = @lambda(price: number, tax_rate: number): number, {
    return: price * (1 + tax_rate)
})

###
# User data structure
# @typedef {Object} UserData
# @property {string} name - User's full name
# @property {number} age - User's age
# @property {string[]} roles - User roles
###
```

## Type System Configuration

### Strict Mode

```tusk
# Enable strict type checking
@pragma strict_types true

# Now all variables must have types
name = "John"         # Error: missing type annotation
name: string = "John" # OK

# Function parameters must be typed
add = @lambda(a, b, a + b)                    # Error
add = @lambda(a: number, b: number, a + b)    # OK
```

### Type Checking Options

```tusk
# Configure type system behavior
@pragma {
    strict_types: true           # Require type annotations
    implicit_any: false          # Disallow implicit any type
    null_checks: true           # Strict null checking
    type_coercion: "warn"       # Warn on implicit coercion
}
```

## Best Practices

### 1. Use Types for Public APIs

```tusk
# Type public interfaces clearly
export create_user = @lambda(
    name: string, 
    email: string, 
    age?: number
): User, {
    # Implementation
})
```

### 2. Progressive Typing

```tusk
# Start loose, add types gradually
# Phase 1: No types
data = fetch_data()

# Phase 2: Basic types
data: object = fetch_data()

# Phase 3: Specific types
data: UserData[] = fetch_data()
```

### 3. Type Critical Paths

```tusk
# Type error-prone or critical code
payment_processor = @lambda(
    amount: number,
    currency: "USD" | "EUR" | "GBP",
    card: CardDetails
): PaymentResult, {
    # Typed for safety
})
```

### 4. Document Complex Types

```tusk
###
# Represents a node in the tree structure
# @type TreeNode<T>
###
type TreeNode<T> = {
    value: T
    children: TreeNode<T>[]
    parent?: TreeNode<T>
}
```

## Common Patterns

### Result Types

```tusk
# Success/Error pattern
type Result<T, E> = 
    | { success: true, data: T }
    | { success: false, error: E }

fetch_user = @lambda(id: number): Result<User, string>, {
    user = @db.find("users", id)
    
    @if(user == null, {
        return: { success: false, error: "User not found" }
    })
    
    return: { success: true, data: user }
})
```

### Builder Pattern with Types

```tusk
type QueryBuilder = {
    select: (fields: string[]) => QueryBuilder
    where: (condition: string) => QueryBuilder
    limit: (count: number) => QueryBuilder
    build: () => string
}

create_query_builder = @lambda(): QueryBuilder, {
    _parts: { select: [], where: [], limit: null }
    
    return: {
        select: @lambda(fields, {
            _parts.select = fields
            return: @self
        }),
        where: @lambda(condition, {
            @push(_parts.where, condition)
            return: @self
        }),
        limit: @lambda(count, {
            _parts.limit = count
            return: @self
        }),
        build: @lambda({
            # Build SQL query
        })
    }
})
```

## Next Steps

- Explore [References](026-references.md) for object relationships
- Learn about [Variable Naming](027-variable-naming.md)
- Master [Best Practices](030-best-practices.md) for type usage
---

[References in TuskLang]


References in TuskLang allow you to link to other values, create aliases, and avoid duplication in your configuration. This guide covers how to use references effectively.

## Basic References

### Using the @ Symbol

```tusk
# Define a value
database_host: "localhost"

# Reference it elsewhere
connection_string: "postgresql://user@${@database_host}:5432/mydb"

# Direct reference
primary_host: @database_host

# Reference in objects
database:
    primary:
        host: @database_host
        port: 5432
```

### Reference Syntax Types

```tusk
# Direct reference
value1: @other_value

# Reference in interpolation
message: "Host is ${@server.host}"

# Reference with path
nested_value: @config.database.host

# Reference with brackets
dynamic_key: "host"
value: @config.database[dynamic_key]
```

## Object References

### Referencing Nested Values

```tusk
config:
    app:
        name: "MyApp"
        version: "1.0.0"
    server:
        host: "localhost"
        port: 8080

# Reference nested values
app_name: @config.app.name
server_url: "http://${@config.server.host}:${@config.server.port}"

# Deep nesting
deep_reference: @config.app.metadata.author.name
```

### Self References

```tusk
server:
    host: "localhost"
    port: 8080
    # Reference sibling properties
    url: "http://${@self.host}:${@self.port}"
    
    # Reference parent
    config_name: @parent.name
```

## Array References

### Referencing Array Elements

```tusk
servers: ["server1", "server2", "server3"]

# Reference by index
primary_server: @servers[0]
backup_server: @servers[1]

# Reference in loops
server_configs: @map(@servers, @lambda(server, {
    host: server
    port: 8080
    url: "http://${server}:8080"
}))
```

### Dynamic Array Access

```tusk
users: [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
]

# Find and reference
active_user_id: 2
active_user: @find(@users, @lambda(u, u.id == @active_user_id))
```

## Reference Patterns

### Configuration Inheritance

```tusk
# Base configuration
base_config:
    timeout: 30
    retries: 3
    log_level: "info"

# Environment-specific configs reference base
dev_config:
    ...@base_config     # Spread reference
    log_level: "debug"  # Override
    host: "localhost"

prod_config:
    ...@base_config
    host: "api.example.com"
    ssl: true
```

### Avoiding Duplication

```tusk
# Define once
api_version: "v1"
api_base: "/api/${@api_version}"

# Reference multiple times
endpoints:
    users: "${@api_base}/users"
    products: "${@api_base}/products"
    orders: "${@api_base}/orders"
    
    # Version-specific endpoints
    legacy:
        users: "/api/v0/users"
    current:
        users: @endpoints.users
```

### Computed References

```tusk
# Dynamic reference based on condition
environment: "production"

database:
    development:
        host: "localhost"
        name: "app_dev"
    production:
        host: "db.example.com"
        name: "app_prod"

# Computed reference
current_db: @database[@environment]
connection: "postgresql://${@current_db.host}/${@current_db.name}"
```

## Reference Scoping

### Local Scope

```tusk
global_value: "I'm global"

function_example: @lambda({
    local_value: "I'm local"
    
    # Can reference both
    message: "${@global_value} and ${local_value}"
    
    # Local shadows global if same name
    global_value: "I shadow the global"
    shadowed: @global_value  # References local version
})
```

### Module Scope

```tusk
# In user_module.tsk
module:
    name: "User Module"
    version: "1.0.0"
    
    api:
        get_user: @lambda(id, { /* ... */ })
        create_user: @lambda(data, { /* ... */ })

# In main.tsk
user_module: @import("user_module.tsk")

# Reference module contents
get_user_fn: @user_module.api.get_user
module_version: @user_module.version
```

## Circular Reference Prevention

### Detecting Circular References

```tusk
# This creates a circular reference - will error
a: @b
b: @c  
c: @a  # Error: Circular reference detected

# Safe pattern - use functions for lazy evaluation
get_a: @lambda({ @b() })
get_b: @lambda({ @c() })
get_c: @lambda({ "final value" })
```

### Breaking Reference Cycles

```tusk
# Use intermediate values
step1: "initial"
step2: "${@step1} -> second"
step3: "${@step2} -> third"
# No cycle, each depends only on previous

# Or use conditional references
node:
    value: "data"
    next: @if(@has_next, @nodes[@index + 1], null)
```

## Advanced Reference Techniques

### Reference Guards

```tusk
# Safe reference with fallback
value: @some.deep.path ?? "default"

# Check if reference exists
has_config: @exists(@config.optional_section)

# Conditional reference
db_host: @if(@env.DB_HOST, @env.DB_HOST, @config.database.host)
```

### Reference Transformation

```tusk
# Transform referenced value
raw_port: "8080"
numeric_port: @number(@raw_port)

# Chain transformations
user_input: "  HELLO WORLD  "
cleaned: @trim(@lower(@user_input))  # "hello world"

# Reference with method call
items: ["apple", "banana", "orange"]
items_string: @join(@items, ", ")
```

### Dynamic Reference Paths

```tusk
# Build reference path dynamically
get_config_value = @lambda(section, key, {
    path: "${section}.${key}"
    return: @resolve(path)  # Resolve string as reference path
})

# Usage
db_host: @get_config_value("database", "host")
```

## Reference Resolution

### Order of Resolution

```tusk
# TuskLang resolves references in order:
# 1. Local scope
# 2. Parent scopes (upward)
# 3. Global scope
# 4. Imported modules

value: "global"

section:
    value: "section"
    
    subsection:
        # References section-level value, not global
        referenced: @value  # "section"
```

### Lazy vs Eager Resolution

```tusk
# Eager resolution (immediate)
static_ref: @config.value

# Lazy resolution (on demand)
lazy_ref = @lambda({ @config.value })

# Useful for circular dependencies
a:
    value: 1
    get_b: @lambda({ @b.value })

b:
    value: 2
    get_a: @lambda({ @a.value })
```

## Common Reference Patterns

### Configuration Templates

```tusk
# Template with references
server_template:
    host: @hostname
    port: @port
    url: "http://${@self.host}:${@self.port}"
    health_check: "${@self.url}/health"

# Create instances
web_server:
    hostname: "web.example.com"
    port: 80
    ...@server_template

api_server:
    hostname: "api.example.com"  
    port: 8080
    ...@server_template
```

### Shared Constants

```tusk
# Define constants once
constants:
    MAX_RETRIES: 3
    TIMEOUT_MS: 30000
    API_VERSION: "v2"
    
# Reference throughout
http_client:
    retries: @constants.MAX_RETRIES
    timeout: @constants.TIMEOUT_MS
    base_url: "/api/${@constants.API_VERSION}"
```

### Reference Factories

```tusk
# Factory pattern with references
create_service = @lambda(name, port, {
    return: {
        name: name
        port: port
        host: @config.default_host
        url: "http://${@config.default_host}:${port}"
        health: "${@self.url}/health"
    }
})

# Create services
auth_service: @create_service("auth", 9001)
user_service: @create_service("users", 9002)
```

## Performance Considerations

### Reference Caching

```tusk
# References are resolved once and cached
expensive_value: @compute_expensive_operation()

# Multiple references don't recompute
ref1: @expensive_value  # Uses cached value
ref2: @expensive_value  # Uses cached value

# Force recomputation with function
get_fresh = @lambda({ @compute_expensive_operation() })
```

### Avoiding Deep References

```tusk
# Deep reference chains can be slow
deep: @a.b.c.d.e.f.g.h.i.j

# Better - store intermediate reference
intermediate: @a.b.c.d.e
shallow: @intermediate.f.g.h.i.j

# Or destructure
{ f: { g: { h: { i: { j: target }}}}} = @a.b.c.d.e
result: @target
```

## Best Practices

### 1. Use Meaningful Names

```tusk
# Bad - unclear references
x: @y.z

# Good - descriptive references  
user_email: @current_user.contact.email
```

### 2. Document Complex References

```tusk
# Reference to dynamically selected database based on environment
# @see database configuration section
active_db: @databases[@env.APP_ENV || "development"]
```

### 3. Validate References

```tusk
# Check references exist before use
safe_reference = @if(@exists(@optional.path), {
    value: @optional.path
}, {
    value: "default"
    warning: "Optional path not found, using default"
})
```

### 4. Group Related References

```tusk
# Group configuration references
refs:
    db_host: @config.database.host
    db_port: @config.database.port
    api_key: @secrets.api_key
    
# Use grouped references
connection: "postgresql://${@refs.db_host}:${@refs.db_port}"
```

## Common Mistakes

### Missing @ Symbol

```tusk
# Wrong - treats as literal string
value: other_value

# Right - creates reference
value: @other_value
```

### Reference to Non-Existent Path

```tusk
# This will error if path doesn't exist
value: @non.existent.path

# Safe approach
value: @non.existent.path ?? "fallback"
```

### Circular References

```tusk
# Avoid circular dependencies
# Wrong
a: @b
b: @a

# Right - break the cycle
a: @b.value
b: { value: "actual data" }
```

## Next Steps

- Learn about [Variable Naming](027-variable-naming.md)
- Explore [Reserved Keywords](028-reserved-keywords.md)  
- Master [Best Practices](030-best-practices.md) for references
---

[Variable Naming in TuskLang]


Choosing good variable names is crucial for writing maintainable TuskLang code. This guide covers naming conventions, rules, and best practices for variables in TuskLang.

## Naming Rules

### Valid Variable Names

```tusk
# Letters, numbers, and underscores
username: "john_doe"
user_id: 12345
firstName: "John"
_private_var: "hidden"
var123: "numeric suffix"
user2: "second user"

# Unicode letters are allowed
用户名: "张三"
prénom: "Jean"
```

### Invalid Variable Names

```tusk
# Cannot start with number
# 123var: "invalid"  # Error

# Cannot contain spaces
# user name: "invalid"  # Error

# Cannot contain special characters (except underscore)
# user-name: "invalid"  # Error
# user.name: "invalid"  # Error (dot notation)
# user@email: "invalid" # Error

# Cannot use reserved words
# true: "invalid"  # Error
# null: "invalid"  # Error
```

### Case Sensitivity

```tusk
# Variable names are case-sensitive
userName: "John"
username: "jane"  # Different variable
USERNAME: "ADMIN" # Different variable

# All three are distinct variables
```

## Naming Conventions

### Snake Case (Recommended)

```tusk
# Lowercase with underscores - Python/Ruby style
user_name: "John Doe"
first_name: "John"
last_name: "Doe"
is_active: true
created_at: @time.now()
max_retry_count: 3

# Good for most variables
database_connection: @db.connect()
api_endpoint: "/api/v1/users"
```

### Camel Case

```tusk
# First letter lowercase - JavaScript style
userName: "John Doe"
firstName: "John"
lastName: "Doe"
isActive: true
createdAt: @time.now()
maxRetryCount: 3

# Common in web development contexts
apiEndpoint: "/api/v1/users"
requestHandler: @lambda(req, res, { })
```

### Pascal Case

```tusk
# First letter uppercase - C#/Java class style
# Typically used for types or constructors
UserModel: {
    Name: "string"
    Age: "number"
    IsActive: "boolean"
}

# Type definitions
DatabaseConfig: {
    Host: "string"
    Port: "number"
}
```

### Constant Case

```tusk
# All uppercase with underscores - constant values
MAX_CONNECTIONS: 100
DEFAULT_TIMEOUT: 30000
API_VERSION: "v1"
DATABASE_URL: "postgresql://localhost/myapp"
ITEMS_PER_PAGE: 20

# Environment variable mappings
NODE_ENV: @env.NODE_ENV
API_KEY: @env.API_KEY
```

## Semantic Naming

### Descriptive Names

```tusk
# Bad - too short, unclear
d: @db.query("SELECT * FROM users")
n: 42
s: "active"

# Good - descriptive and clear
user_data: @db.query("SELECT * FROM users")
retry_count: 42
account_status: "active"

# Clear intent
is_authenticated: true
has_permission: false
can_edit: @user.role == "admin"
```

### Purpose-Driven Names

```tusk
# Name by purpose, not type
# Bad
string1: "john@example.com"
bool1: true
obj1: { }

# Good
user_email: "john@example.com"
is_email_verified: true
user_preferences: { }
```

### Context-Aware Names

```tusk
# Include context in names
# Instead of generic 'id'
user_id: 123
product_id: 456
order_id: 789

# Instead of generic 'name'
customer_name: "John Doe"
company_name: "Tech Corp"
product_name: "Widget Pro"
```

## Common Patterns

### Boolean Variables

```tusk
# Use is_, has_, can_, should_ prefixes
is_active: true
is_verified: false
is_loading: false

has_permission: true
has_children: false
has_been_processed: true

can_edit: true
can_delete: false
can_view: true

should_retry: true
should_cache: false
```

### Collection Names

```tusk
# Use plural for arrays/lists
users: ["Alice", "Bob", "Charlie"]
products: []
order_items: []

# Single item from collection
user: @users[0]
product: @find(@products, { id: 123 })

# Count/length variables
user_count: @len(@users)
total_products: @len(@products)
```

### Function/Method Names

```tusk
# Use verb or verb phrases
get_user: @lambda(id, { })
create_order: @lambda(data, { })
validate_email: @lambda(email, { })
calculate_total: @lambda(items, { })
send_notification: @lambda(user, message, { })

# Boolean returning functions
is_valid_email: @lambda(email, { })
has_sufficient_funds: @lambda(account, amount, { })
can_process_payment: @lambda(payment, { })
```

### Temporal Variables

```tusk
# Time-related variables
created_at: @time.now()
updated_at: @time.now()
deleted_at: null

start_date: "2024-01-01"
end_date: "2024-12-31"
duration_seconds: 3600

last_login: @user.last_login_timestamp
next_retry_at: @time.now() + @retry_delay
```

## Avoiding Ambiguity

### Clear Distinctions

```tusk
# Ambiguous
data: { }
info: { }
temp: 0

# Clear
user_profile_data: { }
system_info: { }
temperature_celsius: 0

# Distinguish similar concepts
raw_input: "user input"
sanitized_input: @sanitize(@raw_input)
validated_input: @validate(@sanitized_input)
```

### Units in Names

```tusk
# Include units for clarity
timeout: 30           # Unclear unit
timeout_seconds: 30   # Clear
timeout_ms: 30000    # Clear

file_size: 1024        # Unclear unit
file_size_bytes: 1024  # Clear
file_size_kb: 1       # Clear

distance: 100          # Unclear unit
distance_meters: 100   # Clear
distance_km: 0.1      # Clear
```

## Scoping and Namespacing

### Module Prefixes

```tusk
# Prefix with module/component name
auth_user: { }
auth_token: "xyz"
auth_validate: @lambda(token, { })

db_connection: { }
db_query: @lambda(sql, { })
db_transaction: @lambda(operations, { })

ui_theme: "dark"
ui_language: "en"
```

### Nested Scopes

```tusk
# Use clear scope indicators
global_config: { }

module:
    module_config: { }
    
    function: @lambda({
        local_var: "scoped"
        # Clear what scope we're referencing
        use_global: @global_config.setting
        use_module: @module_config.option
    })
```

## Special Naming Patterns

### Private Variables

```tusk
# Leading underscore for private/internal
_internal_cache: { }
_private_key: "secret"
_helper_function: @lambda({ })

public_api: {
    # Public interface
    get_data: @lambda({ })
    
    # Private implementation detail
    _fetch_from_cache: @lambda({ })
}
```

### Temporary Variables

```tusk
# Clear temporary nature
temp_result: @process_data()
tmp_file_path: "/tmp/upload_${@uuid()}"

# Or use meaningful names even for temps
intermediate_calculation: @step1()
final_result: @step2(@intermediate_calculation)
```

### Loop Variables

```tusk
# Traditional single letters for simple loops
@map(items, @lambda(i, i * 2))

# But prefer descriptive names
@map(users, @lambda(user, {
    name: user.name
    email: user.email
}))

# Index variables
@each(products, @lambda(product, index, {
    rank: index + 1
    name: product.name
}))
```

## Anti-Patterns to Avoid

### Overly Abbreviated

```tusk
# Bad - too abbreviated
usrNm: "John"
prdCt: 5
dbConn: @connect()

# Good - clear and readable
user_name: "John"
product_count: 5
database_connection: @connect()
```

### Hungarian Notation

```tusk
# Avoid type prefixes
strName: "John"      # Don't do this
intAge: 30          # Don't do this
boolActive: true    # Don't do this

# Prefer clear names without type prefixes
name: "John"
age: 30
is_active: true
```

### Generic Names

```tusk
# Avoid meaningless names
data: { }
obj: { }
val: 42
thing: "something"
stuff: []

# Use specific, meaningful names
user_profile: { }
configuration: { }
retry_count: 42
error_message: "something"
menu_items: []
```

## Refactoring Names

### Progressive Improvement

```tusk
# Initial version
x: @db.query("SELECT * FROM users WHERE active = true")

# Better
users: @db.query("SELECT * FROM users WHERE active = true")

# Even better
active_users: @db.query("SELECT * FROM users WHERE active = true")

# Best - extracted to function
get_active_users: @lambda({
    @db.query("SELECT * FROM users WHERE active = true")
})
active_users: @get_active_users()
```

## Best Practices Summary

1. **Be descriptive** - Names should convey purpose
2. **Be consistent** - Use the same convention throughout
3. **Be specific** - Avoid generic names
4. **Include context** - Add prefixes/suffixes for clarity
5. **Consider scope** - Name based on usage scope
6. **Think maintenance** - Will others understand?
7. **Avoid ambiguity** - Make distinctions clear

## Style Guide Template

```tusk
# Project naming conventions
style_guide:
    variables: "snake_case"
    constants: "UPPER_SNAKE_CASE"
    functions: "snake_case with verb"
    types: "PascalCase"
    private: "_leading_underscore"
    
    prefixes:
        booleans: ["is_", "has_", "can_", "should_"]
        getters: "get_"
        setters: "set_"
        handlers: "handle_"
        
    suffixes:
        time: ["_at", "_date", "_timestamp"]
        counts: ["_count", "_total", "_num"]
        ids: "_id"
```

## Next Steps

- Learn about [Reserved Keywords](028-reserved-keywords.md)
- Understand [Syntax Errors](029-syntax-errors.md)
- Review [Best Practices](030-best-practices.md)
---

[Reserved Keywords in TuskLang]


TuskLang reserves certain keywords that have special meaning in the language. These words cannot be used as variable names, function names, or identifiers. This guide covers all reserved keywords and how to work around them when needed.

## Core Reserved Keywords

### Boolean Literals

```tusk
# Reserved boolean values
true   # Boolean true literal
false  # Boolean false literal

# These are reserved and cannot be used as variable names
# true: "some value"   # ERROR
# false: "some value"  # ERROR

# Workarounds
is_true: true
false_value: false
true_flag: true
```

### Null Literal

```tusk
# Reserved null value
null   # Represents absence of value

# Cannot use as variable name
# null: "some value"   # ERROR

# Workarounds
null_value: null
is_null: true
empty: null
```

### Type Keywords

```tusk
# Reserved type names
string    # String type
number    # Number type
boolean   # Boolean type
object    # Object type
array     # Array type
function  # Function type
any       # Any type

# Cannot use as variable names
# string: "text"      # ERROR
# number: 42          # ERROR

# Workarounds
string_value: "text"
number_type: "number"
my_string: "text"
```

## Control Flow Keywords

### Conditional Keywords

```tusk
# Reserved for future control flow
if      # Used with @if
else    # Used with @if
switch  # Used with @switch
case    # Used with @switch
default # Used with @switch

# These may be reserved for future syntax
# if: "condition"     # ERROR
# else: "alternative" # ERROR

# Current usage with @ operator
result = @if(condition, true_value, false_value)
```

### Loop Keywords

```tusk
# Reserved for loops
for     # For loops
while   # While loops
do      # Do-while loops
break   # Break statement
continue # Continue statement

# Cannot use as variables
# for: "iterator"    # ERROR
# while: true        # ERROR

# Current loop usage
@for(i in range(10), {
    # Loop body
})
```

## Function Keywords

### Function Definition

```tusk
# Reserved for functions
function  # Function declaration
return    # Return statement
lambda    # Lambda expression

# Cannot use as variables
# function: "my function"  # ERROR
# return: "value"         # ERROR

# Current function usage
my_function: @lambda(param, {
    return: param * 2
})
```

### Special Function Keywords

```tusk
# Reserved for special behaviors
self     # Self reference
parent   # Parent reference
this     # This context
super    # Super reference

# Usage in objects
object: {
    value: 10
    method: @lambda({
        return: @self.value  # References object.value
    })
}
```

## Declaration Keywords

### Variable Declaration

```tusk
# Reserved for declarations
var    # Variable declaration
let    # Block-scoped variable
const  # Constant declaration
type   # Type declaration

# May be reserved for future syntax
# var: "variable"   # ERROR
# const: "constant" # ERROR

# Current declaration style
my_var: "value"
MY_CONST: "constant value"
```

## Import/Export Keywords

### Module Keywords

```tusk
# Reserved for modules
import   # Import statement
export   # Export statement
from     # Import from
as       # Import/export alias
module   # Module declaration

# Cannot use as variables
# import: "data"    # ERROR
# export: "data"    # ERROR

# Current import syntax
data: @import("./data.tsk")
utils: @import("./utils.tsk") as utilities
```

## Operator Keywords

### Logical Operators

```tusk
# Reserved operators
and      # Logical AND (use &&)
or       # Logical OR (use ||)
not      # Logical NOT (use !)
in       # In operator
of       # Of operator

# Cannot use as variables
# and: true        # ERROR
# or: false        # ERROR

# Use symbols instead
result = a && b  # AND
result = a || b  # OR
result = !a      # NOT
```

### Comparison Keywords

```tusk
# Reserved for comparisons
is       # Identity check
typeof   # Type check
instanceof # Instance check

# May be reserved
# is: "comparison"  # ERROR

# Current usage
type_check = @typeof(value)
```

## Special Keywords

### Async Keywords

```tusk
# Reserved for async operations
async    # Async function
await    # Await expression
promise  # Promise type

# Reserved for future async support
# async: "operation"  # ERROR
# await: "result"     # ERROR
```

### Error Handling

```tusk
# Reserved for error handling
try      # Try block
catch    # Catch block
finally  # Finally block
throw    # Throw statement

# Cannot use as variables
# try: "attempt"     # ERROR
# catch: "error"     # ERROR

# Current error handling
result = @try({
    # Try block
}, {
    # Catch block
})
```

## Class-Related Keywords

### OOP Keywords

```tusk
# Reserved for object-oriented features
class      # Class declaration
extends    # Class inheritance
implements # Interface implementation
interface  # Interface declaration
abstract   # Abstract class/method
static     # Static member
private    # Private member
public     # Public member
protected  # Protected member

# These are reserved
# class: "MyClass"    # ERROR
# private: "data"     # ERROR
```

## Working with Reserved Keywords

### Naming Strategies

```tusk
# When you need similar names, use prefixes/suffixes

# Instead of 'class'
class_name: "User"
user_class: "User"
className: "User"

# Instead of 'type'
type_name: "string"
data_type: "string"
typeOf: "string"

# Instead of 'return'
return_value: 42
returns: 42
returned: 42
```

### Context-Specific Alternatives

```tusk
# For configuration that might clash

# Instead of 'default'
default_value: "none"
defaults: {
    timeout: 30
}
fallback: "default"

# Instead of 'public'
public_key: "xyz123"
is_public: true
visibility: "public"
```

### Escaping (If Supported)

```tusk
# Some languages allow escaping reserved words
# TuskLang may support this in the future
# `class`: "MyClass"  # Hypothetical escaped keyword
# "class": "MyClass"  # Using quotes as keys
```

## Reserved Prefixes

### @ Operator Prefix

```tusk
# The @ symbol is reserved for operators
@if()       # Conditional operator
@env        # Environment access
@time       # Time functions
@lambda()   # Lambda functions

# Cannot create variables starting with @
# @myvar: "value"    # ERROR

# Use without @
myvar: "value"
```

### System Prefixes

```tusk
# Double underscore may be reserved
__proto__    # Prototype chain
__internal__ # Internal use

# Single underscore is fine
_private: "value"
_internal: "data"
```

## Future Reserved Keywords

### Potential Future Keywords

```tusk
# These might be reserved in future versions
namespace   # Namespace declaration
package     # Package declaration
yield       # Generator yield
enum        # Enumeration
sealed      # Sealed class
readonly    # Readonly property
override    # Method override
virtual     # Virtual method

# Avoid using these as variable names
# namespace: "my.namespace"  # Might break in future
```

## Best Practices

### 1. Check Documentation

```tusk
# Always refer to the latest documentation
# Reserved keywords may change between versions

# Safe approach - use descriptive names
configuration: { }      # Instead of 'config'
authentication: { }     # Instead of 'auth'
```

### 2. Use Linters

```tusk
# TuskLang linters will warn about reserved keywords
# Run: tusk lint myfile.tsk

# Linter will catch:
# - Reserved keyword usage
# - Potential conflicts
# - Future deprecations
```

### 3. Naming Conventions

```tusk
# Follow conventions to avoid conflicts

# Use prefixes for clarity
my_class: "User"
my_type: "string"
my_default: "value"

# Use domain-specific terms
user_type: "admin"
default_role: "guest"
return_code: 200
```

### 4. Error Messages

```tusk
# TuskLang provides clear error messages
# Error: Cannot use reserved keyword 'true' as identifier
# Line 10: true: "some value"
#          ^^^^

# The error will suggest alternatives
```

## Common Mistakes

### Using Reserved Words

```tusk
# Common mistakes to avoid

# Wrong
# true: "yes"
# false: "no"
# null: "empty"

# Right
is_true: "yes"
is_false: "no"
is_null: "empty"
```

### Forgetting Context

```tusk
# Keywords might be valid in some contexts

# As object property (if allowed)
config: {
    "default": "value"  # May work with quotes
}

# As string value (always works)
keyword: "class"  # Fine as string value
```

## Quick Reference

### Always Reserved

- `true`, `false`, `null`
- Basic types: `string`, `number`, `boolean`, `object`, `array`, `function`
- May be reserved: `if`, `else`, `for`, `while`, `return`

### Context-Sensitive

- `@` prefix - reserved for operators
- `__` prefix - may be reserved for internals
- Future keywords - check documentation

### Safe Practices

1. Use descriptive names
2. Add prefixes/suffixes when needed
3. Check linter warnings
4. Keep up with language updates

## Next Steps

- Learn about [Syntax Errors](029-syntax-errors.md)
- Review [Best Practices](030-best-practices.md)
- Explore [@ Operators](031-at-operator-intro.md)
---

[Syntax Errors in TuskLang]


Understanding and fixing syntax errors is crucial for writing valid TuskLang code. This guide covers common syntax errors, how to identify them, and how to fix them.

## Common Syntax Errors

### Missing Colons or Equals

```tusk
# ERROR: Missing assignment operator
name "John"          # Error: Expected ':' or '='

# CORRECT: Use colon for static values
name: "John"

# ERROR: Wrong operator for dynamic values  
timestamp: @time.now()  # Error: @ operators need '='

# CORRECT: Use equals for dynamic values
timestamp = @time.now()
```

### Incorrect Indentation

```tusk
# ERROR: Inconsistent indentation
server:
    host: "localhost"
  port: 8080        # Error: Inconsistent indentation

# CORRECT: Consistent indentation
server:
    host: "localhost"
    port: 8080

# ERROR: Mixed tabs and spaces
config:
    name: "app"     # Spaces
	version: "1.0"  # Tab - Error!

# CORRECT: Use either spaces OR tabs consistently
config:
    name: "app"
    version: "1.0"
```

### Unterminated Strings

```tusk
# ERROR: Missing closing quote
message: "Hello World    # Error: Unterminated string

# CORRECT: Close the string
message: "Hello World"

# ERROR: Mismatched quotes
greeting: "Hello'        # Error: Started with " but ended with '

# CORRECT: Match quote types
greeting: "Hello"
greeting: 'Hello'

# ERROR: Unterminated heredoc
text: """
This is a heredoc
without closing delimiter

# CORRECT: Close heredoc
text: """
This is a heredoc
with proper closing
"""
```

### Invalid Array Syntax

```tusk
# ERROR: Missing commas
numbers: [1 2 3]        # Error: Missing commas

# CORRECT: Use commas
numbers: [1, 2, 3]

# ERROR: Trailing comma (if not supported)
items: [
    "a",
    "b",
    "c",                # May cause error in some versions
]

# CORRECT: Remove trailing comma or check if supported
items: [
    "a",
    "b",
    "c"
]

# ERROR: Mixed syntax
data: [1, 2, {key: value}]  # Error: 'value' is undefined

# CORRECT: Quote strings or reference properly
data: [1, 2, {key: "value"}]
```

## Object Syntax Errors

### Missing Commas in Objects

```tusk
# ERROR: Missing comma between properties
user: {
    name: "John"
    age: 30         # Error: Missing comma after previous property
}

# CORRECT: Add commas
user: {
    name: "John",
    age: 30
}

# ERROR: Comma after last property (inline)
config: { host: "localhost", port: 8080, }  # May error

# CORRECT: Remove trailing comma in inline objects
config: { host: "localhost", port: 8080 }
```

### Invalid Property Names

```tusk
# ERROR: Unquoted property with special characters
headers: {
    Content-Type: "application/json"  # Error: '-' not allowed
}

# CORRECT: Quote special property names
headers: {
    "Content-Type": "application/json"
}

# ERROR: Starting with number
data: {
    1st: "first"    # Error: Property can't start with number
}

# CORRECT: Quote or rename
data: {
    "1st": "first"  # Or use 'first' as key
}
```

## Function and Expression Errors

### Invalid @ Operator Usage

```tusk
# ERROR: @ operator with colon
result: @compute_value()  # Error: @ requires '='

# CORRECT: Use equals with @ operators
result = @compute_value()

# ERROR: Missing @ for operator calls
current_time = time.now()  # Error: 'time' is not defined

# CORRECT: Use @ prefix
current_time = @time.now()

# ERROR: Space after @
value = @ env.PORT  # Error: No space after @

# CORRECT: No space after @
value = @env.PORT
```

### Lambda Syntax Errors

```tusk
# ERROR: Missing arrow or braces
add = @lambda(a, b, a + b)  # Error in some contexts

# CORRECT: Use proper lambda syntax
add = @lambda(a, b, {
    return: a + b
})

# ERROR: Missing parameter parentheses
greet = @lambda name, {     # Error: Need parentheses
    return: "Hello, ${name}"
})

# CORRECT: Include parentheses
greet = @lambda(name, {
    return: "Hello, ${name}"
})
```

## Reference Errors

### Invalid References

```tusk
# ERROR: Reference to undefined variable
value: @undefined_variable  # Error: undefined_variable not found

# CORRECT: Define before referencing
defined_variable: "value"
value: @defined_variable

# ERROR: Deep reference to non-existent path
data: @config.database.primary.host  # Error if path doesn't exist

# CORRECT: Use optional chaining or check existence
data: @config?.database?.primary?.host ?? "localhost"
```

### Circular References

```tusk
# ERROR: Direct circular reference
a: @b
b: @a  # Error: Circular reference detected

# CORRECT: Break the cycle
a: "value"
b: @a  # Now b references a's value

# ERROR: Indirect circular reference
x: @y.value
y: { value: @z.value }
z: { value: @x }  # Error: Circular through chain

# CORRECT: Use functions for lazy evaluation
x = @lambda({ @y.value })
y: { value: @lambda({ @z.value }) }
z: { value: "actual value" }
```

## Type-Related Errors

### Type Mismatches

```tusk
# ERROR: Assigning wrong type with strict typing
age: string = 30  # Error: Expected string, got number

# CORRECT: Match types or convert
age: string = "30"
# Or
age: number = 30

# ERROR: Array type mismatch
numbers: number[] = [1, "2", 3]  # Error: "2" is not a number

# CORRECT: Ensure all elements match type
numbers: number[] = [1, 2, 3]
# Or convert
numbers: number[] = [1, @number("2"), 3]
```

## Comment Errors

### Incorrect Comment Syntax

```tusk
# CORRECT: Single line comment
name: "John"  # This is a comment

// ERROR: C-style comments not supported
// This won't work as a comment

/* ERROR: Block comments not supported
   This style is not valid */

# CORRECT: Use # for all comments
# This is a comment
# This is another comment

### Documentation comments use ###
# User model documentation
###
```

## String Interpolation Errors

### Invalid Interpolation Syntax

```tusk
# ERROR: Wrong interpolation syntax
message: "Hello $name"       # Error: Missing braces
message: "Hello {name}"      # Error: Missing $
message: "Hello $(name)"     # Error: Wrong syntax

# CORRECT: Use ${} for interpolation
name: "World"
message: "Hello ${name}"

# ERROR: Interpolation in single quotes
text: 'Hello ${name}'  # Won't interpolate

# CORRECT: Use double quotes for interpolation
text: "Hello ${name}"
```

## Error Messages and Debugging

### Understanding Error Messages

```tusk
# Typical error message format:
# Error: Unexpected token '}' at line 15, column 8
# File: config.tsk
# Line 15: server: { host: "localhost" }}
#                                        ^

# The error points to the exact location
```

### Common Error Patterns

```tusk
# "Unexpected token" - Usually syntax error
server: {
    host: "localhost"
    }  # Error: Expected property or '}'

# "Undefined variable" - Reference error
value: @nonexistent  # Error: 'nonexistent' is not defined

# "Type mismatch" - Type error
count: string = 42  # Error: Expected string, got number

# "Invalid indentation" - Formatting error
data:
  item1: "value"
    item2: "value"  # Error: Inconsistent indentation
```

## Prevention Strategies

### Use a Linter

```bash
# Run TuskLang linter
tusk lint myfile.tsk

# Linter catches:
# - Syntax errors
# - Undefined variables
# - Type mismatches
# - Style violations
```

### Format Your Code

```bash
# Auto-format to fix indentation
tusk format myfile.tsk

# Before:
server:{host:"localhost",port:8080}

# After:
server: {
    host: "localhost",
    port: 8080
}
```

### Development Tools

```tusk
# Use IDE/editor with TuskLang support
# Features to look for:
# - Syntax highlighting
# - Real-time error detection
# - Auto-completion
# - Format on save

# VS Code settings
{
    "[tusklang]": {
        "editor.formatOnSave": true,
        "editor.tabSize": 4
    }
}
```

## Best Practices for Error Prevention

### 1. Consistent Style

```tusk
# Pick a style and stick to it
# Good: Consistent throughout
config:
    server:
        host: "localhost"
        port: 8080
    database:
        host: "db.local"
        port: 5432
```

### 2. Validate Early

```tusk
# Validate inputs early
process_user = @lambda(data, {
    # Validate first
    @assert(data != null, "Data cannot be null")
    @assert(data.name, "Name is required")
    @assert(@isNumber(data.age), "Age must be a number")
    
    # Then process
    # ...
})
```

### 3. Use Type Hints

```tusk
# Add type hints for clarity
create_user = @lambda(
    name: string,
    age: number,
    roles: string[]
): User, {
    # Implementation
})
```

### 4. Test Incrementally

```tusk
# Test as you write
# Step 1: Basic structure
config:
    name: "test"

# Step 2: Add nested data
config:
    name: "test"
    server:
        host: "localhost"

# Step 3: Add dynamic values
config:
    name: "test"
    server:
        host: "localhost"
        port = @env.PORT || 8080
```

## Recovery Strategies

### Debugging Steps

1. **Read the error message** - It usually points to the exact issue
2. **Check the line number** - Look at the specific line and surrounding context
3. **Verify syntax** - Ensure proper operators (:, =), quotes, commas
4. **Check indentation** - Use consistent spaces or tabs
5. **Validate references** - Ensure all referenced variables exist
6. **Test in isolation** - Extract problematic code and test separately

### Common Fixes

```tusk
# For "Unexpected token" - Check for missing commas, quotes, or brackets
# For "Undefined variable" - Ensure variable is defined before use
# For "Invalid indentation" - Reformat with consistent spacing
# For "Type mismatch" - Convert values or fix type annotations
# For "Circular reference" - Restructure to break the cycle
```

## Next Steps

- Review [Best Practices](030-best-practices.md)
- Learn about [@ Operators](031-at-operator-intro.md)
- Master [Error Handling](058-at-operator-errors.md)
---

[TuskLang Best Practices]


This guide compiles the best practices for writing clean, maintainable, and efficient TuskLang code. Following these guidelines will help you create robust applications and make your code easier to understand and maintain.

## Code Organization

### File Structure

```tusk
# Organize files logically
project/
├── config/
│   ├── app.tsk         # Application configuration
│   ├── database.tsk    # Database settings
│   └── security.tsk    # Security settings
├── src/
│   ├── models/         # Data models
│   ├── services/       # Business logic
│   └── utils/          # Helper functions
├── tests/              # Test files
└── main.tsk           # Entry point

# Each file should have a single responsibility
# Good: auth.tsk handles only authentication
# Bad: utils.tsk with mixed concerns
```

### Module Design

```tusk
# Good: Cohesive module with clear purpose
# auth.tsk
module:
    name: "Authentication"
    version: "1.0.0"
    description: "Handles user authentication and sessions"

# Public interface
export:
    login: @login_user
    logout: @logout_user  
    verify: @verify_token
    refresh: @refresh_token

# Private implementation
_hash_password = @lambda(password, { })
_generate_token = @lambda(user, { })

# Bad: Module doing too many things
# everything.tsk - Avoid this!
```

## Naming Conventions

### Variable Naming

```tusk
# Good: Descriptive and consistent
user_count: 42
is_authenticated: true
can_edit_posts: false
max_retry_attempts: 3

# Bad: Unclear or inconsistent
n: 42
flag: true
editOK: false  # Mixed naming style
MAX: 3
```

### Function Naming

```tusk
# Good: Verb-based, clear intent
get_user_by_id = @lambda(id, { })
calculate_total_price = @lambda(items, { })
is_valid_email = @lambda(email, { })
send_notification = @lambda(user, message, { })

# Bad: Unclear or noun-based
user = @lambda(id, { })      # Should be get_user
total = @lambda(items, { })   # Should be calculate_total
email = @lambda(addr, { })    # Unclear purpose
```

## Type Safety

### Use Type Annotations

```tusk
# Good: Clear types for public interfaces
create_user = @lambda(
    name: string,
    email: string,
    age: number,
    roles: string[] = ["user"]
): User, {
    # Implementation
})

# Bad: No type information
create_user = @lambda(name, email, age, roles, {
    # What types are expected?
})
```

### Validate Input Types

```tusk
# Good: Validate early
process_payment = @lambda(amount: any, currency: any, {
    # Validate inputs
    @assert(@isNumber(amount) && amount > 0, "Invalid amount")
    @assert(@includes(["USD", "EUR", "GBP"], currency), "Invalid currency")
    
    # Process payment
})

# Bad: Assume inputs are correct
process_payment = @lambda(amount, currency, {
    total = amount * exchange_rate  # May fail if amount isn't a number
})
```

## Error Handling

### Graceful Error Handling

```tusk
# Good: Handle errors explicitly
fetch_user_data = @lambda(user_id: number, {
    result = @try({
        user: @database.find_user(user_id)
        
        @if(!user, {
            @throw("User not found")
        })
        
        return: { success: true, data: user }
    }, {
        error: @catch_error
        @log.error("Failed to fetch user ${user_id}: ${error}")
        return: { success: false, error: error.message }
    })
    
    return: result
})

# Bad: Let errors propagate unchecked
fetch_user_data = @lambda(user_id, {
    return: @database.find_user(user_id)  # What if this fails?
})
```

### Use Result Types

```tusk
# Good: Explicit success/failure states
type Result<T, E> = 
    | { ok: true, value: T }
    | { ok: false, error: E }

divide = @lambda(a: number, b: number): Result<number, string>, {
    @if(b == 0, {
        return: { ok: false, error: "Division by zero" }
    })
    
    return: { ok: true, value: a / b }
})

# Usage
result = @divide(10, 2)
@if(result.ok, {
    @print("Result: ${result.value}")
}, {
    @print("Error: ${result.error}")
})
```

## Configuration Management

### Environment-Based Config

```tusk
# Good: Separate config by environment
base_config:
    app_name: "MyApp"
    version: "1.0.0"
    features:
        logging: true
        metrics: true

development_config:
    ...@base_config
    debug: true
    database_url: "postgresql://localhost/myapp_dev"
    
production_config:
    ...@base_config
    debug: false
    database_url: @env.DATABASE_URL
    ssl_required: true

# Load based on environment
config = @env.NODE_ENV == "production" 
    ? @production_config 
    : @development_config
```

### Secure Secrets

```tusk
# Good: Never hardcode secrets
api_config:
    key: @env.API_KEY || @error("API_KEY not set")
    secret: @env.API_SECRET || @error("API_SECRET not set")
    
# Bad: Hardcoded secrets
api_config:
    key: "sk_live_abcd1234"  # NEVER DO THIS
    secret: "my-secret-key"  # SECURITY RISK
```

## Performance Optimization

### Avoid Unnecessary Computation

```tusk
# Good: Cache expensive operations
_user_permissions_cache: {}

get_user_permissions = @lambda(user_id: number, {
    # Check cache first
    cached = @_user_permissions_cache[user_id]
    @if(cached, return: cached)
    
    # Compute if not cached
    permissions = @database.query(
        "SELECT * FROM permissions WHERE user_id = ?", 
        user_id
    )
    
    # Cache for future use
    _user_permissions_cache[user_id] = permissions
    return: permissions
})

# Bad: Recompute every time
get_user_permissions = @lambda(user_id, {
    return: @database.query(
        "SELECT * FROM permissions WHERE user_id = ?",
        user_id
    )
})
```

### Use Appropriate Data Structures

```tusk
# Good: Use object for key-value lookups
user_lookup: {
    "user_123": { name: "Alice", role: "admin" },
    "user_456": { name: "Bob", role: "user" }
}
user = @user_lookup[user_id]  # O(1) lookup

# Bad: Use array for lookups
users: [
    { id: "user_123", name: "Alice", role: "admin" },
    { id: "user_456", name: "Bob", role: "user" }
]
user = @find(users, @lambda(u, u.id == user_id))  # O(n) lookup
```

## Code Clarity

### Single Responsibility

```tusk
# Good: Each function does one thing
validate_email = @lambda(email: string): boolean, {
    return: @regex.test(email, "^[^@]+@[^@]+\.[^@]+$")
})

send_email = @lambda(to: string, subject: string, body: string, {
    # Just sends email
    @email_service.send({ to, subject, body })
})

# Bad: Function doing multiple things
process_user_email = @lambda(email, {
    # Validates
    @if(!@regex.test(email, "^[^@]+@[^@]+$"), {
        return: false
    })
    
    # Normalizes
    email = @lower(@trim(email))
    
    # Saves to database
    @database.save_email(email)
    
    # Sends welcome email
    @email_service.send({
        to: email,
        subject: "Welcome",
        body: "..."
    })
    
    return: true
})
```

### Clear Control Flow

```tusk
# Good: Easy to follow logic
process_order = @lambda(order: Order, {
    # Validate
    validation = @validate_order(order)
    @if(!validation.valid, {
        return: { error: validation.errors }
    })
    
    # Check inventory
    available = @check_inventory(order.items)
    @if(!available, {
        return: { error: "Insufficient inventory" }
    })
    
    # Process payment
    payment = @process_payment(order.payment)
    @if(!payment.success, {
        return: { error: payment.error }
    })
    
    # Fulfill order
    return: @fulfill_order(order)
})

# Bad: Nested and hard to follow
process_order = @lambda(order, {
    @if(@validate_order(order), {
        @if(@check_inventory(order.items), {
            payment = @process_payment(order.payment)
            @if(payment.success, {
                return: @fulfill_order(order)
            }, {
                return: { error: payment.error }
            })
        }, {
            return: { error: "Insufficient inventory" }
        })
    }, {
        return: { error: "Invalid order" }
    })
})
```

## Documentation

### Document Public APIs

```tusk
###
# Creates a new user account
# 
# @param {string} email - User's email address
# @param {string} password - User's password (will be hashed)
# @param {object} profile - Optional profile data
# @returns {Result<User, string>} Success with user or error
# @throws {ValidationError} If input validation fails
# 
# @example
# result = @create_user("john@example.com", "secure123", {
#     name: "John Doe",
#     timezone: "UTC"
# })
###
create_user = @lambda(
    email: string,
    password: string, 
    profile: object = {}
): Result<User, string>, {
    # Implementation
})
```

### Inline Comments

```tusk
# Good: Explain why, not what
# Use exponential backoff to avoid overwhelming the server
retry_delay = @min(base_delay * (2 ** attempt), max_delay)

# Bad: Explain what (obvious from code)
# Multiply base_delay by 2 to the power of attempt
retry_delay = base_delay * (2 ** attempt)
```

## Testing

### Write Testable Code

```tusk
# Good: Pure function, easy to test
calculate_discount = @lambda(
    price: number,
    discount_percent: number
): number, {
    @assert(price >= 0, "Price must be non-negative")
    @assert(discount_percent >= 0 && discount_percent <= 100, 
            "Discount must be between 0 and 100")
    
    return: price * (1 - discount_percent / 100)
})

# Bad: Side effects, hard to test
apply_discount = @lambda(order_id, discount_percent, {
    order = @database.get_order(order_id)  # External dependency
    order.total = order.total * (1 - discount_percent / 100)
    @database.save_order(order)  # Side effect
    @email.send_discount_applied(order)  # Another side effect
})
```

### Structure Tests

```tusk
# Good: Organized test structure
tests:
    "User Authentication":
        "should hash passwords": {
            hashed = @hash_password("password123")
            assert: hashed != "password123"
            assert: @verify_password("password123", hashed)
        }
        
        "should reject weak passwords": {
            result = @validate_password("123")
            assert: !result.valid
            assert: @includes(result.errors, "Too short")
        }
```

## Security

### Input Validation

```tusk
# Good: Validate and sanitize all inputs
handle_user_input = @lambda(input: string, {
    # Validate length
    @if(@len(input) > 1000, {
        @error("Input too long")
    })
    
    # Sanitize for different contexts
    html_safe = @html.escape(input)
    sql_safe = @sql.escape(input)
    
    # Use appropriately based on context
})

# Bad: Trust user input
handle_user_input = @lambda(input, {
    @database.query("SELECT * FROM users WHERE name = '${input}'")  # SQL injection risk!
})
```

### Principle of Least Privilege

```tusk
# Good: Expose only what's necessary
auth_module:
    # Private implementation details
    _secret_key: @env.JWT_SECRET
    _hash_algorithm: "SHA256"
    
    # Public interface only exposes safe operations
    export:
        login: @public_login
        verify_token: @public_verify
        # _secret_key is NOT exported
```

## Common Patterns

### Builder Pattern

```tusk
# Good: Fluent interface for complex objects
create_email_builder = @lambda({
    _email: {
        to: [],
        cc: [],
        subject: "",
        body: "",
        attachments: []
    }
    
    return: {
        to: @lambda(address, {
            @push(_email.to, address)
            return: @self
        }),
        cc: @lambda(address, {
            @push(_email.cc, address)
            return: @self
        }),
        subject: @lambda(text, {
            _email.subject = text
            return: @self
        }),
        body: @lambda(content, {
            _email.body = content
            return: @self
        }),
        attach: @lambda(file, {
            @push(_email.attachments, file)
            return: @self
        }),
        build: @lambda({ return: _email })
    }
})

# Usage
email = @create_email_builder()
    .to("user@example.com")
    .cc("manager@example.com")
    .subject("Monthly Report")
    .body("Please find attached...")
    .attach("report.pdf")
    .build()
```

### Repository Pattern

```tusk
# Good: Abstraction over data access
user_repository:
    find_by_id: @lambda(id: number, {
        @database.query_one("SELECT * FROM users WHERE id = ?", id)
    })
    
    find_by_email: @lambda(email: string, {
        @database.query_one("SELECT * FROM users WHERE email = ?", email)
    })
    
    save: @lambda(user: User, {
        @if(user.id, {
            # Update existing
            @database.execute(
                "UPDATE users SET name = ?, email = ? WHERE id = ?",
                user.name, user.email, user.id
            )
        }, {
            # Insert new
            user.id = @database.insert(
                "INSERT INTO users (name, email) VALUES (?, ?)",
                user.name, user.email
            )
        })
        return: user
    })
```

## Summary Checklist

- ✅ Use descriptive names
- ✅ Add type annotations for public APIs
- ✅ Handle errors gracefully
- ✅ Validate inputs early
- ✅ Keep functions focused (single responsibility)
- ✅ Document complex logic
- ✅ Use consistent formatting
- ✅ Avoid hardcoded secrets
- ✅ Write testable code
- ✅ Follow security best practices
- ✅ Optimize for readability over cleverness
- ✅ Use appropriate data structures
- ✅ Cache expensive operations
- ✅ Keep modules cohesive
- ✅ Review and refactor regularly

## Next Steps

- Explore [@ Operators](031-at-operator-intro.md) for advanced features
- Learn about [Performance Optimization](059-at-operator-performance.md)
- Master [Security Practices](060-at-operator-security.md)
---

[Introduction to @ Operators]


The @ operator is one of TuskLang's most powerful features, providing runtime functionality and dynamic behavior. This guide introduces the @ operator system and its capabilities.

## What is the @ Operator?

The @ operator signifies runtime operations in TuskLang. When you see `@`, you know that something dynamic is happening - whether it's accessing environment variables, calling functions, or performing computations.

```tusk
# Static value (no @)
static_port: 8080

# Dynamic value (with @)
dynamic_port = @env.PORT || 8080

# The @ indicates runtime evaluation
```

## Why @ Operators?

### Visual Distinction

```tusk
# Immediately clear what's static vs dynamic
config:
    name: "MyApp"              # Static - set at parse time
    version: "1.0.0"          # Static
    port = @env.PORT || 3000  # Dynamic - evaluated at runtime
    timestamp = @time.now()    # Dynamic - changes each run
```

### Consistent Syntax

```tusk
# All runtime operations use @ prefix
environment = @env.NODE_ENV
current_time = @time.now()
user_data = @database.query("SELECT * FROM users")
json_output = @json.stringify(data)

# Easy to spot dynamic operations at a glance
```

## Basic @ Operator Usage

### Environment Access

```tusk
# Access environment variables
api_key = @env.API_KEY
database_url = @env.DATABASE_URL || "postgresql://localhost/dev"

# Check if environment variable exists
has_key = @env.API_KEY != null
```

### Function Calls

```tusk
# Built-in functions
random_number = @random()
uuid = @uuid.generate()
timestamp = @time.now()

# User-defined functions
result = @calculate_total(items)
user = @fetch_user(id)
```

### Property Access

```tusk
# Access nested properties dynamically
request_method = @request.method
user_agent = @request.headers.user_agent
query_param = @request.query.page

# Safe navigation
city = @user?.address?.city || "Unknown"
```

## @ Operator Categories

### 1. Variable References

```tusk
# Reference other variables
base_url: "https://api.example.com"
endpoint = "${@base_url}/users"

# Reference with paths
database_host = @config.database.host
```

### 2. System Functions

```tusk
# Time operations
now = @time.now()
formatted = @time.format(now, "YYYY-MM-DD")

# String operations
uppercase = @upper("hello")
trimmed = @trim("  spaced  ")

# Array operations
mapped = @map(array, @lambda(x, x * 2))
filtered = @filter(array, @lambda(x, x > 10))
```

### 3. I/O Operations

```tusk
# File operations
content = @file.read("config.json")
@file.write("output.txt", data)

# HTTP operations
response = @http.get("https://api.example.com/data")
result = @http.post(url, { body: data })

# Database operations
users = @db.query("SELECT * FROM users")
```

### 4. Control Flow

```tusk
# Conditional execution
result = @if(condition, true_value, false_value)

# Error handling
safe_result = @try({
    return: @risky_operation()
}, {
    return: "default value"
})

# Loops
@each(items, @lambda(item, {
    @process(item)
}))
```

## @ Operator Rules

### Assignment Requirements

```tusk
# @ operators require = (not :)
# Wrong:
dynamic: @env.PORT  # Error!

# Correct:
dynamic = @env.PORT

# This is because @ operations happen at runtime
```

### Chaining

```tusk
# @ operators can be chained
result = @trim(@upper(@env.APP_NAME || "default"))

# With property access
user_city = @users[@index].address.city

# With method calls
formatted = @time.format(@time.now(), "HH:mm:ss")
```

### Context Sensitivity

```tusk
# @ operators may behave differently based on context

# In a web server context
client_ip = @request.ip  # Gets current request's IP

# In a CLI context  
args = @argv  # Gets command line arguments

# Context determines available operators
```

## Common @ Operator Patterns

### Default Values

```tusk
# Use || for fallbacks
port = @env.PORT || 8080
name = @config.app_name || "DefaultApp"
timeout = @settings.timeout || 30000
```

### Computed Properties

```tusk
server:
    host: "localhost"
    port = @env.PORT || 3000
    url = "http://${@self.host}:${@self.port}"
    health_check = "${@self.url}/health"
```

### Dynamic Configuration

```tusk
# Load config based on environment
environment = @env.NODE_ENV || "development"
config = @import("./config/${@environment}.tsk")

# Conditional features
features:
    debug = @environment != "production"
    analytics = @env.ANALYTICS_ENABLED == "true"
```

### Template Processing

```tusk
# Process templates with @ operators
email_template: """
Hello ${@user.name},

Your account was created at ${@time.format(@user.created_at, "MMMM DD, YYYY")}.

Best regards,
${@config.company_name}
"""

# Send with processed template
@email.send({
    to: @user.email
    subject: "Welcome!"
    body: @email_template
})
```

## @ Operator Precedence

```tusk
# @ operators follow standard precedence rules
result = @a + @b * @c  # Multiplication first
result = (@a + @b) * @c  # Parentheses override

# Property access is left-to-right
value = @config.database.primary.host

# Function calls have high precedence
result = @calculate(x) + @calculate(y)
```

## Performance Considerations

### Caching Results

```tusk
# @ operators execute each time they're accessed
# This runs the query twice:
users1 = @db.query("SELECT * FROM users")
users2 = @db.query("SELECT * FROM users")  # Runs again!

# Better: Cache the result
users = @db.query("SELECT * FROM users")
users1 = @users
users2 = @users  # Uses cached result
```

### Lazy Evaluation

```tusk
# Use functions for lazy evaluation
get_expensive_data = @lambda({
    return: @db.complex_query()
})

# Only runs when called
@if(need_data, {
    data = @get_expensive_data()
})
```

## Error Handling with @

### Safe Navigation

```tusk
# Use ?. for safe property access
value = @deeply?.nested?.property?.value

# Equivalent to multiple null checks
value = @deeply && @deeply.nested && @deeply.nested.property && @deeply.nested.property.value
```

### Try-Catch Pattern

```tusk
# Wrap risky @ operations
result = @try({
    data: @http.get(url)
    return: @json.parse(data.body)
}, {
    error: @catch
    @log.error("Failed to fetch data: ${error}")
    return: null
})
```

## @ Operator Best Practices

### 1. Use Meaningful Names

```tusk
# Good
user_email = @current_user.email
request_timestamp = @request.timestamp

# Bad
e = @u.e
t = @r.t
```

### 2. Handle Null Values

```tusk
# Always consider null possibilities
username = @user?.name || "Anonymous"
port = @env.PORT || 3000

# Check before using
@if(@database.connected, {
    users = @database.query("SELECT * FROM users")
})
```

### 3. Document Dynamic Behavior

```tusk
# Server port from environment or default to 3000
# Updates on server restart if env changes
port = @env.PORT || 3000

# Cache user permissions for current request
# Refreshed on each new request
permissions = @cache.request("user_perms", {
    @db.get_user_permissions(@user.id)
})
```

## Available @ Operators Overview

Here's a quick reference of major @ operator categories:

- **Variables**: `@variable_name`, `@path.to.value`
- **Environment**: `@env.VARIABLE`
- **Request**: `@request.method`, `@request.body`, `@request.query`
- **Time**: `@time.now()`, `@time.format()`
- **String**: `@upper()`, `@lower()`, `@trim()`
- **Array**: `@map()`, `@filter()`, `@reduce()`
- **Object**: `@keys()`, `@values()`, `@merge()`
- **I/O**: `@file.read()`, `@http.get()`, `@db.query()`
- **JSON**: `@json.parse()`, `@json.stringify()`
- **Control**: `@if()`, `@try()`, `@each()`

## Next Steps

Now that you understand the basics of @ operators, explore specific operators:

- [Variable References](032-at-variable-reference.md) - Using @ to reference values
- [Request Object](034-at-request-object.md) - Web request handling
- [Built-in Functions](041-at-json-function.md) - JSON and data manipulation
- [Database Operations](044-at-query-database.md) - Data persistence

The @ operator system is designed to make dynamic operations clear and consistent throughout your TuskLang code.
---

[@ Variable Reference]


The @ operator allows you to reference variables and values dynamically in TuskLang. This guide covers how to use @ for variable references, property access, and value resolution.

## Basic Variable References

### Simple References

```tusk
# Define a variable
app_name: "MyApplication"

# Reference it with @
title = "@{app_name} Dashboard"  # Direct reference
welcome = "Welcome to ${@app_name}"  # In string interpolation

# Reference equals the value
name_copy = @app_name  # "MyApplication"
```

### Reference vs Value

```tusk
# Understanding the difference
original: "Hello"

# These are different:
copy_value: "Hello"     # Literal string
copy_reference = @original  # Reference to original

# If original changes (in dynamic contexts):
original = "Goodbye"
# copy_value is still "Hello"
# copy_reference reflects the new value
```

## Property Access

### Dot Notation

```tusk
# Access nested properties
config:
    app:
        name: "MyApp"
        version: "1.0.0"
    server:
        host: "localhost"
        port: 8080

# Reference nested values
app_name = @config.app.name
server_url = "http://${@config.server.host}:${@config.server.port}"

# Deep nesting
deep_value = @config.app.metadata.author.email
```

### Bracket Notation

```tusk
# Dynamic property access
users:
    alice: { age: 30, role: "admin" }
    bob: { age: 25, role: "user" }

username: "alice"
user_data = @users[@username]  # Dynamic key

# With expressions
index: 0
first_item = @array[@index]

# Computed property names
property: "age"
alice_age = @users.alice[@property]  # 30
```

## Array References

### Index Access

```tusk
# Array references
colors: ["red", "green", "blue", "yellow"]

# By index
primary_color = @colors[0]    # "red"
secondary_color = @colors[1]  # "green"

# Negative indices
last_color = @colors[-1]      # "yellow"
second_last = @colors[-2]     # "blue"

# Dynamic index
index: 2
selected_color = @colors[@index]  # "blue"
```

### Array Methods with @

```tusk
numbers: [1, 2, 3, 4, 5]

# Reference in operations
doubled = @map(@numbers, @lambda(n, n * 2))
sum = @reduce(@numbers, @lambda(a, b, a + b), 0)

# Length reference
count = @numbers.length
last_index = @numbers.length - 1
```

## Self and Parent References

### Using @self

```tusk
# Reference current object
server:
    host: "api.example.com"
    port: 443
    protocol: "https"
    url = "${@self.protocol}://${@self.host}:${@self.port}"
    health_endpoint = "${@self.url}/health"

# In nested contexts
user:
    first_name: "John"
    last_name: "Doe"
    profile:
        full_name = "${@parent.first_name} ${@parent.last_name}"
        display_name = @self.full_name
```

### Parent References

```tusk
# Access parent scope
app:
    name: "MyApp"
    modules:
        auth:
            module_name: "Authentication"
            app_name = @parent.parent.name  # "MyApp"
            full_name = "${@parent.parent.name} - ${@self.module_name}"
```

## Scope Resolution

### Local vs Global

```tusk
# Global scope
global_value: "I'm global"

function_example = @lambda({
    # Local scope
    local_value: "I'm local"
    global_value: "I shadow global"  # Shadows global
    
    # Access local (shadowed)
    local_ref = @global_value  # "I shadow global"
    
    # Access global explicitly
    global_ref = @root.global_value  # "I'm global"
})
```

### Module Scope

```tusk
# In module.tsk
module_data:
    version: "1.0.0"
    api_key: "secret"

export:
    get_version: @lambda({ return: @module_data.version })
    get_key: @lambda({ return: @module_data.api_key })

# In main.tsk
mod = @import("module.tsk")
version = @mod.get_version()  # Accesses module's scope
```

## Optional Chaining

### Safe Property Access

```tusk
# Potentially null/undefined values
user: {
    name: "John"
    # address might be missing
}

# Without optional chaining (risky)
# city = @user.address.city  # Error if address is null!

# With optional chaining (safe)
city = @user?.address?.city  # Returns null if any part is missing

# With default value
city = @user?.address?.city ?? "Unknown City"
```

### Array Optional Chaining

```tusk
# Safe array access
data: {
    users: null  # Might be null
}

# Safe access
first_user = @data?.users?.[0]
first_user_name = @data?.users?.[0]?.name ?? "No user"

# Chaining method calls
uppercase_name = @data?.users?.[0]?.name?.toUpperCase?.()
```

## Dynamic References

### Building Reference Paths

```tusk
# Dynamic path construction
get_config_value = @lambda(section, key, {
    # Build path dynamically
    path: "${section}.${key}"
    
    # Resolve path to value
    return: @resolve_path(@config, path)
})

# Usage
db_host = @get_config_value("database", "host")
api_key = @get_config_value("api", "key")
```

### Reference Resolution

```tusk
# Resolve string paths to values
resolve_path = @lambda(obj, path, {
    parts = @split(path, ".")
    result = obj
    
    @each(parts, @lambda(part, {
        result = result?.[part]
    }))
    
    return: result
})

# Example usage
config: {
    database: {
        primary: {
            host: "db1.example.com"
        }
    }
}

host = @resolve_path(@config, "database.primary.host")
```

## Reference Patterns

### Configuration References

```tusk
# Base configuration with references
defaults:
    timeout: 30
    retries: 3
    base_url: "https://api.example.com"

# Service configurations reference defaults
service_a:
    timeout = @defaults.timeout
    retries = @defaults.retries
    url = "${@defaults.base_url}/service-a"

service_b:
    timeout = @defaults.timeout * 2  # Custom timeout
    retries = @defaults.retries
    url = "${@defaults.base_url}/service-b"
```

### Computed References

```tusk
# References in computed properties
pricing:
    base_price: 100
    tax_rate: 0.08
    
    # Computed using references
    tax_amount = @self.base_price * @self.tax_rate
    total_price = @self.base_price + @self.tax_amount
    
    # Format for display
    display_price = "$${@self.total_price.toFixed(2)}"
```

### Circular Reference Prevention

```tusk
# This would cause an error:
# a = @b
# b = @a  # Circular reference!

# Safe patterns:

# 1. Use functions for lazy evaluation
node_a:
    value: "A"
    get_next: @lambda({ return: @node_b })

node_b:
    value: "B"
    get_next: @lambda({ return: @node_a })

# 2. Use conditional references
config:
    use_default: true
    default_value: 100
    custom_value: 200
    active_value = @self.use_default ? @self.default_value : @self.custom_value
```

## Performance Optimization

### Reference Caching

```tusk
# References are resolved when accessed
expensive_data = @compute_expensive_operation()

# Multiple references don't recompute
ref1 = @expensive_data  # Uses cached value
ref2 = @expensive_data  # Uses same cached value

# But function calls re-execute
data1 = @compute_expensive_operation()  # Runs
data2 = @compute_expensive_operation()  # Runs again!
```

### Efficient Reference Patterns

```tusk
# Inefficient: Multiple deep references
user_name = @app.data.users[0].profile.name
user_email = @app.data.users[0].profile.email
user_phone = @app.data.users[0].profile.phone

# Efficient: Store intermediate reference
user_profile = @app.data.users[0].profile
user_name = @user_profile.name
user_email = @user_profile.email
user_phone = @user_profile.phone
```

## Error Handling

### Reference Validation

```tusk
# Check if reference exists
safe_reference = @lambda(path, default_value, {
    try_result = @try({
        return: @resolve_path(@root, path)
    }, {
        return: default_value
    })
    
    return: try_result
})

# Usage
value = @safe_reference("config.missing.path", "default")
```

### Debugging References

```tusk
# Debug helper for references
debug_reference = @lambda(ref_path, {
    @console.log("Attempting to resolve: ${ref_path}")
    
    result = @try({
        value: @resolve_path(@root, ref_path)
        @console.log("Success: ${@json.stringify(value)}")
        return: value
    }, {
        error: @catch
        @console.error("Failed: ${error}")
        return: null
    })
})
```

## Best Practices

### 1. Use Clear Reference Names

```tusk
# Good: Clear what's being referenced
user_email = @current_user.email
api_endpoint = @config.api.endpoint

# Bad: Ambiguous references
e = @u.e
url = @c.a.e
```

### 2. Handle Missing References

```tusk
# Always consider null/undefined
name = @user?.name ?? "Anonymous"
settings = @config?.user_settings ?? @default_settings

# Check existence before use
@if(@config?.database?.host, {
    connect_to_database(@config.database.host)
})
```

### 3. Document Complex References

```tusk
# Retrieves user permissions from cache or database
# Falls back to empty array if user not found
permissions = @cache.get("perms_${@user.id}") ?? 
              @db.get_permissions(@user.id) ?? 
              []
```

### 4. Avoid Deep Nesting

```tusk
# Hard to read and maintain
value = @app.modules.user.services.auth.providers.oauth.google.client_id

# Better: Break it down
auth_providers = @app.modules.user.services.auth.providers
google_client_id = @auth_providers.oauth.google.client_id
```

## Common Patterns

### Default Values Chain

```tusk
# Priority-based configuration
port = @env.PORT ??              # 1. Environment variable
       @config.server.port ??     # 2. Config file
       @defaults.port ??          # 3. Default config
       8080                       # 4. Hardcoded fallback
```

### Reference Factories

```tusk
# Create references dynamically
create_service_ref = @lambda(service_name, {
    return: {
        config: @config.services[@service_name]
        status: @status.services[@service_name]
        metrics: @metrics.services[@service_name]
    }
})

# Usage
auth_service = @create_service_ref("auth")
auth_config = @auth_service.config
```

## Next Steps

- Learn about [Variable Fallbacks](033-at-variable-fallback.md)
- Explore [Request Object](034-at-request-object.md) references
- Master [Object Navigation](045-at-tusk-object.md)
---

[@ Variable Fallback]


Variable fallbacks in TuskLang provide elegant ways to handle missing values, undefined variables, and null references. This guide covers fallback patterns and best practices for robust error handling.

## Basic Fallback Syntax

### The || Operator

```tusk
# Basic fallback with ||
port = @env.PORT || 8080
name = @config.app_name || "DefaultApp"
timeout = @settings.timeout || 30000

# The || operator returns the first truthy value
value = null || undefined || "" || 0 || "found"  # "found"
```

### The ?? Operator (Null Coalescing)

```tusk
# Null coalescing - only checks for null/undefined
count = @user.count ?? 0  # Preserves 0 as valid value

# Difference between || and ??
value1 = 0 || 10        # 10 (0 is falsy)
value2 = 0 ?? 10        # 0 (0 is not null)

value3 = "" || "default" # "default" (empty string is falsy)
value4 = "" ?? "default" # "" (empty string is not null)
```

## Chained Fallbacks

### Multiple Fallback Levels

```tusk
# Priority-based fallbacks
database_url = @env.DATABASE_URL ??          # 1. Environment variable
               @config.database.url ??        # 2. Config file
               @secrets.db_url ??             # 3. Secrets manager
               "postgresql://localhost/dev"   # 4. Development default

# With different sources
user_name = @request.body.name ??     # From request
            @request.query.name ??     # From query string
            @session.user.name ??      # From session
            "Anonymous"                # Default
```

### Conditional Fallbacks

```tusk
# Environment-specific fallbacks
api_endpoint = @if(@env.NODE_ENV == "production",
    @env.API_URL ?? "https://api.example.com",
    @env.DEV_API_URL ?? "http://localhost:3000"
)

# Complex fallback logic
cache_ttl = @if(@feature_flags.aggressive_cache,
    @config.cache.long_ttl ?? 3600,
    @config.cache.short_ttl ?? 300
)
```

## Safe Navigation with Fallbacks

### Optional Chaining with Defaults

```tusk
# Combine ?. and ?? for safe access with defaults
user_city = @user?.address?.city ?? "Unknown City"
first_item_name = @items?.[0]?.name ?? "No items"

# Deep navigation with fallbacks
setting_value = @config?.features?.advanced?.timeout ?? 5000

# Method calls with fallbacks
formatted_date = @date?.toLocaleDateString?.() ?? "Invalid Date"
```

### Nested Object Fallbacks

```tusk
# Fallback for entire objects
user_preferences = @user?.preferences ?? {
    theme: "light"
    language: "en"
    notifications: true
}

# Merge with defaults
user_settings = @merge({
    theme: "light"
    language: "en"
    notifications: true
}, @user?.preferences ?? {})
```

## Function Fallbacks

### Fallback Functions

```tusk
# Try primary function, fall back to secondary
get_user_data = @lambda(id, {
    # Try cache first
    cached = @cache.get("user_${id}")
    @if(cached, return: cached)
    
    # Try primary database
    user = @try({
        return: @primary_db.get_user(id)
    }, {
        # Fall back to replica
        return: @replica_db.get_user(id)
    })
    
    return: user ?? null
})
```

### Lazy Evaluation Fallbacks

```tusk
# Only compute fallback if needed
expensive_default = @lambda({ 
    @compute_expensive_default() 
})

# Only calls expensive_default if config value is null
value = @config.setting ?? @expensive_default()

# Pattern for expensive fallbacks
get_or_compute = @lambda(key, compute_fn, {
    cached = @cache.get(key)
    @if(cached != null, return: cached)
    
    computed = @compute_fn()
    @cache.set(key, computed)
    return: computed
})
```

## Type-Safe Fallbacks

### Type Coercion with Fallbacks

```tusk
# Ensure correct types
port = @number(@env.PORT) ?? 8080
debug = @boolean(@env.DEBUG) ?? false
max_items = @int(@env.MAX_ITEMS) ?? 100

# With validation
safe_port = @lambda({
    port = @number(@env.PORT)
    @if(port && port > 0 && port <= 65535,
        return: port,
        return: 8080
    )
})()
```

### Typed Fallback Patterns

```tusk
# Type-specific fallbacks
get_string_config = @lambda(key, default_value: string, {
    value = @config[key]
    return: @isString(value) ? value : default_value
})

get_number_config = @lambda(key, default_value: number, {
    value = @config[key]
    return: @isNumber(value) ? value : default_value
})

# Usage
app_name = @get_string_config("name", "DefaultApp")
port = @get_number_config("port", 8080)
```

## Array and Collection Fallbacks

### Empty Array Fallbacks

```tusk
# Fallback for empty or missing arrays
user_roles = @user?.roles ?? []
active_users = @users?.filter(@lambda(u, u.active)) ?? []

# First item with fallback
primary_server = @servers?.[0] ?? { host: "localhost", port: 8080 }

# Safe array operations
first_three = @items?.slice(0, 3) ?? []
```

### Collection Access Patterns

```tusk
# Safe collection access with defaults
get_from_map = @lambda(map, key, default_value, {
    return: @map?.[key] ?? default_value
})

# Multiple collection fallbacks
find_setting = @lambda(key, {
    return: @user_settings?.[key] ??
            @team_settings?.[key] ??
            @global_settings?.[key] ??
            @default_settings[key]
})
```

## Error Handling with Fallbacks

### Try-Catch Fallbacks

```tusk
# Fallback on errors
safe_parse_json = @lambda(text, fallback = {}, {
    return: @try({
        return: @json.parse(text)
    }, {
        @log.error("JSON parse failed: ${@error.message}")
        return: fallback
    })
})

# Multiple error fallbacks
fetch_data = @lambda(url, {
    return: @try({
        # Try primary URL
        return: @http.get(url)
    }, {
        # Try backup URL
        return: @try({
            return: @http.get(@backup_url)
        }, {
            # Return cached data
            return: @cache.get("last_known_data") ?? {
                error: "All sources failed"
            }
        })
    })
})
```

### Validation with Fallbacks

```tusk
# Validate and provide fallback
validate_email = @lambda(email, fallback = "noreply@example.com", {
    is_valid = @regex.test(email, "^[^@]+@[^@]+\.[^@]+$")
    return: is_valid ? email : fallback
})

# Sanitize with fallback
sanitize_username = @lambda(input, {
    sanitized = @regex.replace(input ?? "", "[^a-zA-Z0-9_]", "")
    return: @len(sanitized) > 0 ? sanitized : "user_${@random_id()}"
})
```

## Configuration Fallback Patterns

### Hierarchical Configuration

```tusk
# Configuration hierarchy with fallbacks
get_config = @lambda(key, {
    # Check in order of precedence
    return: @env[key] ??                    # 1. Environment
            @cli_args[key] ??               # 2. CLI arguments
            @config_file[key] ??            # 3. Config file
            @defaults[key] ??               # 4. Defaults
            null                            # 5. Explicit null
})

# Nested configuration fallbacks
get_nested_config = @lambda(path, default_value, {
    parts = @split(path, ".")
    value = @config
    
    @each(parts, @lambda(part, {
        value = value?.[part]
        @if(value == null, return: default_value)
    }))
    
    return: value ?? default_value
})
```

### Environment-Specific Fallbacks

```tusk
# Development vs Production fallbacks
config:
    api_url = @if(@env.NODE_ENV == "production",
        @env.API_URL ?? @error("API_URL required in production"),
        @env.API_URL ?? "http://localhost:3000"
    )
    
    cache_enabled = @if(@env.NODE_ENV == "production",
        true,  # Always in production
        @env.ENABLE_CACHE ?? false  # Optional in dev
    )
```

## Performance Considerations

### Eager vs Lazy Fallbacks

```tusk
# Eager evaluation (always computes both)
result = @expensive_operation() || @another_expensive_operation()

# Lazy evaluation (only computes if needed)
result = @cached_value ?? @lambda({
    value = @expensive_operation()
    @cache.set("key", value)
    return: value
})()

# Memoized fallbacks
create_memoized = @lambda(fn, {
    cache: null
    return: @lambda({
        @if(cache != null, return: cache)
        cache = @fn()
        return: cache
    })
})
```

### Fallback Chains Performance

```tusk
# Inefficient: Multiple deep property access
value = @obj?.deep?.nested?.value ?? 
        @obj?.deep?.nested?.default ??
        @obj?.deep?.default_value ??
        "fallback"

# Efficient: Cache intermediate values
deep = @obj?.deep
nested = @deep?.nested
value = @nested?.value ?? 
        @nested?.default ?? 
        @deep?.default_value ?? 
        "fallback"
```

## Best Practices

### 1. Order Fallbacks by Likelihood

```tusk
# Most likely to succeed first
user_pref = @user.preferences.theme ??      # User's choice
            @team.settings.theme ??          # Team default
            @organization.theme ??           # Org default
            "light"                          # System default
```

### 2. Use Appropriate Operators

```tusk
# Use ?? for values that might be falsy but valid
items_per_page = @config.pagination.items ?? 10  # 0 would be valid

# Use || for truly falsy checks
message = @error_message || "An error occurred"  # Empty string not valid
```

### 3. Document Fallback Behavior

```tusk
# API timeout configuration
# Priority: Environment > Config > Default (30s)
# Note: 0 means no timeout, not a fallback trigger
api_timeout = @env.API_TIMEOUT ?? @config.api.timeout ?? 30000
```

### 4. Fail Fast in Production

```tusk
# Development: Permissive fallbacks
dev_config:
    api_key = @env.API_KEY ?? "dev-key-12345"
    
# Production: Fail if critical values missing
prod_config:
    api_key = @env.API_KEY ?? @error("API_KEY environment variable required")
```

## Common Patterns

### Settings with Defaults

```tusk
# Application settings with structured defaults
app_settings = @merge({
    # Defaults
    theme: "light"
    language: "en"
    timezone: "UTC"
    features: {
        analytics: false
        notifications: true
    }
}, @user_settings ?? {})
```

### Resource Loading

```tusk
# Load resource with fallbacks
load_template = @lambda(name, {
    # Try user templates
    template = @file.read("./templates/user/${name}.tsk") ??
               # Try theme templates  
               @file.read("./templates/theme/${name}.tsk") ??
               # Try system templates
               @file.read("./templates/system/${name}.tsk") ??
               # Use inline default
               @default_templates[name] ??
               # Error
               @error("Template '${name}' not found")
               
    return: template
})
```

### API Response Handling

```tusk
# Graceful API response handling
handle_api_response = @lambda(response, {
    # Check response validity
    data = @response?.data ?? 
           @response?.body ?? 
           @response
    
    # Parse if needed
    parsed = @if(@isString(data),
        @json.parse(data) ?? {},
        data ?? {}
    )
    
    # Extract with fallbacks
    return: {
        items: @parsed.items ?? @parsed.results ?? []
        total: @parsed.total ?? @parsed.count ?? 0
        page: @parsed.page ?? 1
        success: @parsed.success ?? true
    }
})
```

## Next Steps

- Explore [Request Object](034-at-request-object.md) fallbacks
- Learn about [Error Operators](058-at-operator-errors.md)
- Master [Null Safety](017-null-values.md) patterns
---

[@ Request Object]


The @request object provides access to HTTP request data in TuskLang web applications. This guide covers how to use @request to handle incoming HTTP requests, access headers, parse bodies, and work with query parameters.

## Overview

The @request object is available in web server contexts and contains all information about the current HTTP request:

```tusk
# Basic request information
method = @request.method        # "GET", "POST", etc.
url = @request.url             # Full URL
path = @request.path           # URL path
ip = @request.ip               # Client IP address
```

## Request Properties

### Core Properties

```tusk
# Essential request properties
request_info:
    method: @request.method           # HTTP method
    url: @request.url                # Complete URL
    path: @request.path              # Path without query string
    protocol: @request.protocol      # "http" or "https"
    hostname: @request.hostname      # Host header value
    ip: @request.ip                  # Client IP address
    timestamp: @request.timestamp    # Request timestamp
```

### URL Components

```tusk
# For URL: https://api.example.com:8080/users/123?filter=active&page=2

url_parts:
    protocol: @request.protocol      # "https"
    hostname: @request.hostname      # "api.example.com"
    port: @request.port             # 8080
    path: @request.path             # "/users/123"
    pathname: @request.pathname      # Same as path
    search: @request.search         # "?filter=active&page=2"
    href: @request.href             # Full URL
```

## Request Headers

### Accessing Headers

```tusk
# Access specific headers
auth_token = @request.headers.authorization
content_type = @request.headers["content-type"]
user_agent = @request.headers.user_agent

# Common headers
headers:
    auth: @request.headers.authorization
    content_type: @request.headers["content-type"]
    accept: @request.headers.accept
    user_agent: @request.headers["user-agent"]
    referer: @request.headers.referer
    host: @request.headers.host
```

### Header Normalization

```tusk
# Headers are normalized to lowercase
# These all access the same header:
auth1 = @request.headers.authorization
auth2 = @request.headers.Authorization
auth3 = @request.headers.AUTHORIZATION
auth4 = @request.headers["authorization"]

# Custom headers
api_key = @request.headers["x-api-key"]
request_id = @request.headers["x-request-id"]
```

## Query Parameters

### Basic Query Access

```tusk
# URL: /search?q=tusklang&page=1&limit=10

# Access individual parameters
search_query = @request.query.q      # "tusklang"
page = @request.query.page          # "1" (string)
limit = @request.query.limit        # "10" (string)

# With type conversion
page_num = @int(@request.query.page ?? 1)
limit_num = @int(@request.query.limit ?? 10)
```

### Query Parameter Patterns

```tusk
# Handle missing parameters
search_params:
    query: @request.query.q ?? ""
    page: @int(@request.query.page ?? 1)
    limit: @int(@request.query.limit ?? 20)
    sort: @request.query.sort ?? "relevance"
    order: @request.query.order ?? "desc"

# Array parameters (?tags[]=js&tags[]=web)
tags = @request.query.tags ?? []

# Boolean parameters
include_deleted = @request.query.deleted == "true"
is_active = @request.query.active != "false"
```

## Request Body

### Accessing Body Data

```tusk
# Raw body
raw_body = @request.body

# Parsed JSON body (automatic for application/json)
json_data = @request.body  # Already parsed if JSON

# Form data (application/x-www-form-urlencoded)
form_data = @request.body

# Access specific fields
user_name = @request.body.name
user_email = @request.body.email
```

### Body Parsing Patterns

```tusk
# Safe body access
create_user = @lambda({
    # Validate content type
    @if(@request.headers["content-type"] != "application/json", {
        return: { error: "Content-Type must be application/json" }
    })
    
    # Safe field access
    name = @request.body?.name
    email = @request.body?.email
    
    # Validation
    @if(!name || !email, {
        return: { error: "Name and email required" }
    })
    
    # Process...
})
```

### Multipart/Form-Data

```tusk
# Handle file uploads
upload_handler = @lambda({
    # Check if multipart
    is_multipart = @includes(@request.headers["content-type"], "multipart/form-data")
    
    @if(is_multipart, {
        # Access files
        uploaded_file = @request.files.upload
        
        file_info: {
            filename: @uploaded_file.filename
            mimetype: @uploaded_file.mimetype
            size: @uploaded_file.size
            data: @uploaded_file.data
        }
        
        # Access form fields
        title = @request.body.title
        description = @request.body.description
    })
})
```

## HTTP Methods

### Method-Based Routing

```tusk
# Route based on HTTP method
handle_request = @lambda({
    @switch(@request.method, {
        "GET": @handle_get(),
        "POST": @handle_post(),
        "PUT": @handle_put(),
        "DELETE": @handle_delete(),
        "PATCH": @handle_patch(),
        default: {
            status: 405
            body: { error: "Method not allowed" }
        }
    })
})

# RESTful patterns
user_routes:
    # GET /users - List users
    GET: @lambda({
        users = @db.query("SELECT * FROM users")
        return: { users: users }
    })
    
    # POST /users - Create user
    POST: @lambda({
        user = @create_user(@request.body)
        return: { user: user }
    })
```

## Path Parameters

### Extract Path Parameters

```tusk
# Route: /users/:id/posts/:postId

# Manual extraction
extract_params = @lambda(pattern, path, {
    # Implementation to extract :id and :postId
})

# With routing library
route_params = @request.params  # { id: "123", postId: "456" }

# Access parameters
user_id = @request.params.id
post_id = @request.params.postId
```

### Dynamic Routing

```tusk
# Route patterns
routes:
    "/users/:id": @lambda({
        user_id = @request.params.id
        user = @db.find("users", user_id)
        return: { user: user }
    })
    
    "/users/:id/posts/:postId": @lambda({
        user_id = @request.params.id
        post_id = @request.params.postId
        post = @db.query(
            "SELECT * FROM posts WHERE user_id = ? AND id = ?",
            user_id, post_id
        )
        return: { post: post }
    })
```

## Request Context

### User and Session

```tusk
# Access authenticated user
current_user = @request.user
is_authenticated = @request.user != null

# Session data
session_id = @request.session.id
session_data = @request.session.data
user_preferences = @request.session.preferences

# Authentication check
require_auth = @lambda(handler, {
    return: @lambda({
        @if(!@request.user, {
            return: {
                status: 401
                body: { error: "Authentication required" }
            }
        })
        
        return: @handler()
    })
})
```

### Request Metadata

```tusk
# Additional request context
context:
    request_id: @request.id ?? @uuid()
    timestamp: @request.timestamp
    processing_time: @time.now() - @request.timestamp
    
    # Geo information (if available)
    geo: @request.geo ?? {
        country: "unknown"
        region: "unknown"
        city: "unknown"
    }
    
    # Device information
    is_mobile: @includes(@request.headers["user-agent"], "Mobile")
    is_bot: @regex.test(@request.headers["user-agent"], "bot|crawler|spider")
```

## Request Validation

### Input Validation

```tusk
# Comprehensive request validation
validate_request = @lambda(rules, {
    errors: []
    
    # Validate method
    @if(rules.method && @request.method != rules.method, {
        @push(errors, "Method must be ${rules.method}")
    })
    
    # Validate headers
    @each(rules.required_headers ?? [], @lambda(header, {
        @if(!@request.headers[header], {
            @push(errors, "Missing required header: ${header}")
        })
    }))
    
    # Validate body
    @each(rules.required_fields ?? [], @lambda(field, {
        @if(!@request.body?.[field], {
            @push(errors, "Missing required field: ${field}")
        })
    }))
    
    # Validate query params
    @each(rules.required_params ?? [], @lambda(param, {
        @if(!@request.query[param], {
            @push(errors, "Missing required parameter: ${param}")
        })
    }))
    
    return: {
        valid: @len(errors) == 0
        errors: errors
    }
})
```

### Schema Validation

```tusk
# Define request schema
user_create_schema:
    method: "POST"
    headers: {
        "content-type": "application/json"
    }
    body: {
        name: { type: "string", required: true, min: 2, max: 100 }
        email: { type: "string", required: true, pattern: "^[^@]+@[^@]+$" }
        age: { type: "number", required: false, min: 13, max: 120 }
    }

# Validate against schema
validate_create_user = @lambda({
    validation = @validate_request_schema(@request, @user_create_schema)
    
    @if(!validation.valid, {
        return: {
            status: 400
            body: { errors: validation.errors }
        }
    })
    
    # Process valid request...
})
```

## Security Considerations

### CORS Headers

```tusk
# Handle CORS
cors_middleware = @lambda(handler, {
    return: @lambda({
        # Set CORS headers
        headers: {
            "Access-Control-Allow-Origin": @env.CORS_ORIGIN ?? "*"
            "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS"
            "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
        
        # Handle preflight
        @if(@request.method == "OPTIONS", {
            return: { status: 204, headers: headers }
        })
        
        # Process request
        response = @handler()
        response.headers = @merge(response.headers ?? {}, headers)
        return: response
    })
})
```

### Rate Limiting

```tusk
# Simple rate limiting
rate_limit = @lambda(max_requests, window_seconds, {
    key: "${@request.ip}_${@request.path}"
    count = @cache.get(key) ?? 0
    
    @if(count >= max_requests, {
        return: {
            status: 429
            body: { error: "Too many requests" }
            headers: {
                "X-RateLimit-Limit": max_requests
                "X-RateLimit-Remaining": 0
                "Retry-After": window_seconds
            }
        }
    })
    
    @cache.set(key, count + 1, window_seconds)
    return: null  # Continue processing
})
```

## Common Patterns

### RESTful API Handler

```tusk
# Generic REST handler
create_rest_handler = @lambda(resource_name, {
    return: {
        # GET /resources
        list: @lambda({
            page = @int(@request.query.page ?? 1)
            limit = @int(@request.query.limit ?? 20)
            
            items = @db.query(
                "SELECT * FROM ${resource_name} LIMIT ? OFFSET ?",
                limit, (page - 1) * limit
            )
            
            return: { 
                [resource_name]: items,
                page: page,
                limit: limit
            }
        })
        
        # GET /resources/:id
        get: @lambda({
            id = @request.params.id
            item = @db.find(resource_name, id)
            
            @if(!item, {
                return: { status: 404, body: { error: "Not found" }}
            })
            
            return: { [resource_name]: item }
        })
        
        # POST /resources
        create: @lambda({
            data = @request.body
            item = @db.insert(resource_name, data)
            return: { status: 201, body: { [resource_name]: item }}
        })
    }
})
```

### Request Logging

```tusk
# Log all requests
request_logger = @lambda(handler, {
    return: @lambda({
        start_time = @time.now()
        
        # Log request
        @log.info({
            method: @request.method
            path: @request.path
            ip: @request.ip
            user_agent: @request.headers["user-agent"]
            timestamp: start_time
        })
        
        # Process request
        response = @handler()
        
        # Log response
        @log.info({
            method: @request.method
            path: @request.path
            status: response.status ?? 200
            duration: @time.now() - start_time
        })
        
        return: response
    })
})
```

## Best Practices

1. **Always validate input** - Never trust request data
2. **Use type conversion** - Convert query/body values to expected types
3. **Handle missing data** - Use fallbacks for optional parameters
4. **Set security headers** - CORS, CSP, etc.
5. **Log requests** - For debugging and monitoring
6. **Rate limit** - Protect against abuse
7. **Sanitize output** - Prevent XSS when rendering user input

## Next Steps

- Learn about [Request Methods](035-at-request-method.md)
- Explore [Query Parameters](036-at-request-query.md)
- Master [Request Body Handling](037-at-request-body.md)
---

[@ Request Method]


The @request.method property provides access to the HTTP method of the current request. This guide covers how to handle different HTTP methods and implement RESTful patterns in TuskLang.

## HTTP Methods Overview

### Accessing the Method

```tusk
# Get the HTTP method
method = @request.method  # "GET", "POST", "PUT", "DELETE", etc.

# Common usage patterns
is_get = @request.method == "GET"
is_post = @request.method == "POST"
is_write_method = @includes(["POST", "PUT", "PATCH"], @request.method)
```

### Standard HTTP Methods

```tusk
# Standard methods and their typical usage
methods:
    GET: "Retrieve resource(s)"
    POST: "Create new resource"
    PUT: "Update entire resource"
    PATCH: "Partial update"
    DELETE: "Remove resource"
    HEAD: "Get headers only"
    OPTIONS: "Get allowed methods"
    CONNECT: "Establish tunnel"
    TRACE: "Loop-back test"
```

## Method-Based Routing

### Simple Method Handling

```tusk
# Basic method routing
handle_request = @lambda({
    @if(@request.method == "GET", {
        return: @handle_get()
    })
    
    @if(@request.method == "POST", {
        return: @handle_post()
    })
    
    # Method not allowed
    return: {
        status: 405
        body: { error: "Method not allowed" }
        headers: { "Allow": "GET, POST" }
    }
})
```

### Switch-Based Routing

```tusk
# Clean method routing with switch
route_handler = @lambda({
    response = @switch(@request.method, {
        "GET": @get_handler(),
        "POST": @post_handler(),
        "PUT": @put_handler(),
        "PATCH": @patch_handler(),
        "DELETE": @delete_handler(),
        "OPTIONS": @options_handler(),
        default: {
            status: 405
            body: { error: "Method ${@request.method} not allowed" }
        }
    })
    
    return: response
})
```

### Method Map Pattern

```tusk
# Define handlers in a map
method_handlers: {
    GET: @lambda({ 
        # List or retrieve resources
        return: @get_resources() 
    }),
    POST: @lambda({ 
        # Create new resource
        return: @create_resource(@request.body) 
    }),
    PUT: @lambda({ 
        # Replace entire resource
        return: @replace_resource(@request.params.id, @request.body) 
    }),
    PATCH: @lambda({ 
        # Update specific fields
        return: @update_resource(@request.params.id, @request.body) 
    }),
    DELETE: @lambda({ 
        # Remove resource
        return: @delete_resource(@request.params.id) 
    })
}

# Route to appropriate handler
handle = @lambda({
    handler = @method_handlers[@request.method]
    
    @if(!handler, {
        return: {
            status: 405
            body: { error: "Method not allowed" }
            headers: { "Allow": @join(@keys(@method_handlers), ", ") }
        }
    })
    
    return: @handler()
})
```

## RESTful Resource Handling

### Complete REST Controller

```tusk
# RESTful user controller
user_controller:
    # GET /users - List all users
    # GET /users/:id - Get specific user
    GET: @lambda({
        @if(@request.params.id, {
            # Get single user
            user = @db.find("users", @request.params.id)
            
            @if(!user, {
                return: { 
                    status: 404, 
                    body: { error: "User not found" } 
                }
            })
            
            return: { body: { user: user } }
        }, {
            # List users with pagination
            page = @int(@request.query.page ?? 1)
            limit = @int(@request.query.limit ?? 20)
            offset = (page - 1) * limit
            
            users = @db.query(
                "SELECT * FROM users LIMIT ? OFFSET ?",
                limit, offset
            )
            
            total = @db.count("users")
            
            return: {
                body: {
                    users: users
                    pagination: {
                        page: page
                        limit: limit
                        total: total
                        pages: @ceil(total / limit)
                    }
                }
            }
        })
    })
    
    # POST /users - Create new user
    POST: @lambda({
        # Validate required fields
        required = ["name", "email", "password"]
        missing = @filter(required, @lambda(field, !@request.body[field]))
        
        @if(@len(missing) > 0, {
            return: {
                status: 400
                body: { 
                    error: "Missing required fields",
                    fields: missing
                }
            }
        })
        
        # Create user
        user_data = {
            name: @request.body.name
            email: @request.body.email
            password_hash: @hash(@request.body.password)
            created_at: @time.now()
        }
        
        user = @db.insert("users", user_data)
        
        return: {
            status: 201
            body: { user: user }
            headers: { "Location": "/users/${user.id}" }
        }
    })
    
    # PUT /users/:id - Replace user
    PUT: @lambda({
        id = @request.params.id
        
        # Check if exists
        existing = @db.find("users", id)
        @if(!existing, {
            return: { status: 404, body: { error: "User not found" } }
        })
        
        # Replace entire record
        user_data = {
            id: id
            name: @request.body.name
            email: @request.body.email
            password_hash: @hash(@request.body.password)
            created_at: existing.created_at
            updated_at: @time.now()
        }
        
        @db.update("users", id, user_data)
        
        return: { body: { user: user_data } }
    })
    
    # PATCH /users/:id - Partial update
    PATCH: @lambda({
        id = @request.params.id
        
        # Check if exists
        user = @db.find("users", id)
        @if(!user, {
            return: { status: 404, body: { error: "User not found" } }
        })
        
        # Update only provided fields
        updates = {}
        
        @if(@request.body.name != null, {
            updates.name = @request.body.name
        })
        
        @if(@request.body.email != null, {
            updates.email = @request.body.email
        })
        
        @if(@request.body.password != null, {
            updates.password_hash = @hash(@request.body.password)
        })
        
        updates.updated_at = @time.now()
        
        @db.update("users", id, updates)
        updated_user = @merge(user, updates)
        
        return: { body: { user: updated_user } }
    })
    
    # DELETE /users/:id - Delete user
    DELETE: @lambda({
        id = @request.params.id
        
        # Check if exists
        user = @db.find("users", id)
        @if(!user, {
            return: { status: 404, body: { error: "User not found" } }
        })
        
        # Delete user
        @db.delete("users", id)
        
        return: { 
            status: 204  # No content
        }
    })
```

## Method-Specific Behaviors

### Safe vs Unsafe Methods

```tusk
# Categorize methods
safe_methods: ["GET", "HEAD", "OPTIONS", "TRACE"]
unsafe_methods: ["POST", "PUT", "PATCH", "DELETE"]

# Check if method is safe (no side effects)
is_safe_method = @includes(@safe_methods, @request.method)

# Apply different logic
handle_with_safety = @lambda({
    @if(@is_safe_method, {
        # Can be cached, retried
        return: @cache_wrapper(@handle_request)
    }, {
        # Should not be cached, needs CSRF protection
        return: @csrf_protection(@handle_request)
    })
})
```

### Idempotent Methods

```tusk
# Idempotent methods (same result for multiple calls)
idempotent_methods: ["GET", "PUT", "DELETE", "HEAD", "OPTIONS"]

# Check idempotency
is_idempotent = @includes(@idempotent_methods, @request.method)

# Retry logic for idempotent methods only
retry_handler = @lambda(handler, {
    @if(@is_idempotent, {
        return: @retry_with_backoff(handler, 3)
    }, {
        # Don't retry non-idempotent methods
        return: @handler()
    })
})
```

## Method Validation

### Allowed Methods Per Route

```tusk
# Define allowed methods for routes
route_methods: {
    "/users": ["GET", "POST"],
    "/users/:id": ["GET", "PUT", "PATCH", "DELETE"],
    "/auth/login": ["POST"],
    "/auth/logout": ["POST"],
    "/public/*": ["GET", "HEAD"]
}

# Validate method for route
validate_method = @lambda(route, method, {
    allowed = @route_methods[route] ?? ["GET"]
    
    @if(!@includes(allowed, method), {
        return: {
            valid: false
            error: "Method ${method} not allowed for ${route}"
            allowed: allowed
        }
    })
    
    return: { valid: true }
})
```

### Method-Specific Validation

```tusk
# Different validation rules per method
method_validators: {
    POST: @lambda({
        # POST must have body
        @if(!@request.body || @isEmpty(@request.body), {
            return: { error: "Request body required for POST" }
        })
        
        # Check content-type
        @if(!@request.headers["content-type"], {
            return: { error: "Content-Type header required" }
        })
        
        return: { valid: true }
    }),
    
    GET: @lambda({
        # GET should not have body
        @if(@request.body, {
            return: { error: "GET requests should not have a body" }
        })
        
        return: { valid: true }
    }),
    
    DELETE: @lambda({
        # DELETE requires resource ID
        @if(!@request.params.id, {
            return: { error: "Resource ID required for DELETE" }
        })
        
        return: { valid: true }
    })
}

# Validate current request method
validate_request = @lambda({
    validator = @method_validators[@request.method]
    
    @if(validator, {
        return: @validator()
    })
    
    return: { valid: true }
})
```

## CORS and OPTIONS

### OPTIONS Method Handler

```tusk
# Handle preflight requests
options_handler = @lambda({
    # Get allowed methods for this route
    allowed_methods = @get_allowed_methods(@request.path)
    
    return: {
        status: 204  # No content
        headers: {
            "Allow": @join(allowed_methods, ", ")
            "Access-Control-Allow-Methods": @join(allowed_methods, ", ")
            "Access-Control-Allow-Headers": "Content-Type, Authorization"
            "Access-Control-Max-Age": "86400"  # 24 hours
        }
    }
})

# Auto-handle OPTIONS
cors_middleware = @lambda(handler, {
    # Handle OPTIONS automatically
    @if(@request.method == "OPTIONS", {
        return: @options_handler()
    })
    
    # Add CORS headers to response
    response = @handler()
    response.headers = @merge(response.headers ?? {}, {
        "Access-Control-Allow-Origin": "*"
    })
    
    return: response
})
```

## Method Override

### Supporting Method Override

```tusk
# Allow method override for clients that only support GET/POST
get_effective_method = @lambda({
    # Check override header
    override_header = @request.headers["x-http-method-override"]
    @if(override_header, {
        return: @upper(override_header)
    })
    
    # Check override parameter
    override_param = @request.query._method
    @if(override_param, {
        return: @upper(override_param)
    })
    
    # Use actual method
    return: @request.method
})

# Use overridden method
effective_method = @get_effective_method()
```

## Security Considerations

### CSRF Protection

```tusk
# CSRF protection for state-changing methods
csrf_protection = @lambda(handler, {
    # Skip for safe methods
    @if(@includes(["GET", "HEAD", "OPTIONS"], @request.method), {
        return: @handler()
    })
    
    # Check CSRF token
    token = @request.headers["x-csrf-token"] ?? @request.body.csrf_token
    
    @if(!@verify_csrf_token(token), {
        return: {
            status: 403
            body: { error: "Invalid CSRF token" }
        }
    })
    
    return: @handler()
})
```

### Method-Based Rate Limiting

```tusk
# Different rate limits per method
method_rate_limits: {
    GET: { requests: 1000, window: 3600 },     # 1000/hour
    POST: { requests: 100, window: 3600 },      # 100/hour
    PUT: { requests: 100, window: 3600 },       # 100/hour
    DELETE: { requests: 50, window: 3600 }      # 50/hour
}

# Apply method-specific rate limit
apply_rate_limit = @lambda({
    limit = @method_rate_limits[@request.method] ?? { 
        requests: 100, 
        window: 3600 
    }
    
    key = "${@request.ip}_${@request.method}"
    current = @cache.increment(key)
    
    @if(current > limit.requests, {
        return: {
            status: 429
            body: { error: "Rate limit exceeded" }
            headers: {
                "X-RateLimit-Limit": limit.requests
                "X-RateLimit-Window": limit.window
                "Retry-After": limit.window
            }
        }
    })
    
    @cache.expire(key, limit.window)
})
```

## Best Practices

1. **Use appropriate methods** - GET for retrieval, POST for creation, etc.
2. **Validate method early** - Check if method is allowed before processing
3. **Return 405 properly** - Include Allow header with permitted methods
4. **Handle OPTIONS** - Support CORS preflight requests
5. **Be idempotent** - PUT and DELETE should be idempotent
6. **Protect unsafe methods** - Add CSRF protection to POST, PUT, DELETE
7. **Document allowed methods** - Make it clear which methods each endpoint supports

## Common Patterns

### Method Middleware Stack

```tusk
# Build middleware stack based on method
create_middleware_stack = @lambda({
    stack: [@logging_middleware]
    
    # Add method-specific middleware
    @if(@includes(["POST", "PUT", "PATCH", "DELETE"], @request.method), {
        @push(stack, @auth_middleware)
        @push(stack, @csrf_middleware)
        @push(stack, @validation_middleware)
    })
    
    @if(@request.method == "GET", {
        @push(stack, @cache_middleware)
    })
    
    return: stack
})
```

### RESTful Collection Pattern

```tusk
# Generic collection handler
create_collection_handler = @lambda(resource_name, {
    handlers: {
        # GET /resources
        "GET:collection": @lambda({
            items = @db.all(resource_name)
            return: { [resource_name]: items }
        }),
        
        # POST /resources  
        "POST:collection": @lambda({
            item = @db.create(resource_name, @request.body)
            return: { 
                status: 201,
                body: { [resource_name]: item }
            }
        }),
        
        # GET /resources/:id
        "GET:item": @lambda({
            item = @db.find(resource_name, @request.params.id)
            return: item ? { [resource_name]: item } : { status: 404 }
        }),
        
        # PUT /resources/:id
        "PUT:item": @lambda({
            @db.replace(resource_name, @request.params.id, @request.body)
            return: { [resource_name]: @request.body }
        }),
        
        # DELETE /resources/:id
        "DELETE:item": @lambda({
            @db.delete(resource_name, @request.params.id)
            return: { status: 204 }
        })
    }
    
    return: @lambda({
        type = @request.params.id ? "item" : "collection"
        key = "${@request.method}:${type}"
        handler = handlers[key]
        
        return: handler ? @handler() : { status: 405 }
    })
})
```

## Next Steps

- Explore [Query Parameters](036-at-request-query.md)
- Learn about [Request Body](037-at-request-body.md)
- Master [Request Headers](038-at-request-headers.md)
---

[@ Request Query]


The @request.query object provides access to URL query parameters in TuskLang web applications. This guide covers parsing, validating, and working with query strings.

## Basic Query Access

### Simple Parameters

```tusk
# URL: /search?q=tusklang&page=2&limit=10

# Access query parameters
search_term = @request.query.q       # "tusklang"
page = @request.query.page          # "2" (string)
limit = @request.query.limit        # "10" (string)

# All parameters as object
all_params = @request.query         # { q: "tusklang", page: "2", limit: "10" }
```

### Type Conversion

```tusk
# Query parameters are always strings, convert as needed
page_number = @int(@request.query.page ?? "1")
items_limit = @int(@request.query.limit ?? "20")
include_draft = @request.query.draft == "true"

# Safe conversion with validation
safe_int = @lambda(value, default_value, {
    num = @int(value)
    return: @isNaN(num) ? default_value : num
})

page = @safe_int(@request.query.page, 1)
```

## Query Parameter Patterns

### Optional Parameters with Defaults

```tusk
# Handle missing parameters gracefully
search_params:
    query: @request.query.q ?? ""
    page: @int(@request.query.page ?? "1")
    limit: @int(@request.query.limit ?? "20")
    sort: @request.query.sort ?? "relevance"
    order: @request.query.order ?? "desc"
    filters: @request.query.filters ?? "all"

# Validate ranges
validated_params:
    page: @max(1, @int(@request.query.page ?? "1"))
    limit: @clamp(@int(@request.query.limit ?? "20"), 1, 100)
```

### Boolean Parameters

```tusk
# Different boolean conventions
parse_boolean = @lambda(value, default_value = false, {
    @if(value == null, return: default_value)
    
    # Common truthy values
    truthy: ["true", "1", "yes", "on", "y", "t"]
    return: @includes(@lower(value), truthy)
})

# Usage
include_archived = @parse_boolean(@request.query.archived)
show_details = @parse_boolean(@request.query.details, true)
debug_mode = @parse_boolean(@request.query.debug)
```

## Array Parameters

### Multiple Values

```tusk
# URL: /filter?tags=javascript&tags=web&tags=frontend
# Or: /filter?tags[]=javascript&tags[]=web&tags[]=frontend

# Access array parameters
tags = @request.query.tags  # ["javascript", "web", "frontend"]

# Handle both single and multiple values
ensure_array = @lambda(value, {
    @if(value == null, return: [])
    @if(@isArray(value), return: value)
    return: [value]
})

selected_tags = @ensure_array(@request.query.tags)
```

### Comma-Separated Values

```tusk
# URL: /filter?ids=1,2,3,4,5

# Parse comma-separated values
ids_string = @request.query.ids ?? ""
ids = @map(@split(ids_string, ","), @lambda(id, @int(@trim(id))))

# More robust parsing
parse_csv = @lambda(value, separator = ",", {
    @if(!value, return: [])
    
    items = @split(value, separator)
    return: @map(items, @lambda(item, @trim(item)))
        .filter(@lambda(item, item != ""))
})

categories = @parse_csv(@request.query.categories)
```

## Complex Query Structures

### Nested Parameters

```tusk
# URL: /search?filter[category]=books&filter[price][min]=10&filter[price][max]=50

# Parse nested structures
parse_nested_query = @lambda(query, {
    result: {}
    
    @each(@keys(query), @lambda(key, {
        # Check for bracket notation
        matches = @regex.match(key, "^([^\\[]+)(\\[.+\\])$")
        
        @if(matches, {
            # Parse nested key
            base_key = matches[1]
            nested_path = matches[2]
            # Implementation for nested parsing...
        }, {
            # Simple key
            result[key] = query[key]
        })
    }))
    
    return: result
})

# Common pattern: object-like parameters
filters:
    category: @request.query["filter[category]"]
    min_price: @int(@request.query["filter[price][min]"] ?? "0")
    max_price: @int(@request.query["filter[price][max]"] ?? "999999")
```

### JSON in Query

```tusk
# URL: /api?data={"name":"John","age":30}

# Parse JSON from query parameter
parse_json_param = @lambda(param_name, default_value = {}, {
    json_string = @request.query[param_name]
    @if(!json_string, return: default_value)
    
    return: @try({
        return: @json.parse(@url.decode(json_string))
    }, {
        @log.warn("Invalid JSON in query parameter: ${param_name}")
        return: default_value
    })
})

# Usage
data = @parse_json_param("data")
config = @parse_json_param("config", { theme: "default" })
```

## Query String Parsing

### Manual Query Parsing

```tusk
# Parse query string manually
parse_query_string = @lambda(query_string, {
    @if(!query_string, return: {})
    
    # Remove leading ?
    clean_query = @regex.replace(query_string, "^\\?", "")
    
    # Split into key-value pairs
    pairs = @split(clean_query, "&")
    result: {}
    
    @each(pairs, @lambda(pair, {
        [key, value] = @split(pair, "=")
        
        # Decode key and value
        decoded_key = @url.decode(key)
        decoded_value = @url.decode(value ?? "")
        
        # Handle array notation
        @if(@regex.test(decoded_key, "\\[\\]$"), {
            array_key = @regex.replace(decoded_key, "\\[\\]$", "")
            result[array_key] = result[array_key] ?? []
            @push(result[array_key], decoded_value)
        }, {
            result[decoded_key] = decoded_value
        })
    }))
    
    return: result
})
```

### Query String Building

```tusk
# Build query string from object
build_query_string = @lambda(params, {
    pairs: []
    
    @each(@keys(params), @lambda(key, {
        value = params[key]
        
        @if(@isArray(value), {
            # Handle arrays
            @each(value, @lambda(item, {
                @push(pairs, "${@url.encode(key)}[]=${@url.encode(item)}")
            }))
        }, {
            # Handle single values
            @if(value != null && value != "", {
                @push(pairs, "${@url.encode(key)}=${@url.encode(@string(value))}")
            })
        })
    }))
    
    return: @join(pairs, "&")
})

# Usage
query = @build_query_string({
    q: "search term"
    page: 2
    tags: ["javascript", "web"]
})
# Result: "q=search%20term&page=2&tags[]=javascript&tags[]=web"
```

## Validation and Sanitization

### Query Parameter Validation

```tusk
# Define validation schema
query_schema: {
    q: { type: "string", required: false, max_length: 100 },
    page: { type: "integer", required: false, min: 1 },
    limit: { type: "integer", required: false, min: 1, max: 100 },
    sort: { type: "enum", values: ["relevance", "date", "title"] },
    order: { type: "enum", values: ["asc", "desc"] }
}

# Validate query parameters
validate_query = @lambda(schema, {
    errors: []
    validated: {}
    
    @each(@keys(schema), @lambda(param, {
        rule = schema[param]
        value = @request.query[param]
        
        # Check required
        @if(rule.required && !value, {
            @push(errors, "${param} is required")
            return
        })
        
        # Skip if not provided and not required
        @if(!value && !rule.required, return)
        
        # Type validation
        @switch(rule.type, {
            "string": {
                @if(rule.max_length && @len(value) > rule.max_length, {
                    @push(errors, "${param} exceeds maximum length")
                })
                validated[param] = value
            },
            "integer": {
                num = @int(value)
                @if(@isNaN(num), {
                    @push(errors, "${param} must be a number")
                    return
                })
                @if(rule.min != null && num < rule.min, {
                    @push(errors, "${param} must be at least ${rule.min}")
                })
                @if(rule.max != null && num > rule.max, {
                    @push(errors, "${param} must be at most ${rule.max}")
                })
                validated[param] = num
            },
            "enum": {
                @if(!@includes(rule.values, value), {
                    @push(errors, "${param} must be one of: ${@join(rule.values, ', ')}")
                })
                validated[param] = value
            }
        })
    }))
    
    return: {
        valid: @len(errors) == 0
        errors: errors
        data: validated
    }
})
```

### Sanitization

```tusk
# Sanitize query parameters
sanitize_query = @lambda({
    sanitized: {}
    
    # Define sanitization rules
    @each(@keys(@request.query), @lambda(key, {
        value = @request.query[key]
        
        # Skip potentially dangerous keys
        @if(@regex.test(key, "^__"), return)
        
        # Sanitize key
        safe_key = @regex.replace(key, "[^a-zA-Z0-9_\\[\\]]", "")
        
        # Sanitize value based on expected type
        @if(@isArray(value), {
            sanitized[safe_key] = @map(value, @lambda(v, {
                # Remove HTML/script tags
                @regex.replace(v, "<[^>]*>", "")
            }))
        }, {
            # Single value sanitization
            sanitized[safe_key] = @regex.replace(value, "<[^>]*>", "")
        })
    }))
    
    return: sanitized
})
```

## Pagination with Query Parameters

### Standard Pagination

```tusk
# Extract pagination parameters
parse_pagination = @lambda(defaults = {}, {
    page = @max(1, @int(@request.query.page ?? defaults.page ?? 1))
    limit = @clamp(
        @int(@request.query.limit ?? defaults.limit ?? 20),
        1,
        100  # Maximum items per page
    )
    
    offset = (page - 1) * limit
    
    return: {
        page: page
        limit: limit
        offset: offset
    }
})

# Usage in query
pagination = @parse_pagination({ limit: 25 })
results = @db.query(
    "SELECT * FROM items LIMIT ? OFFSET ?",
    pagination.limit,
    pagination.offset
)
```

### Cursor-Based Pagination

```tusk
# Parse cursor pagination
parse_cursor_pagination = @lambda({
    cursor = @request.query.cursor
    limit = @clamp(@int(@request.query.limit ?? "20"), 1, 100)
    
    # Decode cursor (base64 encoded timestamp or ID)
    decoded_cursor = @if(cursor, {
        @try({
            return: @base64.decode(cursor)
        }, {
            return: null
        })
    }, null)
    
    return: {
        cursor: decoded_cursor
        limit: limit
        direction: @request.query.direction ?? "next"
    }
})

# Generate next/previous cursors
generate_cursor = @lambda(last_item, {
    @if(!last_item, return: null)
    
    # Encode relevant data for cursor
    cursor_data = {
        id: last_item.id
        timestamp: last_item.created_at
    }
    
    return: @base64.encode(@json.stringify(cursor_data))
})
```

## Search and Filtering

### Advanced Search Parameters

```tusk
# Parse complex search parameters
parse_search_params = @lambda({
    # Basic search
    query = @request.query.q ?? ""
    
    # Parse search operators
    filters: {}
    
    # Price range
    @if(@request.query.price_min || @request.query.price_max, {
        filters.price = {
            min: @float(@request.query.price_min ?? "0")
            max: @float(@request.query.price_max ?? "999999")
        }
    })
    
    # Date range
    @if(@request.query.date_from || @request.query.date_to, {
        filters.date = {
            from: @request.query.date_from
            to: @request.query.date_to
        }
    })
    
    # Categories (multiple)
    @if(@request.query.category, {
        filters.categories = @ensure_array(@request.query.category)
    })
    
    # Boolean filters
    filters.in_stock = @parse_boolean(@request.query.in_stock)
    filters.on_sale = @parse_boolean(@request.query.on_sale)
    
    # Sorting
    sort = {
        field: @request.query.sort ?? "relevance"
        order: @request.query.order ?? "desc"
    }
    
    return: {
        query: query
        filters: filters
        sort: sort
        facets: @parse_csv(@request.query.facets)
    }
})
```

### Building Search Queries

```tusk
# Convert search params to database query
build_search_query = @lambda(params, {
    conditions: []
    values: []
    
    # Text search
    @if(params.query, {
        @push(conditions, "(title LIKE ? OR description LIKE ?)")
        search_term = "%${params.query}%"
        @push(values, search_term)
        @push(values, search_term)
    })
    
    # Price filter
    @if(params.filters.price, {
        @push(conditions, "price BETWEEN ? AND ?")
        @push(values, params.filters.price.min)
        @push(values, params.filters.price.max)
    })
    
    # Category filter
    @if(params.filters.categories && @len(params.filters.categories) > 0, {
        placeholders = @join(@repeat("?", @len(params.filters.categories)), ",")
        @push(conditions, "category IN (${placeholders})")
        values = @concat(values, params.filters.categories)
    })
    
    # Build final query
    where_clause = @if(@len(conditions) > 0,
        "WHERE ${@join(conditions, ' AND ')}",
        ""
    )
    
    order_clause = "ORDER BY ${params.sort.field} ${params.sort.order}"
    
    return: {
        sql: "SELECT * FROM products ${where_clause} ${order_clause}"
        params: values
    }
})
```

## URL State Management

### Preserving Query Parameters

```tusk
# Merge new parameters with existing
update_query_params = @lambda(updates, {
    # Start with current parameters
    current = { ...@request.query }
    
    # Apply updates
    @each(@keys(updates), @lambda(key, {
        value = updates[key]
        
        @if(value == null || value == "", {
            # Remove parameter
            delete current[key]
        }, {
            # Update parameter
            current[key] = value
        })
    }))
    
    return: current
})

# Generate URL with updated params
generate_url = @lambda(path, params, {
    query_string = @build_query_string(params)
    return: @if(query_string, "${path}?${query_string}", path)
})

# Usage: pagination links
next_page_url = @generate_url(@request.path, @update_query_params({
    page: @string(current_page + 1)
}))
```

## Security Considerations

### Query Parameter Injection

```tusk
# Prevent SQL injection from query params
safe_search = @lambda({
    # Never directly interpolate query params into SQL
    # BAD:
    # query = "SELECT * FROM users WHERE name = '${@request.query.name}'"
    
    # GOOD: Use parameterized queries
    name = @request.query.name
    results = @db.query(
        "SELECT * FROM users WHERE name = ?",
        name
    )
    
    return: results
})
```

### XSS Prevention

```tusk
# Escape query parameters for display
escape_for_html = @lambda(value, {
    @if(@isArray(value), {
        return: @map(value, @escape_for_html)
    })
    
    return: @html.escape(@string(value))
})

# Safe display of search term
safe_display = @lambda({
    search_term = @escape_for_html(@request.query.q ?? "")
    return: "<h1>Search results for: ${search_term}</h1>"
})
```

## Best Practices

1. **Always validate and sanitize** query parameters
2. **Convert types explicitly** - Query params are strings
3. **Use defaults** for missing parameters
4. **Limit array sizes** to prevent abuse
5. **Escape for display** to prevent XSS
6. **Use parameterized queries** to prevent SQL injection
7. **Document expected parameters** in API documentation
8. **Consider URL length limits** (around 2000 characters)

## Common Patterns

### Filter Builder

```tusk
# Generic filter builder from query params
build_filters = @lambda(allowed_fields, {
    filters: {}
    
    @each(allowed_fields, @lambda(field, {
        value = @request.query[field]
        @if(value != null && value != "", {
            filters[field] = value
        })
    }))
    
    return: filters
})

# Usage
product_filters = @build_filters([
    "category", 
    "brand", 
    "color", 
    "size"
])
```

### API Response with Query Echo

```tusk
# Include query parameters in response for transparency
api_response = @lambda(data, {
    return: {
        data: data
        query: @request.query
        pagination: {
            page: @int(@request.query.page ?? "1")
            limit: @int(@request.query.limit ?? "20")
            total: data.total_count
        }
        links: {
            self: @request.url
            next: @generate_next_page_url()
            prev: @generate_prev_page_url()
        }
    }
})
```

## Next Steps

- Learn about [Request Body](037-at-request-body.md)
- Explore [Request Headers](038-at-request-headers.md)
- Master [Request IP Address](039-at-request-ip.md)
---

[@request.post - Accessing POST Data]


The `@request.post` operator provides access to POST data sent in HTTP requests, enabling form processing and API data handling.

## Basic Syntax

```tusk
# Access specific POST field
username: @request.post.username

# Access nested POST data
address: @request.post.user.address.street

# With fallback value
email: @request.post.email|"no-email@example.com"
```

## Form Processing

```tusk
# Process a contact form
contact_form: {
    name: @request.post.name
    email: @request.post.email
    message: @request.post.message
    timestamp: @timestamp
}

# Validate required fields
is_valid: @request.post.name && @request.post.email && @request.post.message

# Save if valid
@if(@is_valid) {
    @query("INSERT INTO contacts", @contact_form)
    response: "Thank you for your message!"
} else {
    response: "Please fill all required fields"
}
```

## JSON POST Data

```tusk
# Handle JSON API requests
api_data: @request.post

# Process webhook data
webhook: {
    event: @request.post.event
    payload: @request.post.data
    signature: @request.headers.x-webhook-signature
}

# Validate webhook
is_valid_webhook: @validate_signature(@webhook.signature, @webhook.payload)
```

## File Uploads

```tusk
# Access uploaded file information
uploaded_file: @request.files.upload

# File properties
file_info: {
    name: @uploaded_file.name
    size: @uploaded_file.size
    type: @uploaded_file.type
    tmp_name: @uploaded_file.tmp_name
}

# Process upload
@if(@file_info.type == "image/jpeg" || @file_info.type == "image/png") {
    @move_uploaded_file(@file_info.tmp_name, "/uploads/" + @file_info.name)
    result: "File uploaded successfully"
} else {
    result: "Invalid file type"
}
```

## Array Handling

```tusk
# Handle array inputs (e.g., checkboxes)
selected_items: @request.post.items[]

# Process each item
@foreach(@selected_items as @item) {
    # Process individual item
    @process_item(@item)
}

# Count selections
selection_count: @count(@selected_items)
```

## Security Considerations

```tusk
# Sanitize input
clean_input: @sanitize(@request.post.user_input)

# Validate data types
age: @int(@request.post.age|0)
price: @float(@request.post.price|0.00)

# Escape for database
safe_query: @escape(@request.post.search_term)

# Check content length
@if(@strlen(@request.post.content) > 10000) {
    error: "Content too long"
}
```

## Common Patterns

```tusk
# Login form processing
#api /login {
    username: @request.post.username
    password: @request.post.password
    
    # Validate credentials
    user: @query("SELECT * FROM users WHERE username = ?", [@username])
    
    @if(@verify_password(@password, @user.password_hash)) {
        @session.user_id: @user.id
        @redirect("/dashboard")
    } else {
        error: "Invalid credentials"
    }
}

# CRUD operations
#api /users/create {
    # Collect all POST data
    user_data: {
        name: @request.post.name
        email: @request.post.email
        role: @request.post.role|"user"
        created_at: @timestamp
    }
    
    # Insert into database
    new_user_id: @query("INSERT INTO users", @user_data)
    
    # Return response
    @json({
        success: true
        user_id: @new_user_id
        message: "User created successfully"
    })
}
```

## Best Practices

1. **Always validate POST data** - Never trust user input
2. **Use fallback values** - Provide defaults for optional fields
3. **Sanitize inputs** - Clean data before processing
4. **Check data types** - Ensure numeric fields contain numbers
5. **Limit input size** - Prevent memory exhaustion attacks

## Related Operators

- `@request` - Parent request object
- `@request.method` - Check if POST request
- `@request.files` - Handle file uploads
- `@sanitize()` - Clean user input
- `@validate()` - Validate data formats
---

[@request.headers - HTTP Headers Access]


The `@request.headers` operator provides access to HTTP request headers, enabling authentication, content negotiation, and custom header processing.

## Basic Syntax

```tusk
# Access specific header
user_agent: @request.headers.user-agent

# Case-insensitive access
auth_header: @request.headers.authorization

# With fallback
accept_lang: @request.headers.accept-language|"en-US"
```

## Common Headers

```tusk
# Browser information
browser_info: {
    user_agent: @request.headers.user-agent
    accept: @request.headers.accept
    accept_language: @request.headers.accept-language
    accept_encoding: @request.headers.accept-encoding
}

# Request metadata
request_meta: {
    host: @request.headers.host
    referer: @request.headers.referer
    origin: @request.headers.origin
    content_type: @request.headers.content-type
    content_length: @request.headers.content-length
}
```

## Authentication Headers

```tusk
# Bearer token authentication
auth_header: @request.headers.authorization

@if(@auth_header && @starts_with(@auth_header, "Bearer ")) {
    token: @substr(@auth_header, 7)
    user: @verify_jwt_token(@token)
    
    @if(@user) {
        # Authenticated request
        @request.user: @user
    } else {
        @response.status: 401
        error: "Invalid token"
    }
} else {
    @response.status: 401
    error: "Authorization required"
}
```

## API Key Authentication

```tusk
# Check API key in header
api_key: @request.headers.x-api-key

# Validate API key
valid_key: @query("SELECT * FROM api_keys WHERE key = ? AND active = 1", [@api_key])

@if(!@valid_key) {
    @response.status: 403
    error: "Invalid API key"
}

# Track API usage
@query("UPDATE api_keys SET last_used = NOW(), calls = calls + 1 WHERE key = ?", [@api_key])
```

## Custom Headers

```tusk
# Application-specific headers
app_headers: {
    version: @request.headers.x-app-version
    platform: @request.headers.x-platform
    device_id: @request.headers.x-device-id
}

# Webhook signatures
webhook_signature: @request.headers.x-webhook-signature
webhook_timestamp: @request.headers.x-webhook-timestamp

# Validate webhook
expected_signature: @hmac_sha256(@webhook_secret, @request.body + @webhook_timestamp)
is_valid: @webhook_signature == @expected_signature
```

## Content Negotiation

```tusk
# Determine response format
accept_header: @request.headers.accept

@if(@contains(@accept_header, "application/json")) {
    response_format: "json"
} elseif(@contains(@accept_header, "text/html")) {
    response_format: "html"
} else {
    response_format: "text"
}

# Language preference
languages: @explode(",", @request.headers.accept-language)
preferred_language: @trim(@languages[0])
```

## CORS Headers

```tusk
# Handle CORS preflight
@if(@request.method == "OPTIONS") {
    @response.headers.access-control-allow-origin: @request.headers.origin|"*"
    @response.headers.access-control-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    @response.headers.access-control-allow-headers: "Content-Type, Authorization"
    @response.headers.access-control-max-age: 86400
    @response.status: 204
}

# Regular CORS headers
@response.headers.access-control-allow-origin: @request.headers.origin|"*"
```

## Security Headers

```tusk
# Check security headers
security_check: {
    has_csrf: @request.headers.x-csrf-token
    has_nonce: @request.headers.x-nonce
    is_secure: @request.headers.x-forwarded-proto == "https"
}

# Validate CSRF token
@if(@request.method == "POST" && !@security_check.has_csrf) {
    @response.status: 403
    error: "CSRF token required"
}

# Check if behind proxy
real_ip: @request.headers.x-forwarded-for|@request.headers.x-real-ip|@request.ip
```

## Rate Limiting

```tusk
# Identify client for rate limiting
client_id: @request.headers.x-api-key|@request.ip

# Check rate limit
rate_limit: @cache.get("rate_limit:" + @client_id)|0

@if(@rate_limit >= 100) {
    @response.status: 429
    @response.headers.x-ratelimit-limit: 100
    @response.headers.x-ratelimit-remaining: 0
    @response.headers.retry-after: 3600
    error: "Rate limit exceeded"
}

# Increment counter
@cache.increment("rate_limit:" + @client_id, 1, 3600)
```

## Debugging Headers

```tusk
# Log all headers for debugging
@if(@debug_mode) {
    all_headers: @request.headers
    @log("Request Headers", @all_headers)
    
    # Add debug response headers
    @response.headers.x-debug-request-id: @generate_uuid()
    @response.headers.x-debug-timestamp: @timestamp
}
```

## Common Patterns

```tusk
# Mobile app API endpoint
#api /app/data {
    # Require app headers
    @if(!@request.headers.x-app-version || !@request.headers.x-platform) {
        @response.status: 400
        error: "Missing required app headers"
    }
    
    # Version compatibility check
    min_version: "2.0.0"
    @if(@version_compare(@request.headers.x-app-version, @min_version) < 0) {
        @response.status: 426
        error: "App version too old, please update"
    }
    
    # Platform-specific response
    @if(@request.headers.x-platform == "ios") {
        data: @get_ios_specific_data()
    } else {
        data: @get_android_specific_data()
    }
}
```

## Best Practices

1. **Header names are case-insensitive** - TuskLang normalizes them
2. **Always provide fallbacks** - Headers might be missing
3. **Validate authentication headers** - Don't trust client claims
4. **Check content types** - Ensure you can process the request
5. **Use custom headers wisely** - Prefix with X- or your app name

## Related Operators

- `@request` - Parent request object
- `@response.headers` - Set response headers
- `@request.ip` - Client IP address
- `@request.method` - HTTP method
- `@contains()` - Check header values
---

[@session - Session Variables]


The `@session` operator provides server-side session storage for maintaining state across HTTP requests, perfect for user authentication and shopping carts.

## Basic Syntax

```tusk
# Set session variable
@session.username: "john_doe"

# Read session variable
current_user: @session.username

# Delete session variable
@session.cart: null

# Check if exists
has_user: @isset(@session.user_id)
```

## Session Lifecycle

```tusk
# Start session (automatic in web context)
@session_start()

# Get session ID
session_id: @session_id()

# Regenerate session ID (security)
@session_regenerate_id()

# Destroy session
@session_destroy()
```

## User Authentication

```tusk
# Login endpoint
#api /login {
    username: @request.post.username
    password: @request.post.password
    
    # Verify credentials
    user: @query("SELECT * FROM users WHERE username = ?", [@username])
    
    @if(@verify_password(@password, @user.password_hash)) {
        # Set session variables
        @session.user_id: @user.id
        @session.username: @user.username
        @session.role: @user.role
        @session.login_time: @timestamp
        
        # Regenerate session ID for security
        @session_regenerate_id()
        
        @json({
            success: true
            message: "Login successful"
        })
    } else {
        @json({
            success: false
            error: "Invalid credentials"
        })
    }
}

# Logout endpoint
#api /logout {
    # Clear session
    @session_destroy()
    
    @json({
        success: true
        message: "Logged out successfully"
    })
}
```

## Shopping Cart

```tusk
# Initialize cart if not exists
@if(!@isset(@session.cart)) {
    @session.cart: []
}

# Add to cart
#api /cart/add {
    product_id: @request.post.product_id
    quantity: @request.post.quantity|1
    
    # Get current cart
    cart: @session.cart
    
    # Check if product already in cart
    existing_index: @array_search(@cart, "product_id", @product_id)
    
    @if(@existing_index !== false) {
        # Update quantity
        cart[@existing_index].quantity: @cart[@existing_index].quantity + @quantity
    } else {
        # Add new item
        product: @query("SELECT * FROM products WHERE id = ?", [@product_id])
        cart[]: {
            product_id: @product_id
            name: @product.name
            price: @product.price
            quantity: @quantity
        }
    }
    
    # Save cart
    @session.cart: @cart
    
    @json({
        success: true
        cart_count: @count(@cart)
        cart_total: @array_sum(@cart, "price * quantity")
    })
}
```

## Session Security

```tusk
# Session timeout check
last_activity: @session.last_activity|0
timeout_minutes: 30

@if(@time() - @last_activity > @timeout_minutes * 60) {
    # Session expired
    @session_destroy()
    @redirect("/login?expired=1")
}

# Update last activity
@session.last_activity: @time()

# IP validation
@if(@session.ip && @session.ip != @request.ip) {
    # Possible session hijacking
    @session_destroy()
    @log_security_event("Session IP mismatch", {
        session_ip: @session.ip
        request_ip: @request.ip
    })
    @redirect("/login?security=1")
}
```

## Flash Messages

```tusk
# Set flash message
@session.flash: {
    type: "success"
    message: "Profile updated successfully"
}

# Display flash message
@if(@session.flash) {
    flash: @session.flash
    # Clear after displaying
    @session.flash: null
    
    # In template
    <div class="alert alert-{@flash.type}">
        {@flash.message}
    </div>
}
```

## Multi-step Forms

```tusk
# Wizard step tracking
#api /wizard/step/{step} {
    current_step: @step
    
    # Store form data
    @session.wizard[@current_step]: @request.post
    
    # Validate current step
    is_valid: @validate_step(@current_step, @request.post)
    
    @if(@is_valid) {
        @if(@current_step < 3) {
            # Go to next step
            @redirect("/wizard/step/" + (@current_step + 1))
        } else {
            # Process complete form
            all_data: @session.wizard
            result: @process_wizard(@all_data)
            
            # Clear wizard data
            @session.wizard: null
            
            @redirect("/wizard/complete")
        }
    } else {
        # Show errors
        @session.flash: {
            type: "error"
            message: "Please correct the errors"
        }
        @redirect("/wizard/step/" + @current_step)
    }
}
```

## Preferences Storage

```tusk
# User preferences
@session.preferences: {
    theme: @request.post.theme|"light"
    language: @request.post.language|"en"
    timezone: @request.post.timezone|"UTC"
    notifications: @request.post.notifications|true
}

# Apply preferences
current_theme: @session.preferences.theme|"light"
current_language: @session.preferences.language|"en"

# Theme switcher
#api /preferences/theme {
    new_theme: @request.post.theme
    
    # Update preference
    prefs: @session.preferences|{}
    prefs.theme: @new_theme
    @session.preferences: @prefs
    
    # Also save to database if logged in
    @if(@session.user_id) {
        @query("UPDATE users SET theme = ? WHERE id = ?", 
               [@new_theme, @session.user_id])
    }
    
    @json({
        success: true
        theme: @new_theme
    })
}
```

## Session Arrays

```tusk
# Recent searches
@if(!@isset(@session.recent_searches)) {
    @session.recent_searches: []
}

# Add search term
search_term: @request.get.q
@if(@search_term) {
    # Add to beginning, limit to 10
    @session.recent_searches: @array_unique(
        @array_merge([@search_term], @session.recent_searches)
    )
    @session.recent_searches: @array_slice(@session.recent_searches, 0, 10)
}

# Recently viewed products
@session.viewed_products[]: @product_id
@session.viewed_products: @array_slice(@array_unique(@session.viewed_products), -5)
```

## Session Debugging

```tusk
# Debug session data
#api /debug/session {
    # Only in development
    @if(@env.APP_ENV != "development") {
        @response.status: 403
        error: "Forbidden"
    }
    
    session_data: {
        id: @session_id()
        data: @session
        save_path: @session_save_path()
        cookie_params: @session_get_cookie_params()
    }
    
    @json(@session_data)
}
```

## Best Practices

1. **Always regenerate session ID after login** - Prevents fixation attacks
2. **Set session timeout** - Don't keep sessions forever
3. **Validate session data** - Don't trust that it hasn't been tampered
4. **Use HTTPS** - Session cookies should be secure
5. **Clean up old sessions** - Implement garbage collection

## Related Operators

- `@cookie` - Client-side storage
- `@cache` - Server-side caching
- `@user` - Current user shortcuts
- `@session_start()` - Manual session control
- `@session_destroy()` - End session
---

[@cookie - Cookie Variables]


The `@cookie` operator provides easy access to HTTP cookies for client-side data persistence, remember-me functionality, and user preferences.

## Basic Syntax

```tusk
# Read cookie
username: @cookie.username

# Set cookie (simple)
@cookie.theme: "dark"

# Set cookie with options
@cookie.remember_token: {
    value: @generate_token()
    expires: @time() + 2592000  # 30 days
    path: "/"
    domain: ".example.com"
    secure: true
    httponly: true
    samesite: "Lax"
}

# Delete cookie
@cookie.old_data: null
```

## Cookie Options

```tusk
# Comprehensive cookie setting
@cookie.user_preferences: {
    value: @json_encode({
        theme: "dark"
        language: "en"
        timezone: "UTC"
    })
    expires: @time() + 31536000     # 1 year
    path: "/"                       # Available site-wide
    domain: @request.host           # Current domain
    secure: @is_https()             # HTTPS only
    httponly: true                  # No JavaScript access
    samesite: "Strict"              # CSRF protection
}

# Session cookie (expires on browser close)
@cookie.session_data: {
    value: @session_id
    path: "/"
    httponly: true
}
```

## Remember Me Implementation

```tusk
# Login with remember me
#api /login {
    username: @request.post.username
    password: @request.post.password
    remember: @request.post.remember|false
    
    user: @authenticate(@username, @password)
    
    @if(@user) {
        # Set session
        @session.user_id: @user.id
        
        @if(@remember) {
            # Generate secure token
            token: @generate_secure_token()
            token_hash: @hash("sha256", @token)
            
            # Store in database
            @query("INSERT INTO remember_tokens (user_id, token_hash, expires) 
                    VALUES (?, ?, DATE_ADD(NOW(), INTERVAL 30 DAY))", 
                   [@user.id, @token_hash])
            
            # Set cookie
            @cookie.remember_me: {
                value: @user.id + ":" + @token
                expires: @time() + 2592000  # 30 days
                httponly: true
                secure: true
                samesite: "Lax"
            }
        }
        
        @json({success: true})
    }
}

# Auto-login check
auto_login: {
    # Check remember cookie
    remember: @cookie.remember_me
    
    @if(@remember && !@session.user_id) {
        parts: @explode(":", @remember)
        user_id: @parts[0]
        token: @parts[1]
        token_hash: @hash("sha256", @token)
        
        # Verify token
        valid: @query("SELECT * FROM remember_tokens 
                      WHERE user_id = ? AND token_hash = ? 
                      AND expires > NOW()", 
                     [@user_id, @token_hash])
        
        @if(@valid) {
            # Auto login
            @session.user_id: @user_id
            @session.auto_login: true
            
            # Refresh token
            @query("UPDATE remember_tokens 
                   SET expires = DATE_ADD(NOW(), INTERVAL 30 DAY) 
                   WHERE token_hash = ?", [@token_hash])
        }
    }
}
```

## User Preferences

```tusk
# Theme switcher
#api /preferences/theme/{theme} {
    # Validate theme
    valid_themes: ["light", "dark", "auto"]
    
    @if(@in_array(@theme, @valid_themes)) {
        # Set cookie
        @cookie.theme: {
            value: @theme
            expires: @time() + 31536000  # 1 year
            path: "/"
        }
        
        # Update session too
        @session.theme: @theme
        
        @json({
            success: true
            theme: @theme
        })
    } else {
        @response.status: 400
        @json({error: "Invalid theme"})
    }
}

# Read preference with fallback
current_theme: @cookie.theme|@session.theme|"light"
```

## Shopping Cart Backup

```tusk
# Save cart to cookie (for non-logged users)
save_cart_to_cookie: {
    cart: @session.cart|[]
    
    @if(@count(@cart) > 0 && !@session.user_id) {
        # Compress cart data
        cart_data: @json_encode(@cart)
        compressed: @gzcompress(@cart_data)
        encoded: @base64_encode(@compressed)
        
        @cookie.cart_backup: {
            value: @encoded
            expires: @time() + 604800  # 7 days
            path: "/"
        }
    }
}

# Restore cart from cookie
restore_cart: {
    @if(@cookie.cart_backup && !@session.cart) {
        decoded: @base64_decode(@cookie.cart_backup)
        decompressed: @gzuncompress(@decoded)
        cart_data: @json_decode(@decompressed)
        
        @session.cart: @cart_data
        
        # Clear backup
        @cookie.cart_backup: null
    }
}
```

## Analytics and Tracking

```tusk
# First visit tracking
@if(!@cookie.first_visit) {
    @cookie.first_visit: {
        value: @timestamp
        expires: @time() + 63072000  # 2 years
        path: "/"
    }
    
    # Track new visitor
    @track_event("new_visitor", {
        referrer: @request.headers.referer
        landing_page: @request.uri
    })
}

# Visit counter
visits: @int(@cookie.visit_count|0) + 1
@cookie.visit_count: {
    value: @visits
    expires: @time() + 31536000
    path: "/"
}

# A/B testing
@if(!@cookie.ab_variant) {
    variant: @rand(0, 1) ? "A" : "B"
    @cookie.ab_variant: {
        value: @variant
        expires: @time() + 2592000  # 30 days
        path: "/"
    }
}
```

## Security Cookies

```tusk
# CSRF token
@if(!@cookie.csrf_token) {
    @cookie.csrf_token: {
        value: @generate_csrf_token()
        expires: @time() + 7200  # 2 hours
        path: "/"
        secure: true
        samesite: "Strict"
    }
}

# Verify CSRF
verify_csrf: {
    cookie_token: @cookie.csrf_token
    header_token: @request.headers.x-csrf-token
    
    is_valid: @cookie_token && @cookie_token == @header_token
    
    @if(!@is_valid && @request.method != "GET") {
        @response.status: 403
        error: "Invalid CSRF token"
    }
}
```

## Cookie Consent

```tusk
# Check consent
has_consent: @cookie.cookie_consent == "accepted"

# Set analytics cookies only with consent
@if(@has_consent) {
    @cookie.analytics_id: {
        value: @generate_analytics_id()
        expires: @time() + 63072000  # 2 years
        path: "/"
    }
}

# Consent banner endpoint
#api /cookies/consent {
    action: @request.post.action
    
    @if(@action == "accept") {
        @cookie.cookie_consent: {
            value: "accepted"
            expires: @time() + 31536000
            path: "/"
        }
    } elseif(@action == "reject") {
        # Clear non-essential cookies
        @cookie.analytics_id: null
        @cookie.marketing_id: null
        
        @cookie.cookie_consent: {
            value: "rejected"
            expires: @time() + 31536000
            path: "/"
        }
    }
    
    @json({success: true})
}
```

## Language Selection

```tusk
# Detect language preference
user_language: @cookie.language|@detect_browser_language()|"en"

# Language switcher
#api /language/{lang} {
    # Validate language code
    supported: ["en", "es", "fr", "de", "ja"]
    
    @if(@in_array(@lang, @supported)) {
        @cookie.language: {
            value: @lang
            expires: @time() + 157680000  # 5 years
            path: "/"
            domain: ".example.com"  # All subdomains
        }
        
        # Redirect to localized version
        @redirect("/" + @lang + @request.uri)
    }
}
```

## Cookie Debugging

```tusk
# List all cookies
#api /debug/cookies {
    @if(@env.DEBUG != "true") {
        @response.status: 403
        error: "Forbidden"
    }
    
    all_cookies: @cookie
    
    # Parse cookie options
    cookie_info: {}
    @foreach(@all_cookies as @name => @value) {
        cookie_info[@name]: {
            value: @value
            size: @strlen(@value)
            type: @get_type(@value)
        }
    }
    
    @json({
        cookies: @cookie_info
        total: @count(@all_cookies)
        header: @request.headers.cookie
    })
}
```

## Best Practices

1. **Use secure flag on HTTPS** - Prevent cookie theft
2. **Set httponly for sensitive data** - Prevent XSS attacks
3. **Use samesite attribute** - CSRF protection
4. **Set appropriate expiration** - Don't keep cookies forever
5. **Minimize cookie size** - Sent with every request
6. **Encrypt sensitive data** - Don't store plaintext passwords

## Related Operators

- `@session` - Server-side storage
- `@request.headers.cookie` - Raw cookie header
- `@response.headers.set-cookie` - Manual cookie setting
- `@time()` - Current timestamp for expiration
- `@is_https()` - Check secure connection
---

[@ JSON Function]


The @json functions provide powerful JSON parsing and stringification capabilities in TuskLang. This guide covers working with JSON data, including parsing, stringifying, and manipulating JSON structures.

## JSON Parsing

### Basic Parsing

```tusk
# Parse JSON string to object
json_string: '{"name": "John", "age": 30, "active": true}'
data = @json.parse(json_string)

# Access parsed data
name = data.name        # "John"
age = data.age         # 30
is_active = data.active # true

# Parse with error handling
safe_parse = @lambda(json_text, {
    return: @try({
        return: @json.parse(json_text)
    }, {
        @log.error("Invalid JSON: ${@error.message}")
        return: null
    })
})
```

### Parsing Complex Structures

```tusk
# Parse nested JSON
complex_json: '''
{
    "users": [
        {"id": 1, "name": "Alice", "roles": ["admin", "user"]},
        {"id": 2, "name": "Bob", "roles": ["user"]}
    ],
    "metadata": {
        "total": 2,
        "page": 1,
        "timestamp": "2024-01-01T00:00:00Z"
    }
}
'''

response = @json.parse(complex_json)

# Access nested data
first_user = response.users[0]
total_users = response.metadata.total
admin_users = @filter(response.users, @lambda(u, @includes(u.roles, "admin")))
```

### Parse Options

```tusk
# Parse with custom reviver function
json_with_dates: '{"created": "2024-01-01T00:00:00Z", "count": 42}'

parsed = @json.parse(json_with_dates, @lambda(key, value, {
    # Convert date strings to timestamps
    @if(key == "created" && @isString(value), {
        return: @date.parse(value)
    })
    return: value
}))

# Safe parsing with defaults
parse_with_defaults = @lambda(json_text, defaults = {}, {
    parsed = @try({
        return: @json.parse(json_text)
    }, {
        return: {}
    })
    
    return: @merge(defaults, parsed)
})
```

## JSON Stringification

### Basic Stringification

```tusk
# Convert object to JSON string
data: {
    name: "John Doe"
    age: 30
    active: true
    tags: ["developer", "designer"]
}

json_string = @json.stringify(data)
# Result: '{"name":"John Doe","age":30,"active":true,"tags":["developer","designer"]}'

# Pretty printing
pretty_json = @json.stringify(data, null, 2)
# Result:
# {
#   "name": "John Doe",
#   "age": 30,
#   "active": true,
#   "tags": [
#     "developer",
#     "designer"
#   ]
# }
```

### Stringify Options

```tusk
# Custom replacer function
data: {
    name: "John"
    password: "secret123"
    email: "john@example.com"
    internal_id: "usr_123"
}

# Filter sensitive data
safe_json = @json.stringify(data, @lambda(key, value, {
    # Exclude sensitive fields
    @if(@includes(["password", "internal_id"], key), {
        return: undefined  # Exclude from output
    })
    
    # Mask email
    @if(key == "email", {
        return: @regex.replace(value, "(?<=.{3}).(?=.*@)", "*")
    })
    
    return: value
}))

# Result: '{"name":"John","email":"joh***@example.com"}'
```

### Circular Reference Handling

```tusk
# Handle circular references
create_safe_stringify = @lambda({
    seen: []
    
    return: @lambda(obj, space = 0, {
        return: @json.stringify(obj, @lambda(key, value, {
            @if(@isObject(value), {
                @if(@includes(@seen, value), {
                    return: "[Circular Reference]"
                })
                @push(@seen, value)
            })
            return: value
        }), space)
    })
})

safe_stringify = @create_safe_stringify()
```

## JSON Manipulation

### Deep Merge JSON

```tusk
# Merge JSON objects deeply
deep_merge_json = @lambda(json1, json2, {
    obj1 = @if(@isString(json1), @json.parse(json1), json1)
    obj2 = @if(@isString(json2), @json.parse(json2), json2)
    
    merged = @deep_merge(obj1, obj2)
    
    return: @json.stringify(merged)
})

# Example usage
base_config: '{"app": {"name": "MyApp", "version": "1.0"}, "debug": false}'
overrides: '{"app": {"version": "2.0"}, "debug": true, "new_feature": true}'

final_config = @deep_merge_json(base_config, overrides)
# Result: {"app":{"name":"MyApp","version":"2.0"},"debug":true,"new_feature":true}
```

### JSON Path Access

```tusk
# Access JSON data using path notation
json_path = @lambda(data, path, {
    # Parse if string
    obj = @if(@isString(data), @json.parse(data), data)
    
    # Split path and traverse
    parts = @split(path, ".")
    result = obj
    
    @each(parts, @lambda(part, {
        # Handle array notation
        @if(@regex.test(part, "\\[\\d+\\]"), {
            [key, index] = @regex.match(part, "(.+)\\[(\\d+)\\]")
            result = result?.[key]?.[parseInt(index)]
        }, {
            result = result?.[part]
        })
    }))
    
    return: result
})

# Usage
data: '{"users": [{"name": "John", "address": {"city": "NYC"}}]}'
city = @json_path(data, "users[0].address.city")  # "NYC"
```

### JSON Schema Validation

```tusk
# Validate JSON against schema
validate_json_schema = @lambda(data, schema, {
    errors: []
    
    # Parse if needed
    obj = @if(@isString(data), @json.parse(data), data)
    
    # Check required fields
    @each(schema.required ?? [], @lambda(field, {
        @if(!obj[field], {
            @push(errors, "Missing required field: ${field}")
        })
    }))
    
    # Validate types
    @each(@keys(schema.properties ?? {}), @lambda(key, {
        @if(obj[key] != null, {
            expected_type = schema.properties[key].type
            actual_type = @typeof(obj[key])
            
            @if(expected_type != actual_type, {
                @push(errors, "Field '${key}' should be ${expected_type}, got ${actual_type}")
            })
        })
    }))
    
    return: {
        valid: @len(errors) == 0
        errors: errors
    }
})

# Example schema
user_schema: {
    required: ["name", "email"]
    properties: {
        name: { type: "string" }
        email: { type: "string" }
        age: { type: "number" }
    }
}
```

## Working with JSON APIs

### API Response Handling

```tusk
# Fetch and parse JSON API response
fetch_json = @lambda(url, options = {}, {
    response = @http.request(url, @merge({
        headers: {
            "Accept": "application/json"
            "Content-Type": "application/json"
        }
    }, options))
    
    # Check response
    @if(response.status >= 400, {
        @throw("HTTP Error ${response.status}: ${response.statusText}")
    })
    
    # Parse JSON response
    return: @json.parse(response.body)
})

# Usage with error handling
get_user_data = @lambda(user_id, {
    return: @try({
        data: @fetch_json("https://api.example.com/users/${user_id}")
        return: { success: true, data: data }
    }, {
        error: @catch
        return: { success: false, error: error.message }
    })
})
```

### JSON-RPC Implementation

```tusk
# Simple JSON-RPC client
json_rpc_call = @lambda(url, method, params = null, {
    request_data: {
        jsonrpc: "2.0"
        method: method
        params: params
        id: @uuid()
    }
    
    response = @http.post(url, {
        headers: { "Content-Type": "application/json" }
        body: @json.stringify(request_data)
    })
    
    result = @json.parse(response.body)
    
    # Check for JSON-RPC error
    @if(result.error, {
        @throw("JSON-RPC Error ${result.error.code}: ${result.error.message}")
    })
    
    return: result.result
})

# Usage
user = @json_rpc_call("https://api.example.com/rpc", "getUser", { id: 123 })
```

## JSON Transformation

### Transform Keys

```tusk
# Convert between naming conventions
transform_keys = @lambda(data, transformer, {
    obj = @if(@isString(data), @json.parse(data), data)
    
    transform_object = @lambda(o, {
        @if(@isArray(o), {
            return: @map(o, transform_object)
        })
        
        @if(@isObject(o), {
            result: {}
            @each(@keys(o), @lambda(key, {
                new_key = @transformer(key)
                result[new_key] = @transform_object(o[key])
            }))
            return: result
        })
        
        return: o
    })
    
    return: @transform_object(obj)
})

# Snake case to camel case
snake_to_camel = @lambda(str, {
    @regex.replace(str, "_([a-z])", @lambda(match, letter, {
        return: @upper(letter)
    }))
})

# Usage
snake_data: { user_name: "John", user_age: 30 }
camel_data = @transform_keys(snake_data, @snake_to_camel)
# Result: { userName: "John", userAge: 30 }
```

### Filter JSON Data

```tusk
# Filter JSON array based on criteria
filter_json_array = @lambda(json_data, filter_fn, {
    data = @if(@isString(json_data), @json.parse(json_data), json_data)
    
    @if(!@isArray(data), {
        @throw("Input must be an array")
    })
    
    filtered = @filter(data, filter_fn)
    return: @json.stringify(filtered)
})

# Example: Filter active users
users_json: '[{"name":"John","active":true},{"name":"Jane","active":false}]'
active_users = @filter_json_array(users_json, @lambda(user, user.active))
```

## JSON Diff and Patch

### Compare JSON Objects

```tusk
# Compare two JSON objects
json_diff = @lambda(obj1, obj2, path = "", {
    diffs: []
    
    # Compare all keys from both objects
    all_keys = @unique(@concat(@keys(obj1), @keys(obj2)))
    
    @each(all_keys, @lambda(key, {
        current_path = path ? "${path}.${key}" : key
        val1 = obj1[key]
        val2 = obj2[key]
        
        @if(val1 === undefined, {
            @push(diffs, { type: "added", path: current_path, value: val2 })
        }, @if(val2 === undefined, {
            @push(diffs, { type: "removed", path: current_path, value: val1 })
        }, @if(@isObject(val1) && @isObject(val2), {
            # Recursive diff
            nested_diffs = @json_diff(val1, val2, current_path)
            diffs = @concat(diffs, nested_diffs)
        }, @if(val1 !== val2, {
            @push(diffs, { 
                type: "changed", 
                path: current_path, 
                oldValue: val1, 
                newValue: val2 
            })
        }))))
    }))
    
    return: diffs
})
```

## Performance Optimization

### Streaming JSON Parser

```tusk
# Parse large JSON files in chunks
stream_json_parse = @lambda(file_path, callback, {
    buffer: ""
    depth: 0
    in_string: false
    escape_next: false
    
    # Process chunks
    @file.stream(file_path, @lambda(chunk, {
        buffer = buffer + chunk
        
        # Simple JSON object detection
        @each(@split(chunk, ""), @lambda(char, {
            @if(escape_next, {
                escape_next = false
                return
            })
            
            @if(char == "\\" && in_string, {
                escape_next = true
                return
            })
            
            @if(char == '"' && !escape_next, {
                in_string = !in_string
                return
            })
            
            @if(!in_string, {
                @if(char == "{", depth = depth + 1)
                @if(char == "}", {
                    depth = depth - 1
                    @if(depth == 0, {
                        # Complete object found
                        obj = @json.parse(buffer)
                        @callback(obj)
                        buffer = ""
                    })
                })
            })
        }))
    }))
})
```

### JSON Memory Optimization

```tusk
# Optimize memory for large JSON operations
optimize_json_memory = @lambda({
    # Use streaming for large files
    large_file_threshold: 10 * 1024 * 1024  # 10MB
    
    # Clear parsed objects after use
    process_json_file = @lambda(file_path, processor, {
        size = @file.size(file_path)
        
        @if(size > large_file_threshold, {
            # Stream process
            @stream_json_parse(file_path, processor)
        }, {
            # Load all at once
            data = @json.parse(@file.read(file_path))
            result = @processor(data)
            data = null  # Clear reference
            return: result
        })
    })
})
```

## Error Handling

### Safe JSON Operations

```tusk
# Comprehensive JSON error handling
safe_json_operation = @lambda(operation, fallback = null, {
    return: @try({
        return: @operation()
    }, {
        error: @catch
        
        @if(@includes(error.message, "JSON"), {
            @log.error("JSON Error: ${error.message}")
            return: fallback
        })
        
        # Re-throw non-JSON errors
        @throw(error)
    })
})

# Usage
result = @safe_json_operation(@lambda({
    data = @json.parse(potentially_invalid_json)
    return: data.some.deep.property
}), { default: "value" })
```

## Best Practices

1. **Always handle parse errors** - JSON.parse can throw
2. **Use pretty printing** for debugging and logs
3. **Filter sensitive data** when stringifying
4. **Validate JSON structure** before using
5. **Consider memory usage** for large JSON files
6. **Use streaming** for very large datasets
7. **Cache parsed JSON** when used multiple times

## Common Patterns

### JSON Configuration Loader

```tusk
# Load and merge JSON configuration files
load_json_config = @lambda(base_path, env = "development", {
    # Load base config
    base_config = @json.parse(@file.read("${base_path}/config.base.json"))
    
    # Load environment config
    env_config = @try({
        return: @json.parse(@file.read("${base_path}/config.${env}.json"))
    }, {
        return: {}
    })
    
    # Load local overrides
    local_config = @try({
        return: @json.parse(@file.read("${base_path}/config.local.json"))
    }, {
        return: {}
    })
    
    # Merge all configs
    return: @deep_merge(base_config, env_config, local_config)
})
```

### JSON Logger

```tusk
# Structured JSON logging
json_logger = @lambda(level, message, context = {}, {
    log_entry: {
        timestamp: @time.iso()
        level: level
        message: message
        context: context
        hostname: @system.hostname
        pid: @process.pid
    }
    
    # Output as JSON line
    @console.log(@json.stringify(log_entry))
    
    # Also write to file if configured
    @if(@config.log_file, {
        @file.append(@config.log_file, @json.stringify(log_entry) + "\n")
    })
})

# Usage
@json_logger("info", "User logged in", { user_id: 123, ip: @request.ip })
```

## Next Steps

- Learn about [Render Function](042-at-render-function.md)
- Explore [HTTP Operations](050-at-http-host.md)
- Master [Database Queries](044-at-query-database.md)
---

[@render() - Template Rendering]


The `@render()` function loads and processes TuskLang templates, enabling dynamic content generation with template inheritance and partials.

## Basic Syntax

```tusk
# Render a template
output: @render("templates/page.tusk")

# Render with data
output: @render("templates/user.tusk", {
    name: "John Doe"
    email: "john@example.com"
})

# Render inline template
output: @render(template_string, data, {inline: true})
```

## Template Files

```tusk
# templates/layout.tusk
<!DOCTYPE html>
<html>
<head>
    <title>{@title|"Default Title"}</title>
    <meta charset="utf-8">
    {@head_extra}
</head>
<body>
    <header>
        {@render("partials/header.tusk", {user: @user})}
    </header>
    
    <main>
        {@content}
    </main>
    
    <footer>
        {@render("partials/footer.tusk")}
    </footer>
</body>
</html>

# templates/page.tusk
@extend("layout.tusk", {
    title: @page_title
    head_extra: '<link rel="stylesheet" href="/css/page.css">'
    content: @page_content
})
```

## Passing Data

```tusk
# Controller
#web /users/{id} {
    user: @query("SELECT * FROM users WHERE id = ?", [@id])
    posts: @query("SELECT * FROM posts WHERE user_id = ?", [@id])
    
    @render("templates/profile.tusk", {
        user: @user
        posts: @posts
        current_user: @session.user
        is_owner: @session.user.id == @id
    })
}

# templates/profile.tusk
<div class="profile">
    <h1>{@user.name}</h1>
    <p>{@user.bio}</p>
    
    @if(@is_owner) {
        <a href="/profile/edit">Edit Profile</a>
    }
    
    <div class="posts">
        @foreach(@posts as @post) {
            {@render("partials/post.tusk", {post: @post})}
        }
    </div>
</div>
```

## Template Inheritance

```tusk
# Base template: templates/base.tusk
<!DOCTYPE html>
<html>
<head>
    <title>{@block('title')}Default Title{@endblock}</title>
    {@block('head')}{@endblock}
</head>
<body>
    {@block('content')}{@endblock}
    
    <script src="/js/app.js"></script>
    {@block('scripts')}{@endblock}
</body>
</html>

# Child template: templates/home.tusk
@extends('base.tusk')

@block('title')Home Page{@endblock}

@block('head')
    <link rel="stylesheet" href="/css/home.css">
{@endblock}

@block('content')
    <h1>Welcome Home</h1>
    <p>This is the home page content.</p>
{@endblock}

@block('scripts')
    <script src="/js/home.js"></script>
{@endblock}
```

## Partials and Components

```tusk
# Reusable card component
# templates/components/card.tusk
<div class="card {@class}">
    @if(@image) {
        <img src="{@image}" alt="{@title}">
    }
    <div class="card-body">
        <h3>{@title}</h3>
        <p>{@description}</p>
        @if(@actions) {
            <div class="card-actions">
                {@actions}
            </div>
        }
    </div>
</div>

# Using the component
products: @query("SELECT * FROM products LIMIT 6")

<div class="product-grid">
    @foreach(@products as @product) {
        {@render("components/card.tusk", {
            title: @product.name
            description: @product.description
            image: @product.image_url
            class: "product-card"
            actions: '<button onclick="addToCart(' + @product.id + ')">Add to Cart</button>'
        })}
    }
</div>
```

## Conditional Rendering

```tusk
# Render different templates based on conditions
#web /content/{type}/{id} {
    content: @query("SELECT * FROM content WHERE id = ?", [@id])
    
    # Choose template based on type
    template: @switch(@type) {
        case "article": "templates/article.tusk"
        case "video": "templates/video.tusk"
        case "gallery": "templates/gallery.tusk"
        default: "templates/generic.tusk"
    }
    
    @render(@template, {
        content: @content
        type: @type
    })
}

# In template
@if(@user.role == "admin") {
    {@render("partials/admin-tools.tusk")}
} elseif(@user.role == "editor") {
    {@render("partials/editor-tools.tusk")}
}
```

## Loop Rendering

```tusk
# Render collections
# templates/list.tusk
<ul class="{@list_class|'default-list'}">
    @foreach(@items as @index => @item) {
        <li class="{@item_class} {@index % 2 ? 'odd' : 'even'}">
            {@render(@item_template|"partials/list-item.tusk", {
                item: @item
                index: @index
                is_first: @index == 0
                is_last: @index == @count(@items) - 1
            })}
        </li>
    }
</ul>

# Using the list
categories: @query("SELECT * FROM categories ORDER BY name")

{@render("templates/list.tusk", {
    items: @categories
    list_class: "category-list"
    item_class: "category-item"
    item_template: "partials/category.tusk"
})}
```

## Email Templates

```tusk
# Send email with template
#api /send-welcome-email {
    user_id: @request.post.user_id
    user: @query("SELECT * FROM users WHERE id = ?", [@user_id])
    
    # Render email template
    email_html: @render("emails/welcome.tusk", {
        user: @user
        activation_link: @base_url + "/activate/" + @user.activation_token
        year: @date("Y")
    })
    
    # Send email
    @send_email({
        to: @user.email
        subject: "Welcome to " + @app_name
        html: @email_html
        text: @strip_tags(@email_html)
    })
}

# emails/welcome.tusk
@extends('emails/layout.tusk')

@block('content')
    <h1>Welcome, {@user.name}!</h1>
    <p>Thank you for joining {@app_name}.</p>
    <p>Please activate your account by clicking the link below:</p>
    <a href="{@activation_link}" class="button">Activate Account</a>
{@endblock}
```

## Caching Rendered Templates

```tusk
# Cache rendered output
#web /expensive-page {
    cache_key: "page:expensive:" + @request.uri
    cached: @cache.get(@cache_key)
    
    @if(@cached) {
        @output(@cached)
    } else {
        # Expensive data operations
        data: @complex_data_calculation()
        
        # Render template
        html: @render("templates/expensive.tusk", {data: @data})
        
        # Cache for 1 hour
        @cache.set(@cache_key, @html, 3600)
        
        @output(@html)
    }
}
```

## Error Handling

```tusk
# Safe template rendering
try_render: {
    template_path: "templates/" + @page_name + ".tusk"
    
    @if(@file_exists(@template_path)) {
        @try {
            output: @render(@template_path, @page_data)
        } catch (error) {
            @log_error("Template render failed", {
                template: @template_path
                error: @error
            })
            output: @render("templates/error.tusk", {
                message: "Page temporarily unavailable"
            })
        }
    } else {
        output: @render("templates/404.tusk")
    }
}
```

## Dynamic Template Loading

```tusk
# Plugin system
#web /plugin/{plugin}/{page} {
    # Load plugin template
    plugin_path: "plugins/" + @plugin + "/templates/" + @page + ".tusk"
    
    @if(@file_exists(@plugin_path) && @is_plugin_active(@plugin)) {
        # Load plugin configuration
        config: @load_plugin_config(@plugin)
        
        @render(@plugin_path, {
            config: @config
            user: @session.user
            params: @request.all
        })
    } else {
        @response.status: 404
        @render("templates/404.tusk", {
            message: "Plugin or page not found"
        })
    }
}
```

## Template Helpers

```tusk
# Register template helpers
template_helpers: {
    # Format currency
    money: (@amount) => {
        "$" + @number_format(@amount, 2)
    }
    
    # Format date
    date_format: (@date, @format) => {
        @strftime(@format, @strtotime(@date))
    }
    
    # Truncate text
    truncate: (@text, @length: 100) => {
        @strlen(@text) > @length 
            ? @substr(@text, 0, @length) + "..."
            : @text
    }
}

# Use in template
<p>Price: {@money(@product.price)}</p>
<p>Posted: {@date_format(@post.created_at, "%B %d, %Y")}</p>
<p>{@truncate(@article.content, 200)}</p>
```

## Best Practices

1. **Organize templates logically** - Use folders for different types
2. **Use partials for reusability** - Don't repeat yourself
3. **Pass only needed data** - Don't send entire objects if not needed
4. **Escape output by default** - Prevent XSS attacks
5. **Cache expensive renders** - Improve performance
6. **Handle missing templates** - Graceful error handling

## Related Functions

- `@include()` - Include raw files
- `@render_string()` - Render string templates
- `@extends()` - Template inheritance
- `@block()` - Define template blocks
- `@escape()` - Escape HTML output
---

[@redirect() - HTTP Redirects]


The `@redirect()` function sends HTTP redirect responses to navigate users to different URLs, with support for various redirect types and data passing.

## Basic Syntax

```tusk
# Simple redirect
@redirect("/dashboard")

# External redirect
@redirect("https://example.com")

# Redirect with status code
@redirect("/new-location", 301)  # Permanent redirect

# Redirect with flash data
@redirect("/login", {
    flash: "Please login first"
})
```

## Redirect Types

```tusk
# Temporary redirect (302 - default)
@redirect("/temporary-page")

# Permanent redirect (301)
@redirect("/new-url", 301)

# See Other (303 - after POST)
@redirect("/success", 303)

# Temporary Redirect (307 - preserve method)
@redirect("/process", 307)

# Permanent Redirect (308 - preserve method)
@redirect("/new-endpoint", 308)
```

## After Form Submission

```tusk
#api /contact {
    # Process form
    name: @request.post.name
    email: @request.post.email
    message: @request.post.message
    
    # Validate
    @if(!@name || !@email || !@message) {
        @redirect("/contact", {
            flash: {
                type: "error"
                message: "All fields are required"
            },
            old: @request.post  # Preserve form data
        })
    }
    
    # Save to database
    @query("INSERT INTO messages (name, email, message) VALUES (?, ?, ?)",
           [@name, @email, @message])
    
    # Redirect with success message
    @redirect("/contact", {
        flash: {
            type: "success"
            message: "Thank you! Your message has been sent."
        }
    }, 303)  # Use 303 after POST
}
```

## Authentication Redirects

```tusk
# Middleware to check authentication
check_auth: {
    @if(!@session.user_id) {
        # Store intended destination
        @session.redirect_after_login: @request.uri
        
        @redirect("/login", {
            flash: "Please login to continue"
        })
    }
}

# After successful login
#api /login {
    # ... authentication logic ...
    
    @if(@authenticated) {
        # Check for intended destination
        redirect_to: @session.redirect_after_login|"/dashboard"
        @session.redirect_after_login: null
        
        @redirect(@redirect_to)
    }
}
```

## Conditional Redirects

```tusk
#web /profile {
    # Redirect based on user type
    @if(!@session.user_id) {
        @redirect("/login")
    } elseif(@session.user.role == "admin") {
        @redirect("/admin/profile")
    } elseif(@session.user.role == "vendor") {
        @redirect("/vendor/profile")
    } else {
        @redirect("/user/profile")
    }
}

# Feature flags
#web /new-feature {
    @if(!@feature_enabled("new_ui")) {
        @redirect("/old-feature", {
            flash: "This feature is coming soon!"
        })
    }
    
    # Show new feature...
}
```

## Redirect with Query Parameters

```tusk
# Build redirect URL with parameters
#api /search {
    query: @request.post.q
    category: @request.post.category
    sort: @request.post.sort|"relevance"
    
    # Build query string
    params: @http_build_query({
        q: @query
        category: @category
        sort: @sort
        page: 1
    })
    
    @redirect("/search/results?" + @params)
}

# Preserve existing parameters
#web /filter {
    # Get current parameters
    current_params: @request.query
    
    # Add/update filter
    current_params.filter: @request.post.filter
    
    # Redirect with updated parameters
    @redirect(@request.path + "?" + @http_build_query(@current_params))
}
```

## Back/Referrer Redirects

```tusk
# Redirect back with fallback
#api /action {
    # Perform action...
    
    # Redirect to referrer or fallback
    referrer: @request.headers.referer
    
    @if(@referrer && @is_safe_url(@referrer)) {
        @redirect(@referrer)
    } else {
        @redirect("/dashboard")
    }
}

# Helper function for safe URLs
is_safe_url: (url) => {
    # Check if URL is from same domain
    parsed: @parse_url(@url)
    current_host: @request.headers.host
    
    return !@parsed.host || @parsed.host == @current_host
}
```

## Named Routes

```tusk
# Define routes with names
routes: {
    home: "/"
    dashboard: "/dashboard"
    profile: "/user/profile"
    post: "/blog/post/{id}"
}

# Redirect to named route
@redirect(@route("dashboard"))

# With parameters
@redirect(@route("post", {id: 123}))

# Route helper
route: (name, params: {}) => {
    path: @routes[@name]
    
    # Replace parameters
    @foreach(@params as @key => @value) {
        path: @str_replace("{" + @key + "}", @value, @path)
    }
    
    return @path
}
```

## Flash Messages

```tusk
# Set flash message and redirect
#api /update-profile {
    # Update user profile
    success: @update_user_profile(@request.post)
    
    @if(@success) {
        @session.flash: {
            type: "success"
            message: "Profile updated successfully!"
        }
        @redirect("/profile")
    } else {
        @session.flash: {
            type: "error"
            message: "Failed to update profile"
        }
        @redirect("/profile/edit")
    }
}

# Display flash messages (in template)
@if(@session.flash) {
    <div class="alert alert-{@session.flash.type}">
        {@session.flash.message}
    </div>
    @session.flash: null  # Clear after display
}
```

## Mobile App Redirects

```tusk
# Detect mobile and redirect
#web / {
    is_mobile: @is_mobile_device()
    has_app: @cookie.has_mobile_app
    
    @if(@is_mobile && !@has_app) {
        # Redirect to app store
        @if(@is_ios()) {
            @redirect("https://apps.apple.com/app/id123456")
        } elseif(@is_android()) {
            @redirect("https://play.google.com/store/apps/details?id=com.example")
        } else {
            @redirect("/mobile")
        }
    }
}

# Deep linking
#web /product/{id} {
    @if(@is_mobile_app()) {
        # Redirect to app deep link
        @redirect("myapp://product/" + @id)
    }
    
    # Regular web view...
}
```

## Maintenance Mode

```tusk
# Global maintenance redirect
maintenance_check: {
    is_maintenance: @env.MAINTENANCE_MODE == "true"
    allowed_ips: ["192.168.1.1", "10.0.0.1"]
    
    @if(@is_maintenance && !@in_array(@request.ip, @allowed_ips)) {
        @redirect("/maintenance", 503)
    }
}

# Maintenance page
#web /maintenance {
    @response.status: 503
    @response.headers.retry-after: 3600  # 1 hour
    
    @render("templates/maintenance.tusk", {
        message: "We'll be back soon!"
    })
}
```

## Redirect Loops Prevention

```tusk
# Prevent redirect loops
#web /setup {
    # Check if already redirected
    redirect_count: @session.redirect_count|0
    
    @if(@redirect_count > 3) {
        # Break the loop
        @session.redirect_count: 0
        @response.status: 500
        error: "Redirect loop detected"
        return
    }
    
    # Check setup status
    @if(!@is_setup_complete()) {
        @session.redirect_count: @redirect_count + 1
        @redirect("/setup/step1")
    }
    
    @session.redirect_count: 0
}
```

## AJAX Redirects

```tusk
# Handle AJAX redirect responses
#api /ajax-action {
    # Check if AJAX request
    is_ajax: @request.headers.x-requested-with == "XMLHttpRequest"
    
    # Perform action...
    
    @if(@is_ajax) {
        # Return JSON with redirect URL
        @json({
            redirect: "/success",
            message: "Action completed"
        })
    } else {
        # Regular redirect
        @redirect("/success")
    }
}

# Client-side handling:
# if (response.redirect) {
#     window.location.href = response.redirect;
# }
```

## Best Practices

1. **Use appropriate status codes** - 301 for permanent, 302 for temporary
2. **Prevent redirect loops** - Add loop detection
3. **Validate redirect URLs** - Prevent open redirects
4. **Use 303 after POST** - Prevent form resubmission
5. **Include flash messages** - Provide user feedback
6. **Handle AJAX differently** - Return JSON for AJAX requests

## Related Functions

- `@response.status` - Set response status
- `@response.headers` - Set custom headers
- `@route()` - Generate URLs
- `@session.flash` - Flash messages
- `@request.headers.referer` - Get referrer URL
---

[@ Query Database]


The @query function and related database operators provide powerful database interaction capabilities in TuskLang. This guide covers executing queries, handling results, and building robust database applications.

## Basic Database Queries

### Simple Query Execution

```tusk
# Execute a basic query
users = @query("SELECT * FROM users WHERE active = true")

# Query with parameters (prevents SQL injection)
user_id: 123
user = @query("SELECT * FROM users WHERE id = ?", user_id)

# Multiple parameters
age_min: 18
age_max: 65
users = @query(
    "SELECT * FROM users WHERE age BETWEEN ? AND ?",
    age_min,
    age_max
)
```

### Query Result Handling

```tusk
# Query returns array of objects
result = @query("SELECT id, name, email FROM users")
# Result: [
#   { id: 1, name: "John", email: "john@example.com" },
#   { id: 2, name: "Jane", email: "jane@example.com" }
# ]

# Access results
first_user = result[0]
user_count = @len(result)

# Handle empty results
users = @query("SELECT * FROM users WHERE age > ?", 100)
@if(@len(users) == 0, {
    @print("No users found")
})
```

### Single Row Queries

```tusk
# Get single row
query_one = @lambda(sql, ...params, {
    results = @query(sql, ...params)
    return: results[0] ?? null
})

# Usage
user = @query_one("SELECT * FROM users WHERE id = ?", user_id)

@if(user, {
    @print("Found user: ${user.name}")
}, {
    @print("User not found")
})
```

## Database Connection Management

### Connection Configuration

```tusk
# Database configuration
db_config:
    driver: "postgresql"  # or "mysql", "sqlite", etc.
    host: @env.DB_HOST || "localhost"
    port: @env.DB_PORT || 5432
    database: @env.DB_NAME || "myapp"
    username: @env.DB_USER || "dbuser"
    password: @env.DB_PASSWORD
    
    # Connection pool settings
    pool:
        min: 2
        max: 10
        idle_timeout: 30000  # 30 seconds

# Initialize connection
@db.init(@db_config)
```

### Connection Patterns

```tusk
# Ensure connection before queries
with_connection = @lambda(callback, {
    # Check connection
    @if(!@db.connected, {
        @db.connect(@db_config)
    })
    
    try_result = @try({
        return: @callback()
    }, {
        error: @catch
        @log.error("Database error: ${error}")
        
        # Attempt reconnection on connection errors
        @if(@includes(error.message, "connection"), {
            @db.reconnect()
            return: @callback()  # Retry once
        })
        
        @throw(error)
    })
    
    return: try_result
})
```

## Transaction Management

### Basic Transactions

```tusk
# Execute queries in a transaction
transfer_funds = @lambda(from_id, to_id, amount, {
    @db.transaction(@lambda({
        # Deduct from sender
        @query(
            "UPDATE accounts SET balance = balance - ? WHERE id = ? AND balance >= ?",
            amount, from_id, amount
        )
        
        # Check if update succeeded
        @if(@db.affected_rows == 0, {
            @throw("Insufficient funds")
        })
        
        # Add to receiver
        @query(
            "UPDATE accounts SET balance = balance + ? WHERE id = ?",
            amount, to_id
        )
        
        # Log transaction
        @query(
            "INSERT INTO transactions (from_id, to_id, amount, created_at) VALUES (?, ?, ?, ?)",
            from_id, to_id, amount, @time.now()
        )
        
        return: true
    }))
})
```

### Transaction with Savepoints

```tusk
# Nested transactions with savepoints
complex_operation = @lambda({
    @db.transaction(@lambda({
        # Main transaction
        @query("INSERT INTO orders (user_id, total) VALUES (?, ?)", user_id, total)
        order_id = @db.last_insert_id
        
        # Savepoint for items
        @db.savepoint("items", @lambda({
            @each(items, @lambda(item, {
                result = @try({
                    @query(
                        "INSERT INTO order_items (order_id, product_id, quantity) VALUES (?, ?, ?)",
                        order_id, item.product_id, item.quantity
                    )
                }, {
                    # Rollback to savepoint on error
                    @db.rollback_to("items")
                    @throw("Failed to add item: ${item.product_id}")
                })
            }))
        }))
        
        return: order_id
    }))
})
```

## Query Builders

### Dynamic Query Construction

```tusk
# Build queries dynamically
build_select_query = @lambda(table, options = {}, {
    parts: ["SELECT"]
    
    # SELECT clause
    fields = options.fields ?? ["*"]
    @push(parts, @join(fields, ", "))
    
    # FROM clause
    @push(parts, "FROM ${table}")
    
    # WHERE clause
    @if(options.where, {
        conditions = []
        values = []
        
        @each(@entries(options.where), @lambda(entry, {
            [field, value] = entry
            
            @if(@isArray(value), {
                # IN clause
                placeholders = @join(@repeat("?", @len(value)), ", ")
                @push(conditions, "${field} IN (${placeholders})")
                values = @concat(values, value)
            }, {
                # Equal comparison
                @push(conditions, "${field} = ?")
                @push(values, value)
            })
        }))
        
        @if(@len(conditions) > 0, {
            @push(parts, "WHERE ${@join(conditions, ' AND ')}")
        })
    })
    
    # ORDER BY clause
    @if(options.order_by, {
        @push(parts, "ORDER BY ${options.order_by}")
    })
    
    # LIMIT clause
    @if(options.limit, {
        @push(parts, "LIMIT ${options.limit}")
        
        @if(options.offset, {
            @push(parts, "OFFSET ${options.offset}")
        })
    })
    
    return: {
        sql: @join(parts, " ")
        params: values
    }
})

# Usage
query_info = @build_select_query("users", {
    fields: ["id", "name", "email"]
    where: { active: true, role: ["admin", "moderator"] }
    order_by: "created_at DESC"
    limit: 10
})

results = @query(query_info.sql, ...query_info.params)
```

### INSERT Query Builder

```tusk
# Build INSERT queries
build_insert_query = @lambda(table, data, {
    fields = @keys(data)
    values = @values(data)
    
    placeholders = @join(@repeat("?", @len(fields)), ", ")
    field_list = @join(fields, ", ")
    
    sql = "INSERT INTO ${table} (${field_list}) VALUES (${placeholders})"
    
    return: { sql: sql, params: values }
})

# Bulk insert
bulk_insert = @lambda(table, records, {
    @if(@len(records) == 0, return: 0)
    
    fields = @keys(records[0])
    field_list = @join(fields, ", ")
    
    # Build value placeholders
    value_template = "(${@join(@repeat('?', @len(fields)), ', ')})"
    value_clauses = @join(@repeat(value_template, @len(records)), ", ")
    
    # Flatten parameters
    params = []
    @each(records, @lambda(record, {
        @each(fields, @lambda(field, {
            @push(params, record[field])
        }))
    }))
    
    sql = "INSERT INTO ${table} (${field_list}) VALUES ${value_clauses}"
    
    @query(sql, ...params)
    return: @db.affected_rows
})
```

## Prepared Statements

### Using Prepared Statements

```tusk
# Prepare statement for reuse
prepare_user_query = @lambda({
    stmt = @db.prepare("SELECT * FROM users WHERE email = ? AND active = ?")
    
    return: @lambda(email, active = true, {
        return: @stmt.execute(email, active)
    })
})

# Use prepared statement multiple times
get_user = @prepare_user_query()
user1 = @get_user("john@example.com")
user2 = @get_user("jane@example.com", false)
```

### Cached Prepared Statements

```tusk
# Cache prepared statements
statement_cache: {}

execute_prepared = @lambda(key, sql, params, {
    # Get or create prepared statement
    stmt = @statement_cache[key] ?? @db.prepare(sql)
    @statement_cache[key] = stmt
    
    # Execute with parameters
    return: @stmt.execute(...params)
})

# Usage
user = @execute_prepared(
    "get_user_by_id",
    "SELECT * FROM users WHERE id = ?",
    [user_id]
)[0]
```

## Result Processing

### Mapping Results

```tusk
# Transform query results
get_users_with_age = @lambda({
    results = @query("SELECT * FROM users")
    
    return: @map(results, @lambda(user, {
        # Calculate age from birthdate
        age = @date.years_between(user.birthdate, @date.now())
        
        return: {
            ...user
            age: age
            is_adult: age >= 18
        }
    }))
})

# Group results
group_users_by_role = @lambda({
    users = @query("SELECT * FROM users")
    
    return: @group_by(users, @lambda(user, user.role))
})
```

### Pagination

```tusk
# Paginated query helper
paginate = @lambda(query, page = 1, per_page = 20, {
    offset = (page - 1) * per_page
    
    # Get total count
    count_query = "SELECT COUNT(*) as total FROM (${query}) as subquery"
    total = @query(count_query)[0].total
    
    # Get paginated results
    paginated_query = "${query} LIMIT ? OFFSET ?"
    results = @query(paginated_query, per_page, offset)
    
    return: {
        data: results
        pagination: {
            current_page: page
            per_page: per_page
            total: total
            total_pages: @ceil(total / per_page)
            has_next: page < @ceil(total / per_page)
            has_prev: page > 1
        }
    }
})

# Usage
page_results = @paginate(
    "SELECT * FROM products WHERE category = 'electronics' ORDER BY price",
    @request.query.page ?? 1
)
```

## Database Migrations

### Migration System

```tusk
# Simple migration system
run_migrations = @lambda({
    # Create migrations table if not exists
    @query("""
        CREATE TABLE IF NOT EXISTS migrations (
            id INTEGER PRIMARY KEY,
            filename VARCHAR(255) UNIQUE,
            executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    # Get list of migration files
    migration_files = @file.list("./migrations/*.sql")
    
    # Get executed migrations
    executed = @map(
        @query("SELECT filename FROM migrations"),
        @lambda(row, row.filename)
    )
    
    # Run pending migrations
    @each(migration_files, @lambda(file, {
        filename = @path.basename(file)
        
        @if(!@includes(executed, filename), {
            @log.info("Running migration: ${filename}")
            
            @db.transaction(@lambda({
                # Execute migration
                sql = @file.read(file)
                @query(sql)
                
                # Record migration
                @query(
                    "INSERT INTO migrations (filename) VALUES (?)",
                    filename
                )
            }))
        })
    }))
})
```

## Error Handling

### Comprehensive Error Handling

```tusk
# Database operation with full error handling
safe_query = @lambda(sql, params = [], options = {}, {
    max_retries = options.retries ?? 3
    retry_delay = options.retry_delay ?? 1000
    
    attempt = @lambda(retry_count, {
        return: @try({
            result: @query(sql, ...params)
            return: { success: true, data: result }
        }, {
            error: @catch
            
            # Check error type
            @if(@includes(error.message, "deadlock") && retry_count < max_retries, {
                @log.warn("Deadlock detected, retrying...")
                @time.sleep(retry_delay * retry_count)
                return: @attempt(retry_count + 1)
            })
            
            @if(@includes(error.message, "connection"), {
                @log.error("Connection error: ${error.message}")
                # Attempt reconnection
                @db.reconnect()
                
                @if(retry_count < max_retries, {
                    return: @attempt(retry_count + 1)
                })
            })
            
            return: {
                success: false
                error: error.message
                code: error.code
            }
        })
    })
    
    return: @attempt(0)
})
```

## Performance Optimization

### Query Optimization

```tusk
# Add query analysis
analyze_query = @lambda(sql, params = [], {
    # Explain query
    explain = @query("EXPLAIN ${sql}", ...params)
    
    # Check for performance issues
    issues = []
    
    @each(explain, @lambda(row, {
        @if(@includes(row.Extra ?? "", "Using filesort"), {
            @push(issues, "Query uses filesort - consider adding index")
        })
        
        @if(row.type == "ALL", {
            @push(issues, "Full table scan detected")
        })
    }))
    
    return: {
        plan: explain
        issues: issues
        recommendations: @generate_index_recommendations(sql)
    }
})
```

### Connection Pooling

```tusk
# Connection pool management
connection_pool:
    connections: []
    max_size: 10
    
    acquire: @lambda({
        # Find available connection
        conn = @find(@connections, @lambda(c, !c.in_use))
        
        @if(conn, {
            conn.in_use = true
            return: conn
        })
        
        # Create new if under limit
        @if(@len(@connections) < @max_size, {
            conn = @db.create_connection()
            @push(@connections, {
                connection: conn
                in_use: true
                created_at: @time.now()
            })
            return: conn
        })
        
        # Wait for available connection
        @wait_for_connection()
    })
    
    release: @lambda(conn, {
        conn.in_use = false
        conn.last_used = @time.now()
    })
```

## Best Practices

1. **Always use parameterized queries** to prevent SQL injection
2. **Handle connection errors** gracefully with retries
3. **Use transactions** for data consistency
4. **Implement connection pooling** for performance
5. **Add appropriate indexes** based on query patterns
6. **Monitor query performance** in production
7. **Use prepared statements** for repeated queries
8. **Implement proper error handling** and logging

## Common Patterns

### Repository Pattern

```tusk
# Create a repository for data access
create_repository = @lambda(table_name, {
    return: {
        find_by_id: @lambda(id, {
            @query_one("SELECT * FROM ${table_name} WHERE id = ?", id)
        })
        
        find_all: @lambda(conditions = {}, {
            query_info = @build_select_query(table_name, { where: conditions })
            @query(query_info.sql, ...query_info.params)
        })
        
        create: @lambda(data, {
            query_info = @build_insert_query(table_name, data)
            @query(query_info.sql, ...query_info.params)
            
            return: {
                ...data
                id: @db.last_insert_id
            }
        })
        
        update: @lambda(id, data, {
            fields = @keys(data)
            set_clause = @join(@map(fields, @lambda(f, "${f} = ?")), ", ")
            values = @concat(@values(data), [id])
            
            @query(
                "UPDATE ${table_name} SET ${set_clause} WHERE id = ?",
                ...values
            )
            
            return: @db.affected_rows > 0
        })
        
        delete: @lambda(id, {
            @query("DELETE FROM ${table_name} WHERE id = ?", id)
            return: @db.affected_rows > 0
        })
    }
})

# Usage
user_repo = @create_repository("users")
user = @user_repo.find_by_id(123)
new_user = @user_repo.create({ name: "John", email: "john@example.com" })
```

## Next Steps

- Explore [Cache Functions](046-at-cache-function.md)
- Learn about [Transaction Patterns](044-at-query-database.md)
- Master [Performance Optimization](059-at-operator-performance.md)
---

[@tusk{} - TuskLang Active Record ORM]


The `@tusk{}` object provides an elegant Active Record pattern for database operations, making it easy to work with database records as objects.

## Basic Syntax

```tusk
# Define a model
User: @tusk{
    table: "users"
    primary_key: "id"
    fillable: ["name", "email", "password"]
    hidden: ["password", "remember_token"]
    timestamps: true
}

# Create new record
user: @User.create({
    name: "John Doe"
    email: "john@example.com"
    password: @hash_password("secret")
})

# Find record
user: @User.find(123)

# Update record
user.name: "Jane Doe"
user.save()
```

## Model Definition

```tusk
# Complete model example
Product: @tusk{
    table: "products"
    primary_key: "id"
    
    # Mass assignment protection
    fillable: ["name", "description", "price", "category_id"]
    guarded: ["id", "created_at", "updated_at"]
    
    # Hide sensitive fields
    hidden: ["cost", "supplier_id"]
    
    # Automatic timestamps
    timestamps: true  # created_at, updated_at
    
    # Soft deletes
    soft_deletes: true  # deleted_at
    
    # Type casting
    casts: {
        price: "float"
        active: "boolean"
        metadata: "json"
        published_at: "datetime"
    }
    
    # Default values
    defaults: {
        active: true
        price: 0.00
        views: 0
    }
}
```

## CRUD Operations

```tusk
# Create
# Method 1: Using create()
product: @Product.create({
    name: "Laptop"
    description: "High-performance laptop"
    price: 999.99
    category_id: 5
})

# Method 2: Using new() and save()
product: @Product.new()
product.name: "Tablet"
product.price: 299.99
product.save()

# Read
# Find by primary key
product: @Product.find(1)

# Find with exception if not found
product: @Product.findOrFail(1)

# Find by attributes
user: @User.findBy("email", "john@example.com")

# First record
first_user: @User.first()

# Update
# Method 1: Direct update
product: @Product.find(1)
product.price: 899.99
product.save()

# Method 2: Mass update
@Product.update(1, {
    price: 899.99
    description: "Updated description"
})

# Delete
# Soft delete (if enabled)
product.delete()

# Force delete
product.forceDelete()

# Restore soft deleted
product.restore()
```

## Querying

```tusk
# All records
products: @Product.all()

# Where conditions
active_products: @Product.where("active", true).get()

# Multiple conditions
products: @Product
    .where("price", ">", 100)
    .where("category_id", 5)
    .get()

# Or where
products: @Product
    .where("category_id", 1)
    .orWhere("category_id", 2)
    .get()

# Where in
products: @Product.whereIn("id", [1, 2, 3, 4, 5]).get()

# Where between
products: @Product.whereBetween("price", [100, 500]).get()

# Like queries
products: @Product.where("name", "like", "%laptop%").get()

# Ordering
products: @Product.orderBy("price", "desc").get()

# Limiting
top_products: @Product.orderBy("sales", "desc").limit(10).get()

# Pagination
page: @request.get.page|1
products: @Product.paginate(20, @page)
```

## Relationships

```tusk
# Define relationships
User: @tusk{
    table: "users"
    
    # Has many posts
    posts: @hasMany("Post", "user_id")
    
    # Has one profile
    profile: @hasOne("Profile", "user_id")
    
    # Belongs to many roles
    roles: @belongsToMany("Role", "user_roles", "user_id", "role_id")
}

Post: @tusk{
    table: "posts"
    
    # Belongs to user
    user: @belongsTo("User", "user_id")
    
    # Has many comments
    comments: @hasMany("Comment", "post_id")
    
    # Has many tags through pivot
    tags: @belongsToMany("Tag", "post_tags", "post_id", "tag_id")
}

# Using relationships
user: @User.find(1)
user_posts: user.posts()

# Eager loading
users: @User.with(["posts", "profile"]).get()

# Lazy eager loading
user: @User.find(1)
user.load("posts")

# Query relationships
users_with_posts: @User.has("posts").get()
users_with_many_posts: @User.has("posts", ">", 5).get()
```

## Scopes

```tusk
# Define scopes
Product: @tusk{
    table: "products"
    
    # Scope methods
    scopes: {
        active: (query) => {
            query.where("active", true)
        }
        
        expensive: (query) => {
            query.where("price", ">", 1000)
        }
        
        inCategory: (query, category_id) => {
            query.where("category_id", @category_id)
        }
    }
}

# Using scopes
active_products: @Product.active().get()
expensive_active: @Product.active().expensive().get()
category_products: @Product.inCategory(5).active().get()
```

## Accessors and Mutators

```tusk
User: @tusk{
    table: "users"
    
    # Accessors (getters)
    accessors: {
        full_name: (user) => {
            return @user.first_name + " " + @user.last_name
        }
        
        avatar_url: (user) => {
            return @user.avatar ?: "/images/default-avatar.png"
        }
    }
    
    # Mutators (setters)
    mutators: {
        password: (value) => {
            return @hash_password(@value)
        }
        
        email: (value) => {
            return @strtolower(@value)
        }
    }
}

# Usage
user: @User.find(1)
name: user.full_name  # Accessor
user.password: "newpass"  # Mutator applies hash
```

## Events

```tusk
# Model events
User: @tusk{
    table: "users"
    
    # Event handlers
    events: {
        creating: (user) => {
            user.uuid: @generate_uuid()
            user.api_key: @generate_api_key()
        }
        
        created: (user) => {
            @send_welcome_email(@user)
            @log_activity("user_created", @user.id)
        }
        
        updating: (user) => {
            user.updated_by: @session.user_id
        }
        
        deleting: (user) => {
            # Clean up related data
            @delete_user_files(@user.id)
        }
    }
}
```

## Validation

```tusk
# Model validation
User: @tusk{
    table: "users"
    
    # Validation rules
    rules: {
        name: "required|string|max:255"
        email: "required|email|unique:users,email"
        password: "required|min:8"
        age: "integer|min:18|max:120"
    }
    
    # Custom validation messages
    messages: {
        email.unique: "This email is already registered"
        age.min: "You must be at least 18 years old"
    }
}

# Validate before saving
user: @User.new({
    name: @request.post.name
    email: @request.post.email
    password: @request.post.password
})

@if(user.validate()) {
    user.save()
    success: "User created successfully"
} else {
    errors: user.errors()
}
```

## Advanced Queries

```tusk
# Raw expressions
products: @Product
    .select(["*", @raw("(price * 0.9) as sale_price")])
    .where(@raw("YEAR(created_at) = ?", [@current_year]))
    .get()

# Joins
orders: @Order
    .join("users", "orders.user_id", "=", "users.id")
    .join("products", "orders.product_id", "=", "products.id")
    .select([
        "orders.*",
        "users.name as user_name",
        "products.name as product_name"
    ])
    .get()

# Aggregates
stats: {
    total: @Product.count()
    average_price: @Product.average("price")
    max_price: @Product.max("price")
    min_price: @Product.min("price")
    total_value: @Product.sum("price * stock")
}

# Group by
sales_by_category: @Product
    .select(["category_id", @raw("SUM(sales) as total_sales")])
    .groupBy("category_id")
    .having("total_sales", ">", 1000)
    .get()
```

## Caching

```tusk
# Cache query results
Product: @tusk{
    table: "products"
    
    # Cache configuration
    cache: {
        enabled: true
        ttl: 3600  # 1 hour
        prefix: "product"
    }
}

# Cached queries
products: @Product.remember(3600).where("active", true).get()

# Clear cache on update
Product: @tusk{
    events: {
        saved: (product) => {
            @cache.forget("products:all")
            @cache.forget("product:" + @product.id)
        }
    }
}
```

## Batch Operations

```tusk
# Insert multiple records
products_data: [
    {name: "Product 1", price: 10.00},
    {name: "Product 2", price: 20.00},
    {name: "Product 3", price: 30.00}
]

@Product.insert(@products_data)

# Update multiple records
@Product
    .whereIn("id", [1, 2, 3])
    .update({
        active: false,
        updated_at: @now()
    })

# Delete multiple records
@Product.destroy([4, 5, 6])

# Chunk processing for large datasets
@Product.chunk(100, (products) => {
    @foreach(@products as @product) {
        # Process each product
        @process_product(@product)
    }
})
```

## Best Practices

1. **Use fillable/guarded** - Protect against mass assignment
2. **Hide sensitive data** - Use hidden array for passwords, etc.
3. **Validate data** - Always validate before saving
4. **Use relationships** - More efficient than manual joins
5. **Cache frequently accessed data** - Improve performance
6. **Use scopes** - Make queries reusable and readable

## Related Features

- `@query()` - Raw database queries
- `@transaction()` - Database transactions
- `@cache` - Query caching
- `@validate()` - Data validation
- `@paginate()` - Result pagination
---

[@cache - Caching System]


The `@cache` operator provides a powerful caching layer for improving application performance by storing frequently accessed data in memory.

## Basic Syntax

```tusk
# Store value in cache
@cache.set("key", "value")

# Get value from cache
value: @cache.get("key")

# Store with expiration (seconds)
@cache.set("user:123", @user_data, 3600)  # 1 hour

# Get with default fallback
value: @cache.get("key", "default value")

# Delete from cache
@cache.delete("key")

# Clear entire cache
@cache.flush()
```

## Cache Stores

```tusk
# Different cache stores
memory_cache: @cache.store("memory")     # In-memory (default)
redis_cache: @cache.store("redis")       # Redis backend
file_cache: @cache.store("file")         # File-based
memcached: @cache.store("memcached")     # Memcached

# Use specific store
@redis_cache.set("key", "value", 3600)
value: @redis_cache.get("key")
```

## Caching Patterns

```tusk
# Cache-aside pattern
get_user: (id) => {
    cache_key: "user:" + @id
    
    # Try cache first
    user: @cache.get(@cache_key)
    
    @if(!@user) {
        # Cache miss - load from database
        user: @query("SELECT * FROM users WHERE id = ?", [@id])
        
        @if(@user) {
            # Store in cache for 1 hour
            @cache.set(@cache_key, @user, 3600)
        }
    }
    
    return @user
}

# Remember pattern
products: @cache.remember("products:active", 3600, () => {
    # This closure runs only on cache miss
    return @query("SELECT * FROM products WHERE active = 1")
})
```

## Cache Tags

```tusk
# Tag-based caching
@cache.tags(["products", "homepage"]).set("featured_products", @products, 3600)

# Get tagged cache
products: @cache.tags(["products"]).get("featured_products")

# Flush by tag
@cache.tags(["products"]).flush()  # Clears all product caches

# Multiple tags
@cache.tags(["user:123", "posts"]).set("user_posts", @posts)

# Clear specific user's caches
@cache.tags(["user:123"]).flush()
```

## Cache Invalidation

```tusk
# Update product and clear related caches
update_product: (id, data) => {
    # Update database
    @query("UPDATE products SET ? WHERE id = ?", [@data, @id])
    
    # Clear specific caches
    @cache.delete("product:" + @id)
    @cache.delete("products:all")
    @cache.tags(["products", "category:" + @data.category_id]).flush()
    
    # Clear page caches
    @cache.delete("page:home")
    @cache.delete("page:category:" + @data.category_id)
}

# Time-based invalidation
@cache.set("stats:daily", @daily_stats, @seconds_until_midnight())

# Event-based invalidation
on_order_placed: (order) => {
    # Clear product stock cache
    @cache.delete("product:stock:" + @order.product_id)
    
    # Clear user order cache
    @cache.delete("user:orders:" + @order.user_id)
    
    # Update counters
    @cache.increment("stats:orders:today")
}
```

## Atomic Operations

```tusk
# Increment/decrement
@cache.increment("page_views")
@cache.increment("product:views:123", 1)
@cache.decrement("stock:product:456", 1)

# Atomic add (only if doesn't exist)
@if(@cache.add("lock:process", 1, 60)) {
    # Got the lock, process...
    @do_exclusive_operation()
    @cache.delete("lock:process")
} else {
    # Another process has the lock
    error: "Process already running"
}

# Compare and swap
current: @cache.get("counter")
@cache.cas("counter", @current, @current + 1)
```

## Cache Warming

```tusk
# Warm cache on startup
warm_cache: {
    # Pre-load frequently accessed data
    categories: @query("SELECT * FROM categories WHERE active = 1")
    @cache.set("categories:all", @categories, 86400)  # 24 hours
    
    # Pre-load configuration
    config: @load_config()
    @cache.set("app:config", @config, 3600)
    
    # Pre-generate expensive computations
    @foreach(@categories as @category) {
        products: @query("SELECT * FROM products WHERE category_id = ?", [@category.id])
        @cache.set("products:category:" + @category.id, @products, 3600)
    }
}

# Scheduled cache warming
#cron "0 * * * *" {
    # Refresh cache every hour
    @warm_popular_products_cache()
    @warm_user_stats_cache()
}
```

## Distributed Caching

```tusk
# Configure distributed cache
cache_config: {
    default: "redis"
    stores: {
        redis: {
            driver: "redis"
            host: @env.REDIS_HOST|"localhost"
            port: @env.REDIS_PORT|6379
            database: 0
            prefix: @env.APP_NAME + ":"
        }
    }
}

# Cache with namespacing
app_cache: @cache.namespace(@env.APP_NAME)
@app_cache.set("settings", @settings)

# Cache across servers
session_cache: @cache.store("redis").namespace("sessions")
@session_cache.set(@session_id, @session_data, 1800)  # 30 minutes
```

## Query Result Caching

```tusk
# Cache database queries
get_products: (category_id, page: 1) => {
    cache_key: "products:cat:" + @category_id + ":page:" + @page
    
    return @cache.remember(@cache_key, 3600, () => {
        return @query("
            SELECT * FROM products 
            WHERE category_id = ? 
            ORDER BY created_at DESC 
            LIMIT ?, 20
        ", [@category_id, (@page - 1) * 20])
    })
}

# Cache with dependencies
get_product_with_reviews: (id) => {
    product: @cache.remember("product:" + @id, 3600, () => {
        return @query("SELECT * FROM products WHERE id = ?", [@id])
    })
    
    reviews: @cache.remember("reviews:product:" + @id, 1800, () => {
        return @query("SELECT * FROM reviews WHERE product_id = ?", [@id])
    })
    
    return {
        product: @product
        reviews: @reviews
    }
}
```

## Page Caching

```tusk
# Full page caching
#web /page/{slug} {
    cache_key: "page:" + @slug + ":" + @request.query_string
    
    # Check cache
    cached_html: @cache.get(@cache_key)
    
    @if(@cached_html) {
        @response.headers.x-cache: "HIT"
        @output(@cached_html)
        return
    }
    
    # Generate page
    page: @query("SELECT * FROM pages WHERE slug = ?", [@slug])
    html: @render("page.tusk", {page: @page})
    
    # Cache for 1 hour
    @cache.set(@cache_key, @html, 3600)
    
    @response.headers.x-cache: "MISS"
    @output(@html)
}
```

## Fragment Caching

```tusk
# In templates
<div class="sidebar">
    {@cache.remember("sidebar:user:" + @user.id, 1800, () => {
        return @render("partials/user_sidebar.tusk", {user: @user})
    })}
</div>

<div class="products">
    @foreach(@categories as @category) {
        {@cache.remember("category:box:" + @category.id, 3600, () => {
            return @render("partials/category_box.tusk", {
                category: @category,
                products: @get_category_products(@category.id, 5)
            })
        })}
    }
</div>
```

## Cache Monitoring

```tusk
# Cache statistics
cache_stats: {
    # Get cache statistics
    stats: @cache.stats()
    
    # Monitor hit rate
    hits: @stats.hits
    misses: @stats.misses
    hit_rate: @hits / (@hits + @misses) * 100
    
    # Memory usage
    memory_used: @stats.memory_used
    memory_limit: @stats.memory_limit
    memory_percent: @memory_used / @memory_limit * 100
}

# Log cache performance
#middleware cache_monitor {
    start: @microtime(true)
    
    # Process request...
    
    duration: @microtime(true) - @start
    
    @if(@duration > 0.1) {  # Log slow cache operations
        @log.warning("Slow cache operation", {
            duration: @duration,
            key: @cache_key,
            operation: @cache_operation
        })
    }
}
```

## Cache Configuration

```tusk
# Application cache configuration
cache: {
    # Default TTLs by type
    ttl: {
        default: 3600        # 1 hour
        user: 1800          # 30 minutes  
        product: 7200       # 2 hours
        static: 86400       # 24 hours
        session: 1800       # 30 minutes
    }
    
    # Size limits
    limits: {
        max_key_length: 250
        max_value_size: 1048576  # 1MB
        max_entries: 10000
    }
    
    # Eviction policy
    eviction: "lru"  # Least Recently Used
}

# Helper for consistent TTLs
cache_ttl: (type: "default") => {
    return @cache.ttl[@type]|@cache.ttl.default
}

# Usage
@cache.set("user:" + @id, @user, @cache_ttl("user"))
```

## Best Practices

1. **Use consistent key naming** - Establish naming conventions
2. **Set appropriate TTLs** - Balance freshness vs performance
3. **Handle cache misses gracefully** - Always have fallback logic
4. **Invalidate related caches** - Keep data consistent
5. **Monitor cache performance** - Track hit rates and memory usage
6. **Use cache tags** - Easier bulk invalidation

## Related Features

- `@remember()` - Cache helper function
- `@cache.tags()` - Tagged caching
- `@cache.lock()` - Cache-based locking
- `@redis` - Redis client
- `@memcached` - Memcached client
---

[@metrics - Performance and Business Metrics]


The `@metrics` operator provides comprehensive application monitoring, tracking both technical performance and business KPIs in real-time.

## Basic Syntax

```tusk
# Record a metric
@metrics.record("page_views", 1)

# Record with tags
@metrics.record("api_calls", 1, {
    endpoint: "/users"
    method: "GET"
    status: 200
})

# Timing metrics
@metrics.time("database_query", () => {
    return @query("SELECT * FROM users")
})

# Gauge (current value)
@metrics.gauge("active_users", @count_active_users())

# Histogram (distribution)
@metrics.histogram("response_time", @request_duration)
```

## Performance Tracking

```tusk
# Request timing middleware
#middleware performance_tracking {
    start_time: @microtime(true)
    start_memory: @memory_get_usage()
    
    # Process request
    @next()
    
    # Record metrics
    duration: @microtime(true) - @start_time
    memory_used: @memory_get_usage() - @start_memory
    
    @metrics.histogram("request_duration", @duration, {
        method: @request.method
        endpoint: @request.route
        status: @response.status
    })
    
    @metrics.histogram("memory_usage", @memory_used, {
        endpoint: @request.route
    })
    
    # Alert on slow requests
    @if(@duration > 1.0) {
        @metrics.increment("slow_requests", {
            endpoint: @request.route
        })
        @log.warning("Slow request", {
            duration: @duration
            endpoint: @request.route
        })
    }
}
```

## Business Metrics

```tusk
# E-commerce metrics
track_purchase: (order) => {
    # Revenue metric
    @metrics.increment("revenue", @order.total, {
        currency: @order.currency
        payment_method: @order.payment_method
        customer_type: @order.is_new_customer ? "new" : "returning"
    })
    
    # Order metrics
    @metrics.increment("orders", 1, {
        status: "completed"
        source: @order.source
    })
    
    # Average order value
    @metrics.gauge("average_order_value", 
        @calculate_average_order_value())
    
    # Items per order
    @metrics.histogram("items_per_order", 
        @count(@order.items))
}

# User engagement
track_user_action: (action, user_id) => {
    @metrics.increment("user_actions", 1, {
        action: @action
        user_segment: @get_user_segment(@user_id)
    })
    
    # Daily active users
    @metrics.set("daily_active_users", @user_id)
    
    # Session duration
    @if(@action == "logout") {
        duration: @time() - @session.start_time
        @metrics.histogram("session_duration", @duration)
    }
}
```

## Real-time Dashboards

```tusk
# Dashboard metrics endpoint
#api /metrics/dashboard {
    period: @request.get.period|"hour"
    
    metrics: {
        # Current values
        current: {
            active_users: @metrics.gauge_value("active_users")
            requests_per_minute: @metrics.rate("requests", "minute")
            error_rate: @metrics.error_rate()
            response_time_p95: @metrics.percentile("response_time", 95)
        }
        
        # Time series data
        timeseries: {
            requests: @metrics.timeseries("requests", @period, 24)
            errors: @metrics.timeseries("errors", @period, 24)
            response_times: @metrics.timeseries("response_time", @period, 24)
        }
        
        # Top endpoints
        top_endpoints: @metrics.top("requests", "endpoint", 10)
        slowest_endpoints: @metrics.top("response_time", "endpoint", 10)
        
        # Business metrics
        business: {
            revenue_today: @metrics.sum("revenue", "today")
            orders_today: @metrics.count("orders", "today")
            conversion_rate: @calculate_conversion_rate()
            cart_abandonment_rate: @calculate_abandonment_rate()
        }
    }
    
    @json(@metrics)
}
```

## Custom Metrics

```tusk
# Define custom metric types
Metrics: {
    # Counter - only goes up
    counter: (name, increment: 1, tags: {}) => {
        @metrics.increment(@name, @increment, @tags)
    }
    
    # Timer - tracks durations
    timer: (name, start_time, tags: {}) => {
        duration: @microtime(true) - @start_time
        @metrics.histogram(@name, @duration, @tags)
        return @duration
    }
    
    # Rate - tracks frequency
    rate: (name, tags: {}) => {
        @metrics.increment(@name + "_total", 1, @tags)
        @metrics.gauge(@name + "_rate", 
            @calculate_rate(@name), @tags)
    }
}

# Usage
@Metrics.counter("user_registrations", 1, {source: "web"})
@Metrics.timer("api_call_duration", @start_time, {endpoint: "/users"})
@Metrics.rate("uploads", {type: "image"})
```

## Error Tracking

```tusk
# Error metrics
track_error: (error, context: {}) => {
    @metrics.increment("errors", 1, {
        type: @error.type|"unknown"
        code: @error.code|500
        file: @error.file
        line: @error.line
        endpoint: @context.endpoint
    })
    
    # Error rate by endpoint
    @metrics.rate("error_rate", {
        endpoint: @context.endpoint
    })
    
    # Alert on error spike
    error_rate: @metrics.get_rate("errors", "minute")
    @if(@error_rate > 10) {
        @alert("High error rate detected", {
            rate: @error_rate
            endpoint: @context.endpoint
        })
    }
}

# Exception handler
#middleware error_tracking {
    @try {
        @next()
    } catch (error) {
        @track_error(@error, {
            endpoint: @request.route
            user_id: @session.user_id
        })
        @throw @error  # Re-throw
    }
}
```

## Database Metrics

```tusk
# Query performance tracking
db_metrics: {
    # Before query
    before_query: (sql) => {
        query_id: @generate_id()
        @metrics.queries[@query_id]: {
            sql: @sql
            start: @microtime(true)
        }
        return @query_id
    }
    
    # After query
    after_query: (query_id, result) => {
        query: @metrics.queries[@query_id]
        duration: @microtime(true) - @query.start
        
        @metrics.histogram("db_query_time", @duration, {
            table: @extract_table_name(@query.sql)
            operation: @extract_operation(@query.sql)
        })
        
        # Slow query logging
        @if(@duration > 0.1) {
            @metrics.increment("slow_queries")
            @log.warning("Slow query", {
                sql: @query.sql
                duration: @duration
            })
        }
        
        delete @metrics.queries[@query_id]
    }
}
```

## API Metrics

```tusk
# API usage tracking
#middleware api_metrics {
    # API key metrics
    api_key: @request.headers.x-api-key
    
    @if(@api_key) {
        @metrics.increment("api_usage", 1, {
            api_key: @hash_api_key(@api_key)
            endpoint: @request.route
            method: @request.method
        })
        
        # Rate limiting metrics
        rate_limit: @get_rate_limit(@api_key)
        usage: @get_api_usage(@api_key)
        
        @metrics.gauge("api_rate_limit_usage", 
            @usage / @rate_limit * 100, {
                api_key: @hash_api_key(@api_key)
            })
    }
    
    @next()
    
    # Response metrics
    @metrics.increment("api_responses", 1, {
        status: @response.status
        endpoint: @request.route
    })
}
```

## Cache Metrics

```tusk
# Cache performance tracking
cache_metrics: {
    on_hit: (key) => {
        @metrics.increment("cache_hits", 1, {
            cache: "redis"
            key_prefix: @get_key_prefix(@key)
        })
    }
    
    on_miss: (key) => {
        @metrics.increment("cache_misses", 1, {
            cache: "redis"
            key_prefix: @get_key_prefix(@key)
        })
    }
    
    on_set: (key, size) => {
        @metrics.histogram("cache_item_size", @size, {
            key_prefix: @get_key_prefix(@key)
        })
    }
    
    # Calculate hit rate
    hit_rate: () => {
        hits: @metrics.sum("cache_hits", "hour")
        misses: @metrics.sum("cache_misses", "hour")
        return @hits / (@hits + @misses) * 100
    }
}
```

## Alerting

```tusk
# Define alert rules
alert_rules: [
    {
        name: "High Error Rate"
        condition: () => @metrics.rate("errors", "minute") > 10
        action: (data) => @send_alert("error_rate", @data)
    },
    {
        name: "Low Conversion Rate"
        condition: () => @metrics.gauge_value("conversion_rate") < 1.0
        action: (data) => @send_alert("conversion_rate", @data)
    },
    {
        name: "High Response Time"
        condition: () => @metrics.percentile("response_time", 95) > 2.0
        action: (data) => @send_alert("response_time", @data)
    }
]

# Check alerts
#cron "* * * * *" {
    @foreach(@alert_rules as @rule) {
        @if(@rule.condition()) {
            @rule.action({
                rule: @rule.name
                timestamp: @timestamp
                value: @rule.condition()
            })
        }
    }
}
```

## Exporting Metrics

```tusk
# Prometheus format export
#api /metrics/export {
    format: @request.get.format|"prometheus"
    
    @if(@format == "prometheus") {
        output: @metrics.export_prometheus()
        @response.headers.content-type: "text/plain"
        @output(@output)
    } elseif(@format == "json") {
        @json(@metrics.export_json())
    } else {
        @response.status: 400
        error: "Unsupported format"
    }
}

# StatsD integration
statsd_export: {
    host: @env.STATSD_HOST|"localhost"
    port: @env.STATSD_PORT|8125
    
    @foreach(@metrics.get_all() as @metric) {
        @statsd.send(@metric.name, @metric.value, @metric.type)
    }
}
```

## Performance Optimization

```tusk
# Batch metrics recording
metrics_buffer: []

# Add to buffer instead of immediate send
buffer_metric: (type, name, value, tags) => {
    @metrics_buffer[]: {
        type: @type
        name: @name
        value: @value
        tags: @tags
        timestamp: @time()
    }
    
    # Flush if buffer is full
    @if(@count(@metrics_buffer) >= 100) {
        @flush_metrics()
    }
}

# Flush metrics periodically
#cron "* * * * *" {
    @flush_metrics()
}

flush_metrics: () => {
    @if(@count(@metrics_buffer) > 0) {
        @metrics.batch(@metrics_buffer)
        @metrics_buffer: []
    }
}
```

## Best Practices

1. **Use consistent naming** - Follow naming conventions for metrics
2. **Add relevant tags** - Enable filtering and grouping
3. **Avoid high cardinality** - Don't use unique IDs as tags
4. **Set up alerts** - Monitor critical metrics
5. **Regular cleanup** - Archive old metrics data
6. **Performance impact** - Minimize metrics overhead

## Related Features

- `@monitor` - Application monitoring
- `@log` - Logging system
- `@alert` - Alert management
- `@analytics` - User analytics
- `@performance` - Performance profiling
---

[@learn() - Machine Learning Integration]


The `@learn()` function provides built-in machine learning capabilities, enabling pattern recognition, predictions, and intelligent automation directly within TuskLang.

## Basic Syntax

```tusk
# Train a model
model: @learn.train("classifier", @training_data, {
    features: ["age", "income", "history"]
    target: "approved"
})

# Make predictions
prediction: @model.predict({
    age: 25
    income: 50000
    history: "good"
})

# Confidence score
confidence: @prediction.confidence
result: @prediction.class
```

## Classification

```tusk
# Customer churn prediction
churn_model: @learn.train("classifier", {
    data: @query("SELECT * FROM customer_history")
    features: [
        "months_active",
        "total_purchases", 
        "avg_order_value",
        "support_tickets",
        "last_login_days"
    ]
    target: "churned"
    algorithm: "random_forest"
    split: 0.8  # 80% training, 20% testing
})

# Predict churn risk
#api /customers/{id}/churn-risk {
    customer: @query("SELECT * FROM customers WHERE id = ?", [@id])
    
    risk: @churn_model.predict({
        months_active: @customer.months_active
        total_purchases: @customer.total_purchases
        avg_order_value: @customer.avg_order_value
        support_tickets: @customer.support_tickets
        last_login_days: @days_since(@customer.last_login)
    })
    
    @json({
        customer_id: @id
        churn_probability: @risk.probability
        risk_level: @risk.probability > 0.7 ? "high" : 
                   @risk.probability > 0.4 ? "medium" : "low"
        factors: @risk.feature_importance
    })
}
```

## Regression

```tusk
# Price prediction model
price_model: @learn.train("regression", {
    data: @query("SELECT * FROM products WHERE price IS NOT NULL")
    features: [
        "category_id",
        "brand_popularity",
        "features_count",
        "weight",
        "competitor_avg_price"
    ]
    target: "price"
    algorithm: "gradient_boosting"
})

# Suggest pricing
#api /products/suggest-price {
    features: @request.post
    
    prediction: @price_model.predict(@features)
    
    @json({
        suggested_price: @round(@prediction.value, 2)
        confidence_interval: {
            low: @round(@prediction.lower_bound, 2)
            high: @round(@prediction.upper_bound, 2)
        }
        similar_products: @find_similar_products(@features)
    })
}
```

## Clustering

```tusk
# Customer segmentation
segmentation_model: @learn.train("clustering", {
    data: @query("
        SELECT 
            customer_id,
            avg_order_value,
            order_frequency,
            total_spent,
            categories_purchased
        FROM customer_analytics
    ")
    features: ["avg_order_value", "order_frequency", "total_spent"]
    algorithm: "kmeans"
    clusters: 5
})

# Assign customer to segment
#api /customers/{id}/segment {
    customer: @get_customer_analytics(@id)
    
    segment: @segmentation_model.predict({
        avg_order_value: @customer.avg_order_value
        order_frequency: @customer.order_frequency
        total_spent: @customer.total_spent
    })
    
    # Get segment characteristics
    segment_info: @segmentation_model.cluster_centers[@segment.cluster]
    
    @json({
        customer_id: @id
        segment: @segment.cluster
        segment_name: @get_segment_name(@segment.cluster)
        characteristics: @segment_info
        marketing_recommendations: @get_marketing_strategy(@segment.cluster)
    })
}
```

## Recommendation Engine

```tusk
# Collaborative filtering
recommendation_model: @learn.train("recommender", {
    interactions: @query("
        SELECT user_id, product_id, rating 
        FROM reviews 
        WHERE rating IS NOT NULL
    ")
    algorithm: "matrix_factorization"
    factors: 50
})

# Get recommendations
#api /users/{id}/recommendations {
    limit: @request.get.limit|10
    
    # Get user's purchase history
    purchased: @query("
        SELECT DISTINCT product_id 
        FROM orders 
        WHERE user_id = ?
    ", [@id])
    
    # Get recommendations
    recommendations: @recommendation_model.recommend(@id, {
        exclude: @purchased
        limit: @limit
    })
    
    # Enhance with product details
    products: @query("
        SELECT * FROM products 
        WHERE id IN (?)
    ", [@recommendations.map(r => r.product_id)])
    
    @json({
        user_id: @id
        recommendations: @products.map((product, index) => {
            score: @recommendations[@index].score
            product: @product
            reason: @get_recommendation_reason(@id, @product.id)
        })
    })
}
```

## Natural Language Processing

```tusk
# Sentiment analysis
sentiment_model: @learn.load("sentiment_analysis")

# Analyze reviews
#api /products/{id}/sentiment {
    reviews: @query("
        SELECT review_text, rating 
        FROM reviews 
        WHERE product_id = ?
    ", [@id])
    
    sentiments: @reviews.map(review => {
        analysis: @sentiment_model.analyze(@review.review_text)
        return {
            text: @review.review_text
            rating: @review.rating
            sentiment: @analysis.sentiment  # positive, negative, neutral
            confidence: @analysis.confidence
            keywords: @analysis.keywords
        }
    })
    
    # Aggregate results
    summary: {
        total_reviews: @count(@reviews)
        positive: @sentiments.filter(s => s.sentiment == "positive").length
        negative: @sentiments.filter(s => s.sentiment == "negative").length
        neutral: @sentiments.filter(s => s.sentiment == "neutral").length
        average_confidence: @average(@sentiments.map(s => s.confidence))
    }
    
    @json({
        product_id: @id
        summary: @summary
        recent_sentiments: @sentiments.slice(0, 5)
    })
}
```

## Time Series Forecasting

```tusk
# Sales forecasting
forecast_model: @learn.train("timeseries", {
    data: @query("
        SELECT date, total_sales 
        FROM daily_sales 
        ORDER BY date
    ")
    algorithm: "prophet"
    seasonality: ["weekly", "yearly"]
})

# Generate forecast
#api /forecast/sales {
    days: @request.get.days|30
    
    forecast: @forecast_model.predict(@days)
    
    @json({
        forecast: @forecast.map(day => {
            date: @day.date
            predicted_sales: @round(@day.value, 2)
            lower_bound: @round(@day.lower, 2)
            upper_bound: @round(@day.upper, 2)
        })
        total_predicted: @sum(@forecast.map(d => d.value))
        trend: @forecast_model.trend
        seasonality: @forecast_model.seasonality_components
    })
}
```

## Anomaly Detection

```tusk
# Fraud detection
fraud_model: @learn.train("anomaly_detection", {
    data: @query("
        SELECT * FROM transactions 
        WHERE fraud_label IS NOT NULL
    ")
    features: [
        "amount",
        "merchant_category",
        "time_since_last_transaction",
        "distance_from_home",
        "unusual_time"
    ]
    algorithm: "isolation_forest"
    contamination: 0.01  # Expected 1% fraud rate
})

# Real-time fraud detection
#api /transactions/check {
    transaction: @request.post
    
    # Enhance with calculated features
    features: {
        ...@transaction,
        time_since_last: @calculate_time_since_last(@transaction.user_id),
        distance_from_home: @calculate_distance(@transaction.location),
        unusual_time: @is_unusual_time(@transaction.timestamp)
    }
    
    result: @fraud_model.predict(@features)
    
    @if(@result.is_anomaly) {
        # Flag for review
        @query("
            INSERT INTO fraud_alerts (transaction_id, score, features)
            VALUES (?, ?, ?)
        ", [@transaction.id, @result.score, @json_encode(@features)])
        
        # Send alert
        @send_fraud_alert(@transaction)
    }
    
    @json({
        transaction_id: @transaction.id
        is_suspicious: @result.is_anomaly
        risk_score: @result.score
        risk_factors: @result.contributing_features
        action: @result.is_anomaly ? "review_required" : "approved"
    })
}
```

## Model Management

```tusk
# Model versioning and deployment
model_registry: {
    # Save model
    save: (name, model, metadata) => {
        version: @generate_version()
        
        @query("
            INSERT INTO ml_models (name, version, model_data, metadata)
            VALUES (?, ?, ?, ?)
        ", [@name, @version, @serialize(@model), @json_encode(@metadata)])
        
        return @version
    }
    
    # Load specific version
    load: (name, version: null) => {
        @if(@version) {
            model_data: @query("
                SELECT model_data FROM ml_models 
                WHERE name = ? AND version = ?
            ", [@name, @version])
        } else {
            # Load latest
            model_data: @query("
                SELECT model_data FROM ml_models 
                WHERE name = ? 
                ORDER BY created_at DESC 
                LIMIT 1
            ", [@name])
        }
        
        return @deserialize(@model_data.model_data)
    }
    
    # A/B testing models
    ab_test: (name, traffic_split: 0.5) => {
        models: @query("
            SELECT version FROM ml_models 
            WHERE name = ? AND active = 1 
            ORDER BY created_at DESC 
            LIMIT 2
        ", [@name])
        
        # Randomly assign model based on traffic split
        use_new_model: @random() < @traffic_split
        
        return @use_new_model ? @models[0] : @models[1]
    }
}
```

## AutoML

```tusk
# Automatic model selection and tuning
automl: @learn.auto({
    data: @training_data
    target: "conversion"
    task: "classification"
    time_budget: 300  # 5 minutes
    metric: "auc"
})

# Best model is automatically selected
best_model: @automl.best_model
results: @automl.leaderboard

# Deploy best model
@model_registry.save("conversion_predictor", @best_model, {
    performance: @results[0],
    features: @automl.feature_importance,
    training_date: @timestamp
})
```

## Real-time Learning

```tusk
# Online learning for personalization
personalization_model: @learn.online("contextual_bandit")

# Learn from user interactions
#api /content/interact {
    user_id: @request.post.user_id
    content_id: @request.post.content_id
    action: @request.post.action  # click, ignore, share, etc.
    
    # Update model with feedback
    reward: @calculate_reward(@action)
    @personalization_model.update(@user_id, @content_id, @reward)
    
    # Store for batch retraining
    @query("
        INSERT INTO interactions (user_id, content_id, action, reward)
        VALUES (?, ?, ?, ?)
    ", [@user_id, @content_id, @action, @reward])
}

# Get personalized content
#api /content/personalized/{user_id} {
    available_content: @get_available_content()
    
    # Get personalized ranking
    rankings: @personalization_model.rank(@user_id, @available_content)
    
    @json({
        user_id: @user_id
        recommendations: @rankings.slice(0, 10)
        exploration_rate: @personalization_model.exploration_rate
    })
}
```

## Best Practices

1. **Data quality** - Clean and preprocess data properly
2. **Feature engineering** - Create meaningful features
3. **Model validation** - Use proper train/test splits
4. **Monitor performance** - Track model accuracy over time
5. **Retrain regularly** - Keep models up to date
6. **Explain predictions** - Provide interpretability

## Related Features

- `@analyze()` - Data analysis
- `@optimize()` - Optimization algorithms
- `@metrics` - Performance tracking
- `@experiment()` - A/B testing
- `@pipeline()` - Data pipelines
---

[@optimize() - Performance Optimization]


The `@optimize()` function provides intelligent performance optimization, automatically improving code execution, database queries, and resource utilization.

## Basic Syntax

```tusk
# Optimize a function
optimized_fn: @optimize(@my_function)

# Optimize with hints
optimized: @optimize(@slow_function, {
    cache: true
    memoize: true
    parallel: true
})

# Query optimization
optimized_query: @optimize.query(@sql_query)

# Auto-optimize block
@optimize.block {
    # Code here is automatically optimized
    results: @expensive_operation()
}
```

## Function Optimization

```tusk
# Automatic memoization
fibonacci: @optimize.memoize((n) => {
    @if(@n <= 1) return @n
    return @fibonacci(@n - 1) + @fibonacci(@n - 2)
})

# Parallel execution
process_items: @optimize.parallel((items) => {
    return @items.map(item => {
        # Heavy processing per item
        result: @complex_calculation(@item)
        return @result
    })
}, {
    workers: 4
    chunk_size: 100
})

# JIT compilation
hot_function: @optimize.jit((data) => {
    # Frequently called function
    # TuskLang JIT compiles after threshold
    total: 0
    @foreach(@data as @item) {
        total: @total + @item.value * @item.weight
    }
    return @total
})
```

## Query Optimization

```tusk
# Automatic query optimization
get_user_orders: (user_id) => {
    # Original query
    query: "
        SELECT o.*, p.name as product_name, p.price
        FROM orders o
        JOIN products p ON o.product_id = p.id
        WHERE o.user_id = ?
        ORDER BY o.created_at DESC
    "
    
    # Optimize query
    optimized: @optimize.query(@query, {
        analyze: true
        add_indexes: true
        cache_plan: true
    })
    
    return @query(@optimized, [@user_id])
}

# Index recommendations
#api /admin/optimize-database {
    recommendations: @optimize.analyze_database({
        tables: ["orders", "products", "users"]
        workload: @get_recent_queries()
    })
    
    @json({
        missing_indexes: @recommendations.indexes
        slow_queries: @recommendations.slow_queries
        optimization_suggestions: @recommendations.suggestions
        estimated_improvement: @recommendations.impact_percent + "%"
    })
}
```

## Caching Optimization

```tusk
# Intelligent caching
get_product_details: @optimize.cache((product_id) => {
    product: @query("SELECT * FROM products WHERE id = ?", [@product_id])
    reviews: @query("SELECT * FROM reviews WHERE product_id = ?", [@product_id])
    related: @get_related_products(@product_id)
    
    return {
        product: @product
        reviews: @reviews
        related: @related
        computed_score: @calculate_product_score(@product, @reviews)
    }
}, {
    key_pattern: "product:{id}"
    ttl: "adaptive"  # TuskLang adjusts based on access patterns
    invalidate_on: ["product_update", "review_added"]
})

# Cache warming
@optimize.warm_cache({
    patterns: [
        "product:*",
        "category:*",
        "user:preferences:*"
    ],
    strategy: "most_accessed"
    schedule: "0 */4 * * *"  # Every 4 hours
})
```

## Memory Optimization

```tusk
# Memory-efficient data processing
process_large_file: @optimize.memory((file_path) => {
    # Automatically chunks large operations
    results: []
    
    @optimize.stream(@file_path, (chunk) => {
        # Process chunk without loading entire file
        processed: @process_chunk(@chunk)
        @results.push(@processed)
        
        # TuskLang manages memory automatically
    })
    
    return @aggregate_results(@results)
})

# Object pooling
connection_pool: @optimize.pool({
    create: () => @create_database_connection()
    destroy: (conn) => @conn.close()
    validate: (conn) => @conn.is_alive()
    size: 10
    max: 50
})

# Use pooled connection
@connection_pool.use((conn) => {
    return @conn.query("SELECT * FROM users")
})
```

## Algorithm Optimization

```tusk
# Automatic algorithm selection
sort_data: @optimize.algorithm((data) => {
    # TuskLang chooses best sorting algorithm
    # based on data size and characteristics
    return @sort(@data)
}, {
    algorithms: ["quicksort", "mergesort", "radixsort"]
    benchmark: true
})

# Dynamic programming optimization
knapsack: @optimize.dynamic((items, capacity) => {
    # Automatically applies DP optimization
    @if(@capacity == 0 || @items.length == 0) {
        return 0
    }
    
    item: @items[0]
    remaining: @items.slice(1)
    
    @if(@item.weight > @capacity) {
        return @knapsack(@remaining, @capacity)
    }
    
    with_item: @item.value + @knapsack(@remaining, @capacity - @item.weight)
    without_item: @knapsack(@remaining, @capacity)
    
    return @max(@with_item, @without_item)
})
```

## Request Optimization

```tusk
# Batch API requests
batch_fetcher: @optimize.batch((ids) => {
    # Instead of N individual requests
    # TuskLang batches them automatically
    return @fetch_multiple(@ids)
}, {
    max_batch_size: 100
    delay: 10  # ms to wait for more requests
})

# Usage - these get batched
user1: @batch_fetcher(123)
user2: @batch_fetcher(456)
user3: @batch_fetcher(789)

# Request deduplication
get_user: @optimize.dedupe((user_id) => {
    # Multiple simultaneous requests for same ID
    # only result in one actual fetch
    return @query("SELECT * FROM users WHERE id = ?", [@user_id])
})
```

## Lazy Loading

```tusk
# Lazy evaluation
Report: @optimize.lazy({
    # These are only computed when accessed
    summary: () => @calculate_summary()
    details: () => @fetch_detailed_data()
    charts: () => @generate_charts()
    
    # Always computed
    title: "Sales Report"
    date: @today()
})

# Only summary is calculated
@if(@Report.summary.total > 1000) {
    # Now details are fetched
    @send_email(@Report.details)
}
```

## Compilation Optimization

```tusk
# Pre-compile templates
templates: @optimize.precompile({
    "email/welcome": @load_template("email/welcome.tusk")
    "email/reset": @load_template("email/reset.tusk")
    "pages/home": @load_template("pages/home.tusk")
})

# Pre-compile regex patterns
patterns: @optimize.regex({
    email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    phone: /^\+?[\d\s-()]+$/
    url: /^https?:\/\/.+$/
})

# Use pre-compiled
is_valid_email: @patterns.email.test(@email)
```

## Network Optimization

```tusk
# HTTP/2 multiplexing
api_client: @optimize.http({
    base_url: "https://api.example.com"
    connection_pooling: true
    http2: true
    compression: "gzip"
    keepalive: true
})

# Automatic retry with backoff
fetch_with_retry: @optimize.retry((url) => {
    return @http.get(@url)
}, {
    max_attempts: 3
    backoff: "exponential"
    retry_on: [408, 429, 500, 502, 503, 504]
})

# Circuit breaker pattern
external_api: @optimize.circuit_breaker((endpoint) => {
    return @fetch(@endpoint)
}, {
    failure_threshold: 5
    reset_timeout: 60000  # 1 minute
    half_open_requests: 3
})
```

## Database Connection Optimization

```tusk
# Connection pooling with optimization
db: @optimize.database({
    host: @env.DB_HOST
    pool: {
        min: 2
        max: 10
        acquire_timeout: 30000
        idle_timeout: 10000
    }
    query_timeout: 5000
    statement_cache_size: 100
})

# Prepared statement caching
get_user_by_email: @optimize.prepare("
    SELECT * FROM users WHERE email = ?
")

# Use prepared statement (faster)
user: @get_user_by_email(@email)
```

## Profiling and Analysis

```tusk
# Profile code block
@optimize.profile("expensive_operation") {
    data: @load_large_dataset()
    processed: @process_data(@data)
    results: @analyze_results(@processed)
}

# Get profiling results
profile: @optimize.get_profile("expensive_operation")
/*
{
    total_time: 1.234
    memory_peak: 134217728
    breakdown: {
        load_large_dataset: 0.456
        process_data: 0.678  
        analyze_results: 0.100
    }
    suggestions: [
        "Consider caching load_large_dataset results",
        "process_data could benefit from parallelization"
    ]
}
*/

# Continuous profiling
@optimize.watch({
    functions: ["api_handler", "database_query", "render_template"]
    threshold: 100  # ms
    action: (profile) => {
        @if(@profile.duration > @threshold) {
            @log.warning("Slow operation detected", @profile)
            @metrics.record("slow_operation", @profile.duration, {
                function: @profile.function
            })
        }
    }
})
```

## Auto-Scaling

```tusk
# Dynamic resource allocation
worker_pool: @optimize.auto_scale({
    min_workers: 2
    max_workers: 20
    scale_up_threshold: 0.8  # 80% CPU
    scale_down_threshold: 0.2  # 20% CPU
    
    task: (job) => {
        # Process job
        return @process_job(@job)
    }
})

# Submit work - pool scales automatically
@foreach(@jobs as @job) {
    @worker_pool.submit(@job)
}
```

## Best Practices

1. **Measure first** - Profile before optimizing
2. **Set budgets** - Define performance targets
3. **Cache wisely** - Not everything benefits from caching
4. **Monitor impact** - Track optimization effectiveness
5. **Iterate** - Optimization is an ongoing process
6. **Document changes** - Note what was optimized and why

## Related Features

- `@profile()` - Performance profiling
- `@cache` - Caching system
- `@parallel()` - Parallel execution
- `@benchmark()` - Performance testing
- `@metrics` - Performance monitoring
---

[@http.host - HTTP Host Information]


The `@http.host` operator provides access to host and domain information from HTTP requests, useful for multi-tenant applications and domain-based routing.

## Basic Syntax

```tusk
# Get the host header
host: @http.host

# Get specific parts
domain: @http.host.domain
subdomain: @http.host.subdomain
port: @http.host.port
protocol: @http.host.protocol
```

## Host Components

```tusk
# Full host information
host_info: {
    # Full host header (e.g., "app.example.com:8080")
    full: @http.host
    
    # Protocol (http or https)
    protocol: @http.host.protocol
    
    # Domain parts
    subdomain: @http.host.subdomain    # "app"
    domain: @http.host.domain          # "example"
    tld: @http.host.tld                # "com"
    
    # Full domain
    full_domain: @http.host.full_domain  # "example.com"
    
    # Port (if specified)
    port: @http.host.port|80
    
    # Is secure
    is_secure: @http.host.is_secure
}
```

## Multi-Tenant Applications

```tusk
# Subdomain-based tenancy
#web /* {
    tenant_subdomain: @http.host.subdomain
    
    @if(@tenant_subdomain && @tenant_subdomain != "www") {
        # Load tenant configuration
        tenant: @query("SELECT * FROM tenants WHERE subdomain = ?", 
                      [@tenant_subdomain])
        
        @if(@tenant) {
            # Set tenant context
            @context.tenant: @tenant
            @context.database: @tenant.database_name
            
            # Route to tenant app
            @render("tenant/app.tusk", {tenant: @tenant})
        } else {
            @response.status: 404
            @render("errors/tenant_not_found.tusk")
        }
    } else {
        # Main website
        @render("main/home.tusk")
    }
}
```

## Domain-Based Routing

```tusk
# Route based on domain
domain_router: {
    routes: {
        "api.example.com": "/api/handler"
        "admin.example.com": "/admin/dashboard"
        "blog.example.com": "/blog/home"
        "shop.example.com": "/shop/catalog"
    }
    
    current_host: @http.host.subdomain + "." + @http.host.full_domain
    route: @routes[@current_host]|"/main/home"
    
    @include(@route)
}

# Country-specific domains
#web /* {
    tld: @http.host.tld
    
    country_config: {
        "com": {locale: "en_US", currency: "USD", timezone: "America/New_York"}
        "co.uk": {locale: "en_GB", currency: "GBP", timezone: "Europe/London"}
        "de": {locale: "de_DE", currency: "EUR", timezone: "Europe/Berlin"}
        "jp": {locale: "ja_JP", currency: "JPY", timezone: "Asia/Tokyo"}
    }
    
    config: @country_config[@tld]|@country_config["com"]
    
    # Apply configuration
    @locale.set(@config.locale)
    @currency.set(@config.currency)
    @timezone.set(@config.timezone)
}
```

## SSL/HTTPS Detection

```tusk
# Force HTTPS
#middleware force_https {
    @if(@http.host.protocol != "https" && @env.APP_ENV == "production") {
        secure_url: "https://" + @http.host + @request.uri
        @redirect(@secure_url, 301)
    }
}

# Security headers based on protocol
#middleware security_headers {
    @if(@http.host.is_secure) {
        @response.headers.strict-transport-security: 
            "max-age=31536000; includeSubDomains"
        @response.headers.content-security-policy: 
            "default-src 'self' https:"
    }
}
```

## Development vs Production

```tusk
# Environment detection based on host
detect_environment: {
    host: @http.host
    
    @if(@contains(@host, "localhost") || @contains(@host, "127.0.0.1")) {
        environment: "development"
    } elseif(@contains(@host, "staging.")) {
        environment: "staging"
    } elseif(@contains(@host, ".test") || @contains(@host, ".local")) {
        environment: "testing"
    } else {
        environment: "production"
    }
    
    @env.APP_ENV: @environment
}

# Development tools
@if(@http.host.is_local) {
    @enable_debug_toolbar()
    @disable_cache()
    @enable_error_display()
}
```

## API Versioning

```tusk
# Version based on subdomain
#api /* {
    # Extract version from subdomain (e.g., v1.api.example.com)
    subdomain_parts: @explode(".", @http.host.subdomain)
    api_version: @subdomain_parts[0]
    
    @if(@starts_with(@api_version, "v")) {
        version: @substr(@api_version, 1)
        
        # Route to versioned API
        @include("api/v" + @version + "/router.tusk")
    } else {
        # Default to latest version
        @include("api/v2/router.tusk")
    }
}
```

## White-Label Support

```tusk
# Custom domains for clients
#web /* {
    custom_domain: @http.host.full_domain
    
    # Check if custom domain
    client: @query("SELECT * FROM clients WHERE custom_domain = ?", 
                  [@custom_domain])
    
    @if(@client) {
        # Load client branding
        branding: {
            logo: @client.logo_url
            colors: @json_decode(@client.brand_colors)
            company_name: @client.company_name
            favicon: @client.favicon_url
        }
        
        @context.branding: @branding
        @context.client: @client
        
        # Render with custom branding
        @render("white_label/app.tusk", {
            branding: @branding
            client: @client
        })
    }
}
```

## Cross-Origin Handling

```tusk
# CORS configuration based on origin
#middleware cors {
    origin: @request.headers.origin
    
    # Parse origin host
    origin_host: @parse_url(@origin).host
    
    # Allowed origins
    allowed_origins: [
        @http.host,
        "app." + @http.host.full_domain,
        "api." + @http.host.full_domain
    ]
    
    @if(@in_array(@origin_host, @allowed_origins)) {
        @response.headers.access-control-allow-origin: @origin
        @response.headers.access-control-allow-credentials: "true"
    } elseif(@env.APP_ENV == "development") {
        # Allow localhost in development
        @if(@contains(@origin, "localhost")) {
            @response.headers.access-control-allow-origin: @origin
        }
    }
}
```

## Port-Based Services

```tusk
# Route based on port
service_router: {
    port: @http.host.port|80
    
    services: {
        80: "web"
        443: "web_secure"
        8080: "api"
        8081: "admin"
        3000: "websocket"
    }
    
    service: @services[@port]|"web"
    
    @include("services/" + @service + "/handler.tusk")
}

# Development port detection
@if(@http.host.port >= 3000 && @http.host.port <= 9999) {
    @env.APP_DEBUG: true
    @env.APP_ENV: "development"
}
```

## Mobile App Detection

```tusk
# Detect mobile app subdomains
#web /* {
    subdomain: @http.host.subdomain
    
    @if(@subdomain == "m" || @subdomain == "mobile") {
        # Mobile web version
        @context.is_mobile: true
        @render("mobile/app.tusk")
    } elseif(@subdomain == "app") {
        # Deep link to mobile app
        @redirect("myapp://home")
    }
}
```

## Wildcard Subdomain Handling

```tusk
# User profile subdomains (e.g., john.example.com)
#web /* {
    subdomain: @http.host.subdomain
    reserved_subdomains: ["www", "api", "admin", "app", "mail"]
    
    @if(@subdomain && !@in_array(@subdomain, @reserved_subdomains)) {
        # Treat as username
        user: @query("SELECT * FROM users WHERE username = ?", 
                    [@subdomain])
        
        @if(@user) {
            @render("profiles/public.tusk", {user: @user})
        } else {
            @response.status: 404
            @render("errors/profile_not_found.tusk")
        }
    }
}
```

## Geo-Based Routing

```tusk
# Route based on country domain
geo_router: {
    # Map TLD to region
    regions: {
        "com": "us-east-1"
        "eu": "eu-west-1"
        "co.uk": "eu-west-2"
        "com.au": "ap-southeast-2"
        "co.jp": "ap-northeast-1"
    }
    
    tld: @http.host.tld
    region: @regions[@tld]|"us-east-1"
    
    # Connect to regional database
    @database.connect(@region)
    
    # Set regional configuration
    @config.region: @region
    @config.currency: @get_regional_currency(@region)
    @config.tax_rate: @get_regional_tax_rate(@region)
}
```

## Debugging Host Information

```tusk
# Debug endpoint
#api /debug/host {
    @if(@env.APP_ENV != "development") {
        @response.status: 403
        error: "Forbidden"
        return
    }
    
    @json({
        raw_host: @request.headers.host
        parsed: {
            full: @http.host
            protocol: @http.host.protocol
            subdomain: @http.host.subdomain
            domain: @http.host.domain
            tld: @http.host.tld
            port: @http.host.port
            full_domain: @http.host.full_domain
        }
        flags: {
            is_secure: @http.host.is_secure
            is_local: @http.host.is_local
            is_ip: @http.host.is_ip
        }
        environment: @env.APP_ENV
    })
}
```

## Best Practices

1. **Validate host headers** - Don't trust user-supplied host headers
2. **Use HTTPS in production** - Always check protocol
3. **Handle missing subdomains** - Not all requests have subdomains
4. **Set default ports** - Handle when port is not specified
5. **Whitelist domains** - For security in multi-tenant apps
6. **Cache host parsing** - It doesn't change during request

## Related Operators

- `@request.headers.host` - Raw host header
- `@request.uri` - Request URI
- `@env` - Environment variables
- `@redirect()` - URL redirection
- `@parse_url()` - URL parsing function
---

[@env - Environment Variables]


The `@env` operator provides secure access to environment variables, enabling configuration management across different deployment environments.

## Basic Syntax

```tusk
# Access environment variable
database_url: @env.DATABASE_URL

# With fallback value
app_name: @env.APP_NAME|"My App"

# Check if exists
has_api_key: @isset(@env.API_KEY)

# Type casting
debug_mode: @bool(@env.DEBUG|"false")
port: @int(@env.PORT|"3000")
```

## Configuration Management

```tusk
# Application configuration
config: {
    app: {
        name: @env.APP_NAME|"TuskApp"
        env: @env.APP_ENV|"production"
        debug: @bool(@env.APP_DEBUG|"false")
        url: @env.APP_URL|"http://localhost"
        key: @env.APP_KEY  # Required, no default
    }
    
    database: {
        driver: @env.DB_DRIVER|"mysql"
        host: @env.DB_HOST|"localhost"
        port: @int(@env.DB_PORT|"3306")
        name: @env.DB_DATABASE
        user: @env.DB_USERNAME
        pass: @env.DB_PASSWORD
    }
    
    cache: {
        driver: @env.CACHE_DRIVER|"redis"
        host: @env.REDIS_HOST|"localhost"
        port: @int(@env.REDIS_PORT|"6379")
    }
}

# Validate required variables
required_vars: ["APP_KEY", "DB_DATABASE", "DB_USERNAME", "DB_PASSWORD"]
missing: []

@foreach(@required_vars as @var) {
    @if(!@isset(@env[@var])) {
        @missing[]: @var
    }
}

@if(@count(@missing) > 0) {
    @throw("Missing required environment variables: " + @implode(", ", @missing))
}
```

## Environment-Specific Behavior

```tusk
# Development environment
@if(@env.APP_ENV == "development") {
    # Enable debugging
    @error_reporting(E_ALL)
    @ini_set("display_errors", 1)
    
    # Use local services
    @config.api_url: "http://localhost:8080"
    @config.cdn_url: "http://localhost:3000"
    
    # Disable caching
    @cache.disable()
}

# Production environment
@if(@env.APP_ENV == "production") {
    # Error handling
    @error_reporting(0)
    @ini_set("display_errors", 0)
    
    # Use production services
    @config.api_url: @env.API_URL
    @config.cdn_url: @env.CDN_URL
    
    # Enable all optimizations
    @optimize.enable_all()
}

# Staging environment
@if(@env.APP_ENV == "staging") {
    # Use production-like settings but with debugging
    @config.debug: true
    @config.api_url: @env.STAGING_API_URL
}
```

## Service Configuration

```tusk
# Database connections
databases: {
    primary: {
        dsn: @env.DATABASE_URL|@build_dsn({
            driver: @env.DB_DRIVER
            host: @env.DB_HOST
            port: @env.DB_PORT
            dbname: @env.DB_DATABASE
        })
        username: @env.DB_USERNAME
        password: @env.DB_PASSWORD
        options: {
            persistent: @bool(@env.DB_PERSISTENT|"false")
            charset: @env.DB_CHARSET|"utf8mb4"
        }
    }
    
    # Read replica
    @if(@env.DB_READ_HOST) {
        read: {
            host: @env.DB_READ_HOST
            port: @env.DB_READ_PORT|@env.DB_PORT
            username: @env.DB_READ_USERNAME|@env.DB_USERNAME
            password: @env.DB_READ_PASSWORD|@env.DB_PASSWORD
        }
    }
}

# External services
services: {
    stripe: {
        public_key: @env.STRIPE_PUBLIC_KEY
        secret_key: @env.STRIPE_SECRET_KEY
        webhook_secret: @env.STRIPE_WEBHOOK_SECRET
        test_mode: @env.STRIPE_TEST_MODE|(@env.APP_ENV != "production")
    }
    
    aws: {
        key: @env.AWS_ACCESS_KEY_ID
        secret: @env.AWS_SECRET_ACCESS_KEY
        region: @env.AWS_DEFAULT_REGION|"us-east-1"
        bucket: @env.AWS_S3_BUCKET
    }
    
    mail: {
        driver: @env.MAIL_DRIVER|"smtp"
        host: @env.MAIL_HOST
        port: @int(@env.MAIL_PORT|"587")
        username: @env.MAIL_USERNAME
        password: @env.MAIL_PASSWORD
        encryption: @env.MAIL_ENCRYPTION|"tls"
        from_address: @env.MAIL_FROM_ADDRESS
        from_name: @env.MAIL_FROM_NAME|@env.APP_NAME
    }
}
```

## Feature Flags

```tusk
# Feature flag management
features: {
    # Boolean flags
    new_ui: @bool(@env.FEATURE_NEW_UI|"false")
    beta_api: @bool(@env.FEATURE_BETA_API|"false")
    ab_testing: @bool(@env.FEATURE_AB_TESTING|"true")
    
    # Percentage rollouts
    new_checkout: @int(@env.FEATURE_NEW_CHECKOUT_PERCENT|"0")
    
    # User lists
    beta_users: @explode(",", @env.FEATURE_BETA_USERS|"")
}

# Feature check helper
has_feature: (feature, user_id: null) => {
    # Check if feature exists
    @if(!@isset(@features[@feature])) {
        return false
    }
    
    value: @features[@feature]
    
    # Boolean feature
    @if(@is_bool(@value)) {
        return @value
    }
    
    # Percentage rollout
    @if(@is_numeric(@value) && @user_id) {
        user_hash: @crc32(@user_id + @feature)
        return (@user_hash % 100) < @value
    }
    
    # User list
    @if(@is_array(@value) && @user_id) {
        return @in_array(@user_id, @value)
    }
    
    return false
}
```

## Secrets Management

```tusk
# Encrypted secrets
secrets: {
    # Decrypt secrets from environment
    api_key: @decrypt(@env.ENCRYPTED_API_KEY, @env.MASTER_KEY)
    db_password: @decrypt(@env.ENCRYPTED_DB_PASSWORD, @env.MASTER_KEY)
    
    # Rotate secrets periodically
    should_rotate: @days_since(@env.LAST_SECRET_ROTATION) > 90
}

# Secret validation
validate_secrets: {
    # Check format
    @if(!@preg_match("/^[A-Za-z0-9+\/=]+$/", @env.ENCRYPTED_API_KEY)) {
        @throw("Invalid encrypted secret format")
    }
    
    # Check master key
    @if(@strlen(@env.MASTER_KEY) < 32) {
        @throw("Master key too short")
    }
}

# Secure loading
load_secrets: () => {
    # Only load in memory, never log
    @foreach(@secrets as @name => @value) {
        @putenv(@name + "=" + @value)
    }
}
```

## Dynamic Environment

```tusk
# Load environment based on host
dynamic_env: {
    host: @http.host.full_domain
    
    env_map: {
        "example.com": "production"
        "staging.example.com": "staging"
        "dev.example.com": "development"
        "*.test": "testing"
    }
    
    @foreach(@env_map as @pattern => @env) {
        @if(@matches_pattern(@host, @pattern)) {
            @env.APP_ENV: @env
            break
        }
    }
}

# Load .env.{environment} file
env_file: ".env." + @env.APP_ENV
@if(@file_exists(@env_file)) {
    @load_env_file(@env_file)
}
```

## Validation and Defaults

```tusk
# Environment schema
env_schema: {
    APP_ENV: {
        type: "string"
        values: ["development", "staging", "production"]
        default: "production"
    }
    APP_DEBUG: {
        type: "boolean"
        default: false
    }
    APP_PORT: {
        type: "integer"
        min: 1
        max: 65535
        default: 3000
    }
    LOG_LEVEL: {
        type: "string"
        values: ["debug", "info", "warning", "error"]
        default: "info"
    }
    SESSION_LIFETIME: {
        type: "integer"
        min: 1
        max: 525600  # 1 year in minutes
        default: 120
    }
}

# Validate environment
validate_env: () => {
    errors: []
    
    @foreach(@env_schema as @key => @schema) {
        value: @env[@key]|@schema.default
        
        # Type validation
        @switch(@schema.type) {
            case "boolean":
                @if(!@in_array(@strtolower(@value), ["true", "false", "1", "0"])) {
                    @errors[]: @key + " must be boolean"
                }
                
            case "integer":
                @if(!@is_numeric(@value)) {
                    @errors[]: @key + " must be integer"
                } else {
                    num: @int(@value)
                    @if(@isset(@schema.min) && @num < @schema.min) {
                        @errors[]: @key + " must be >= " + @schema.min
                    }
                    @if(@isset(@schema.max) && @num > @schema.max) {
                        @errors[]: @key + " must be <= " + @schema.max
                    }
                }
                
            case "string":
                @if(@isset(@schema.values) && !@in_array(@value, @schema.values)) {
                    @errors[]: @key + " must be one of: " + @implode(", ", @schema.values)
                }
        }
    }
    
    return @errors
}
```

## Environment Debugging

```tusk
# Debug environment (never in production!)
#api /debug/env {
    @if(@env.APP_ENV == "production") {
        @response.status: 403
        error: "Forbidden"
        return
    }
    
    # Sanitize sensitive values
    safe_env: {}
    sensitive_patterns: ["KEY", "SECRET", "PASSWORD", "TOKEN"]
    
    @foreach(@env as @key => @value) {
        is_sensitive: false
        @foreach(@sensitive_patterns as @pattern) {
            @if(@contains(@upper(@key), @pattern)) {
                is_sensitive: true
                break
            }
        }
        
        @if(@is_sensitive) {
            @safe_env[@key]: "***REDACTED***"
        } else {
            @safe_env[@key]: @value
        }
    }
    
    @json({
        environment: @safe_env
        php_ini: @ini_get_all()
        loaded_extensions: @get_loaded_extensions()
    })
}
```

## Environment File Loading

```tusk
# Custom .env loader
load_env_file: (file_path) => {
    @if(!@file_exists(@file_path)) {
        return false
    }
    
    lines: @file_get_lines(@file_path)
    
    @foreach(@lines as @line) {
        # Skip comments and empty lines
        line: @trim(@line)
        @if(@empty(@line) || @starts_with(@line, "#")) {
            continue
        }
        
        # Parse KEY=VALUE
        parts: @explode("=", @line, 2)
        @if(@count(@parts) == 2) {
            key: @trim(@parts[0])
            value: @trim(@parts[1])
            
            # Remove quotes
            @if(@starts_with(@value, '"') && @ends_with(@value, '"')) {
                value: @substr(@value, 1, -1)
            }
            
            # Set environment variable
            @putenv(@key + "=" + @value)
            @env[@key]: @value
        }
    }
    
    return true
}
```

## Best Practices

1. **Never commit .env files** - Use .env.example as template
2. **Validate required variables** - Fail fast if missing
3. **Use appropriate defaults** - But not for secrets
4. **Type cast values** - Environment variables are strings
5. **Separate environments** - Different configs for dev/staging/prod
6. **Encrypt sensitive values** - Don't store plaintext secrets

## Related Features

- `@config` - Configuration management
- `@secret()` - Secret decryption
- `@putenv()` - Set environment variables
- `@file_get_contents()` - Read .env files
- `@validate()` - Schema validation
---

[@server - Server Variables]


The `@server` operator provides access to server information and PHP's $_SERVER superglobal, offering details about the server environment and request execution.

## Basic Syntax

```tusk
# Access server variables
server_name: @server.SERVER_NAME
document_root: @server.DOCUMENT_ROOT

# Common server info
method: @server.REQUEST_METHOD
script: @server.SCRIPT_NAME
```

## Request Information

```tusk
# Request details
request_info: {
    # HTTP method
    method: @server.REQUEST_METHOD
    
    # Request URI and query
    uri: @server.REQUEST_URI
    query_string: @server.QUERY_STRING
    
    # Script information
    script_name: @server.SCRIPT_NAME
    script_filename: @server.SCRIPT_FILENAME
    php_self: @server.PHP_SELF
    
    # Request time
    time: @server.REQUEST_TIME
    time_float: @server.REQUEST_TIME_FLOAT
    
    # Protocol
    protocol: @server.SERVER_PROTOCOL
    https: @server.HTTPS == "on"
}

# Client information
client_info: {
    # IP addresses
    remote_addr: @server.REMOTE_ADDR
    remote_host: @server.REMOTE_HOST
    remote_port: @server.REMOTE_PORT
    
    # Forwarded IPs (behind proxy)
    forwarded_for: @server.HTTP_X_FORWARDED_FOR
    real_ip: @server.HTTP_X_REAL_IP
    
    # User agent
    user_agent: @server.HTTP_USER_AGENT
    
    # Accept headers
    accept: @server.HTTP_ACCEPT
    accept_language: @server.HTTP_ACCEPT_LANGUAGE
    accept_encoding: @server.HTTP_ACCEPT_ENCODING
}
```

## Server Environment

```tusk
# Server details
server_details: {
    # Software
    software: @server.SERVER_SOFTWARE
    gateway: @server.GATEWAY_INTERFACE
    
    # Server identification
    name: @server.SERVER_NAME
    addr: @server.SERVER_ADDR
    port: @server.SERVER_PORT
    admin: @server.SERVER_ADMIN
    
    # Paths
    document_root: @server.DOCUMENT_ROOT
    context_prefix: @server.CONTEXT_PREFIX
    context_document_root: @server.CONTEXT_DOCUMENT_ROOT
    
    # PHP information
    php_version: PHP_VERSION
    php_os: PHP_OS
    php_sapi: PHP_SAPI
}
```

## Authentication Headers

```tusk
# HTTP authentication
auth_info: {
    # Basic auth
    auth_user: @server.PHP_AUTH_USER
    auth_pass: @server.PHP_AUTH_PW
    auth_type: @server.AUTH_TYPE
    
    # Digest auth
    auth_digest: @server.PHP_AUTH_DIGEST
    
    # Remote user (from web server)
    remote_user: @server.REMOTE_USER
}

# Check authentication
is_authenticated: @isset(@server.PHP_AUTH_USER)

# Validate basic auth
validate_basic_auth: () => {
    @if(!@is_authenticated) {
        @response.status: 401
        @response.headers.www-authenticate: 'Basic realm="Restricted Area"'
        return false
    }
    
    # Verify credentials
    user: @server.PHP_AUTH_USER
    pass: @server.PHP_AUTH_PW
    
    valid: @check_credentials(@user, @pass)
    @if(!@valid) {
        @response.status: 403
        return false
    }
    
    return true
}
```

## Path Information

```tusk
# Path details
paths: {
    # Original request
    request_uri: @server.REQUEST_URI
    
    # Path components
    path_info: @server.PATH_INFO
    orig_path_info: @server.ORIG_PATH_INFO
    path_translated: @server.PATH_TRANSLATED
    
    # Script paths
    script_name: @server.SCRIPT_NAME
    script_filename: @server.SCRIPT_FILENAME
    
    # Parse path
    parsed: @parse_url(@server.REQUEST_URI)
    path: @parsed.path
    query: @parsed.query
}

# Get clean path
clean_path: () => {
    path: @server.PATH_INFO|@server.REQUEST_URI
    
    # Remove query string
    @if(@contains(@path, "?")) {
        path: @explode("?", @path)[0]
    }
    
    # Remove trailing slash
    path: @rtrim(@path, "/")
    
    return @path ?: "/"
}
```

## CLI Detection

```tusk
# Check if running in CLI
is_cli: @server.argc > 0 || PHP_SAPI == "cli"

# CLI arguments
@if(@is_cli) {
    cli_args: @server.argv
    script_name: @cli_args[0]
    arguments: @array_slice(@cli_args, 1)
    
    # Parse CLI options
    options: @getopt("hv:f:", ["help", "verbose:", "file:"])
}

# Different behavior for CLI vs Web
@if(@is_cli) {
    # CLI mode
    @output.format: "text"
    @log.destination: "stdout"
} else {
    # Web mode
    @output.format: "html"
    @log.destination: "file"
}
```

## Request Timing

```tusk
# Performance monitoring
request_timing: {
    # Start time
    start_time: @server.REQUEST_TIME_FLOAT
    
    # Current time
    current_time: @microtime(true)
    
    # Elapsed time
    elapsed: @current_time - @start_time
    
    # Memory usage
    memory_current: @memory_get_usage()
    memory_peak: @memory_get_peak_usage()
}

# Log slow requests
@if(@request_timing.elapsed > 1.0) {
    @log.warning("Slow request", {
        uri: @server.REQUEST_URI
        elapsed: @request_timing.elapsed
        memory: @request_timing.memory_peak
    })
}
```

## Custom Headers

```tusk
# Access all HTTP headers
headers: {}
@foreach(@server as @key => @value) {
    @if(@starts_with(@key, "HTTP_")) {
        # Convert HTTP_HEADER_NAME to Header-Name
        header_name: @substr(@key, 5)
        header_name: @str_replace("_", "-", @header_name)
        header_name: @ucwords(@strtolower(@header_name), "-")
        
        @headers[@header_name]: @value
    }
}

# Custom application headers
app_headers: {
    request_id: @server.HTTP_X_REQUEST_ID
    api_version: @server.HTTP_X_API_VERSION
    client_version: @server.HTTP_X_CLIENT_VERSION
    device_id: @server.HTTP_X_DEVICE_ID
}
```

## Security Checks

```tusk
# Security validation
security_checks: {
    # Check for proxy headers
    is_proxied: @isset(@server.HTTP_X_FORWARDED_FOR) || 
                @isset(@server.HTTP_X_REAL_IP)
    
    # Get real IP
    real_ip: @get_real_ip()
    
    # SSL/TLS check
    is_https: @server.HTTPS == "on" || 
              @server.HTTP_X_FORWARDED_PROTO == "https" ||
              @server.SERVER_PORT == 443
    
    # Validate host header
    valid_host: @in_array(@server.HTTP_HOST, @allowed_hosts)
}

# Get real IP helper
get_real_ip: () => {
    # Check various headers in order
    headers: [
        "HTTP_CF_CONNECTING_IP",     # Cloudflare
        "HTTP_X_REAL_IP",            # Nginx
        "HTTP_X_FORWARDED_FOR",      # Standard proxy
        "REMOTE_ADDR"                # Direct connection
    ]
    
    @foreach(@headers as @header) {
        @if(@isset(@server[@header])) {
            ip: @server[@header]
            
            # Handle comma-separated list
            @if(@contains(@ip, ",")) {
                ip: @trim(@explode(",", @ip)[0])
            }
            
            # Validate IP
            @if(@filter_var(@ip, FILTER_VALIDATE_IP)) {
                return @ip
            }
        }
    }
    
    return @server.REMOTE_ADDR
}
```

## Environment Detection

```tusk
# Detect execution environment
detect_environment: {
    # Check various indicators
    is_docker: @file_exists("/.dockerenv")
    is_kubernetes: @isset(@env.KUBERNETES_SERVICE_HOST)
    is_aws: @isset(@env.AWS_EXECUTION_ENV)
    is_heroku: @isset(@env.DYNO)
    
    # Web server detection
    server_software: @server.SERVER_SOFTWARE
    is_apache: @contains(@server_software, "Apache")
    is_nginx: @contains(@server_software, "nginx")
    is_iis: @contains(@server_software, "IIS")
    
    # PHP SAPI
    sapi: PHP_SAPI
    is_fpm: @sapi == "fpm-fcgi"
    is_cgi: @contains(@sapi, "cgi")
    is_builtin: @sapi == "cli-server"
}
```

## Development Server

```tusk
# Built-in PHP server detection
is_dev_server: PHP_SAPI == "cli-server"

@if(@is_dev_server) {
    # Special handling for PHP built-in server
    # Static file serving
    @if(@file_exists(@server.DOCUMENT_ROOT + @server.REQUEST_URI)) {
        return false  # Let PHP serve the file
    }
    
    # Enable development features
    @ini_set("display_errors", 1)
    @error_reporting(E_ALL)
}
```

## Server Metrics

```tusk
# Collect server metrics
server_metrics: {
    # System load
    load_average: @sys_getloadavg()
    
    # Disk usage
    disk_free: @disk_free_space("/")
    disk_total: @disk_total_space("/")
    disk_usage_percent: ((@disk_total - @disk_free) / @disk_total) * 100
    
    # Memory info
    memory_limit: @ini_get("memory_limit")
    memory_usage: @memory_get_usage(true)
    memory_peak: @memory_get_peak_usage(true)
    
    # Connection info
    connection_status: @connection_status()
    connection_aborted: @connection_aborted()
}

# Health check endpoint
#api /health {
    @json({
        status: "healthy"
        server: {
            software: @server.SERVER_SOFTWARE
            php_version: PHP_VERSION
            uptime: @server.REQUEST_TIME - @server.SERVER_START_TIME
        }
        metrics: @server_metrics
        timestamp: @time()
    })
}
```

## Best Practices

1. **Validate server variables** - May not always be set
2. **Use real IP detection** - Handle proxies properly
3. **Check HTTPS properly** - Consider proxy headers
4. **Sanitize user input** - Even from server vars
5. **Cache server checks** - Don't repeat expensive operations
6. **Handle CLI mode** - Different variables available

## Related Features

- `@request` - Request object
- `@env` - Environment variables
- `@headers` - HTTP headers
- `@cli` - CLI arguments
- `@system` - System information
---

[@global - Global Variables]


The `@global` operator provides access to globally scoped variables that persist across different parts of your application during a single request.

## Basic Syntax

```tusk
# Set global variable
@global.user_context: {id: 123, name: "John"}

# Access global variable
current_user: @global.user_context

# Check if exists
has_user: @isset(@global.user_context)

# Delete global variable
@global.temp_data: null
```

## Application State

```tusk
# Initialize application globals
@global.app: {
    name: @env.APP_NAME|"TuskApp"
    version: "2.0.0"
    started_at: @microtime(true)
    request_id: @generate_uuid()
}

# Configuration globals
@global.config: {
    timezone: @env.TZ|"UTC"
    locale: @env.LOCALE|"en_US"
    currency: @env.CURRENCY|"USD"
    date_format: @env.DATE_FORMAT|"Y-m-d"
}

# Runtime settings
@global.runtime: {
    debug: @bool(@env.DEBUG|"false")
    cache_enabled: @bool(@env.CACHE_ENABLED|"true")
    maintenance_mode: @bool(@env.MAINTENANCE|"false")
}
```

## Request Context

```tusk
# Set up request context
#middleware request_context {
    # Create request context
    @global.request_context: {
        id: @generate_request_id()
        started_at: @microtime(true)
        ip: @get_real_ip()
        user_agent: @request.headers.user-agent
        method: @request.method
        path: @request.path
    }
    
    # Add to response headers
    @response.headers.x-request-id: @global.request_context.id
    
    @next()
    
    # Log request completion
    @global.request_context.ended_at: @microtime(true)
    @global.request_context.duration: @global.request_context.ended_at - 
                                      @global.request_context.started_at
    
    @log.info("Request completed", @global.request_context)
}
```

## User Context

```tusk
# Authentication middleware
#middleware auth {
    token: @request.headers.authorization
    
    @if(@token) {
        user: @verify_token(@token)
        
        @if(@user) {
            # Set global user context
            @global.user: {
                id: @user.id
                name: @user.name
                email: @user.email
                roles: @user.roles
                permissions: @load_permissions(@user.id)
                timezone: @user.timezone|@global.config.timezone
            }
            
            # Set user-specific settings
            @global.user_settings: @load_user_settings(@user.id)
        }
    }
    
    @next()
}

# Access user anywhere
@if(@global.user) {
    welcome_message: "Hello, " + @global.user.name
}

# Permission check helper
can: (permission) => {
    @if(!@global.user) return false
    return @in_array(@permission, @global.user.permissions)
}
```

## Feature Flags

```tusk
# Load feature flags globally
@global.features: {
    new_ui: @bool(@env.FEATURE_NEW_UI|"false")
    beta_api: @bool(@env.FEATURE_BETA_API|"false")
    dark_mode: @bool(@env.FEATURE_DARK_MODE|"true")
    
    # User-specific features
    @if(@global.user) {
        user_features: @get_user_features(@global.user.id)
        @merge(@global.features, @user_features)
    }
}

# Feature check helper
feature_enabled: (feature) => {
    return @global.features[@feature]|false
}

# Use in templates
@if(@feature_enabled("new_ui")) {
    @render("templates/new_ui.tusk")
} else {
    @render("templates/classic_ui.tusk")
}
```

## Database Connections

```tusk
# Global database connections
@global.db: {
    # Primary connection
    primary: @create_connection({
        host: @env.DB_HOST
        database: @env.DB_NAME
        user: @env.DB_USER
        password: @env.DB_PASS
    })
    
    # Read replica
    read: @create_connection({
        host: @env.DB_READ_HOST|@env.DB_HOST
        database: @env.DB_NAME
        user: @env.DB_READ_USER|@env.DB_USER
        password: @env.DB_READ_PASS|@env.DB_PASS
    })
    
    # Analytics database
    analytics: @create_connection({
        host: @env.ANALYTICS_DB_HOST
        database: @env.ANALYTICS_DB_NAME
    })
}

# Query helpers using global connections
query: (sql, params: [], connection: "primary") => {
    return @global.db[@connection].query(@sql, @params)
}

read_query: (sql, params: []) => {
    return @query(@sql, @params, "read")
}
```

## Cache Instances

```tusk
# Global cache instances
@global.cache: {
    # Default cache
    default: @cache.store(@env.CACHE_DRIVER|"redis")
    
    # Session cache
    sessions: @cache.store("redis").namespace("sessions")
    
    # API cache
    api: @cache.store("redis").namespace("api").ttl(300)
    
    # View cache
    views: @cache.store("file").path("/tmp/cache/views")
}

# Helper to use specific cache
cache_get: (key, store: "default") => {
    return @global.cache[@store].get(@key)
}

cache_set: (key, value, ttl: 3600, store: "default") => {
    return @global.cache[@store].set(@key, @value, @ttl)
}
```

## Service Container

```tusk
# Global service container
@global.services: {}

# Register services
register_service: (name, factory) => {
    @global.services[@name]: @factory
}

# Register common services
@register_service("mailer", () => {
    return @create_mailer({
        driver: @env.MAIL_DRIVER
        host: @env.MAIL_HOST
        port: @env.MAIL_PORT
        username: @env.MAIL_USERNAME
        password: @env.MAIL_PASSWORD
    })
})

@register_service("logger", () => {
    return @create_logger({
        level: @env.LOG_LEVEL|"info"
        file: @env.LOG_FILE|"/var/log/app.log"
    })
})

# Get service
service: (name) => {
    @if(!@isset(@global.services[@name])) {
        @throw("Service not found: " + @name)
    }
    
    service: @global.services[@name]
    
    # Lazy instantiation
    @if(@is_callable(@service)) {
        @global.services[@name]: @service()
        return @global.services[@name]
    }
    
    return @service
}

# Use services
@service("mailer").send({
    to: "user@example.com"
    subject: "Welcome"
    body: "Welcome to our app!"
})
```

## Event System

```tusk
# Global event listeners
@global.events: {}

# Register event listener
on: (event, callback) => {
    @if(!@isset(@global.events[@event])) {
        @global.events[@event]: []
    }
    @global.events[@event][]: @callback
}

# Trigger event
emit: (event, data: {}) => {
    @if(@isset(@global.events[@event])) {
        @foreach(@global.events[@event] as @callback) {
            @callback(@data)
        }
    }
}

# Register listeners
@on("user.login", (data) => {
    @log.info("User logged in", {user_id: @data.user_id})
    @update_last_login(@data.user_id)
})

@on("order.placed", (data) => {
    @send_order_confirmation(@data.order_id)
    @update_inventory(@data.items)
    @track_analytics("order_placed", @data)
})

# Emit events
@emit("user.login", {user_id: @user.id, ip: @request.ip})
```

## Shared State

```tusk
# Share state between components
@global.shared: {
    # Shopping cart
    cart: @session.cart|[]
    
    # Current theme
    theme: @cookie.theme|@user.theme|"light"
    
    # Breadcrumbs
    breadcrumbs: []
    
    # Flash messages
    messages: []
}

# Breadcrumb management
add_breadcrumb: (title, url: null) => {
    @global.shared.breadcrumbs[]: {
        title: @title
        url: @url
    }
}

# Flash message management
flash: (type, message) => {
    @global.shared.messages[]: {
        type: @type
        message: @message
        timestamp: @time()
    }
}

# Use in templates
@foreach(@global.shared.breadcrumbs as @crumb) {
    @if(@crumb.url) {
        <a href="{@crumb.url}">{@crumb.title}</a> /
    } else {
        {@crumb.title}
    }
}
```

## Performance Monitoring

```tusk
# Global performance tracking
@global.performance: {
    timers: {}
    counters: {}
    memory_start: @memory_get_usage()
}

# Start timer
start_timer: (name) => {
    @global.performance.timers[@name]: @microtime(true)
}

# End timer
end_timer: (name) => {
    @if(@isset(@global.performance.timers[@name])) {
        duration: @microtime(true) - @global.performance.timers[@name]
        @global.performance.timers[@name]: @duration
        return @duration
    }
    return 0
}

# Increment counter
increment_counter: (name, value: 1) => {
    @if(!@isset(@global.performance.counters[@name])) {
        @global.performance.counters[@name]: 0
    }
    @global.performance.counters[@name]: @global.performance.counters[@name] + @value
}

# Get performance summary
get_performance_summary: () => {
    return {
        timers: @global.performance.timers
        counters: @global.performance.counters
        memory_used: @memory_get_usage() - @global.performance.memory_start
        memory_peak: @memory_get_peak_usage()
    }
}
```

## Cleanup

```tusk
# Register shutdown handler
@register_shutdown(() => {
    # Close database connections
    @foreach(@global.db as @name => @connection) {
        @connection.close()
    }
    
    # Flush cache writes
    @foreach(@global.cache as @name => @cache) {
        @cache.flush_pending()
    }
    
    # Log performance metrics
    @log.debug("Request performance", @get_performance_summary())
    
    # Clear sensitive data
    @global.user: null
    @global.services: {}
})
```

## Best Practices

1. **Use namespacing** - Organize globals by purpose
2. **Initialize early** - Set up globals in middleware
3. **Clean up after use** - Clear sensitive data
4. **Avoid overuse** - Prefer dependency injection
5. **Document globals** - Make their purpose clear
6. **Thread safety** - Be careful in async contexts

## Related Features

- `@session` - Session storage
- `@context` - Request context
- `@store` - Persistent storage
- `@registry` - Service registry
- `@container` - Dependency injection
---

[@debug - Debug Mode and Tools]


The `@debug` operator provides comprehensive debugging capabilities, helping developers identify issues, trace execution, and optimize performance.

## Basic Syntax

```tusk
# Check if debug mode is enabled
@if(@debug) {
    @log("Debug mode active")
}

# Debug output
@debug.log("Variable value", @my_var)

# Dump and die
@debug.dd(@complex_object)

# Conditional debugging
@debug.when(@condition, "This only logs when condition is true")
```

## Debug Configuration

```tusk
# Enable/disable debug mode
@debug.enable()
@debug.disable()

# Configure debug settings
@debug.config({
    # Output settings
    output: "console"      # console, file, browser
    format: "pretty"       # pretty, json, raw
    
    # What to include
    show_types: true
    show_memory: true
    show_time: true
    show_backtrace: false
    max_depth: 10
    
    # Performance
    profile: true
    slow_query_threshold: 0.1
    
    # Error handling
    display_errors: true
    error_level: E_ALL
})
```

## Variable Inspection

```tusk
# Debug dump
@debug.dump(@variable)
/* Output:
string(5) "hello"
Memory: 1.2MB
Time: 0.0023s
*/

# Dump with label
@debug.dump(@user, "Current User")
/* Output:
=== Current User ===
object(User) {
    id: 123
    name: "John Doe"
    email: "john@example.com"
}
*/

# Dump and die
@debug.dd(@data)  # Stops execution

# Dump multiple variables
@debug.dump_all({
    user: @user
    request: @request
    session: @session
})

# Pretty print
@debug.pretty(@complex_array)
```

## Execution Tracing

```tusk
# Trace function calls
@debug.trace("Starting user authentication")

# Trace with data
@debug.trace("Processing order", {
    order_id: @order.id
    items: @count(@order.items)
    total: @order.total
})

# Function execution trace
calculate_total: @debug.trace_function((items) => {
    total: 0
    @foreach(@items as @item) {
        total: @total + @item.price * @item.quantity
    }
    return @total
})

# Backtrace
@debug.backtrace()
/* Output:
#0 /app/controllers/UserController.tusk:45 process_request()
#1 /app/middleware/Auth.tusk:23 authenticate()
#2 /app/routes.tusk:12 handle()
*/

# Get call stack
stack: @debug.get_stack()
@foreach(@stack as @frame) {
    @log(@frame.file + ":" + @frame.line + " " + @frame.function)
}
```

## Performance Profiling

```tusk
# Profile code block
@debug.profile("database_operations") {
    users: @query("SELECT * FROM users")
    @foreach(@users as @user) {
        @update_user_stats(@user)
    }
}

# Get profile results
profile: @debug.get_profile("database_operations")
/* Output:
{
    total_time: 0.234
    memory_used: 2048576
    memory_peak: 3145728
    queries: 101
    query_time: 0.189
}
*/

# Benchmark comparison
@debug.benchmark({
    "method1": () => @process_with_method1(),
    "method2": () => @process_with_method2(),
    "method3": () => @process_with_method3()
}, 1000)  # Run 1000 iterations
/* Output:
method1: 0.0023s average
method2: 0.0019s average (fastest)
method3: 0.0045s average
*/
```

## Query Debugging

```tusk
# Enable query logging
@debug.enable_query_log()

# Execute queries
users: @query("SELECT * FROM users WHERE active = ?", [1])
orders: @query("SELECT * FROM orders WHERE user_id = ?", [@user.id])

# Get query log
queries: @debug.get_queries()
/* Output:
[
    {
        sql: "SELECT * FROM users WHERE active = ?"
        params: [1]
        time: 0.0023
        rows: 150
        file: "/app/models/User.tusk:34"
    },
    {
        sql: "SELECT * FROM orders WHERE user_id = ?"
        params: [123]
        time: 0.0156
        rows: 12
        file: "/app/models/Order.tusk:78"
    }
]
*/

# Explain query
@debug.explain("SELECT * FROM users WHERE email = ?", ["test@example.com"])
/* Output:
+----+-------------+-------+------+---------------+-------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key   | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+-------+---------+-------+------+-------------+
| 1  | SIMPLE      | users | ref  | email_idx     | email | 767     | const | 1    | Using where |
+----+-------------+-------+------+---------------+-------+---------+-------+------+-------------+
*/
```

## Memory Debugging

```tusk
# Memory snapshot
@debug.memory_snapshot("before_operation")

# Do memory-intensive operation
large_data: @load_large_dataset()
processed: @process_data(@large_data)

# Compare memory
@debug.memory_snapshot("after_operation")
diff: @debug.memory_diff("before_operation", "after_operation")
/* Output:
Memory increased by 45.3MB
Peak memory: 128.5MB
Objects created: 15,234
*/

# Memory usage tracking
@debug.track_memory({
    @load_users()
    @process_users()
    @save_results()
})
/* Output:
Step 1: +12.3MB (12.3MB total)
Step 2: +34.2MB (46.5MB total)
Step 3: -15.1MB (31.4MB total)
*/

# Find memory leaks
@debug.find_leaks({
    iterations: 1000
    threshold: 1024  # 1KB
})
```

## Error Debugging

```tusk
# Enhanced error reporting
@debug.on_error((error) => {
    @debug.log("Error occurred", {
        message: @error.message
        file: @error.file
        line: @error.line
        trace: @error.trace
        context: @debug.get_context(@error.file, @error.line, 5)
    })
})

# Try with detailed debugging
@debug.try({
    result: @risky_operation()
} catch (e) {
    @debug.exception(@e)
    /* Output:
    Exception: Database connection failed
    File: /app/db/Connection.tusk:45
    
    Code context:
    43:     @if(!@connection) {
    44:         @retry_count++
    45: >       @throw("Database connection failed")
    46:     }
    47: 
    
    Variables in scope:
    - connection: null
    - retry_count: 3
    - config: {host: "localhost", port: 3306}
    */
})
```

## Interactive Debugging

```tusk
# Set breakpoint
@debug.breakpoint()  # Pauses execution if debugger attached

# Conditional breakpoint
@debug.breakpoint_if(@user.id == 123)

# Watch variables
@debug.watch("user.status", (old_value, new_value) => {
    @log("User status changed from " + @old_value + " to " + @new_value)
})

# Interactive console
@debug.console({
    user: @user
    request: @request
    # Available in console for inspection
})
```

## Network Debugging

```tusk
# Debug HTTP requests
@debug.http_request("GET", "https://api.example.com/users", {
    headers: @headers
    show_request: true
    show_response: true
    show_timing: true
})
/* Output:
=== REQUEST ===
GET https://api.example.com/users
Headers:
  Authorization: Bearer xxx...
  Accept: application/json

=== RESPONSE ===
Status: 200 OK
Time: 234ms
Headers:
  Content-Type: application/json
  X-RateLimit-Remaining: 99
Body:
  {"users": [...]}
*/

# Debug webhook
@debug.webhook(@request, @response)
```

## Template Debugging

```tusk
# Enable template debugging
@debug.templates({
    show_variables: true
    show_includes: true
    show_render_time: true
})

# Debug in template
{@debug.vars()}  # Shows all available variables

{@debug.template_stack()}  # Shows template inheritance

{@debug.partial_time("header.tusk")}  # Time specific partial
```

## Production Debugging

```tusk
# Safe debugging in production
@debug.production({
    # Only enable for specific users
    allowed_users: [@env.DEBUG_USER_ID]
    
    # Or by IP
    allowed_ips: ["192.168.1.100", "10.0.0.5"]
    
    # Log to file instead of output
    log_file: "/var/log/debug.log"
    
    # Mask sensitive data
    mask_fields: ["password", "token", "secret"]
})

# Conditional debug output
@debug.if_allowed("Sensitive operation", @data)

# Debug sampling (1% of requests)
@debug.sample(0.01, "Checking performance", @metrics)
```

## Debug Toolbar

```tusk
# Enable debug toolbar
@debug.toolbar({
    position: "bottom"
    panels: [
        "request",
        "database", 
        "templates",
        "cache",
        "profile",
        "logs",
        "mail"
    ]
})

# Add custom panel
@debug.toolbar.add_panel("custom", {
    title: "My Panel"
    content: @render("debug/custom_panel.tusk")
    badge: @count(@items)
})
```

## Logging Integration

```tusk
# Debug logger
@debug.logger({
    level: "debug"
    file: "/var/log/app_debug.log"
    format: "[{timestamp}] {level}: {message} {context}"
})

# Log with context
@debug.log_context({
    user_id: @user.id
    request_id: @request.id
    session_id: @session.id
})

# All subsequent logs include context
@debug.log("Processing order")  # Includes user_id, request_id, etc.
```

## Best Practices

1. **Disable in production** - Use environment checks
2. **Use descriptive labels** - Make debugging easier
3. **Clean up debug code** - Remove before committing
4. **Log strategically** - Don't over-log
5. **Mask sensitive data** - Never log passwords/tokens
6. **Use appropriate tools** - Profiler for performance, trace for flow

## Related Features

- `@log` - Logging system
- `@profile()` - Performance profiling
- `@trace()` - Execution tracing
- `@monitor` - Application monitoring
- `@test` - Testing utilities
---

[@ Operator Chaining]


TuskLang supports elegant chaining of @ operators, allowing you to compose complex operations in a readable, fluent manner.

## Basic Chaining

```tusk
# Simple property chaining
user_city: @user.address.city

# Method chaining
formatted: @string.trim().lower().replace(" ", "-")

# Mixed chaining
result: @query("SELECT * FROM users").first().name.upper()
```

## Null-Safe Chaining

```tusk
# Safe navigation operator
city: @user?.address?.city

# With fallback
city: @user?.address?.city|"Unknown"

# Multiple levels
manager_email: @employee?.department?.manager?.email|"no-manager@example.com"

# Array access
first_tag: @post?.tags?[0]?.name
```

## Collection Chaining

```tusk
# Array operations
result: @users
    .filter(u => u.active)
    .map(u => u.email)
    .unique()
    .sort()

# More complex example
top_customers: @orders
    .groupBy("customer_id")
    .map((customer_id, orders) => {
        id: @customer_id
        total: @orders.sum("total")
        count: @orders.count()
    })
    .sortBy("total", "desc")
    .limit(10)

# With conditions
active_premium_users: @users
    .where("status", "active")
    .where("subscription", "premium")
    .orderBy("created_at", "desc")
    .get()
```

## Query Builder Chaining

```tusk
# Database query chaining
users: @db.table("users")
    .select(["id", "name", "email"])
    .where("active", true)
    .where("created_at", ">", @last_week)
    .whereIn("role", ["admin", "editor"])
    .orderBy("name")
    .limit(50)
    .get()

# With joins
orders: @db.table("orders")
    .join("users", "orders.user_id", "users.id")
    .join("products", "orders.product_id", "products.id")
    .select([
        "orders.*",
        "users.name as customer_name",
        "products.name as product_name"
    ])
    .where("orders.status", "completed")
    .whereBetween("orders.created_at", [@start_date, @end_date])
    .get()
```

## Transform Chains

```tusk
# String transformations
slug: @title
    .trim()
    .lower()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")

# Date transformations  
formatted_date: @user.created_at
    .toDate()
    .format("Y-m-d")
    .replace("-", "/")

# Number formatting
price_display: @product.price
    .round(2)
    .format(",")
    .prepend("$")
```

## Conditional Chaining

```tusk
# Chain with conditions
query: @db.table("products")
    .when(@category, (q) => q.where("category_id", @category))
    .when(@min_price, (q) => q.where("price", ">=", @min_price))
    .when(@search, (q) => q.where("name", "like", "%" + @search + "%"))
    .when(@sort == "price", (q) => q.orderBy("price", @direction))
    .get()

# Conditional method calls
result: @data
    .if(@should_filter, filter(x => x.active))
    .if(@should_sort, sort())
    .if(@limit, take(@limit))
```

## Pipeline Chaining

```tusk
# Unix-style pipeline
result: @input
    |> @trim()
    |> @split(",")
    |> @map(x => @int(x))
    |> @filter(x => x > 0)
    |> @sum()

# With custom functions
process_text: (text) => @text
    |> @normalize_whitespace()
    |> @remove_punctuation()
    |> @tokenize()
    |> @remove_stopwords()
    |> @stem()

# Data processing pipeline
report: @raw_data
    |> @validate()
    |> @clean()
    |> @transform()
    |> @aggregate()
    |> @format()
```

## Async Chain Operations

```tusk
# Async/await chaining
result: await @fetch(url)
    .then(response => response.json())
    .then(data => @process(data))
    .then(processed => @save(processed))
    .catch(error => @log_error(error))

# Parallel operations
results: await @Promise.all([
    @fetch_user_data(id),
    @fetch_user_posts(id),
    @fetch_user_stats(id)
]).then(([user, posts, stats]) => {
    user: @user
    posts: @posts
    stats: @stats
})
```

## Cache Chaining

```tusk
# Cache with chaining
user: @cache
    .remember("user:" + @id, 3600)
    .get(() => @db.table("users").find(@id))
    .with(["posts", "comments"])
    .append({calculated_field: @calculate_something()})

# Tagged cache chaining
@cache
    .tags(["users", "user:" + @id])
    .put("user_profile:" + @id, @profile, 3600)
```

## Validation Chaining

```tusk
# Input validation chains
validation: @validator
    .input(@request.all())
    .rules({
        name: "required|string|max:255"
        email: "required|email|unique:users"
        age: "required|integer|min:18"
    })
    .validate()
    .onFail(errors => @response.json({errors}, 422))
    .onPass(data => @create_user(data))
```

## HTTP Client Chaining

```tusk
# HTTP request building
response: @http
    .post("https://api.example.com/users")
    .headers({
        "Authorization": "Bearer " + @token
        "Content-Type": "application/json"
    })
    .timeout(5000)
    .retry(3)
    .body({
        name: @name
        email: @email
    })
    .send()

# Response handling
data: @response
    .ensureSuccess()
    .json()
    .get("data")
    .map(item => @transform(item))
```

## Form Builder Chaining

```tusk
# Form building
form: @form("user")
    .method("POST")
    .action("/users")
    .field("name")
        .type("text")
        .required()
        .placeholder("Enter name")
    .field("email")
        .type("email")
        .required()
        .validate("email")
    .field("role")
        .type("select")
        .options(@roles)
        .default("user")
    .csrf()
    .render()
```

## Event Chaining

```tusk
# Event emitter chaining
@events
    .on("user.created", @send_welcome_email)
    .on("user.created", @track_analytics)
    .on("user.created", @update_stats)
    .emit("user.created", {user: @new_user})

# Promise-based events
result: @events
    .emit_async("process.start", {id: @id})
    .then(() => @do_processing())
    .then(() => @events.emit_async("process.complete", {id: @id}))
```

## Error Handling in Chains

```tusk
# Try-catch chaining
result: @try_chain()
    .attempt(() => @risky_operation())
    .catch(DatabaseException, e => @handle_db_error(e))
    .catch(NetworkException, e => @retry_operation())
    .catch(e => @log_error(e))
    .finally(() => @cleanup())

# Safe chaining with defaults
value: @deep_nested_value()
    ?.property
    ?.subproperty
    ?.method()
    .or(@default_value)
```

## Custom Chain Methods

```tusk
# Extend objects with chainable methods
String.prototype.slugify: () => {
    return @this
        .trim()
        .lower()
        .replace(/[^\w\s-]/g, "")
        .replace(/\s+/g, "-")
}

# Usage
slug: @title.slugify()

# Create chainable wrapper
chainable: (value) => {
    return {
        value: @value
        
        map: (fn) => @chainable(@fn(@value))
        filter: (fn) => @chainable(@fn(@value) ? @value : null)
        tap: (fn) => { @fn(@value); return @this }
        get: () => @value
    }
}

# Use custom chainable
result: @chainable(@data)
    .tap(d => @log("Processing", d))
    .map(d => @transform(d))
    .tap(d => @log("Transformed", d))
    .get()
```

## Best Practices

1. **Keep chains readable** - Break long chains into multiple lines
2. **Use null-safe operators** - Prevent errors with ?. operator
3. **Handle errors appropriately** - Add catch() for async chains
4. **Don't over-chain** - Sometimes separate statements are clearer
5. **Create reusable chains** - Extract common patterns into functions
6. **Document complex chains** - Add comments for clarity

## Related Features

- `@pipe()` - Function composition
- `@tap()` - Side effects in chains
- `@when()` - Conditional chaining
- `@unless()` - Negative conditional chaining
- `@collect()` - Collection wrapper
---

[@ Operator Nesting]


TuskLang allows sophisticated nesting of @ operators, enabling complex data transformations and operations while maintaining readability.

## Basic Nesting

```tusk
# Nested property access
city: @users[@index].address.city

# Nested function calls
result: @calculate(@sum(@array.map(x => @x.value)))

# Mixed nesting
formatted: @upper(@trim(@user.name|@default_name))
```

## Array and Object Nesting

```tusk
# Nested array operations
matrix_sum: @array.map(row => @sum(@row.filter(x => @x > 0)))

# Deep object creation
user_profile: {
    name: @user.name
    stats: {
        posts: @count(@posts.where("user_id", @user.id))
        comments: @count(@comments.where("user_id", @user.id))
        likes: @sum(@posts.map(p => @p.likes))
    }
    recent_activity: @activities
        .where("user_id", @user.id)
        .orderBy("created_at", "desc")
        .limit(5)
        .map(a => {
            type: @a.type
            timestamp: @format_date(@a.created_at)
            details: @json_decode(@a.data)
        })
}
```

## Conditional Nesting

```tusk
# Nested ternary operators
status: @user.active ? 
    (@user.verified ? "active-verified" : "active-unverified") : 
    (@user.suspended ? "suspended" : "inactive")

# Nested if conditions
access_level: @if(@user.is_admin) {
    "admin"
} elseif(@user.roles.includes("editor")) {
    @if(@user.department == "news") {
        "news-editor"
    } else {
        "general-editor"
    }
} else {
    @user.is_premium ? "premium-user" : "basic-user"
}

# Complex condition nesting
can_edit: @user && (
    @user.id == @post.author_id || 
    @user.roles.some(r => @allowed_roles.includes(@r)) ||
    (@user.is_moderator && @post.status != "locked")
)
```

## Function Composition Nesting

```tusk
# Nested function composition
process_data: (data) => {
    return @validate(
        @transform(
            @normalize(
                @clean(@data)
            )
        )
    )
}

# Using pipe for clarity
process_data_clear: (data) => {
    return @data
        |> @clean()
        |> @normalize()
        |> @transform()
        |> @validate()
}

# Nested map/filter/reduce
result: @users
    .map(u => {
        user: @u
        orders: @orders.filter(o => @o.user_id == @u.id)
        total: @orders.reduce((sum, o) => @sum + @o.total, 0)
    })
    .filter(u => @u.total > 1000)
    .sort((a, b) => @b.total - @a.total)
```

## Query Nesting

```tusk
# Subqueries in TuskLang
high_value_customers: @query("
    SELECT * FROM users 
    WHERE id IN (?)
", [
    @query("
        SELECT user_id 
        FROM orders 
        GROUP BY user_id 
        HAVING SUM(total) > ?
    ", [1000])
])

# Nested query building
users_with_recent_orders: @User
    .whereIn("id", 
        @Order
            .select("user_id")
            .where("created_at", ">", @last_month)
            .where("status", "completed")
            .distinct()
    )
    .with(["profile", "preferences"])
    .get()
```

## Template Nesting

```tusk
# Nested template rendering
page_html: @render("layouts/main.tusk", {
    title: @page.title
    content: @render("pages/" + @page.template + ".tusk", {
        page: @page
        widgets: @page.widgets.map(w => 
            @render("widgets/" + @w.type + ".tusk", @w.data)
        )
    })
    sidebar: @render("partials/sidebar.tusk", {
        menu: @build_menu(@user.role)
        recent: @get_recent_items(@user.id)
    })
})

# Nested component rendering
form_field: @render("form/field.tusk", {
    label: @field.label
    input: @render("form/inputs/" + @field.type + ".tusk", {
        name: @field.name
        value: @old(@field.name)|@field.default
        attributes: @merge(@field.attributes, {
            class: @errors.has(@field.name) ? "error" : ""
        })
    })
    error: @errors.has(@field.name) ? 
        @render("form/error.tusk", {message: @errors.first(@field.name)}) : 
        ""
})
```

## Cache Nesting

```tusk
# Nested cache operations
user_dashboard: @cache.remember("dashboard:" + @user.id, 3600, () => {
    return {
        profile: @cache.remember("user:" + @user.id, 7200, () => 
            @User.with(["profile", "settings"]).find(@user.id)
        )
        stats: @cache.remember("stats:" + @user.id, 1800, () => {
            posts: @count(@Post.where("user_id", @user.id))
            comments: @count(@Comment.where("user_id", @user.id))
            likes: @cache.remember("likes:" + @user.id, 900, () =>
                @Like.where("user_id", @user.id).count()
            )
            return {posts: @posts, comments: @comments, likes: @likes}
        })
        recent_activity: @get_recent_activity(@user.id)
    }
})
```

## Error Handling Nesting

```tusk
# Nested try-catch blocks
process_payment: (order) => {
    @try {
        payment_result: @try {
            return @payment_gateway.charge({
                amount: @order.total
                currency: @order.currency
                source: @order.payment_token
            })
        } catch (PaymentException e) {
            # Try backup payment method
            @try {
                return @backup_gateway.charge(@order)
            } catch (BackupException be) {
                @log.error("All payment methods failed", {
                    primary_error: @e.message
                    backup_error: @be.message
                })
                @throw new PaymentFailedException("Payment processing failed")
            }
        }
        
        # Process successful payment
        @order.markAsPaid(@payment_result.transaction_id)
        
    } catch (Exception e) {
        @handle_payment_failure(@order, @e)
    }
}
```

## Async Operation Nesting

```tusk
# Nested async operations
load_user_data: async (user_id) => {
    user: await @User.find(@user_id)
    
    # Parallel nested loading
    [posts, comments, likes]: await @Promise.all([
        @Post.where("user_id", @user.id).get(),
        @Comment.where("user_id", @user.id).get(),
        @Like.where("user_id", @user.id).get()
    ])
    
    # Process nested data
    enhanced_posts: await @Promise.all(
        @posts.map(async (post) => {
            post_likes: await @Like.where("post_id", @post.id).count()
            post_comments: await @Comment.where("post_id", @post.id)
                .with("author")
                .limit(3)
                .get()
            
            return {
                ...@post
                likes_count: @post_likes
                recent_comments: @post_comments
                author: @user
            }
        })
    )
    
    return {
        user: @user
        posts: @enhanced_posts
        total_comments: @comments.length
        total_likes: @likes.length
    }
}
```

## Validation Nesting

```tusk
# Nested validation rules
validation_rules: {
    user: {
        name: "required|string|max:255"
        email: "required|email|unique:users"
        profile: {
            bio: "nullable|string|max:500"
            avatar: "nullable|image|max:2048"
            social: {
                twitter: "nullable|regex:/^@[A-Za-z0-9_]+$/"
                github: "nullable|url"
                website: "nullable|url"
            }
        }
        preferences: {
            notifications: {
                email: "boolean"
                push: "boolean"
                frequency: "in:instant,daily,weekly"
            }
        }
    }
}

# Nested validation execution
validate_nested: (data) => {
    errors: {}
    
    @foreach(@validation_rules.user as @field => @rules) {
        @if(@is_array(@rules)) {
            # Nested validation
            @foreach(@rules as @subfield => @subrules) {
                value: @data[@field][@subfield]
                result: @validate(@value, @subrules)
                @if(!@result.passes) {
                    errors[@field + "." + @subfield]: @result.errors
                }
            }
        } else {
            # Direct validation
            result: @validate(@data[@field], @rules)
            @if(!@result.passes) {
                errors[@field]: @result.errors
            }
        }
    }
    
    return @empty(@errors) ? {passes: true} : {passes: false, errors: @errors}
}
```

## Dynamic Property Nesting

```tusk
# Dynamic nested property access
get_nested_value: (object, path) => {
    segments: @explode(".", @path)
    
    return @segments.reduce((current, segment) => {
        return @current?[@segment]
    }, @object)
}

# Usage
value: @get_nested_value(@user, "profile.settings.theme.color")

# Dynamic nested property setting
set_nested_value: (object, path, value) => {
    segments: @explode(".", @path)
    last: @array_pop(@segments)
    
    current: @object
    @foreach(@segments as @segment) {
        @if(!@isset(@current[@segment])) {
            current[@segment]: {}
        }
        current: @current[@segment]
    }
    
    current[@last]: @value
    return @object
}
```

## Performance Considerations

```tusk
# Optimize nested operations
# Bad: Multiple nested queries
users_inefficient: @users.map(u => {
    posts: @Post.where("user_id", @u.id).get()  # N+1 problem
    return {...@u, posts: @posts}
})

# Good: Eager loading
users_efficient: @User.with("posts").get()

# Bad: Deep nesting with repeated calculations
result_bad: @data.map(d => 
    @expensive_calc(@expensive_calc(@expensive_calc(@d)))
)

# Good: Calculate once and reuse
result_good: @data.map(d => {
    step1: @expensive_calc(@d)
    step2: @expensive_calc(@step1)
    step3: @expensive_calc(@step2)
    return @step3
})
```

## Best Practices

1. **Limit nesting depth** - Too deep becomes unreadable
2. **Use intermediate variables** - Break complex nesting into steps
3. **Consider performance** - Nested loops and queries can be expensive
4. **Handle null values** - Use optional chaining (?.) for safety
5. **Extract complex logic** - Move deeply nested code to functions
6. **Document complex nesting** - Add comments explaining the logic

## Related Features

- `@pipe()` - Linear function composition
- `@compose()` - Function composition
- `@tap()` - Debugging nested operations
- `@get()` - Safe nested property access
- `@set()` - Safe nested property setting
---

[@ Custom Operators]


TuskLang allows you to define custom @ operators to extend the language with domain-specific functionality and create reusable abstractions.

## Defining Custom Operators

```tusk
# Basic custom operator
@define("uppercase", (value) => {
    return @strtoupper(@value)
})

# Usage
name: @uppercase("john doe")  # "JOHN DOE"

# Operator with multiple parameters
@define("between", (value, min, max) => {
    return @value >= @min && @value <= @max
})

# Usage
is_valid: @between(@age, 18, 65)
```

## Operator Namespaces

```tusk
# Create namespaced operators
@namespace("math") {
    # Define operators within namespace
    @define("factorial", (n) => {
        @if(@n <= 1) return 1
        return @n * @math.factorial(@n - 1)
    })
    
    @define("fibonacci", (n) => {
        @if(@n <= 1) return @n
        return @math.fibonacci(@n - 1) + @math.fibonacci(@n - 2)
    })
    
    @define("isPrime", (n) => {
        @if(@n <= 1) return false
        @for(i: 2; @i * @i <= @n; @i++) {
            @if(@n % @i == 0) return false
        }
        return true
    })
}

# Usage
result: @math.factorial(5)      # 120
fib: @math.fibonacci(10)        # 55
prime: @math.isPrime(17)        # true
```

## Chainable Operators

```tusk
# Create chainable custom operators
@define_chainable("query", {
    # Initialize with table
    constructor: (table) => {
        @this._table: @table
        @this._conditions: []
        @this._order: null
        @this._limit: null
    }
    
    # Chainable methods
    where: (field, operator, value) => {
        @this._conditions[]: {field: @field, op: @operator, val: @value}
        return @this
    }
    
    orderBy: (field, direction: "asc") => {
        @this._order: {field: @field, direction: @direction}
        return @this
    }
    
    limit: (count) => {
        @this._limit: @count
        return @this
    }
    
    # Execute query
    get: () => {
        sql: "SELECT * FROM " + @this._table
        
        @if(@count(@this._conditions) > 0) {
            conditions: @this._conditions.map(c => 
                @c.field + " " + @c.op + " ?"
            )
            sql: @sql + " WHERE " + @join(" AND ", @conditions)
        }
        
        @if(@this._order) {
            sql: @sql + " ORDER BY " + @this._order.field + " " + 
                 @this._order.direction
        }
        
        @if(@this._limit) {
            sql: @sql + " LIMIT " + @this._limit
        }
        
        params: @this._conditions.map(c => @c.val)
        return @execute_query(@sql, @params)
    }
})

# Usage
users: @query("users")
    .where("age", ">", 18)
    .where("status", "=", "active")
    .orderBy("created_at", "desc")
    .limit(10)
    .get()
```

## Property Operators

```tusk
# Define property-style operators
@define_property("age", {
    get: () => {
        @if(@this.birthdate) {
            return @calculate_age(@this.birthdate)
        }
        return null
    }
    
    set: (value) => {
        # Calculate birthdate from age
        @this.birthdate: @date("Y-m-d", @strtotime("-" + @value + " years"))
    }
})

# Usage in objects
person: {
    name: "John"
    birthdate: "1990-05-15"
    age: @age  # Calculates from birthdate
}

person.age: 25  # Sets birthdate accordingly
```

## Validation Operators

```tusk
# Custom validation operators
@namespace("validate") {
    @define("email", (value) => {
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        return @pattern.test(@value)
    })
    
    @define("phone", (value) => {
        # Remove non-digits
        digits: @preg_replace("/[^0-9]/", "", @value)
        return @strlen(@digits) == 10 || @strlen(@digits) == 11
    })
    
    @define("creditCard", (value) => {
        # Luhn algorithm
        digits: @preg_replace("/[^0-9]/", "", @value)
        sum: 0
        alternate: false
        
        @for(i: @strlen(@digits) - 1; @i >= 0; @i--) {
            n: @int(@digits[@i])
            @if(@alternate) {
                n: @n * 2
                @if(@n > 9) n: @n - 9
            }
            sum: @sum + @n
            alternate: !@alternate
        }
        
        return @sum % 10 == 0
    })
}

# Usage
is_valid_email: @validate.email("user@example.com")
is_valid_phone: @validate.phone("(555) 123-4567")
is_valid_card: @validate.creditCard("4532-1234-5678-9012")
```

## Type Conversion Operators

```tusk
# Custom type converters
@namespace("convert") {
    @define("money", (value, currency: "USD") => {
        amount: @float(@value)
        
        return {
            amount: @amount
            currency: @currency
            formatted: @format_currency(@amount, @currency)
            
            # Methods
            add: (other) => @convert.money(@amount + @other.amount, @currency)
            subtract: (other) => @convert.money(@amount - @other.amount, @currency)
            multiply: (factor) => @convert.money(@amount * @factor, @currency)
            
            # Conversion
            to: (target_currency) => {
                rate: @get_exchange_rate(@currency, @target_currency)
                return @convert.money(@amount * @rate, @target_currency)
            }
        }
    })
    
    @define("duration", (value, unit: "seconds") => {
        seconds: @convert_to_seconds(@value, @unit)
        
        return {
            seconds: @seconds
            minutes: @seconds / 60
            hours: @seconds / 3600
            days: @seconds / 86400
            
            formatted: @format_duration(@seconds)
            
            add: (other) => @convert.duration(@seconds + @other.seconds)
            subtract: (other) => @convert.duration(@seconds - @other.seconds)
        }
    })
}

# Usage
price: @convert.money(99.99)
total: @price.multiply(1.08)  # Add tax
euros: @total.to("EUR")

duration: @convert.duration(90, "minutes")
remaining: @duration.subtract(@convert.duration(30, "minutes"))
```

## Async Operators

```tusk
# Define async operators
@define_async("fetch_json", async (url, options: {}) => {
    response: await @fetch(@url, @options)
    
    @if(!@response.ok) {
        @throw new Error("HTTP " + @response.status)
    }
    
    return await @response.json()
})

@define_async("parallel", async (tasks) => {
    return await @Promise.all(@tasks)
})

# Usage
data: await @fetch_json("https://api.example.com/data")

results: await @parallel([
    @fetch_json("/api/users"),
    @fetch_json("/api/posts"),
    @fetch_json("/api/comments")
])
```

## Macro Operators

```tusk
# Define macro operators for code generation
@define_macro("crud", (model_name) => {
    # Generate CRUD operations
    return {
        create: (data) => @{model_name}.create(@data)
        read: (id) => @{model_name}.find(@id)
        update: (id, data) => @{model_name}.update(@id, @data)
        delete: (id) => @{model_name}.destroy(@id)
        list: (filters: {}) => @{model_name}.where(@filters).get()
    }
})

# Usage
UserCrud: @crud("User")
users: @UserCrud.list({active: true})
new_user: @UserCrud.create({name: "John", email: "john@example.com"})
```

## Domain-Specific Operators

```tusk
# E-commerce operators
@namespace("shop") {
    @define("calculateTax", (amount, location) => {
        rate: @get_tax_rate(@location)
        return @amount * @rate
    })
    
    @define("applyDiscount", (price, discount) => {
        @if(@discount.type == "percentage") {
            return @price * (1 - @discount.value / 100)
        } elseif(@discount.type == "fixed") {
            return @max(0, @price - @discount.value)
        }
        return @price
    })
    
    @define("calculateShipping", (items, destination) => {
        weight: @sum(@items.map(i => @i.weight * @i.quantity))
        distance: @calculate_distance(@destination)
        
        return @calculate_shipping_cost(@weight, @distance)
    })
}

# Usage
subtotal: 99.99
tax: @shop.calculateTax(@subtotal, @user.location)
discounted: @shop.applyDiscount(@subtotal, {type: "percentage", value: 10})
shipping: @shop.calculateShipping(@cart.items, @user.address)
```

## Operator Composition

```tusk
# Compose operators from existing ones
@define("process_order", @compose(
    @validate.order,
    @shop.calculateTotals,
    @payment.charge,
    @inventory.reserve,
    @notification.send
))

# Usage
result: @process_order(@order_data)

# Create operator pipelines
@define("sanitize_input", @pipeline(
    @trim,
    @strip_tags,
    @escape_html,
    @normalize_whitespace
))

# Usage
clean: @sanitize_input(@user_input)
```

## Testing Custom Operators

```tusk
# Test custom operators
@test("math operators") {
    @assert(@math.factorial(5) == 120)
    @assert(@math.fibonacci(10) == 55)
    @assert(@math.isPrime(17) == true)
    @assert(@math.isPrime(18) == false)
}

@test("validation operators") {
    @assert(@validate.email("test@example.com") == true)
    @assert(@validate.email("invalid-email") == false)
    @assert(@validate.phone("555-123-4567") == true)
}
```

## Registration and Discovery

```tusk
# Register operators globally
@register_operator("myapp", {
    version: "1.0.0"
    operators: {
        helper1: @helper1_function
        helper2: @helper2_function
    }
})

# Discover available operators
available: @discover_operators()
/* Output:
{
    core: [...],        # Built-in operators
    math: [...],        # Custom math namespace
    validate: [...],    # Custom validation namespace
    myapp: [...]       # Registered operators
}
*/

# Get operator info
info: @operator_info("math.factorial")
/* Output:
{
    name: "factorial"
    namespace: "math"
    parameters: ["n"]
    description: "Calculate factorial of n"
    examples: ["@math.factorial(5) // returns 120"]
}
*/
```

## Best Practices

1. **Use clear naming** - Operators should be self-documenting
2. **Follow conventions** - Stick to TuskLang naming patterns
3. **Add validation** - Validate inputs in custom operators
4. **Document thoroughly** - Include examples and parameter descriptions
5. **Test extensively** - Custom operators should be well-tested
6. **Consider performance** - Optimize frequently used operators

## Related Features

- `@define()` - Define custom functions
- `@namespace()` - Organize operators
- `@compose()` - Function composition
- `@extend()` - Extend existing operators
- `@override()` - Override built-in operators
---

[@ Operator Errors]


Understanding and handling errors with @ operators is crucial for building robust TuskLang applications. This guide covers error types, handling strategies, and best practices for @ operator error management.

## Common @ Operator Errors

### Reference Errors

```tusk
# Undefined variable reference
value = @undefined_variable  # Error: undefined_variable is not defined

# Non-existent property
user: { name: "John" }
email = @user.email  # Returns null, not error
age = @user.profile.age  # Error: Cannot read property 'age' of undefined

# Safe property access
email = @user?.email ?? "no-email"
age = @user?.profile?.age ?? 0
```

### Type Errors

```tusk
# Wrong operator usage
static_value: @env.PORT  # Error: @ operators require = not :

# Invalid operation on null
value: null
result = @value.toUpperCase()  # Error: Cannot read property of null

# Type mismatch in operations
text: "hello"
result = @text * 2  # Error: Cannot multiply string

# Safe type handling
result = @if(@isString(text), @text.toUpperCase(), text)
```

### Syntax Errors

```tusk
# Missing parentheses
result = @map items, @lambda(x, x * 2)  # Error: Missing parentheses

# Correct syntax
result = @map(items, @lambda(x, x * 2))

# Invalid @ operator syntax
value = @ env.PORT  # Error: Space after @
value = @@double_at  # Error: Invalid syntax

# Nested @ operator issues
value = @{@dynamic_key}  # Error: Invalid syntax
# Correct: Use brackets
value = @parent[@dynamic_key]
```

## Error Handling Strategies

### Try-Catch Pattern

```tusk
# Basic try-catch with @ operators
safe_operation = @try({
    data = @json.parse(@file.read("config.json"))
    port = @data.server.port
    return: port
}, {
    error = @catch
    @log.error("Failed to load config: ${error.message}")
    return: 8080  # Default value
})

# Catching specific errors
result = @try({
    user = @db.query("SELECT * FROM users WHERE id = ?", user_id)[0]
    return: @user.email
}, {
    error = @catch
    
    @if(@includes(error.message, "connection"), {
        @log.error("Database connection error")
        return: null
    })
    
    @if(@includes(error.message, "undefined"), {
        @log.warn("User not found")
        return: "not-found"
    })
    
    # Re-throw unknown errors
    @throw(error)
})
```

### Error Object Structure

```tusk
# Standard error object
handle_error = @lambda(operation, {
    result = @try({
        data: @operation()
        return: { success: true, data: data }
    }, {
        error: @catch
        
        return: {
            success: false
            error: {
                message: error.message
                code: error.code ?? "UNKNOWN_ERROR"
                stack: error.stack
                timestamp: @time.now()
                operation: @operation.name
            }
        }
    })
})
```

### Custom Error Types

```tusk
# Define custom error types
ValidationError = @lambda(message, field, {
    return: {
        name: "ValidationError"
        message: message
        field: field
        code: "VALIDATION_ERROR"
    }
})

NotFoundError = @lambda(resource, id, {
    return: {
        name: "NotFoundError"
        message: "${resource} with id ${id} not found"
        resource: resource
        id: id
        code: "NOT_FOUND"
    }
})

# Throw custom errors
validate_email = @lambda(email, {
    @if(!@regex.test(email, "^[^@]+@[^@]+$"), {
        @throw(@ValidationError("Invalid email format", "email"))
    })
})
```

## @ Operator-Specific Error Handling

### Environment Variable Errors

```tusk
# Missing environment variables
api_key = @env.API_KEY  # Might be null

# Error if required
require_env = @lambda(name, {
    value = @env[name]
    @if(!value, {
        @throw("Environment variable ${name} is required")
    })
    return: value
})

api_key = @require_env("API_KEY")

# With fallback and warning
get_env = @lambda(name, default_value = null, required = false, {
    value = @env[name]
    
    @if(!value, {
        @if(required, {
            @throw("Required environment variable ${name} is not set")
        })
        
        @if(default_value == null, {
            @log.warn("Environment variable ${name} not set")
        })
        
        return: default_value
    })
    
    return: value
})
```

### File Operation Errors

```tusk
# File reading errors
read_config = @lambda(path, {
    return: @try({
        content: @file.read(path)
        data: @json.parse(content)
        return: data
    }, {
        error: @catch
        
        @if(@includes(error.message, "ENOENT"), {
            @log.error("File not found: ${path}")
            return: null
        })
        
        @if(@includes(error.message, "EACCES"), {
            @log.error("Permission denied: ${path}")
            return: null
        })
        
        @if(@includes(error.message, "JSON"), {
            @log.error("Invalid JSON in file: ${path}")
            return: null
        })
        
        @throw(error)
    })
})
```

### HTTP Request Errors

```tusk
# Comprehensive HTTP error handling
http_request = @lambda(url, options = {}, {
    max_retries = options.retries ?? 3
    retry_delay = options.retry_delay ?? 1000
    
    attempt = @lambda(retry_count, {
        return: @try({
            response = @http.request(url, options)
            
            # Check HTTP status
            @if(response.status >= 400, {
                @throw({
                    name: "HTTPError"
                    message: "HTTP ${response.status}: ${response.statusText}"
                    status: response.status
                    response: response
                })
            })
            
            return: response
        }, {
            error = @catch
            
            # Network errors - retry
            @if(@includes(error.message, "ECONNREFUSED") || 
                @includes(error.message, "ETIMEDOUT"), {
                
                @if(retry_count < max_retries, {
                    @log.warn("Network error, retrying... (${retry_count + 1}/${max_retries})")
                    @time.sleep(retry_delay * (retry_count + 1))
                    return: @attempt(retry_count + 1)
                })
            })
            
            # HTTP errors - check if should retry
            @if(error.name == "HTTPError", {
                # Retry on 5xx errors
                @if(error.status >= 500 && retry_count < max_retries, {
                    @log.warn("Server error ${error.status}, retrying...")
                    @time.sleep(retry_delay * (retry_count + 1))
                    return: @attempt(retry_count + 1)
                })
                
                # Don't retry client errors (4xx)
                @throw(error)
            })
            
            @throw(error)
        })
    })
    
    return: @attempt(0)
})
```

### Database Query Errors

```tusk
# Database error handling
safe_query = @lambda(sql, params = [], {
    return: @try({
        results: @query(sql, ...params)
        return: { success: true, data: results }
    }, {
        error: @catch
        
        # Connection errors
        @if(@includes(error.message, "ECONNREFUSED"), {
            return: {
                success: false
                error: "Database connection refused"
                code: "DB_CONNECTION_ERROR"
                retry: true
            }
        })
        
        # Constraint violations
        @if(@includes(error.message, "UNIQUE constraint"), {
            return: {
                success: false
                error: "Duplicate entry"
                code: "DUPLICATE_ERROR"
                retry: false
            }
        })
        
        # Syntax errors
        @if(@includes(error.message, "syntax error"), {
            @log.error("SQL syntax error: ${sql}")
            return: {
                success: false
                error: "Query syntax error"
                code: "SYNTAX_ERROR"
                retry: false
            }
        })
        
        # Unknown database errors
        return: {
            success: false
            error: error.message
            code: "DB_ERROR"
            retry: false
        }
    })
})
```

## Error Recovery Patterns

### Fallback Chain

```tusk
# Multiple fallback sources
get_config_value = @lambda(key, {
    # Try primary source
    value = @try({
        return: @cache.get(key)
    })
    
    # Try secondary source
    @if(!value, {
        value = @try({
            return: @db.query("SELECT value FROM config WHERE key = ?", key)[0]?.value
        })
    })
    
    # Try file source
    @if(!value, {
        value = @try({
            config = @json.parse(@file.read("config.json"))
            return: @config[key]
        })
    })
    
    # Final fallback
    return: value ?? @defaults[key] ?? null
})
```

### Circuit Breaker Pattern

```tusk
# Prevent cascading failures
create_circuit_breaker = @lambda(operation, options = {}, {
    threshold: options.threshold ?? 5
    timeout: options.timeout ?? 60000  # 1 minute
    
    state: "closed"  # closed, open, half-open
    failures: 0
    last_failure: null
    
    return: @lambda(...args, {
        # Check if circuit is open
        @if(state == "open", {
            # Check if timeout has passed
            @if(@time.now() - last_failure > timeout, {
                state = "half-open"
                failures = 0
            }, {
                @throw("Circuit breaker is open")
            })
        })
        
        # Try operation
        result = @try({
            result: @operation(...args)
            
            # Success - reset circuit
            @if(state == "half-open", {
                state = "closed"
            })
            failures = 0
            
            return: result
        }, {
            error: @catch
            failures = failures + 1
            last_failure = @time.now()
            
            # Open circuit if threshold reached
            @if(failures >= threshold, {
                state = "open"
                @log.error("Circuit breaker opened after ${failures} failures")
            })
            
            @throw(error)
        })
        
        return: result
    })
})
```

## Error Logging and Monitoring

### Structured Error Logging

```tusk
# Comprehensive error logger
log_error = @lambda(error, context = {}, {
    error_data: {
        timestamp: @time.iso()
        level: "ERROR"
        message: error.message
        code: error.code
        stack: error.stack
        
        # Context information
        user_id: @request?.user?.id
        request_id: @request?.id
        url: @request?.url
        method: @request?.method
        
        # Custom context
        ...context
        
        # System information
        hostname: @system.hostname
        process_id: @process.pid
        memory_usage: @process.memory_usage
    }
    
    # Log to multiple destinations
    @console.error(@json.stringify(error_data))
    @file.append("errors.log", @json.stringify(error_data) + "\n")
    
    # Send to monitoring service
    @try({
        @http.post("https://monitoring.example.com/errors", {
            body: error_data
        })
    })
    
    return: error_data
})
```

### Error Aggregation

```tusk
# Collect and group errors
error_aggregator:
    errors: []
    max_errors: 100
    
    add: @lambda(error, {
        @push(@errors, {
            error: error
            timestamp: @time.now()
            count: 1
        })
        
        # Limit array size
        @if(@len(@errors) > @max_errors, {
            @shift(@errors)
        })
        
        # Group similar errors
        @aggregate()
    })
    
    aggregate: @lambda({
        grouped = @group_by(@errors, @lambda(e, {
            # Group by error message and code
            return: "${e.error.code}_${e.error.message}"
        }))
        
        return: @map(@entries(grouped), @lambda(entry, {
            [key, errors] = entry
            return: {
                key: key
                count: @len(errors)
                first_seen: @min(@map(errors, @lambda(e, e.timestamp)))
                last_seen: @max(@map(errors, @lambda(e, e.timestamp)))
                sample: errors[0].error
            }
        }))
    })
```

## Best Practices

### 1. Fail Fast with Clear Messages

```tusk
# Bad: Silent failure
value = @env.API_KEY ?? ""

# Good: Clear error for required values
value = @env.API_KEY ?? @throw("API_KEY environment variable is required")
```

### 2. Use Specific Error Types

```tusk
# Bad: Generic error
@throw("Error occurred")

# Good: Specific error with context
@throw({
    name: "ConfigurationError"
    message: "Invalid port number: must be between 1 and 65535"
    field: "port"
    value: port
    code: "INVALID_PORT"
})
```

### 3. Provide Recovery Options

```tusk
# Bad: Just throw error
data = @file.read(path)

# Good: Provide fallback
data = @try({
    return: @file.read(path)
}, {
    @log.warn("Could not read ${path}, using default")
    return: @default_data
})
```

### 4. Log Errors with Context

```tusk
# Bad: No context
@catch(error, {
    @log.error(error.message)
})

# Good: Rich context
@catch(error, {
    @log_error(error, {
        operation: "user_registration"
        user_email: email
        step: "email_validation"
    })
})
```

### 5. Handle Async Errors

```tusk
# Handle Promise rejections
async_operation = @lambda({
    return: @promise(@lambda(resolve, reject, {
        @try({
            result = @http.get(url)
            @resolve(result)
        }, {
            error = @catch
            @log_error(error)
            @reject(error)
        })
    }))
})
```

## Common Error Patterns

### Validation Errors

```tusk
# Collect multiple validation errors
validate_user = @lambda(data, {
    errors: []
    
    # Validate required fields
    @if(!data.name, {
        @push(errors, @ValidationError("Name is required", "name"))
    })
    
    @if(!data.email, {
        @push(errors, @ValidationError("Email is required", "email"))
    }, @if(!@validate.email(data.email), {
        @push(errors, @ValidationError("Invalid email format", "email"))
    }))
    
    @if(data.age != null && (data.age < 0 || data.age > 150), {
        @push(errors, @ValidationError("Age must be between 0 and 150", "age"))
    })
    
    @if(@len(errors) > 0, {
        @throw({
            name: "ValidationError"
            message: "Validation failed"
            errors: errors
        })
    })
    
    return: true
})
```

### Retry with Backoff

```tusk
# Exponential backoff retry
retry_with_backoff = @lambda(operation, max_attempts = 3, {
    attempt = @lambda(count, {
        return: @try({
            return: @operation()
        }, {
            error = @catch
            
            @if(count >= max_attempts, {
                @throw(error)
            })
            
            # Exponential backoff: 1s, 2s, 4s...
            delay = 1000 * (2 ** (count - 1))
            @log.warn("Attempt ${count} failed, retrying in ${delay}ms...")
            
            @time.sleep(delay)
            return: @attempt(count + 1)
        })
    })
    
    return: @attempt(1)
})
```

## Next Steps

- Learn about [Performance Optimization](059-at-operator-performance.md)
- Explore [Security Best Practices](060-at-operator-security.md)
- Master [Error Recovery Patterns](033-at-variable-fallback.md)
---

[@ Operator Performance]


Understanding the performance characteristics of @ operators is crucial for building efficient TuskLang applications. This guide covers optimization techniques and best practices.

## Performance Basics

```tusk
# Operator overhead comparison
@benchmark({
    # Direct property access (fastest)
    "direct": () => {
        value: object.property
    }
    
    # @ operator access (minimal overhead)
    "operator": () => {
        value: @object.property
    }
    
    # Dynamic access (slower)
    "dynamic": () => {
        value: @get(@object, "property")
    }
})
```

## Caching Operator Results

```tusk
# Cache expensive operations
expensive_calculation: @cache.remember("calc:" + @id, 3600, () => {
    return @perform_expensive_calculation(@id)
})

# Memoization for pure functions
@memoize
fibonacci: (n) => {
    @if(@n <= 1) return @n
    return @fibonacci(@n - 1) + @fibonacci(@n - 2)
}

# Manual memoization
memoized_function: (() => {
    cache: {}
    return (input) => {
        key: @json_encode(@input)
        @if(@isset(@cache[@key])) {
            return @cache[@key]
        }
        result: @expensive_operation(@input)
        @cache[@key]: @result
        return @result
    }
})()
```

## Lazy Evaluation

```tusk
# Lazy loading with operators
LazyCollection: {
    items: null
    
    # Only load when accessed
    @lazy
    get_items: () => {
        @if(@this.items === null) {
            @this.items: @load_items_from_database()
        }
        return @this.items
    }
    
    # Lazy computed properties
    @lazy
    total: () => {
        return @sum(@this.get_items().map(i => @i.value))
    }
}

# Usage - items only loaded when needed
collection: @LazyCollection.new()
@if(@some_condition) {
    total: @collection.total  # Now items are loaded
}
```

## Operator Batching

```tusk
# Batch multiple operations
BatchProcessor: {
    queue: []
    
    add: (item) => {
        @this.queue[]: @item
        
        # Process when batch is full
        @if(@count(@this.queue) >= 100) {
            @this.process()
        }
    }
    
    process: () => {
        @if(@empty(@this.queue)) return
        
        # Process entire batch at once
        @bulk_insert(@this.queue)
        @this.queue: []
    }
}

# Batch database operations
@foreach(@items as @item) {
    @BatchProcessor.add(@item)  # Batched inserts
}
@BatchProcessor.process()  # Process remaining
```

## Query Optimization

```tusk
# N+1 query problem (bad)
users_bad: @User.all()
@foreach(@users_bad as @user) {
    posts: @Post.where("user_id", @user.id).get()  # N queries
}

# Eager loading (good)
users_good: @User.with("posts").get()  # 2 queries total

# Query result caching
get_user_with_cache: (id) => {
    # Check memory cache first
    @if(@runtime_cache[@id]) {
        return @runtime_cache[@id]
    }
    
    # Then check Redis
    cached: @redis.get("user:" + @id)
    @if(@cached) {
        @runtime_cache[@id]: @json_decode(@cached)
        return @runtime_cache[@id]
    }
    
    # Finally hit database
    user: @User.find(@id)
    @redis.setex("user:" + @id, 3600, @json_encode(@user))
    @runtime_cache[@id]: @user
    return @user
}
```

## String Operation Performance

```tusk
# String concatenation performance
# Bad - multiple concatenations
result_bad: ""
@foreach(@items as @item) {
    result_bad: @result_bad + @item + ", "  # Creates new string each time
}

# Good - use array join
result_good: @join(", ", @items)

# Better - use string builder
builder: @StringBuilder.new()
@foreach(@items as @item) {
    @builder.append(@item).append(", ")
}
result_better: @builder.toString()

# String operations benchmark
@benchmark({
    "concatenation": () => {
        result: ""
        @for(i: 0; @i < 1000; @i++) {
            result: @result + "x"
        }
    }
    
    "array_join": () => {
        parts: []
        @for(i: 0; @i < 1000; @i++) {
            parts[]: "x"
        }
        result: @join("", @parts)
    }
    
    "string_builder": () => {
        builder: @StringBuilder.new()
        @for(i: 0; @i < 1000; @i++) {
            @builder.append("x")
        }
        result: @builder.toString()
    }
})
```

## Array Operation Performance

```tusk
# Array operation optimization
# Bad - multiple passes
result_bad: @array
    .filter(x => @x.active)
    .map(x => @x.value)
    .filter(x => @x > 100)
    .map(x => @x * 1.1)

# Good - single pass
result_good: []
@foreach(@array as @item) {
    @if(@item.active && @item.value > 100) {
        @result_good[]: @item.value * 1.1
    }
}

# Use generators for large datasets
process_large_file: (file) => {
    @foreach(@file.lines() as @line) {  # Generator, doesn't load all lines
        @if(@matches_criteria(@line)) {
            @yield @process_line(@line)
        }
    }
}
```

## Memory Management

```tusk
# Memory-efficient operations
# Bad - loads entire dataset
all_users: @User.all()  # Loads all users into memory
filtered: @all_users.filter(u => @u.active)

# Good - filter at database level
filtered: @User.where("active", true).get()

# Better - use chunks for large datasets
@User.where("active", true).chunk(100, (users) => {
    @foreach(@users as @user) {
        @process_user(@user)
    }
    # Memory is freed after each chunk
})

# Monitor memory usage
memory_before: @memory_get_usage()
@perform_operation()
memory_after: @memory_get_usage()
memory_used: @memory_after - @memory_before

@if(@memory_used > 10485760) {  # 10MB
    @log.warning("High memory usage", {
        used: @format_bytes(@memory_used)
        peak: @format_bytes(@memory_get_peak_usage())
    })
}
```

## Parallel Processing

```tusk
# Parallel operator execution
results: @parallel.map(@items, (item) => {
    return @expensive_operation(@item)
}, {
    workers: 4
    chunk_size: 50
})

# Async parallel processing
async_results: await @Promise.all(
    @items.map(async (item) => {
        return await @async_operation(@item)
    })
)

# Worker pool for CPU-intensive tasks
worker_pool: @WorkerPool.create({
    workers: @cpu_count()
    task: (data) => @heavy_computation(@data)
})

results: await @worker_pool.process(@large_dataset)
```

## JIT Compilation

```tusk
# Mark hot functions for JIT
@jit
hot_function: (data) => {
    # This function will be JIT compiled after threshold
    result: 0
    @foreach(@data as @item) {
        result: @result + @item.value * @item.weight
    }
    return @result
}

# JIT configuration
@jit.config({
    threshold: 1000      # Compile after 1000 calls
    optimize_level: 3    # Maximum optimization
    profile: true        # Profile for better optimization
})

# Check JIT status
status: @jit.status("hot_function")
/* Output:
{
    compiled: true
    calls: 5234
    avg_time_before: 0.0045
    avg_time_after: 0.0008
    speedup: 5.625
}
*/
```

## Profiling Operators

```tusk
# Profile operator performance
@profile.start("operation_name")

# Your code here
result: @complex_operation()

profile: @profile.end("operation_name")
/* Output:
{
    duration: 0.234
    memory_used: 2048576
    memory_peak: 3145728
    operators_called: {
        "@query": 15,
        "@map": 234,
        "@filter": 89
    }
}
*/

# Automatic profiling
@autoprofile(threshold: 0.01)  # Profile operations over 10ms
process_data: (data) => {
    return @transform(@validate(@clean(@data)))
}

# Get profiling report
report: @profile.report()
```

## Optimization Patterns

```tusk
# Early return pattern
process_item: (item) => {
    # Check conditions early
    @if(!@item) return null
    @if(!@item.active) return null
    @if(@item.processed) return @item.result
    
    # Expensive operations only if needed
    return @expensive_process(@item)
}

# Precompute pattern
PrecomputedData: {
    _lookup_table: null
    
    get_lookup: () => {
        @if(!@this._lookup_table) {
            # Build lookup table once
            @this._lookup_table: {}
            data: @load_all_data()
            @foreach(@data as @item) {
                @this._lookup_table[@item.key]: @item
            }
        }
        return @this._lookup_table
    }
    
    find: (key) => {
        lookup: @this.get_lookup()
        return @lookup[@key]  # O(1) lookup
    }
}

# Circuit breaker pattern
CircuitBreaker: {
    failures: 0
    last_failure: null
    threshold: 5
    timeout: 60  # seconds
    
    call: (operation) => {
        # Check if circuit is open
        @if(@this.failures >= @this.threshold) {
            @if(@time() - @this.last_failure < @this.timeout) {
                @throw("Circuit breaker open")
            }
            # Reset after timeout
            @this.failures: 0
        }
        
        @try {
            result: @operation()
            @this.failures: 0  # Reset on success
            return @result
        } catch (e) {
            @this.failures++
            @this.last_failure: @time()
            @throw @e
        }
    }
}
```

## Performance Monitoring

```tusk
# Monitor operator performance
@monitor.operators({
    slow_threshold: 0.1  # 100ms
    memory_threshold: 10485760  # 10MB
    
    on_slow: (operator, duration) => {
        @log.warning("Slow operator", {
            operator: @operator
            duration: @duration
            stack: @get_stack_trace()
        })
    }
    
    on_memory: (operator, memory) => {
        @log.warning("High memory usage", {
            operator: @operator
            memory: @format_bytes(@memory)
        })
    }
})

# Performance budgets
@performance.budget({
    page_load: 1.0      # 1 second
    api_response: 0.2   # 200ms
    query_time: 0.05    # 50ms
})

# Check budget
@performance.check("api_response", () => {
    return @handle_api_request()
})
```

## Best Practices

1. **Profile first** - Don't optimize without measuring
2. **Cache expensive operations** - Use memoization and caching
3. **Batch operations** - Reduce overhead with batching
4. **Use appropriate data structures** - Choose the right tool
5. **Lazy load when possible** - Don't compute until needed
6. **Monitor production performance** - Real-world data matters
7. **Set performance budgets** - Define acceptable thresholds

## Related Features

- `@benchmark()` - Performance testing
- `@profile()` - Code profiling
- `@cache` - Result caching
- `@optimize()` - Automatic optimization
- `@monitor` - Performance monitoring
---

[@ Operator Security]


Security is paramount when using @ operators. This guide covers best practices for preventing vulnerabilities and securing your TuskLang applications.

## Input Validation

```tusk
# Always validate user input
user_input: @request.post.email

# Bad - direct use without validation
@query("SELECT * FROM users WHERE email = '" + @user_input + "'")  # SQL injection!

# Good - parameterized queries
@query("SELECT * FROM users WHERE email = ?", [@user_input])

# Better - validate first
@if(!@validate.email(@user_input)) {
    @throw("Invalid email format")
}
user: @query("SELECT * FROM users WHERE email = ?", [@user_input])

# Best - comprehensive validation
validate_user_input: (input) => {
    rules: {
        email: "required|email|max:255"
        password: "required|min:8|regex:/[A-Z]/|regex:/[0-9]/"
        name: "required|string|max:100|regex:/^[a-zA-Z\s]+$/"
    }
    
    validation: @validate(@input, @rules)
    @if(!@validation.passes) {
        @throw(@validation.errors)
    }
    
    return @validation.data
}
```

## SQL Injection Prevention

```tusk
# Dangerous patterns to avoid
# NEVER do this:
search: @request.get.q
@query("SELECT * FROM products WHERE name LIKE '%" + @search + "%'")  # SQL injection!

# Safe parameterized queries
# Always use placeholders:
@query("SELECT * FROM products WHERE name LIKE ?", ["%" + @search + "%"])

# Query builder safety
products: @Product
    .where("name", "like", "%" + @search + "%")  # Automatically escaped
    .where("price", "<", @max_price)
    .get()

# Multiple parameters
@query("
    SELECT * FROM orders 
    WHERE user_id = ? 
    AND status = ? 
    AND created_at > ?
", [@user_id, @status, @date])

# Safe dynamic queries
build_safe_query: (filters) => {
    query: @db.table("products")
    
    # Whitelist allowed columns
    allowed_columns: ["name", "category", "price", "status"]
    
    @foreach(@filters as @column => @value) {
        @if(@in_array(@column, @allowed_columns)) {
            @query.where(@column, @value)
        }
    }
    
    return @query.get()
}
```

## XSS Prevention

```tusk
# Escape output by default
user_content: @request.post.comment

# Bad - raw output
<div>{@user_content}</div>  # XSS vulnerability!

# Good - escaped output
<div>{@escape(@user_content)}</div>

# Better - context-aware escaping
<div>{@e(@user_content)}</div>                    # HTML context
<script>var data = {@json(@user_content)};</script>  # JavaScript context
<style>body { font-family: {@css(@font)} }</style>   # CSS context

# Rich text with whitelist
safe_html: @purify(@user_content, {
    allowed_tags: ["p", "br", "strong", "em", "a"]
    allowed_attributes: {
        a: ["href", "title"]
    }
    allowed_protocols: ["http", "https", "mailto"]
})

# Template auto-escaping
@template.config({
    auto_escape: true
    escape_function: @escape_html
})
```

## CSRF Protection

```tusk
# CSRF token generation
@middleware csrf_protection {
    # Generate token if not exists
    @if(!@session.csrf_token) {
        @session.csrf_token: @generate_csrf_token()
    }
    
    # Verify token on state-changing requests
    @if(@in_array(@request.method, ["POST", "PUT", "DELETE", "PATCH"])) {
        token: @request.post._token|@request.headers.x-csrf-token
        
        @if(!@csrf_token_valid(@token)) {
            @response.status: 403
            @throw("CSRF token validation failed")
        }
    }
    
    @next()
}

# Include in forms
<form method="POST" action="/update">
    @csrf()  # Generates hidden input with token
    <!-- form fields -->
</form>

# AJAX requests
fetch("/api/update", {
    method: "POST",
    headers: {
        "X-CSRF-Token": @csrf_token(),
        "Content-Type": "application/json"
    },
    body: JSON.stringify(data)
})
```

## Authentication & Authorization

```tusk
# Secure password handling
register_user: (data) => {
    # Validate password strength
    @if(!@validate_password_strength(@data.password)) {
        @throw("Password does not meet security requirements")
    }
    
    # Never store plain passwords
    user: @User.create({
        email: @data.email
        password: @hash_password(@data.password)  # Bcrypt/Argon2
    })
    
    return @user
}

# Secure authentication
authenticate: (email, password) => {
    user: @User.findBy("email", @email)
    
    @if(!@user || !@verify_password(@password, @user.password)) {
        # Generic error message
        @throw("Invalid credentials")
    }
    
    # Regenerate session ID
    @session_regenerate_id()
    
    # Store minimal session data
    @session.user_id: @user.id
    @session.login_time: @time()
    
    return @user
}

# Authorization checks
@middleware require_permission {
    permission: @params.permission
    
    @if(!@can(@permission)) {
        @response.status: 403
        @throw("Insufficient permissions")
    }
    
    @next()
}
```

## File Upload Security

```tusk
# Secure file upload handling
upload_file: (file) => {
    # Validate file type
    allowed_types: ["image/jpeg", "image/png", "image/gif"]
    @if(!@in_array(@file.type, @allowed_types)) {
        @throw("Invalid file type")
    }
    
    # Validate file size
    max_size: 5242880  # 5MB
    @if(@file.size > @max_size) {
        @throw("File too large")
    }
    
    # Generate secure filename
    extension: @get_file_extension(@file.name)
    filename: @generate_uuid() + "." + @extension
    
    # Scan for malware (if available)
    @if(@has_virus_scanner()) {
        @if(!@scan_file(@file.tmp_name)) {
            @throw("File failed security scan")
        }
    }
    
    # Store outside web root
    upload_path: @storage_path("uploads/" + @filename)
    @move_uploaded_file(@file.tmp_name, @upload_path)
    
    # Verify uploaded file
    @if(!@is_valid_image(@upload_path)) {
        @unlink(@upload_path)
        @throw("Invalid image file")
    }
    
    return @filename
}
```

## API Security

```tusk
# API rate limiting
@middleware rate_limit {
    key: @request.ip|@request.api_key
    limit: 100
    window: 3600  # 1 hour
    
    current: @cache.increment("rate:" + @key)
    
    @if(@current > @limit) {
        @response.status: 429
        @response.headers.retry-after: @window
        @throw("Rate limit exceeded")
    }
    
    @response.headers.x-ratelimit-limit: @limit
    @response.headers.x-ratelimit-remaining: @limit - @current
    
    @next()
}

# API key validation
@middleware api_auth {
    key: @request.headers.x-api-key
    
    @if(!@key) {
        @response.status: 401
        @throw("API key required")
    }
    
    # Validate and get app
    app: @validate_api_key(@key)
    @if(!@app) {
        @response.status: 403
        @throw("Invalid API key")
    }
    
    # Check permissions
    @if(!@app.hasPermission(@request.route)) {
        @response.status: 403
        @throw("Insufficient API permissions")
    }
    
    @context.api_app: @app
    @next()
}
```

## Secure Configuration

```tusk
# Environment variable security
get_secure_config: (key) => {
    value: @env[@key]
    
    # Never expose sensitive keys
    sensitive_keys: ["DB_PASSWORD", "API_SECRET", "PRIVATE_KEY"]
    @if(@in_array(@key, @sensitive_keys) && @env.APP_DEBUG) {
        @log.warning("Attempting to access sensitive config in debug mode")
        return "***REDACTED***"
    }
    
    return @value
}

# Secure defaults
config: {
    session: {
        secure: @env.SESSION_SECURE|true      # HTTPS only
        httponly: @env.SESSION_HTTPONLY|true  # No JS access
        samesite: @env.SESSION_SAMESITE|"Lax" # CSRF protection
        lifetime: @env.SESSION_LIFETIME|120    # Minutes
    }
    
    password: {
        min_length: 8
        require_uppercase: true
        require_numbers: true
        require_special: true
        bcrypt_rounds: 12
    }
    
    security: {
        force_https: @env.FORCE_HTTPS|true
        hsts_max_age: 31536000
        csp_policy: "default-src 'self'"
    }
}
```

## Output Encoding

```tusk
# Context-aware output encoding
encode_for_context: (data, context) => {
    @switch(@context) {
        case "html":
            return @htmlspecialchars(@data, ENT_QUOTES, "UTF-8")
            
        case "attribute":
            return @htmlspecialchars(@data, ENT_QUOTES, "UTF-8")
            
        case "javascript":
            return @json_encode(@data)
            
        case "css":
            return @preg_replace("/[^a-zA-Z0-9\s\-_]/", "", @data)
            
        case "url":
            return @urlencode(@data)
            
        default:
            return @htmlspecialchars(@data, ENT_QUOTES, "UTF-8")
    }
}

# Template helpers
{@html(@user_content)}        # HTML context
{@attr(@user_attribute)}      # Attribute context
{@js(@user_data)}            # JavaScript context
{@css(@user_style)}          # CSS context
{@url(@user_param)}          # URL context
```

## Security Headers

```tusk
# Security headers middleware
@middleware security_headers {
    headers: {
        # Prevent XSS
        "X-XSS-Protection": "1; mode=block"
        "X-Content-Type-Options": "nosniff"
        
        # Prevent clickjacking
        "X-Frame-Options": "SAMEORIGIN"
        
        # HTTPS enforcement
        "Strict-Transport-Security": "max-age=31536000; includeSubDomains"
        
        # Content Security Policy
        "Content-Security-Policy": @build_csp_policy({
            default: ["self"]
            script: ["self", "unsafe-inline", "https://trusted-cdn.com"]
            style: ["self", "unsafe-inline"]
            img: ["self", "data:", "https:"]
            font: ["self", "https://fonts.gstatic.com"]
        })
        
        # Referrer Policy
        "Referrer-Policy": "strict-origin-when-cross-origin"
        
        # Permissions Policy
        "Permissions-Policy": "geolocation=(), microphone=(), camera=()"
    }
    
    @foreach(@headers as @name => @value) {
        @response.headers[@name]: @value
    }
    
    @next()
}
```

## Logging and Monitoring

```tusk
# Security event logging
log_security_event: (event_type, details) => {
    @log.security({
        type: @event_type
        timestamp: @timestamp()
        ip: @request.ip
        user_id: @session.user_id
        user_agent: @request.headers.user_agent
        details: @details
        request_id: @request.id
    })
    
    # Alert on critical events
    critical_events: ["multiple_login_failures", "privilege_escalation", "sql_injection_attempt"]
    @if(@in_array(@event_type, @critical_events)) {
        @alert_security_team(@event_type, @details)
    }
}

# Monitor suspicious activity
@on("login_failed", (data) => {
    key: "login_failures:" + @data.ip
    failures: @cache.increment(@key, 1, 3600)
    
    @if(@failures > 5) {
        @log_security_event("multiple_login_failures", {
            ip: @data.ip
            attempts: @failures
        })
        
        # Temporary block
        @cache.set("blocked:" + @data.ip, true, 1800)  # 30 minutes
    }
})
```

## Best Practices

1. **Never trust user input** - Always validate and sanitize
2. **Use parameterized queries** - Prevent SQL injection
3. **Escape output** - Prevent XSS attacks
4. **Implement CSRF protection** - For state-changing operations
5. **Hash passwords properly** - Use bcrypt or Argon2
6. **Set security headers** - Defense in depth
7. **Log security events** - Monitor for attacks
8. **Keep dependencies updated** - Patch vulnerabilities
9. **Use HTTPS everywhere** - Encrypt data in transit
10. **Principle of least privilege** - Limit access rights

## Related Features

- `@validate()` - Input validation
- `@escape()` - Output escaping
- `@hash_password()` - Password hashing
- `@verify_password()` - Password verification
- `@csrf()` - CSRF token management
---

[env() - Environment Variables Function]


The `env()` function provides a convenient way to access environment variables with optional default values, ensuring your application can handle missing configuration gracefully.

## Basic Syntax

```tusk
# Get environment variable
database_host: env("DB_HOST")

# With default value
app_name: env("APP_NAME", "My TuskLang App")

# Type casting
debug_mode: env("DEBUG", false)
port: env("PORT", 3000)
```

## Common Usage Patterns

```tusk
# Database configuration
database: {
    driver: env("DB_DRIVER", "mysql")
    host: env("DB_HOST", "localhost")
    port: env("DB_PORT", 3306)
    database: env("DB_DATABASE", "myapp")
    username: env("DB_USERNAME", "root")
    password: env("DB_PASSWORD", "")
    charset: env("DB_CHARSET", "utf8mb4")
}

# Application settings
app: {
    name: env("APP_NAME", "TuskLang Application")
    env: env("APP_ENV", "production")
    debug: env("APP_DEBUG", false)
    url: env("APP_URL", "http://localhost")
    timezone: env("APP_TIMEZONE", "UTC")
}

# Third-party services
services: {
    mail: {
        driver: env("MAIL_DRIVER", "smtp")
        host: env("MAIL_HOST")
        port: env("MAIL_PORT", 587)
        username: env("MAIL_USERNAME")
        password: env("MAIL_PASSWORD")
        encryption: env("MAIL_ENCRYPTION", "tls")
    }
    
    stripe: {
        key: env("STRIPE_KEY")
        secret: env("STRIPE_SECRET")
        webhook_secret: env("STRIPE_WEBHOOK_SECRET")
    }
}
```

## Type Coercion

```tusk
# Boolean values
is_production: env("PRODUCTION", false)  # "true" -> true, "false" -> false
debug_enabled: env("DEBUG") == "true"    # Manual comparison

# Numeric values
port: env("PORT", 3000)                  # Automatically converted to integer
timeout: env("TIMEOUT", 30.5)            # Float values supported
max_connections: env("MAX_CONNECTIONS", 100)

# String values
app_name: env("APP_NAME", "Default")     # Strings remain strings
api_key: env("API_KEY", "")              # Empty string default

# Arrays (comma-separated)
allowed_hosts: env("ALLOWED_HOSTS", "localhost").split(",")
trusted_proxies: env("TRUSTED_PROXIES", "127.0.0.1").split(",").map(ip => ip.trim())
```

## Required Variables

```tusk
# Ensure required variables exist
require_env: (key, message: null) => {
    value: env(key)
    
    if (!value) {
        error_message: message || "Required environment variable '" + key + "' is not set"
        throw new Error(error_message)
    }
    
    return value
}

# Usage
database_url: require_env("DATABASE_URL", "Database connection URL is required")
api_secret: require_env("API_SECRET")

# Multiple required variables
required_vars: ["DATABASE_URL", "API_KEY", "SECRET_KEY"]
missing: []

foreach (required_vars as var_name) {
    if (!env(var_name)) {
        missing[] = var_name
    }
}

if (count(missing) > 0) {
    throw new Error("Missing required environment variables: " + join(", ", missing))
}
```

## Environment-Specific Logic

```tusk
# Different behavior based on environment
if (env("APP_ENV") == "production") {
    # Production settings
    cache_driver: env("CACHE_DRIVER", "redis")
    session_driver: env("SESSION_DRIVER", "redis")
    queue_driver: env("QUEUE_DRIVER", "redis")
    
    # Enable all optimizations
    config.optimize: true
    config.cache_views: true
    config.minify_assets: true
} else if (env("APP_ENV") == "development") {
    # Development settings
    cache_driver: env("CACHE_DRIVER", "file")
    session_driver: env("SESSION_DRIVER", "file")
    queue_driver: env("QUEUE_DRIVER", "sync")
    
    # Disable optimizations for debugging
    config.optimize: false
    config.cache_views: false
    config.minify_assets: false
}

# Feature flags
features: {
    new_dashboard: env("FEATURE_NEW_DASHBOARD", false)
    beta_api: env("FEATURE_BETA_API", false)
    experimental_cache: env("FEATURE_EXPERIMENTAL_CACHE", false)
}

if (features.new_dashboard) {
    include("dashboard/new.tusk")
} else {
    include("dashboard/legacy.tusk")
}
```

## Complex Configurations

```tusk
# Parse JSON from environment
redis_config: env("REDIS_CONFIG") ? 
    json_decode(env("REDIS_CONFIG")) : 
    {
        host: env("REDIS_HOST", "localhost"),
        port: env("REDIS_PORT", 6379),
        password: env("REDIS_PASSWORD")
    }

# Parse URLs
database_url: env("DATABASE_URL")
if (database_url) {
    parsed: parse_url(database_url)
    database: {
        driver: parsed.scheme
        host: parsed.host
        port: parsed.port || 3306
        database: substr(parsed.path, 1)
        username: parsed.user
        password: parsed.pass
    }
}

# Multiple environment support
get_service_url: (service) => {
    # Check environment-specific URL first
    env_key: strtoupper(env("APP_ENV")) + "_" + strtoupper(service) + "_URL"
    url: env(env_key)
    
    # Fallback to general URL
    if (!url) {
        url: env(strtoupper(service) + "_URL")
    }
    
    # Final fallback to localhost
    if (!url) {
        ports: {
            api: 8080,
            admin: 8081,
            websocket: 8082
        }
        url: "http://localhost:" + (ports[service] || 8080)
    }
    
    return url
}
```

## Security Considerations

```tusk
# Sanitize sensitive values in logs
safe_env: (key, default: null) => {
    value: env(key, default)
    sensitive_keys: ["PASSWORD", "SECRET", "KEY", "TOKEN"]
    
    # Check if key contains sensitive words
    is_sensitive: false
    foreach (sensitive_keys as sensitive) {
        if (str_contains(strtoupper(key), sensitive)) {
            is_sensitive: true
            break
        }
    }
    
    # Log access to sensitive variables
    if (is_sensitive && env("LOG_ENV_ACCESS")) {
        log.info("Accessed sensitive environment variable", {
            key: key,
            timestamp: now()
        })
    }
    
    return value
}

# Validate environment values
validated_env: (key, validator, default: null) => {
    value: env(key, default)
    
    if (value && !validator(value)) {
        throw new Error("Invalid value for environment variable '" + key + "': " + value)
    }
    
    return value
}

# Usage
email: validated_env("ADMIN_EMAIL", (v) => filter_var(v, FILTER_VALIDATE_EMAIL))
port: validated_env("PORT", (v) => v > 0 && v < 65536, 3000)
```

## Loading .env Files

```tusk
# Load .env file (usually done by framework)
load_env_file: (file: ".env") => {
    if (!file_exists(file)) {
        return false
    }
    
    lines: file(file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES)
    
    foreach (lines as line) {
        # Skip comments
        if (str_starts_with(trim(line), "#")) {
            continue
        }
        
        # Parse KEY=VALUE
        parts: explode("=", line, 2)
        if (count(parts) == 2) {
            key: trim(parts[0])
            value: trim(parts[1])
            
            # Remove quotes if present
            if (
                (str_starts_with(value, '"') && str_ends_with(value, '"')) ||
                (str_starts_with(value, "'") && str_ends_with(value, "'"))
            ) {
                value: substr(value, 1, -1)
            }
            
            # Set environment variable if not already set
            if (!getenv(key)) {
                putenv(key + "=" + value)
            }
        }
    }
    
    return true
}

# Load environment-specific files
env_file: ".env." + env("APP_ENV", "local")
if (file_exists(env_file)) {
    load_env_file(env_file)
}
```

## Caching Environment Values

```tusk
# Cache parsed environment values
env_cache: {}

cached_env: (key, default: null, parser: null) => {
    # Check cache first
    if (isset(env_cache[key])) {
        return env_cache[key]
    }
    
    # Get and parse value
    value: env(key, default)
    if (parser && value !== default) {
        value: parser(value)
    }
    
    # Cache the result
    env_cache[key]: value
    
    return value
}

# Usage with expensive parsing
allowed_origins: cached_env("CORS_ALLOWED_ORIGINS", [], (value) => {
    origins: explode(",", value)
    return array_map((origin) => trim(origin), origins)
})

feature_flags: cached_env("FEATURE_FLAGS", {}, (value) => {
    return json_decode(value, true)
})
```

## Testing with Environment Variables

```tusk
# Helper for testing with different env values
with_env: (vars, callback) => {
    # Save current values
    original: {}
    foreach (vars as key => value) {
        original[key]: env(key)
        putenv(key + "=" + value)
    }
    
    try {
        # Execute callback with new env
        result: callback()
    } finally {
        # Restore original values
        foreach (original as key => value) {
            if (value === null) {
                putenv(key)  # Unset
            } else {
                putenv(key + "=" + value)
            }
        }
    }
    
    return result
}

# Test example
test_with_production_env: () => {
    return with_env({
        APP_ENV: "production",
        DEBUG: "false",
        CACHE_DRIVER: "redis"
    }, () => {
        # Test code runs with production env
        assert(env("APP_ENV") == "production")
        assert(env("DEBUG") == "false")
        return run_tests()
    })
}
```

## Best Practices

1. **Always provide defaults** - Avoid missing variable errors
2. **Use descriptive names** - Make configuration self-documenting
3. **Don't commit .env files** - Keep secrets out of version control
4. **Validate critical values** - Ensure configuration is valid
5. **Type cast appropriately** - Convert strings to expected types
6. **Cache parsed values** - Avoid repeated parsing
7. **Log sensitive access** - Monitor security-critical variables
8. **Document required variables** - In .env.example file

## Related Functions

- `getenv()` - PHP's native environment function
- `putenv()` - Set environment variables
- `$_ENV` - Environment superglobal
- `config()` - Configuration management
- `setting()` - Application settings
---

[php() - PHP Integration Function]


The `php()` function allows seamless integration with PHP code and libraries, enabling you to leverage the vast PHP ecosystem within TuskLang applications.

## Basic Syntax

```tusk
# Execute PHP code
result: php("return strtoupper('hello');")  # "HELLO"

# Call PHP functions
timestamp: php("time()")
formatted: php("date('Y-m-d H:i:s')")

# Multi-line PHP code
calculation: php("""
    $sum = 0;
    for ($i = 1; $i <= 10; $i++) {
        $sum += $i;
    }
    return $sum;
""")
```

## Passing Variables

```tusk
# Pass TuskLang variables to PHP
name: "John Doe"
age: 30

greeting: php("return 'Hello, ' . $name . '! You are ' . $age . ' years old.';", {
    name: name,
    age: age
})

# Complex data structures
data: {
    users: ["Alice", "Bob", "Charlie"]
    settings: {
        theme: "dark"
        language: "en"
    }
}

processed: php("""
    $result = [];
    foreach ($users as $user) {
        $result[] = strtoupper($user) . ' (' . $settings['language'] . ')';
    }
    return $result;
""", {
    users: data.users,
    settings: data.settings
})
```

## Using PHP Libraries

```tusk
# Load PHP libraries
php("require_once 'vendor/autoload.php';")

# Use Composer packages
markdown_html: php("""
    use League\CommonMark\CommonMarkConverter;
    
    $converter = new CommonMarkConverter();
    return $converter->convertToHtml($markdown);
""", {
    markdown: "# Hello World\n\nThis is **markdown**!"
})

# Using PHP built-in classes
datetime: php("""
    $date = new DateTime($dateString);
    $date->add(new DateInterval('P1D'));
    return $date->format('Y-m-d H:i:s');
""", {
    dateString: "2024-01-01"
})
```

## Class Integration

```tusk
# Define PHP class
php("""
    class Calculator {
        private $precision;
        
        public function __construct($precision = 2) {
            $this->precision = $precision;
        }
        
        public function add($a, $b) {
            return round($a + $b, $this->precision);
        }
        
        public function multiply($a, $b) {
            return round($a * $b, $this->precision);
        }
        
        public function percentage($value, $percent) {
            return round($value * ($percent / 100), $this->precision);
        }
    }
""")

# Use PHP class from TuskLang
calc: php("return new Calculator(2);")

# Call methods
sum: php("return $calc->add($a, $b);", {calc: calc, a: 10.555, b: 20.333})
product: php("return $calc->multiply($x, $y);", {calc: calc, x: 5.5, y: 2.2})
discount: php("return $calc->percentage($price, $percent);", {
    calc: calc,
    price: 99.99,
    percent: 15
})
```

## Database Operations

```tusk
# Use PHP PDO
connection: php("""
    try {
        $pdo = new PDO($dsn, $username, $password);
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        return $pdo;
    } catch (PDOException $e) {
        throw new Exception('Connection failed: ' . $e->getMessage());
    }
""", {
    dsn: "mysql:host=localhost;dbname=myapp",
    username: env("DB_USERNAME"),
    password: env("DB_PASSWORD")
})

# Execute queries
users: php("""
    $stmt = $pdo->prepare("SELECT * FROM users WHERE active = :active");
    $stmt->execute(['active' => 1]);
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
""", {
    pdo: connection
})

# Prepared statements
insert_user: (name, email) => {
    return php("""
        $stmt = $pdo->prepare("INSERT INTO users (name, email) VALUES (:name, :email)");
        $stmt->execute(['name' => $name, 'email' => $email]);
        return $pdo->lastInsertId();
    """, {
        pdo: connection,
        name: name,
        email: email
    })
}
```

## Error Handling

```tusk
# Catch PHP exceptions
safe_php: (code, vars: {}) => {
    try {
        return php(code, vars)
    } catch (e) {
        log.error("PHP execution failed", {
            error: e.message,
            code: code,
            vars: vars
        })
        return null
    }
}

# Error handling in PHP code
result: php("""
    try {
        if (!function_exists($function)) {
            throw new Exception("Function does not exist: " . $function);
        }
        
        return call_user_func($function, $param);
    } catch (Exception $e) {
        return ['error' => $e->getMessage()];
    }
""", {
    function: "some_function",
    param: "test"
})

if (result.error) {
    handle_error(result.error)
}
```

## Working with Files

```tusk
# File operations using PHP
file_info: php("""
    $info = [];
    if (file_exists($path)) {
        $info['exists'] = true;
        $info['size'] = filesize($path);
        $info['modified'] = date('Y-m-d H:i:s', filemtime($path));
        $info['type'] = mime_content_type($path);
        $info['readable'] = is_readable($path);
        $info['writable'] = is_writable($path);
    } else {
        $info['exists'] = false;
    }
    return $info;
""", {
    path: "/path/to/file.txt"
})

# Process CSV with PHP
csv_data: php("""
    $data = [];
    if (($handle = fopen($filename, "r")) !== FALSE) {
        $headers = fgetcsv($handle);
        while (($row = fgetcsv($handle)) !== FALSE) {
            $data[] = array_combine($headers, $row);
        }
        fclose($handle);
    }
    return $data;
""", {
    filename: "data.csv"
})
```

## Image Processing

```tusk
# Use GD library
thumbnail: php("""
    $source = imagecreatefromjpeg($source_path);
    $width = imagesx($source);
    $height = imagesy($source);
    
    $thumb_width = 200;
    $thumb_height = (int)($height * ($thumb_width / $width));
    
    $thumb = imagecreatetruecolor($thumb_width, $thumb_height);
    imagecopyresampled($thumb, $source, 0, 0, 0, 0, 
                      $thumb_width, $thumb_height, $width, $height);
    
    imagejpeg($thumb, $dest_path, 90);
    imagedestroy($source);
    imagedestroy($thumb);
    
    return true;
""", {
    source_path: "original.jpg",
    dest_path: "thumbnail.jpg"
})

# ImageMagick operations
php("exec('convert $input -resize 800x600 -quality 85 $output');", {
    input: escapeshellarg("input.jpg"),
    output: escapeshellarg("output.jpg")
})
```

## Regular Expressions

```tusk
# Complex regex with PHP
matches: php("""
    preg_match_all($pattern, $text, $matches, PREG_SET_ORDER);
    return $matches;
""", {
    pattern: '/(?P<protocol>https?):\/\/(?P<domain>[^\/]+)(?P<path>\/.*)?/',
    text: "Visit https://example.com/page and http://test.com"
})

# Replace with callback
processed: php("""
    return preg_replace_callback($pattern, function($matches) use ($replacements) {
        return $replacements[$matches[1]] ?? $matches[0];
    }, $text);
""", {
    pattern: '/@(\w+)/',
    text: "Hello @user, welcome to @app!",
    replacements: {
        user: "John",
        app: "TuskLang"
    }
})
```

## Cryptography

```tusk
# Encryption with PHP
encrypted: php("""
    $cipher = "AES-256-CBC";
    $ivlen = openssl_cipher_iv_length($cipher);
    $iv = openssl_random_pseudo_bytes($ivlen);
    $ciphertext = openssl_encrypt($plaintext, $cipher, $key, 0, $iv);
    return base64_encode($iv . $ciphertext);
""", {
    plaintext: "Secret message",
    key: env("ENCRYPTION_KEY")
})

# Decryption
decrypted: php("""
    $cipher = "AES-256-CBC";
    $data = base64_decode($encrypted);
    $ivlen = openssl_cipher_iv_length($cipher);
    $iv = substr($data, 0, $ivlen);
    $ciphertext = substr($data, $ivlen);
    return openssl_decrypt($ciphertext, $cipher, $key, 0, $iv);
""", {
    encrypted: encrypted,
    key: env("ENCRYPTION_KEY")
})

# Password hashing
hashed: php("return password_hash($password, PASSWORD_ARGON2ID);", {
    password: "user_password"
})

verified: php("return password_verify($password, $hash);", {
    password: "user_password",
    hash: hashed
})
```

## Performance Optimization

```tusk
# Cache PHP execution results
php_cached: (code, vars: {}, ttl: 3600) => {
    cache_key: "php:" + md5(code + json_encode(vars))
    
    cached: cache.get(cache_key)
    if (cached !== null) {
        return cached
    }
    
    result: php(code, vars)
    cache.set(cache_key, result, ttl)
    
    return result
}

# Precompile PHP code
compiled: php("return create_function('$params', $code);", {
    code: 'return $params["a"] + $params["b"];'
})

# Use compiled function
result: php("return $func(['a' => 10, 'b' => 20]);", {func: compiled})
```

## Sandbox Execution

```tusk
# Safe PHP execution with restrictions
safe_eval: (code, vars: {}) => {
    return php("""
        // Disable dangerous functions
        $disabled = ['exec', 'system', 'shell_exec', 'eval', 'file_get_contents'];
        foreach ($disabled as $func) {
            if (stripos($code, $func) !== false) {
                throw new Exception("Function '$func' is not allowed");
            }
        }
        
        // Execute in limited scope
        $sandbox = function($vars) use ($code) {
            extract($vars);
            return eval('return ' . $code . ';');
        };
        
        return $sandbox($vars);
    """, {
        code: code,
        vars: vars
    })
}
```

## Best Practices

1. **Validate PHP code** - Never execute untrusted PHP code
2. **Use prepared statements** - Prevent SQL injection in PHP
3. **Handle errors gracefully** - Catch PHP exceptions
4. **Sanitize inputs** - Clean data before passing to PHP
5. **Cache results** - Avoid repeated PHP execution
6. **Use type hints** - Ensure correct data types
7. **Minimize context switching** - Batch PHP operations
8. **Document PHP dependencies** - List required extensions

## Related Functions

- `eval()` - Evaluate code (use with caution)
- `include()` - Include PHP files
- `require()` - Require PHP files
- `exec()` - Execute system commands
- `serialize()` - PHP serialization
---

[file() - File Operations Function]


The `file()` function provides comprehensive file system operations in TuskLang, from basic reading and writing to advanced file manipulation.

## Basic File Operations

```tusk
# Read entire file
content: file("path/to/file.txt")

# Write to file
file("output.txt", "Hello, World!")

# Append to file
file("log.txt", "New log entry\n", append: true)

# Check if file exists
if (file.exists("config.tusk")) {
    config: file("config.tusk")
}
```

## Reading Files

```tusk
# Read as string
text: file.read("document.txt")

# Read as lines array
lines: file.lines("data.csv")

# Read with options
content: file.read("large.txt", {
    encoding: "UTF-8"
    max_size: 1048576  # 1MB limit
})

# Read specific bytes
chunk: file.read("binary.dat", {
    offset: 1024
    length: 512
})

# Stream large files
file.stream("huge.log", (line) => {
    if (line.contains("ERROR")) {
        errors[] = line
    }
})
```

## Writing Files

```tusk
# Write string
file.write("output.txt", "Content")

# Write with options
file.write("data.json", json_data, {
    encoding: "UTF-8"
    mode: 0644
    create_dirs: true
})

# Atomic write (write to temp, then rename)
file.write_atomic("important.conf", config_data)

# Write lines
lines: ["Line 1", "Line 2", "Line 3"]
file.write_lines("output.txt", lines)

# Append data
file.append("log.txt", timestamp() + ": Event occurred\n")
```

## File Information

```tusk
# Get file info
info: file.info("document.pdf")
/* Returns:
{
    exists: true
    size: 1048576
    size_human: "1.0 MB"
    type: "application/pdf"
    mime: "application/pdf"
    extension: "pdf"
    modified: "2024-01-15 10:30:00"
    created: "2024-01-01 09:00:00"
    accessed: "2024-01-20 14:00:00"
    permissions: 0644
    owner: "user"
    group: "staff"
    is_readable: true
    is_writable: true
    is_executable: false
    is_directory: false
    is_file: true
    is_link: false
}
*/

# Quick checks
if (file.is_readable("data.txt") && file.size("data.txt") < 1000000) {
    content: file.read("data.txt")
}
```

## Directory Operations

```tusk
# List directory contents
files: file.list("./uploads")

# List with filters
images: file.list("./media", {
    pattern: "*.{jpg,png,gif}"
    recursive: false
    include_dirs: false
})

# Recursive directory scan
all_files: file.scan("./src", {
    recursive: true
    follow_links: false
    filter: (path) => !path.contains("node_modules")
})

# Create directory
file.mkdir("path/to/new/directory", {
    recursive: true
    mode: 0755
})

# Remove directory
file.rmdir("old_directory", {
    recursive: true  # Remove contents too
})
```

## File Manipulation

```tusk
# Copy file
file.copy("source.txt", "destination.txt")

# Copy with options
file.copy("important.doc", "backup/important.doc", {
    overwrite: false
    preserve_time: true
    preserve_permissions: true
})

# Move/rename file
file.move("old_name.txt", "new_name.txt")

# Delete file
file.delete("temp.txt")

# Delete multiple files
file.delete(["temp1.txt", "temp2.txt", "*.tmp"])

# Touch file (create or update timestamp)
file.touch("marker.txt")
```

## File Permissions

```tusk
# Get permissions
perms: file.permissions("script.sh")  # Returns octal like 0755

# Set permissions
file.chmod("script.sh", 0755)

# Make executable
file.make_executable("deploy.sh")

# Change owner (requires privileges)
file.chown("file.txt", "www-data", "www-data")

# Check permissions
if (file.is_writable("config.ini")) {
    file.write("config.ini", new_config)
}
```

## Working with Paths

```tusk
# Path manipulation
path: file.path("../uploads/images/photo.jpg")
/* Returns:
{
    full: "/var/www/uploads/images/photo.jpg"
    dirname: "/var/www/uploads/images"
    basename: "photo.jpg"
    filename: "photo"
    extension: "jpg"
    relative: "../uploads/images/photo.jpg"
    absolute: "/var/www/uploads/images/photo.jpg"
}
*/

# Join paths
full_path: file.join("/var/www", "uploads", "images", "photo.jpg")

# Normalize path
clean: file.normalize("./path/../to/./file.txt")  # "to/file.txt"

# Relative path
relative: file.relative("/var/www/html", "/var/www/html/assets/css/style.css")
# Returns: "assets/css/style.css"
```

## CSV Operations

```tusk
# Read CSV
data: file.csv("data.csv")

# Read with options
records: file.csv("users.csv", {
    headers: true  # First row as headers
    delimiter: ","
    enclosure: '"'
    escape: "\\"
})

# Write CSV
file.write_csv("output.csv", [
    ["Name", "Email", "Age"],
    ["John", "john@example.com", 30],
    ["Jane", "jane@example.com", 25]
])

# Stream large CSV
file.stream_csv("large.csv", (row) => {
    if (row.age > 18) {
        process_adult(row)
    }
}, {headers: true})
```

## JSON File Operations

```tusk
# Read JSON
data: file.json("config.json")

# Write JSON
file.write_json("output.json", data, {
    pretty: true  # Pretty print
    indent: 2
})

# Update JSON file
file.update_json("settings.json", (data) => {
    data.updated_at: timestamp()
    data.version: data.version + 1
    return data
})
```

## Archive Operations

```tusk
# Create ZIP archive
file.zip("archive.zip", [
    "file1.txt",
    "file2.txt",
    "directory/"
])

# Extract ZIP
file.unzip("archive.zip", "extracted/")

# Create with options
file.zip("backup.zip", files, {
    compression: 9  # Max compression
    password: "secret"
    comment: "Backup created " + date()
})

# List ZIP contents
contents: file.zip_list("archive.zip")
```

## Temporary Files

```tusk
# Create temp file
temp: file.temp("myapp_")
/* Returns:
{
    path: "/tmp/myapp_a3f4d2"
    handle: <resource>
}
*/

# Write to temp file
file.write(temp.path, "Temporary data")

# Create temp directory
temp_dir: file.temp_dir("myapp_")

# Auto-cleanup temp file
file.with_temp((temp_path) => {
    file.write(temp_path, "Processing data")
    result: process_file(temp_path)
    return result
    # File automatically deleted after block
})
```

## File Locking

```tusk
# Exclusive lock for writing
file.lock("data.txt", "exclusive", () => {
    content: file.read("data.txt")
    updated: transform(content)
    file.write("data.txt", updated)
})

# Shared lock for reading
file.lock("config.txt", "shared", () => {
    config: file.read("config.txt")
    return parse_config(config)
})

# Non-blocking lock
if (file.try_lock("busy.txt", "exclusive")) {
    try {
        # Do work
    } finally {
        file.unlock("busy.txt")
    }
}
```

## File Watching

```tusk
# Watch for changes
file.watch("config.json", (event) => {
    if (event.type == "modified") {
        reload_config()
    }
})

# Watch directory
file.watch_dir("./src", (event) => {
    console.log(event.type + ": " + event.path)
    if (event.path.endsWith(".tusk")) {
        recompile(event.path)
    }
}, {
    recursive: true
    events: ["create", "modify", "delete"]
})
```

## Binary Files

```tusk
# Read binary
data: file.read_binary("image.jpg")

# Write binary
file.write_binary("output.bin", binary_data)

# Read chunks
file.read_chunks("large.bin", 1024, (chunk, offset) => {
    process_chunk(chunk, offset)
})

# Memory-mapped file
mmap: file.mmap("huge.dat", {
    mode: "r+b"
    offset: 0
    length: 1048576
})
```

## Error Handling

```tusk
# Safe file operations
safe_read: (path) => {
    try {
        if (!file.exists(path)) {
            return {error: "File not found"}
        }
        
        if (!file.is_readable(path)) {
            return {error: "File not readable"}
        }
        
        if (file.size(path) > 10485760) {  # 10MB
            return {error: "File too large"}
        }
        
        content: file.read(path)
        return {success: true, content: content}
        
    } catch (e) {
        return {error: e.message}
    }
}

# File operation with retries
retry_write: (path, content, max_retries: 3) => {
    attempts: 0
    
    while (attempts < max_retries) {
        try {
            file.write(path, content)
            return true
        } catch (e) {
            attempts++
            if (attempts < max_retries) {
                sleep(1)  # Wait 1 second
            } else {
                throw e
            }
        }
    }
}
```

## Best Practices

1. **Always check file existence** - Before operations
2. **Handle errors gracefully** - File operations can fail
3. **Use appropriate methods** - Stream large files
4. **Clean up temp files** - Don't leave garbage
5. **Set correct permissions** - Security matters
6. **Use atomic writes** - For critical files
7. **Validate file types** - Don't trust extensions
8. **Consider file locking** - For concurrent access

## Related Functions

- `fopen()` - Low-level file handle
- `glob()` - Pattern matching
- `realpath()` - Resolve path
- `is_uploaded_file()` - Check uploads
- `mime_content_type()` - Detect MIME type
---

[json() & file.json() - JSON Functions]


TuskLang provides powerful JSON handling through the `json()` function for encoding/decoding and `file.json()` for JSON file operations.

## Basic JSON Operations

```tusk
# Encode to JSON
data: {name: "John", age: 30, active: true}
json_string: json(data)  # {"name":"John","age":30,"active":true}

# Pretty print JSON
pretty: json(data, pretty: true)
/* Output:
{
    "name": "John",
    "age": 30,
    "active": true
}
*/

# Decode JSON
parsed: json.decode('{"name":"John","age":30}')
# Returns: {name: "John", age: 30}

# Safe decoding with default
config: json.decode(json_string, default: {})
```

## JSON File Operations

```tusk
# Read JSON file
config: file.json("config.json")

# Write JSON file
file.json("output.json", {
    timestamp: now()
    data: results
})

# Write with formatting
file.json("formatted.json", data, {
    pretty: true
    indent: 4
    sort_keys: true
})

# Update JSON file
file.json.update("settings.json", (current) => {
    current.last_updated: timestamp()
    current.version: (current.version || 0) + 1
    return current
})
```

## Advanced Encoding Options

```tusk
# Custom encoding options
output: json(data, {
    pretty: true              # Pretty print
    indent: 2                 # Indentation spaces
    sort_keys: true          # Sort object keys
    escape_unicode: false    # Don't escape Unicode
    escape_slashes: false    # Don't escape forward slashes
    null_as_empty: true      # null becomes empty string
    stringify_numbers: true  # Large numbers as strings
})

# Handle special values
special_data: {
    infinity: Infinity
    nan: NaN
    undefined: undefined
    function: () => "test"
}

safe_json: json(special_data, {
    handle_special: true  # Converts special values safely
})
# Result: {"infinity":null,"nan":null,"undefined":null}
```

## Error Handling

```tusk
# Safe JSON parsing
parse_json_safe: (string, default: null) => {
    try {
        return json.decode(string)
    } catch (e) {
        log.error("Invalid JSON", {
            error: e.message
            input: string.substring(0, 100) + "..."
        })
        return default
    }
}

# Validate JSON
is_valid_json: (string) => {
    try {
        json.decode(string)
        return true
    } catch {
        return false
    }
}

# Parse with validation
data: json.decode(input, {
    strict: true  # Strict parsing mode
    max_depth: 10  # Prevent deep nesting attacks
    validate: (obj) => {
        # Custom validation
        if (!obj.version || obj.version < 1) {
            throw "Invalid version"
        }
        return true
    }
})
```

## Working with APIs

```tusk
# API response handling
api_response: http.get("https://api.example.com/data")
data: json.decode(api_response.body)

# Send JSON request
response: http.post("https://api.example.com/users", {
    headers: {
        "Content-Type": "application/json"
    }
    body: json({
        name: "John Doe"
        email: "john@example.com"
    })
})

# Parse response
result: json.decode(response.body, {
    default: {error: "Invalid response"}
})
```

## JSON Streaming

```tusk
# Stream large JSON files
file.json.stream("large.json", (item) => {
    # Process each item as it's parsed
    if (item.type == "user") {
        process_user(item)
    }
})

# Write JSON stream
writer: file.json.stream_writer("output.json")
foreach (items as item) {
    writer.write(item)
}
writer.close()

# NDJSON (Newline Delimited JSON)
file.ndjson.write("events.ndjson", events)

file.ndjson.read("events.ndjson", (event) => {
    process_event(event)
})
```

## JSON Schema Validation

```tusk
# Define schema
user_schema: {
    type: "object"
    required: ["name", "email"]
    properties: {
        name: {
            type: "string"
            minLength: 1
            maxLength: 100
        }
        email: {
            type: "string"
            format: "email"
        }
        age: {
            type: "integer"
            minimum: 0
            maximum: 150
        }
    }
}

# Validate against schema
validate_json: (data, schema) => {
    result: json.validate(data, schema)
    
    if (!result.valid) {
        throw {
            message: "Validation failed"
            errors: result.errors
        }
    }
    
    return data
}

# Use validation
user_data: json.decode(input)
valid_user: validate_json(user_data, user_schema)
```

## JSON Transformation

```tusk
# Transform JSON structure
transformer: {
    # Map old keys to new
    mappings: {
        "firstName": "first_name"
        "lastName": "last_name"
        "phoneNumber": "phone"
    }
    
    transform: (data) => {
        result: {}
        
        foreach (data as key => value) {
            new_key: transformer.mappings[key] || key
            
            if (is_object(value)) {
                result[new_key]: transformer.transform(value)
            } else if (is_array(value)) {
                result[new_key]: value.map(v => 
                    is_object(v) ? transformer.transform(v) : v
                )
            } else {
                result[new_key]: value
            }
        }
        
        return result
    }
}

# Apply transformation
original: json.decode('{"firstName":"John","lastName":"Doe"}')
transformed: transformer.transform(original)
# Result: {first_name: "John", last_name: "Doe"}
```

## JSON Patch

```tusk
# Apply JSON Patch (RFC 6902)
original: {
    name: "John"
    age: 30
    hobbies: ["reading", "gaming"]
}

patches: [
    {op: "replace", path: "/name", value: "Jane"}
    {op: "add", path: "/email", value: "jane@example.com"}
    {op: "remove", path: "/age"}
    {op: "add", path: "/hobbies/-", value: "cooking"}
]

patched: json.patch(original, patches)
/* Result:
{
    name: "Jane"
    email: "jane@example.com"
    hobbies: ["reading", "gaming", "cooking"]
}
*/

# Generate patches
diff: json.diff(original, modified)
# Returns array of patch operations
```

## JSON Query

```tusk
# Query JSON with path expressions
data: {
    users: [
        {id: 1, name: "John", active: true}
        {id: 2, name: "Jane", active: false}
        {id: 3, name: "Bob", active: true}
    ]
}

# JSONPath queries
active_users: json.query(data, "$.users[?(@.active==true)]")
names: json.query(data, "$.users[*].name")
first_user: json.query(data, "$.users[0]")

# JMESPath queries
result: json.jmespath(data, "users[?active].{id: id, name: name}")
```

## JSON Merge

```tusk
# Deep merge JSON objects
base: {
    name: "App"
    settings: {
        theme: "light"
        language: "en"
    }
}

override: {
    settings: {
        theme: "dark"
        notifications: true
    }
}

merged: json.merge(base, override, {
    deep: true  # Deep merge
    arrays: "concat"  # How to handle arrays
})
/* Result:
{
    name: "App"
    settings: {
        theme: "dark"
        language: "en"
        notifications: true
    }
}
*/
```

## Configuration Files

```tusk
# Load cascading config files
config: {}

# Load base config
if (file.exists("config/default.json")) {
    config: json.merge(config, file.json("config/default.json"))
}

# Load environment config
env_config: "config/" + env("APP_ENV", "production") + ".json"
if (file.exists(env_config)) {
    config: json.merge(config, file.json(env_config))
}

# Load local config (not in version control)
if (file.exists("config/local.json")) {
    config: json.merge(config, file.json("config/local.json"))
}

# Save resolved config
file.json("config/.resolved.json", config, {pretty: true})
```

## JSON Performance

```tusk
# Fast JSON parsing for large files
large_data: file.read("huge.json")

# Use streaming parser
json.parse_stream(large_data, {
    chunk_size: 1024 * 1024  # 1MB chunks
    on_value: (path, value) => {
        # Process values as they're parsed
        if (path.startsWith("$.items")) {
            process_item(value)
        }
    }
})

# Optimize JSON size
minified: json(data, {
    pretty: false
    remove_null: true
    remove_empty: true
})

# Binary JSON (BSON)
binary: json.to_bson(data)
restored: json.from_bson(binary)
```

## JSON Security

```tusk
# Sanitize JSON before parsing
sanitize_json: (input) => {
    # Remove potentially dangerous content
    cleaned: input
        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "")  # Control chars
        .replace(/\\x[0-9a-fA-F]{2}/g, "")  # Hex escapes
    
    # Validate structure
    if (!cleaned.match(/^[\s\[\{].*[\]\}]\s*$/)) {
        throw "Invalid JSON structure"
    }
    
    return cleaned
}

# Safe parsing with limits
safe_data: json.decode(sanitized, {
    max_depth: 10  # Prevent deep nesting DoS
    max_length: 1048576  # 1MB max
    allow_comments: false  # Strict JSON only
})
```

## Best Practices

1. **Always handle parse errors** - JSON parsing can fail
2. **Validate untrusted JSON** - Use schemas for validation
3. **Use streaming for large files** - Don't load everything in memory
4. **Set size limits** - Prevent DoS attacks
5. **Escape output properly** - When embedding in HTML/JS
6. **Use pretty print for configs** - Human-readable files
7. **Cache parsed JSON** - Avoid repeated parsing
8. **Consider alternatives** - YAML/TOML for configs

## Related Functions

- `serialize()` - PHP serialization
- `yaml()` - YAML parsing
- `xml()` - XML parsing
- `csv()` - CSV handling
- `parse_str()` - Query string parsing
---

[peanuts() - Lightweight Template Function]


The `peanuts()` function provides a simple, lightweight templating system in TuskLang, perfect for quick string interpolation and basic template needs without the overhead of full template engines.

## Basic Syntax

```tusk
# Simple interpolation
template: "Hello, {name}!"
output: peanuts(template, {name: "World"})  # "Hello, World!"

# Multiple variables
greeting: peanuts("Welcome {user}, you have {count} new messages", {
    user: "John"
    count: 5
})

# With default values
result: peanuts("Hello, {name|Guest}!", {})  # "Hello, Guest!"
```

## Variable Interpolation

```tusk
# Basic variables
data: {
    title: "TuskLang"
    version: "2.0"
    author: "John Doe"
}

readme: peanuts("""
# {title} v{version}

Created by {author}
""", data)

# Nested properties
user: {
    name: "Jane"
    profile: {
        bio: "Developer"
        location: "NYC"
    }
}

bio: peanuts("{name} is a {profile.bio} from {profile.location}", user)

# Array access
items: ["first", "second", "third"]
text: peanuts("The {0} item and the {2} item", items)
```

## Filters and Modifiers

```tusk
# Built-in filters
template: """
Name: {name|upper}
Email: {email|lower}
Price: ${price|number:2}
Date: {date|date:Y-m-d}
Status: {active|yesno:Active:Inactive}
"""

output: peanuts(template, {
    name: "John Doe"
    email: "JOHN@EXAMPLE.COM"
    price: 99.999
    date: "2024-01-15"
    active: true
})

# Chain filters
text: peanuts("{message|trim|upper|truncate:20}", {
    message: "  This is a long message that needs truncation  "
})
```

## Conditional Output

```tusk
# Simple conditionals
template: "{?logged_in}Welcome back!{/logged_in}{?!logged_in}Please login{/logged_in}"

logged_out: peanuts(template, {logged_in: false})  # "Please login"
logged_in: peanuts(template, {logged_in: true})    # "Welcome back!"

# Conditional with variables
user_template: """
{?user}
    Hello, {user.name}!
    {?user.premium}You are a premium member{/user.premium}
{/user}
{?!user}
    Welcome, guest!
{/user}
"""

output: peanuts(user_template, {
    user: {
        name: "Alice"
        premium: true
    }
})
```

## Loops

```tusk
# Simple loops
template: """
<ul>
{#items}
    <li>{.}</li>
{/items}
</ul>
"""

html: peanuts(template, {
    items: ["Apple", "Banana", "Orange"]
})

# Loop with objects
user_list: """
{#users}
<div class="user">
    <h3>{name}</h3>
    <p>{email}</p>
</div>
{/users}
"""

output: peanuts(user_list, {
    users: [
        {name: "John", email: "john@example.com"}
        {name: "Jane", email: "jane@example.com"}
    ]
})

# Loop with index
indexed: """
{#items}
    {_index}. {name} - ${price}
{/items}
"""

result: peanuts(indexed, {
    items: [
        {name: "Item 1", price: 10}
        {name: "Item 2", price: 20}
    ]
})
```

## Custom Filters

```tusk
# Register custom filters
peanuts.filter("currency", (value, symbol: "$") => {
    return symbol + number_format(value, 2)
})

peanuts.filter("ago", (date) => {
    seconds: time() - strtotime(date)
    
    if (seconds < 60) return "just now"
    if (seconds < 3600) return floor(seconds / 60) + " minutes ago"
    if (seconds < 86400) return floor(seconds / 3600) + " hours ago"
    return floor(seconds / 86400) + " days ago"
})

# Use custom filters
template: """
Price: {amount|currency}
Posted: {created_at|ago}
"""

output: peanuts(template, {
    amount: 99.99
    created_at: "2024-01-15 10:00:00"
})
```

## Template Includes

```tusk
# Include other templates
main_template: """
<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
</head>
<body>
    {>header}
    
    <main>
        {content}
    </main>
    
    {>footer}
</body>
</html>
"""

# Register partials
peanuts.partial("header", '<header><h1>{site_name}</h1></header>')
peanuts.partial("footer", '<footer>&copy; {year} {site_name}</footer>')

# Render with includes
html: peanuts(main_template, {
    title: "My Page"
    site_name: "TuskLang Site"
    year: date("Y")
    content: "Page content here"
})
```

## HTML Escaping

```tusk
# Auto-escape HTML
template: """
<h1>{title}</h1>
<p>{content}</p>
<div>{raw_html|raw}</div>
"""

output: peanuts(template, {
    title: "News & Updates"  # Escaped: "News &amp; Updates"
    content: '<script>alert("XSS")</script>'  # Escaped
    raw_html: '<strong>Bold text</strong>'  # Not escaped due to |raw
}, {
    auto_escape: true  # Default
})

# Disable auto-escaping
unsafe: peanuts("{content}", {content: "<b>Bold</b>"}, {
    auto_escape: false
})
```

## Email Templates

```tusk
# Email template
email_template: """
Subject: {subject}

Dear {name},

{?order}
Thank you for your order #{order.id}.

Items:
{#order.items}
- {name}: ${price} x {quantity} = ${total}
{/order.items}

Total: ${order.total}
{/order}

{?!order}
Welcome to our service!
{/order}

Best regards,
{company}
"""

# Send email
email_content: peanuts(email_template, {
    subject: "Order Confirmation"
    name: "John Doe"
    order: {
        id: "12345"
        items: [
            {name: "Widget", price: 10, quantity: 2, total: 20}
            {name: "Gadget", price: 15, quantity: 1, total: 15}
        ]
        total: 35
    }
    company: "TuskLang Store"
})

send_email(to: "john@example.com", body: email_content)
```

## Configuration Templates

```tusk
# Generate config files
nginx_template: """
server {
    listen {port|80};
    server_name {domains|_};
    root {root|/var/www/html};
    
    {?ssl}
    listen 443 ssl;
    ssl_certificate {ssl.cert};
    ssl_certificate_key {ssl.key};
    {/ssl}
    
    {#locations}
    location {path} {
        {?proxy}proxy_pass {proxy};{/proxy}
        {?root}root {root};{/root}
    }
    {/locations}
}
"""

config: peanuts(nginx_template, {
    port: 8080
    domains: "example.com www.example.com"
    root: "/var/www/myapp"
    ssl: {
        cert: "/etc/ssl/cert.pem"
        key: "/etc/ssl/key.pem"
    }
    locations: [
        {path: "/api", proxy: "http://localhost:3000"}
        {path: "/static", root: "/var/www/static"}
    ]
})
```

## SQL Query Templates

```tusk
# Safe SQL templates (still use parameterized queries!)
query_template: """
SELECT {fields|*}
FROM {table}
{?where}WHERE {where}{/where}
{?order}ORDER BY {order}{/order}
{?limit}LIMIT {limit}{/limit}
"""

query: peanuts(query_template, {
    fields: "id, name, email"
    table: "users"
    where: "active = 1"
    order: "created_at DESC"
    limit: 10
})

# Execute with parameters
results: db.query(query)
```

## Markdown Templates

```tusk
# Generate markdown
changelog_template: """
# Changelog

## [{version}] - {date}

### {type}
{#changes}
- {description} {?issue}(#{issue}){/issue}
{/changes}

{?breaking}
### Breaking Changes
{#breaking}
- {.}
{/breaking}
{/breaking}
"""

changelog: peanuts(changelog_template, {
    version: "2.0.0"
    date: date("Y-m-d")
    type: "Added"
    changes: [
        {description: "New feature X", issue: 123}
        {description: "Support for Y"}
    ]
    breaking: [
        "Removed deprecated method Z"
    ]
})
```

## Caching Templates

```tusk
# Cache compiled templates
cached_peanuts: (template, data, cache_key: null) => {
    if (cache_key) {
        cached: cache.get("peanuts:" + cache_key)
        if (cached) return cached
    }
    
    # Compile template once
    compiled: peanuts.compile(template)
    
    # Render with data
    result: compiled(data)
    
    if (cache_key) {
        cache.set("peanuts:" + cache_key, result, 3600)
    }
    
    return result
}

# Pre-compile templates
templates: {
    email: peanuts.compile(file.read("templates/email.peanuts"))
    invoice: peanuts.compile(file.read("templates/invoice.peanuts"))
}

# Use pre-compiled
email_html: templates.email({user: user, message: message})
```

## Error Handling

```tusk
# Safe rendering
safe_peanuts: (template, data, default: "") => {
    try {
        return peanuts(template, data)
    } catch (e) {
        log.error("Template error", {
            error: e.message
            template: template.substring(0, 100)
        })
        return default
    }
}

# Debug mode
debug_output: peanuts(template, data, {
    debug: true  # Shows undefined variables
    strict: false  # Don't throw on missing vars
})
```

## Best Practices

1. **Keep templates simple** - Use full template engine for complex needs
2. **Escape by default** - Prevent XSS vulnerabilities
3. **Cache compiled templates** - Improve performance
4. **Use meaningful names** - Make templates self-documenting
5. **Validate data** - Don't assume variables exist
6. **Separate logic from templates** - Keep templates clean
7. **Use filters for formatting** - Reusable transformations
8. **Test with edge cases** - Empty arrays, null values

## Related Functions

- `render()` - Full template rendering
- `sprintf()` - Simple string formatting
- `str_replace()` - String replacement
- `view()` - View rendering
- `blade()` - Blade template engine
---

[query() - Database Query Function]


The `query()` function provides a powerful and secure way to execute database queries in TuskLang with built-in protection against SQL injection.

## Basic Syntax

```tusk
# Simple query
users: query("SELECT * FROM users")

# Query with parameters (safe from SQL injection)
user: query("SELECT * FROM users WHERE id = ?", [user_id])

# Multiple parameters
results: query(
    "SELECT * FROM orders WHERE user_id = ? AND status = ?", 
    [user_id, "completed"]
)
```

## SELECT Queries

```tusk
# Basic SELECT
all_users: query("SELECT * FROM users")

# SELECT with conditions
active_users: query("SELECT * FROM users WHERE active = ?", [true])

# Complex SELECT
orders: query("
    SELECT 
        o.id,
        o.total,
        u.name as customer_name,
        p.name as product_name
    FROM orders o
    JOIN users u ON o.user_id = u.id
    JOIN products p ON o.product_id = p.id
    WHERE o.created_at > ?
    ORDER BY o.created_at DESC
    LIMIT 100
", [last_week])

# Single row
user: query("SELECT * FROM users WHERE email = ?", [email]).first()

# Single value
count: query("SELECT COUNT(*) as total FROM users").value("total")
```

## INSERT Queries

```tusk
# Basic INSERT
query("
    INSERT INTO users (name, email, created_at) 
    VALUES (?, ?, ?)
", [name, email, now()])

# Get insert ID
user_id: query("
    INSERT INTO users (name, email) 
    VALUES (?, ?)
", [name, email]).insert_id()

# Insert multiple rows
users_data: [
    ["John", "john@example.com"],
    ["Jane", "jane@example.com"],
    ["Bob", "bob@example.com"]
]

foreach (users_data as user) {
    query("INSERT INTO users (name, email) VALUES (?, ?)", user)
}

# Insert with ON DUPLICATE KEY UPDATE
query("
    INSERT INTO settings (user_id, key, value) 
    VALUES (?, ?, ?)
    ON DUPLICATE KEY UPDATE value = VALUES(value)
", [user_id, setting_key, setting_value])
```

## UPDATE Queries

```tusk
# Basic UPDATE
affected: query("
    UPDATE users 
    SET last_login = ? 
    WHERE id = ?
", [now(), user_id]).affected_rows()

# Update multiple fields
query("
    UPDATE products 
    SET 
        name = ?,
        price = ?,
        updated_at = ?
    WHERE id = ?
", [name, price, now(), product_id])

# Conditional update
query("
    UPDATE orders 
    SET status = ?
    WHERE id = ? AND status = ?
", ["shipped", order_id, "pending"])

# Increment value
query("
    UPDATE users 
    SET login_count = login_count + 1 
    WHERE id = ?
", [user_id])
```

## DELETE Queries

```tusk
# Basic DELETE
deleted: query("DELETE FROM users WHERE id = ?", [user_id]).affected_rows()

# Delete with condition
query("DELETE FROM sessions WHERE expires_at < ?", [now()])

# Soft delete
query("UPDATE users SET deleted_at = ? WHERE id = ?", [now(), user_id])

# Delete with JOIN
query("
    DELETE orders 
    FROM orders 
    JOIN users ON orders.user_id = users.id 
    WHERE users.inactive = 1
")
```

## Transactions

```tusk
# Basic transaction
transaction(() => {
    # Deduct from account
    query("UPDATE accounts SET balance = balance - ? WHERE id = ?", [amount, from_id])
    
    # Add to account
    query("UPDATE accounts SET balance = balance + ? WHERE id = ?", [amount, to_id])
    
    # Log transaction
    query("INSERT INTO transactions (from_id, to_id, amount) VALUES (?, ?, ?)", 
          [from_id, to_id, amount])
})

# Manual transaction control
begin_transaction()

try {
    # Multiple queries
    query("INSERT INTO orders (user_id, total) VALUES (?, ?)", [user_id, total])
    order_id: last_insert_id()
    
    foreach (items as item) {
        query("INSERT INTO order_items (order_id, product_id, quantity) VALUES (?, ?, ?)",
              [order_id, item.product_id, item.quantity])
    }
    
    commit()
} catch (e) {
    rollback()
    throw e
}
```

## Prepared Statements

```tusk
# Prepare once, execute many
stmt: prepare("INSERT INTO logs (level, message, created_at) VALUES (?, ?, ?)")

foreach (log_entries as entry) {
    stmt.execute([entry.level, entry.message, now()])
}

stmt.close()

# Named parameters
stmt: prepare("
    SELECT * FROM users 
    WHERE age BETWEEN :min_age AND :max_age 
    AND status = :status
")

results: stmt.execute({
    min_age: 18,
    max_age: 65,
    status: "active"
})
```

## Query Builder Integration

```tusk
# Build query dynamically
conditions: []
params: []

if (search_name) {
    conditions[] = "name LIKE ?"
    params[] = "%" + search_name + "%"
}

if (min_price) {
    conditions[] = "price >= ?"
    params[] = min_price
}

if (category_id) {
    conditions[] = "category_id = ?"
    params[] = category_id
}

sql: "SELECT * FROM products"
if (count(conditions) > 0) {
    sql += " WHERE " + join(" AND ", conditions)
}

results: query(sql, params)
```

## Result Processing

```tusk
# Get all results
users: query("SELECT * FROM users").all()

# Get first result
first_user: query("SELECT * FROM users ORDER BY created_at").first()

# Get single column
emails: query("SELECT email FROM users").column("email")

# Get key-value pairs
user_names: query("SELECT id, name FROM users").pairs("id", "name")

# Custom result processing
query("SELECT * FROM orders").each((row) => {
    # Process each row
    process_order(row)
})

# Map results
totals: query("SELECT * FROM orders").map((order) => order.total)
```

## Advanced Features

```tusk
# Query with timeout
results: query("SELECT * FROM large_table", [], {
    timeout: 5000  # 5 seconds
})

# Read from replica
users: query("SELECT * FROM users", [], {
    connection: "read_replica"
})

# Query profiling
profile: query("SELECT * FROM complex_view", [], {
    profile: true
})
# profile.time, profile.rows, profile.explain

# Streaming results
query("SELECT * FROM huge_table", [], {
    stream: true,
    chunk_size: 1000
}).each_chunk((chunk) => {
    # Process chunk of 1000 rows
    process_chunk(chunk)
})
```

## Error Handling

```tusk
# Basic error handling
try {
    result: query("SELECT * FROM users WHERE id = ?", [user_id])
} catch (QueryException e) {
    log.error("Query failed", {
        error: e.message,
        sql: e.sql,
        params: e.params
    })
    return null
}

# Check query success
result: query("UPDATE users SET active = ? WHERE id = ?", [false, user_id])

if (result.success && result.affected_rows() > 0) {
    log.info("User deactivated", {user_id: user_id})
} else {
    log.warning("No user found to deactivate", {user_id: user_id})
}

# Handle deadlocks
retry_on_deadlock: (sql, params, max_retries: 3) => {
    attempts: 0
    
    while (attempts < max_retries) {
        try {
            return query(sql, params)
        } catch (e) {
            if (e.code == 1213 && attempts < max_retries - 1) {  # Deadlock
                attempts++
                sleep(0.1 * attempts)  # Exponential backoff
            } else {
                throw e
            }
        }
    }
}
```

## Query Caching

```tusk
# Cache query results
cached_query: (sql, params, ttl: 3600) => {
    cache_key: "query:" + md5(sql + json_encode(params))
    
    cached: cache.get(cache_key)
    if (cached !== null) {
        return cached
    }
    
    result: query(sql, params)
    cache.set(cache_key, result, ttl)
    
    return result
}

# Invalidate cache on update
update_user: (id, data) => {
    query("UPDATE users SET ? WHERE id = ?", [data, id])
    
    # Clear related caches
    cache.delete("query:" + md5("SELECT * FROM users WHERE id = ?" + json_encode([id])))
    cache.tags(["users"]).flush()
}
```

## Database Agnostic

```tusk
# Works with different databases
# MySQL
users: query("SELECT * FROM users LIMIT ?", [10])

# PostgreSQL  
users: query("SELECT * FROM users LIMIT $1", [10])

# SQLite
users: query("SELECT * FROM users LIMIT ?", [10])

# SQL Server
users: query("SELECT TOP (?) * FROM users", [10])

# Use database abstraction
users: query.select("users").limit(10).get()
```

## Performance Tips

```tusk
# Use EXPLAIN to analyze queries
explain: query("EXPLAIN SELECT * FROM orders WHERE user_id = ?", [user_id])

# Batch operations
query.batch((batch) => {
    foreach (items as item) {
        batch.add("INSERT INTO items (name, price) VALUES (?, ?)", 
                  [item.name, item.price])
    }
}).execute()

# Use indexes effectively
# Create index
query("CREATE INDEX idx_user_email ON users(email)")

# Query will use index
user: query("SELECT * FROM users WHERE email = ?", [email])
```

## Best Practices

1. **Always use parameterized queries** - Prevent SQL injection
2. **Use transactions for related operations** - Maintain data integrity
3. **Handle errors gracefully** - Queries can fail
4. **Cache when appropriate** - Reduce database load
5. **Profile slow queries** - Identify bottlenecks
6. **Use indexes effectively** - Speed up queries
7. **Limit result sets** - Don't fetch more than needed
8. **Close connections** - Free resources

## Related Functions

- `prepare()` - Prepared statements
- `transaction()` - Transaction management
- `db()` - Database connection
- `schema()` - Schema builder
- `migrate()` - Database migrations
---

[Conditional Logic in TuskLang]


TuskLang provides powerful conditional logic constructs for controlling program flow based on conditions.

## If Statements

```tusk
# Basic if statement
if (user.age >= 18) {
    status: "adult"
}

# If-else statement
if (score >= 90) {
    grade: "A"
} else {
    grade: "B"
}

# If-elseif-else chain
if (score >= 90) {
    grade: "A"
} elseif (score >= 80) {
    grade: "B"
} elseif (score >= 70) {
    grade: "C"
} elseif (score >= 60) {
    grade: "D"
} else {
    grade: "F"
}

# Nested conditions
if (user.authenticated) {
    if (user.role == "admin") {
        access_level: "full"
    } elseif (user.role == "editor") {
        access_level: "limited"
    } else {
        access_level: "read_only"
    }
} else {
    access_level: "none"
}
```

## Inline Conditionals

```tusk
# Single line if
if (debug) log("Debug mode active")

# Conditional assignment
status: if (active) "online" else "offline"

# Multiple statements in one line
if (error) { log.error(error); return null }

# Guard clauses
validate_user: (user) => {
    if (!user) return {error: "User required"}
    if (!user.email) return {error: "Email required"}
    if (!user.age >= 18) return {error: "Must be 18+"}
    return {success: true}
}
```

## Switch Statements

```tusk
# Basic switch
switch (day) {
    case "Monday":
    case "Tuesday":
    case "Wednesday":
    case "Thursday":
    case "Friday":
        type: "weekday"
        break
        
    case "Saturday":
    case "Sunday":
        type: "weekend"
        break
        
    default:
        type: "unknown"
}

# Switch with expressions
result: switch (user.role) {
    case "admin": 
        "Full access"
    case "user": 
        "Limited access"
    default: 
        "No access"
}

# Pattern matching switch
switch (response.status) {
    case 200..299:
        handle_success(response)
        
    case 301, 302:
        handle_redirect(response)
        
    case 400..499:
        handle_client_error(response)
        
    case 500..599:
        handle_server_error(response)
        
    default:
        handle_unknown(response)
}
```

## Boolean Logic

```tusk
# AND operator (&&)
if (user.active && user.verified) {
    allow_access()
}

# OR operator (||)
if (user.role == "admin" || user.role == "moderator") {
    show_mod_tools()
}

# NOT operator (!)
if (!user.banned) {
    allow_posting()
}

# Complex boolean expressions
if ((user.age >= 18 && user.country == "US") || 
    (user.age >= 21 && user.country == "UK")) {
    allow_purchase()
}

# Short-circuit evaluation
result: cached_value || expensive_calculation()

# Null coalescing
name: user.name ?? "Guest"
```

## Truthiness and Falsiness

```tusk
# Falsy values in TuskLang
falsy_values: [
    false,      # boolean false
    null,       # null
    0,          # zero
    "",         # empty string
    [],         # empty array
    {}          # empty object (in some contexts)
]

# Truthy check
if (value) {
    # Executes if value is truthy
}

# Explicit boolean conversion
is_valid: !!value

# Common patterns
if (array.length) {
    # Array has items
}

if (string) {
    # String is not empty
}

if (object.property) {
    # Property exists and is truthy
}
```

## Advanced Conditionals

```tusk
# Multiple condition checking
conditions: [
    user.age >= 18,
    user.verified,
    user.terms_accepted,
    !user.banned
]

if (conditions.all()) {
    grant_full_access()
} elseif (conditions.some()) {
    grant_limited_access()
} else {
    deny_access()
}

# Conditional chaining
result: user?.profile?.settings?.theme ?? "default"

# Conditional method calls
user.active ? user.send_notification() : user.queue_notification()

# Dynamic condition building
filters: []
if (search_term) filters[] = "name LIKE '%" + search_term + "%'"
if (category) filters[] = "category_id = " + category
if (min_price) filters[] = "price >= " + min_price

where_clause: filters.length ? "WHERE " + filters.join(" AND ") : ""
```

## When/Unless Helpers

```tusk
# When helper (executes if condition is true)
when(user.premium, () => {
    enable_premium_features()
    remove_ads()
})

# Unless helper (executes if condition is false)
unless(user.verified, () => {
    show_verification_prompt()
    limit_features()
})

# Conditional rendering
html: """
    {when(user.logged_in, '<a href="/logout">Logout</a>')}
    {unless(user.logged_in, '<a href="/login">Login</a>')}
"""

# Chained conditionals
query.when(has_filter, (q) => q.where("status", "active"))
     .when(has_sort, (q) => q.orderBy(sort_field))
     .unless(include_deleted, (q) => q.whereNull("deleted_at"))
```

## Conditional Loops

```tusk
# While loop
counter: 0
while (counter < 10) {
    process(counter)
    counter++
}

# Do-while loop
do {
    result: attempt_operation()
} while (!result.success && retries++ < 3)

# Break on condition
foreach (items as item) {
    if (item.stop) break
    if (item.skip) continue
    
    process(item)
}

# Conditional loop continuation
items.each((item) => {
    if (!should_process(item)) return true  # Continue
    if (reached_limit()) return false       # Break
    
    process(item)
})
```

## Error Handling Conditionals

```tusk
# Try-catch conditionals
try {
    result: risky_operation()
    if (result.success) {
        handle_success(result.data)
    } else {
        handle_failure(result.error)
    }
} catch (NetworkError e) {
    if (e.code == 'TIMEOUT') {
        retry_operation()
    } else {
        log_error(e)
    }
} catch (e) {
    handle_generic_error(e)
}

# Conditional error recovery
result: attempt_operation()
    .catch_if(
        (e) => e.code == 'RETRY', 
        () => retry_with_backoff()
    )
    .catch_if(
        (e) => e.code == 'AUTH',
        () => refresh_auth_and_retry()
    )
    .catch(() => default_error_handler())
```

## Performance Considerations

```tusk
# Order conditions by likelihood
if (common_case) {
    # Most likely path first
} elseif (less_common) {
    # Less likely
} else {
    # Rare case
}

# Avoid expensive operations in conditions
# Bad
if (expensive_calculation() > threshold) {
    # ...
}

# Good
calc_result: expensive_calculation()
if (calc_result > threshold) {
    # ...
}

# Use early returns
process_user: (user) => {
    if (!user) return null
    if (!user.active) return null
    if (user.banned) return null
    
    # Main logic here
    return process(user)
}
```

## Conditional Compilation

```tusk
# Compile-time conditionals
#if DEBUG
    log.level: "debug"
    enable_profiling: true
#else
    log.level: "error"
    enable_profiling: false
#endif

# Environment-based code inclusion
#if ENVIRONMENT == "production"
    include("optimized_functions.tusk")
#else
    include("debug_functions.tusk")
#endif

# Feature flags
#if FEATURE_NEW_UI
    render_new_ui()
#else
    render_legacy_ui()
#endif
```

## Best Practices

1. **Use meaningful condition names** - Make code self-documenting
2. **Prefer early returns** - Reduce nesting depth
3. **Order by probability** - Put likely cases first
4. **Avoid deep nesting** - Extract complex logic to functions
5. **Use guard clauses** - Handle edge cases early
6. **Leverage short-circuit evaluation** - For performance
7. **Be explicit about truthiness** - When intent isn't clear
8. **Consider readability** - Sometimes verbose is better

## Related Topics

- `ternary-operators` - Conditional expressions
- `logical-operators` - Boolean operations
- `comparison-operators` - Comparison operations
- `switch-expressions` - Pattern matching
- `null-coalescing` - Null handling
---

[Ternary Operators in TuskLang]


Ternary operators provide concise conditional expressions for simple if-else logic, making code more readable and compact.

## Basic Ternary Syntax

```tusk
# Basic ternary operator
result: condition ? true_value : false_value

# Simple example
age: 25
status: age >= 18 ? "adult" : "minor"

# With variables
is_logged_in: true
message: is_logged_in ? "Welcome back!" : "Please log in"

# With expressions
score: 85
grade: score >= 90 ? "A" : score >= 80 ? "B" : "C"
```

## Nested Ternary Operators

```tusk
# Multiple conditions
score: 75
grade: score >= 90 ? "A" :
       score >= 80 ? "B" :
       score >= 70 ? "C" :
       score >= 60 ? "D" : "F"

# Formatted for readability
user_type: user.is_admin ? "Administrator" :
           user.is_moderator ? "Moderator" :
           user.is_premium ? "Premium User" :
           "Standard User"

# Complex nested example
discount: customer.years > 5 ? 0.20 :
          customer.years > 2 ? 0.10 :
          customer.premium ? 0.05 : 0
```

## Ternary with Functions

```tusk
# Function calls in ternary
result: is_valid(input) ? process(input) : handle_error()

# Method calls
output: user.active ? user.get_full_profile() : user.get_basic_info()

# Lazy evaluation
data: use_cache ? get_cached_data() : fetch_fresh_data()

# With closures
handler: is_async ? 
    () => handle_async(request) : 
    () => handle_sync(request)
```

## Ternary in Assignments

```tusk
# Variable assignment
username: user?.name ? user.name : "Guest"

# Property assignment
config: {
    theme: user_preference ? user_preference : "default"
    language: detected_lang ? detected_lang : "en"
    timezone: user.timezone ? user.timezone : "UTC"
}

# Array elements
statuses: [
    order.shipped ? "Shipped" : "Pending",
    payment.confirmed ? "Paid" : "Awaiting Payment",
    stock > 0 ? "In Stock" : "Out of Stock"
]

# Dynamic keys
response: {
    (success ? "data" : "error"): result
}
```

## Ternary with Null Coalescing

```tusk
# Null coalescing operator (??)
name: user.name ?? "Unknown"

# Combined with ternary
display_name: user.nickname ? user.nickname : (user.name ?? "User")

# Multiple fallbacks
theme: user.theme ?? settings.default_theme ?? "light"

# With type checking
value: is_string(input) ? input : (input?.toString() ?? "")
```

## Ternary in Templates

```tusk
# In string templates
greeting: `Hello, ${user.name ? user.name : "Guest"}!`

# HTML generation
html: """
<div class="${active ? 'active' : 'inactive'}">
    ${user.premium ? '<span class="premium-badge">PRO</span>' : ''}
    <h3>${title ? title : 'Untitled'}</h3>
</div>
"""

# Template literals
message: `You have ${count} ${count == 1 ? 'item' : 'items'} in your cart`

# CSS classes
class_name: `
    btn
    ${primary ? 'btn-primary' : 'btn-secondary'}
    ${large ? 'btn-lg' : ''}
    ${disabled ? 'disabled' : ''}
`.trim()
```

## Ternary in Function Returns

```tusk
# Simple return
get_price: (user) => {
    return user.premium ? price * 0.8 : price
}

# Arrow function with ternary
calculate_tax: (amount, location) => 
    location == "NY" ? amount * 0.08 : amount * 0.05

# Multiple return paths
validate: (value) => {
    return !value ? {error: "Required"} :
           value.length < 3 ? {error: "Too short"} :
           value.length > 50 ? {error: "Too long"} :
           {valid: true}
}

# Conditional return types
fetch_data: (use_mock) => 
    use_mock ? 
        Promise.resolve(mock_data) : 
        http.get("/api/data")
```

## Ternary in Loops

```tusk
# In array methods
numbers: [1, 2, 3, 4, 5]
labels: numbers.map(n => n % 2 == 0 ? "even" : "odd")

# Filtering with ternary
items: products.map(p => 
    p.in_stock ? 
        {id: p.id, name: p.name, status: "available"} : 
        null
).filter(Boolean)

# Reduce with ternary
total: items.reduce((sum, item) => 
    sum + (item.taxable ? item.price * 1.08 : item.price), 
    0
)

# Conditional accumulation
grouped: data.reduce((acc, item) => {
    key: item.type == "A" ? "group1" : "group2"
    acc[key]: (acc[key] ?? []).concat(item)
    return acc
}, {})
```

## Ternary with Type Checking

```tusk
# Type-based behavior
process_value: (val) => 
    is_array(val) ? val.join(",") :
    is_object(val) ? JSON.stringify(val) :
    is_number(val) ? val.toFixed(2) :
    String(val)

# Safe type conversion
to_number: (val) => 
    is_number(val) ? val :
    is_string(val) ? parseFloat(val) :
    is_boolean(val) ? (val ? 1 : 0) :
    0

# Type guards
safe_length: (val) => 
    is_string(val) ? val.length :
    is_array(val) ? val.length :
    has_property(val, 'length') ? val.length :
    0
```

## Performance Considerations

```tusk
# Avoid expensive operations in ternary
# Bad - calculates both values
result: condition ? expensive_operation1() : expensive_operation2()

# Good - lazy evaluation
result: condition ? 
    (() => expensive_operation1())() : 
    (() => expensive_operation2())()

# Better - use if statement for complex logic
if (condition) {
    result: expensive_operation1()
} else {
    result: expensive_operation2()
}

# Cache repeated checks
is_valid: validate_input(input)
message: is_valid ? "Success" : "Failed"
class: is_valid ? "success" : "error"
```

## Ternary Best Practices

```tusk
# Keep it simple
# Good
status: active ? "on" : "off"

# Bad - too complex
result: a > b ? (c > d ? (e > f ? "x" : "y") : "z") : (g > h ? "i" : "j")

# Use parentheses for clarity
priority: (user.premium ? 10 : 5) + bonus

# Align for readability
config: {
    timeout:   dev_mode ? 5000  : 30000,
    retries:   dev_mode ? 1     : 3,
    cache:     dev_mode ? false : true,
    compress:  dev_mode ? false : true
}

# Consider extracting to functions
get_user_level: (user) => {
    return user.admin ? 3 :
           user.moderator ? 2 :
           user.premium ? 1 : 0
}

level: get_user_level(user)
```

## Alternative Patterns

```tusk
# Object lookup instead of nested ternary
grades: {
    A: [90, 100],
    B: [80, 89],
    C: [70, 79],
    D: [60, 69],
    F: [0, 59]
}

get_grade: (score) => {
    for (letter, range in grades) {
        if (score >= range[0] && score <= range[1]) {
            return letter
        }
    }
}

# Switch expression
result: switch (true) {
    case score >= 90: "A"
    case score >= 80: "B"
    case score >= 70: "C"
    case score >= 60: "D"
    default: "F"
}

# Guard pattern
get_discount: (user) => {
    if (!user) return 0
    if (user.vip) return 0.25
    if (user.premium) return 0.15
    if (user.member) return 0.10
    return 0.05
}
```

## Common Pitfalls

```tusk
# Falsy value confusion
# Careful with 0, empty string, etc.
count: items.length ? items.length : 1  # 0 becomes 1!
count: items.length ?? 1  # Better for this case

# Assignment vs comparison
# Wrong
result: x = 5 ? "yes" : "no"  # Assignment!

# Right
result: x == 5 ? "yes" : "no"  # Comparison

# Side effects in ternary
# Avoid
counter: validate() ? counter++ : counter--  # Side effects

# Better
if (validate()) {
    counter++
} else {
    counter--
}
```

## Best Practices

1. **Keep ternaries simple** - Use if-else for complex logic
2. **Avoid deep nesting** - Max 2-3 levels
3. **Use parentheses** - Clarify precedence
4. **Consider readability** - Sometimes if-else is clearer
5. **Don't abuse ternaries** - Not everything needs to be compact
6. **Watch for side effects** - Ternaries should be expressions
7. **Use consistent formatting** - Align for readability
8. **Extract complex logic** - Into named functions

## Related Topics

- `conditional-logic` - If-else statements
- `null-coalescing` - ?? operator
- `optional-chaining` - ?. operator
- `logical-operators` - && and || operators
- `switch-expressions` - Pattern matching
---

[Logical Operators in TuskLang]


Logical operators are used to combine or modify boolean expressions, enabling complex conditional logic in your TuskLang applications.

## Basic Logical Operators

```tusk
# AND operator (&&)
if (user.active && user.verified) {
    grant_access()
}

# OR operator (||)
if (error.critical || error.count > 10) {
    send_alert()
}

# NOT operator (!)
if (!user.banned) {
    allow_posting()
}

# Combining operators
if ((age >= 18 && age <= 65) || has_permission) {
    process_request()
}
```

## AND Operator (&&)

```tusk
# Both conditions must be true
can_purchase: user.logged_in && user.age >= 18

# Multiple AND conditions
is_valid: input.length > 0 && 
          input.length <= 100 && 
          !contains_special_chars(input)

# Short-circuit evaluation
# Second condition only evaluated if first is true
result: check_permission() && perform_action()

# Chaining method calls
success: validate_input(data) && 
         save_to_database(data) && 
         send_notification()

# Guard pattern
process_user: (user) => {
    return user && 
           user.active && 
           user.permissions && 
           user.permissions.includes("write")
}
```

## OR Operator (||)

```tusk
# At least one condition must be true
has_access: user.is_admin || user.is_owner || user.has_permission

# Default values (short-circuit)
name: user.name || "Anonymous"
port: env.PORT || config.port || 3000

# Multiple OR conditions
is_weekend: day == "Saturday" || day == "Sunday"

# Fallback chain
data: get_from_cache() || 
      get_from_database() || 
      get_default_data()

# Validation alternatives
is_valid_id: is_uuid(id) || is_numeric(id) || is_legacy_id(id)
```

## NOT Operator (!)

```tusk
# Simple negation
if (!logged_in) {
    redirect("/login")
}

# Double negation for boolean conversion
is_truthy: !!value

# Negating complex expressions
if (!(user.role == "admin" || user.role == "moderator")) {
    deny_access()
}

# Common patterns
is_empty: !array.length
has_no_errors: !errors.length
is_invalid: !is_valid(input)

# Negation in filters
inactive_users: users.filter(user => !user.active)
```

## Combining Logical Operators

```tusk
# Complex conditions
if ((user.age >= 18 && user.country == "US") || 
    (user.age >= 21 && user.country == "UK") ||
    user.has_override_permission) {
    allow_purchase()
}

# Precedence (AND before OR)
# This is evaluated as: a && (b || c)
if (a && b || c) {
    // ...
}

# Use parentheses for clarity
if ((a && b) || c) {
    // Explicit grouping
}

# Multi-level conditions
is_eligible: (user.active && !user.suspended) &&
             (user.tier == "premium" || user.credits > 100) &&
             (!region_restricted || user.region == allowed_region)
```

## Short-Circuit Evaluation

```tusk
# AND short-circuits on false
result: expensive_check() && very_expensive_check()
# very_expensive_check() only runs if expensive_check() is true

# OR short-circuits on true
cached: get_from_cache() || fetch_from_api()
# fetch_from_api() only runs if get_from_cache() returns falsy

# Practical examples
# Safe property access
value: obj && obj.property && obj.property.nested

# Conditional execution
debug && console.log("Debug info:", data)

# Early return pattern
function process(data) {
    data || return null
    data.valid || return {error: "Invalid data"}
    
    # Main processing
    return transform(data)
}
```

## Truthy and Falsy Values

```tusk
# Falsy values in TuskLang
falsy_values: [
    false,          # Boolean false
    null,           # Null value
    undefined,      # Undefined
    0,              # Number zero
    -0,             # Negative zero
    0n,             # BigInt zero
    "",             # Empty string
    NaN             # Not a Number
]

# Everything else is truthy, including:
truthy_examples: [
    true,           # Boolean true
    1,              # Any non-zero number
    "hello",        # Non-empty string
    [],             # Empty array (!)
    {},             # Empty object (!)
    () => {},       # Functions
]

# Testing truthiness
values: [0, 1, "", "hello", [], {}, null, undefined]
results: values.map(v => ({
    value: v,
    truthy: !!v,
    type: typeof v
}))
```

## Logical Assignment Operators

```tusk
# Logical AND assignment (&&=)
# Assigns only if variable is truthy
user.settings &&= load_user_settings()

# Logical OR assignment (||=)
# Assigns only if variable is falsy
config.timeout ||= 5000

# Logical nullish assignment (??=)
# Assigns only if variable is null or undefined
user.name ??= "Guest"

# Practical examples
# Initialize if needed
cache.users ||= {}
cache.users[id] ||= fetch_user(id)

# Conditional update
user.active &&= check_subscription_status()

# Set defaults
options.retries ??= 3
options.timeout ??= 10000
options.headers ||= {}
```

## Advanced Patterns

```tusk
# All/Any patterns
conditions: [
    user.age >= 18,
    user.email_verified,
    user.terms_accepted
]

all_true: conditions.every(c => c)
any_true: conditions.some(c => c)

# Conditional chaining with logical operators
result: step1() && step2() && step3() || handle_failure()

# State machine logic
can_transition: (from, to) => {
    return (from == "pending" && to == "active") ||
           (from == "active" && to == "completed") ||
           (from == "active" && to == "cancelled") ||
           (from == "any" && user.is_admin)
}

# Feature flags with fallbacks
feature_enabled: (flag) => {
    return env.features[flag] ||
           user.beta_features[flag] ||
           default_features[flag] ||
           false
}
```

## Logical Operators in Functions

```tusk
# Parameter validation
create_user: (name, email, age) => {
    # Validate all parameters
    if (!name || !email || !age) {
        throw "All parameters required"
    }
    
    # Validate individual parameters
    if (!is_valid_email(email) || !is_valid_name(name)) {
        throw "Invalid input"
    }
    
    # Create user
    return new User(name, email, age)
}

# Conditional function execution
execute_if_valid: (condition, action, fallback) => {
    return condition && action() || fallback()
}

# Pipeline with error checking
process_pipeline: (data) => {
    return validate(data) &&
           transform(data) &&
           save(data) &&
           notify_success() ||
           handle_error()
}
```

## Performance Considerations

```tusk
# Order matters for short-circuit
# Put cheaper operations first
if (simple_check() && expensive_check()) {
    # expensive_check only runs if needed
}

# Cache boolean results
is_valid: null
get_validation_status: () => {
    # Cache expensive validation
    is_valid ??= perform_expensive_validation()
    return is_valid
}

# Avoid redundant checks
# Bad
if (user.active && user.verified && user.active) {
    # Checking active twice
}

# Good
if (user.active && user.verified) {
    # Each check only once
}
```

## Common Patterns and Idioms

```tusk
# Toggle boolean
is_visible: !is_visible

# Ensure boolean type
is_active: !!status

# Default object pattern
options: user_options || {}

# Safe navigation
value: a && a.b && a.b.c && a.b.c.d

# Existence check
has_property: obj && "property" in obj

# Array/String emptiness
if (array && array.length) {
    # Array exists and has items
}

# Multiple fallbacks
result: try_primary() || 
        try_secondary() || 
        try_tertiary() || 
        use_default()

# Conditional logging
verbose && log.debug("Detailed information")
```

## Best Practices

1. **Use parentheses for clarity** - Make precedence explicit
2. **Order for short-circuit** - Put cheaper/likely-to-fail conditions first
3. **Avoid deep nesting** - Extract complex logic to functions
4. **Be careful with falsy values** - 0 and "" are falsy
5. **Use descriptive names** - For boolean variables and functions
6. **Consider readability** - Sometimes if-else is clearer
7. **Leverage short-circuit** - For performance and control flow
8. **Test edge cases** - Especially with type coercion

## Related Topics

- `comparison-operators` - ==, !=, <, >, etc.
- `conditional-logic` - if, else, switch
- `ternary-operators` - ? : operator
- `nullish-coalescing` - ?? operator
- `optional-chaining` - ?. operator
---

[Comparison Operators in TuskLang]


Comparison operators are used to compare values and return boolean results, essential for conditional logic and data validation.

## Equality Operators

```tusk
# Equality (==)
# Compares values with type coercion
5 == "5"        # true (number == string)
true == 1       # true (boolean == number)
null == undefined # true

# Strict equality (===)
# Compares values without type coercion
5 === "5"       # false (different types)
true === 1      # false (different types)
null === undefined # false (different types)

# Inequality (!=)
5 != "6"        # true
"hello" != "world" # true

# Strict inequality (!==)
5 !== "5"       # true (different types)
5 !== 5         # false (same value and type)
```

## Relational Operators

```tusk
# Greater than (>)
10 > 5          # true
"b" > "a"       # true (lexicographic)
"10" > "2"      # false (string comparison)

# Less than (<)
3 < 7           # true
"apple" < "banana" # true

# Greater than or equal (>=)
5 >= 5          # true
5 >= 3          # true
5 >= 7          # false

# Less than or equal (<=)
3 <= 3          # true
3 <= 5          # true
7 <= 5          # false

# String comparisons
"abc" < "abd"   # true (character by character)
"ABC" < "abc"   # true (uppercase before lowercase)
"10" < "9"      # true (string comparison, not numeric)
```

## Type Checking Operators

```tusk
# typeof operator
typeof 42           # "number"
typeof "hello"      # "string"
typeof true         # "boolean"
typeof {}           # "object"
typeof []           # "array" (TuskLang enhancement)
typeof null         # "null" (TuskLang enhancement)
typeof undefined    # "undefined"
typeof (() => {})   # "function"

# instanceof operator
date: new Date()
date instanceof Date    # true

array: [1, 2, 3]
array instanceof Array  # true

# Custom type checking
is_string(value)    # true if string
is_number(value)    # true if number
is_array(value)     # true if array
is_object(value)    # true if object (not array)
is_function(value)  # true if function
is_null(value)      # true if null
is_undefined(value) # true if undefined
is_boolean(value)   # true if boolean
```

## Pattern Matching Comparisons

```tusk
# in operator (check property existence)
"name" in user      # true if user has name property
"length" in array   # true (arrays have length)

# Array/String inclusion
"hello" in ["hello", "world"]  # true
"ell" in "hello"               # true (substring)

# Pattern matching with match
result: match value {
    0 => "zero"
    1..10 => "low"
    11..100 => "medium"
    _ => "high"
}

# Range comparisons
age in 18..65      # true if age between 18 and 65
score in [90, 95, 100]  # true if score is one of these values
```

## Comparing Different Types

```tusk
# Number comparisons
42 > 30         # true
3.14 < 5        # true
-10 < 0         # true
Infinity > 1000 # true

# String comparisons (lexicographic)
"apple" < "banana"  # true
"Apple" < "apple"   # true (capitals first)
"100" < "20"        # true (string comparison)

# Boolean comparisons
true > false    # true (true = 1, false = 0)
true == 1       # true
false == 0      # true

# Mixed type comparisons (with coercion)
"5" > 3         # true (string converted to number)
true < 2        # true (true = 1)
"" == 0         # true (empty string = 0)
```

## Object and Array Comparisons

```tusk
# Reference equality
obj1: {name: "John"}
obj2: {name: "John"}
obj3: obj1

obj1 == obj2    # false (different objects)
obj1 === obj2   # false (different objects)
obj1 === obj3   # true (same reference)

# Array comparison
[1, 2] == [1, 2]    # false (different arrays)
arr1: [1, 2]
arr2: arr1
arr1 === arr2       # true (same reference)

# Deep comparison functions
deep_equal(obj1, obj2)  # true if same structure/values
arrays_equal([1, 2], [1, 2])  # true

# Custom comparison
users.sort((a, b) => a.age - b.age)  # Numeric comparison
items.sort((a, b) => a.name.localeCompare(b.name))  # String comparison
```

## Null and Undefined Comparisons

```tusk
# Null comparisons
null == null        # true
null === null       # true
null == undefined   # true (special case)
null === undefined  # false

# Undefined comparisons
undefined == undefined  # true
undefined === undefined # true

# Checking for null or undefined
value == null       # true if null OR undefined
value === null      # true only if null
value === undefined # true only if undefined

# Nullish coalescing
result: value ?? "default"  # Use default if null/undefined

# Optional chaining
length: user?.name?.length  # Safe navigation
```

## Special Value Comparisons

```tusk
# NaN comparisons
NaN == NaN      # false (NaN is never equal to anything)
NaN === NaN     # false
isNaN(NaN)      # true (use this to check for NaN)
Number.isNaN(NaN) # true (stricter check)

# Infinity comparisons
Infinity > 1000000  # true
-Infinity < -1000000 # true
Infinity == Infinity # true

# Zero comparisons
0 == -0         # true
0 === -0        # true
Object.is(0, -0) # false (distinguishes +0 and -0)
```

## Comparison Functions

```tusk
# Numeric comparison function
compare_numbers: (a, b) => {
    if (a < b) return -1
    if (a > b) return 1
    return 0
}

# String comparison (case-insensitive)
compare_strings_ci: (a, b) => {
    return a.toLowerCase().localeCompare(b.toLowerCase())
}

# Date comparison
compare_dates: (d1, d2) => {
    return d1.getTime() - d2.getTime()
}

# Complex object comparison
compare_by: (property) => {
    return (a, b) => {
        if (a[property] < b[property]) return -1
        if (a[property] > b[property]) return 1
        return 0
    }
}

# Usage
users.sort(compare_by("age"))
items.sort(compare_by("price"))
```

## Chained Comparisons

```tusk
# Multiple comparisons
if (0 <= value && value <= 100) {
    # Value is between 0 and 100
}

# Validation chains
is_valid: value != null && 
          value != undefined && 
          value !== "" && 
          value.length > 0

# Range checking
in_range: (value, min, max) => {
    return min <= value && value <= max
}

# Between helper
between: (value, a, b) => {
    return value >= Math.min(a, b) && value <= Math.max(a, b)
}
```

## Performance Tips

```tusk
# Use strict equality when possible
# Faster - no type coercion
if (x === 5) { }

# Slower - requires type coercion
if (x == 5) { }

# Order comparisons efficiently
# Check most likely to fail first
if (expensive_check() && cheap_check()) { }  # Bad
if (cheap_check() && expensive_check()) { }  # Good

# Cache comparison results
is_valid: null
if (is_valid === null) {
    is_valid = complex_validation()
}
```

## Common Patterns

```tusk
# Safe string comparison
safe_compare: (a, b) => {
    return String(a).toLowerCase() === String(b).toLowerCase()
}

# Fuzzy equality (with tolerance)
fuzzy_equal: (a, b, tolerance: 0.0001) => {
    return Math.abs(a - b) < tolerance
}

# Version comparison
compare_versions: (v1, v2) => {
    parts1: v1.split('.').map(Number)
    parts2: v2.split('.').map(Number)
    
    for (i: 0; i < Math.max(parts1.length, parts2.length); i++) {
        p1: parts1[i] || 0
        p2: parts2[i] || 0
        
        if (p1 < p2) return -1
        if (p1 > p2) return 1
    }
    return 0
}

# Truthy/Falsy checks
is_truthy: !!value
is_falsy: !value
```

## Comparison Pitfalls

```tusk
# String number comparison gotcha
"10" < "9"      # true (string comparison)
10 < 9          # false (numeric comparison)

# Object comparison gotcha
{a: 1} == {a: 1}    # false (different objects)

# Array comparison gotcha
[1, 2] == [1, 2]    # false (different arrays)

# NaN comparison gotcha
value == NaN        # always false
value === NaN       # always false
isNaN(value)        # use this instead

# Type coercion surprises
[] == false         # true
[] == 0            # true
"" == false        # true
" " == false       # false (non-empty string)
```

## Best Practices

1. **Use strict equality by default** - Avoid type coercion surprises
2. **Be explicit about type conversions** - Convert before comparing
3. **Use specialized functions for complex comparisons** - Don't rely on operators
4. **Handle null/undefined explicitly** - Avoid unexpected behavior
5. **Test edge cases** - Empty strings, zero, null, undefined
6. **Use descriptive comparison functions** - Make intent clear
7. **Consider locale for string comparisons** - Use localeCompare()
8. **Document non-obvious comparisons** - Explain why

## Related Topics

- `logical-operators` - &&, ||, !
- `ternary-operators` - Conditional expressions
- `type-checking` - Type validation
- `null-handling` - Null/undefined handling
- `equality-algorithms` - Deep equality
---

[Math Operations in TuskLang]


TuskLang provides comprehensive mathematical operations and functions for numeric computations, from basic arithmetic to advanced mathematical functions.

## Basic Arithmetic Operators

```tusk
# Addition (+)
sum: 10 + 5        # 15
total: price + tax  # Variable addition

# Subtraction (-)
difference: 20 - 8  # 12
remaining: total - paid

# Multiplication (*)
product: 6 * 7      # 42
area: width * height

# Division (/)
quotient: 15 / 3    # 5
average: sum / count

# Modulo (%)
remainder: 17 % 5   # 2
is_even: number % 2 == 0

# Exponentiation (**)
power: 2 ** 3       # 8
square: x ** 2
cube: x ** 3
```

## Assignment Operators

```tusk
# Basic assignment
x: 10

# Addition assignment
x += 5      # x = x + 5

# Subtraction assignment
x -= 3      # x = x - 3

# Multiplication assignment
x *= 2      # x = x * 2

# Division assignment
x /= 4      # x = x / 4

# Modulo assignment
x %= 3      # x = x % 3

# Exponentiation assignment
x **= 2     # x = x ** 2

# Increment/Decrement
count++     # Post-increment
++count     # Pre-increment
count--     # Post-decrement
--count     # Pre-decrement
```

## Math Constants

```tusk
# Mathematical constants
Math.PI         # 3.141592653589793
Math.E          # 2.718281828459045
Math.LN2        # Natural log of 2
Math.LN10       # Natural log of 10
Math.LOG2E      # Base 2 log of E
Math.LOG10E     # Base 10 log of E
Math.SQRT1_2    # Square root of 1/2
Math.SQRT2      # Square root of 2

# Using constants
circle_area: Math.PI * radius ** 2
circle_circumference: 2 * Math.PI * radius
```

## Rounding Functions

```tusk
# Round to nearest integer
Math.round(4.7)     # 5
Math.round(4.4)     # 4
Math.round(-4.5)    # -4

# Round down (floor)
Math.floor(4.9)     # 4
Math.floor(-4.1)    # -5

# Round up (ceiling)
Math.ceil(4.1)      # 5
Math.ceil(-4.9)     # -4

# Truncate decimal part
Math.trunc(4.9)     # 4
Math.trunc(-4.9)    # -4

# Round to decimal places
round_to: (num, places) => {
    multiplier: 10 ** places
    return Math.round(num * multiplier) / multiplier
}

round_to(3.14159, 2)  # 3.14
round_to(3.14159, 4)  # 3.1416
```

## Mathematical Functions

```tusk
# Absolute value
Math.abs(-10)       # 10
Math.abs(5)         # 5

# Square root
Math.sqrt(16)       # 4
Math.sqrt(2)        # 1.4142135623730951

# Cube root
Math.cbrt(27)       # 3
Math.cbrt(8)        # 2

# Power functions
Math.pow(2, 3)      # 8 (same as 2 ** 3)
Math.exp(1)         # e^1 = 2.718281828459045

# Logarithms
Math.log(Math.E)    # 1 (natural log)
Math.log10(100)     # 2 (base 10 log)
Math.log2(8)        # 3 (base 2 log)

# Sign function
Math.sign(5)        # 1
Math.sign(-5)       # -1
Math.sign(0)        # 0
```

## Trigonometric Functions

```tusk
# Basic trig functions (radians)
Math.sin(Math.PI / 2)   # 1
Math.cos(Math.PI)       # -1
Math.tan(Math.PI / 4)   # 1

# Inverse trig functions
Math.asin(1)        # π/2
Math.acos(0)        # π/2
Math.atan(1)        # π/4

# atan2 for angle calculation
angle: Math.atan2(y, x)

# Hyperbolic functions
Math.sinh(1)        # Hyperbolic sine
Math.cosh(1)        # Hyperbolic cosine
Math.tanh(1)        # Hyperbolic tangent

# Degree/Radian conversion
to_radians: (degrees) => degrees * (Math.PI / 180)
to_degrees: (radians) => radians * (180 / Math.PI)

# Using conversions
sin_45_deg: Math.sin(to_radians(45))  # 0.7071067811865476
```

## Min/Max Operations

```tusk
# Minimum value
Math.min(5, 3, 9, 1)    # 1
Math.min(...array)      # Spread array elements

# Maximum value
Math.max(5, 3, 9, 1)    # 9
Math.max(...array)      # Spread array elements

# Clamping values
clamp: (value, min, max) => {
    return Math.max(min, Math.min(max, value))
}

clamp(15, 0, 10)    # 10 (clamped to max)
clamp(-5, 0, 10)    # 0  (clamped to min)
clamp(5, 0, 10)     # 5  (within range)

# Finding min/max in arrays
numbers: [3, 7, 2, 9, 1]
min_value: Math.min(...numbers)  # 1
max_value: Math.max(...numbers)  # 9
```

## Random Numbers

```tusk
# Basic random (0 to 1)
Math.random()       # e.g., 0.7264975303378

# Random integer between min and max (inclusive)
random_int: (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min
}

dice_roll: random_int(1, 6)

# Random float between min and max
random_float: (min, max) => {
    return Math.random() * (max - min) + min
}

temperature: random_float(20.0, 25.0)

# Random boolean
random_bool: () => Math.random() < 0.5

# Random array element
random_element: (array) => {
    return array[Math.floor(Math.random() * array.length)]
}

color: random_element(["red", "green", "blue"])

# Seeded random (using external library)
rng: new SeededRandom(12345)
predictable_random: rng.next()
```

## Number Formatting

```tusk
# Fixed decimal places
(3.14159).toFixed(2)        # "3.14"
(10).toFixed(2)             # "10.00"

# Exponential notation
(12345).toExponential(2)    # "1.23e+4"

# Precision
(3.14159).toPrecision(4)    # "3.142"

# Locale formatting
(1234567.89).toLocaleString()              # "1,234,567.89"
(1234567.89).toLocaleString('de-DE')       # "1.234.567,89"

# Currency formatting
format_currency: (amount, currency: "USD") => {
    return amount.toLocaleString('en-US', {
        style: 'currency',
        currency: currency
    })
}

format_currency(1234.56)    # "$1,234.56"

# Percentage formatting
format_percent: (value, decimals: 0) => {
    return (value * 100).toFixed(decimals) + "%"
}

format_percent(0.1534, 2)   # "15.34%"
```

## Advanced Math Operations

```tusk
# Factorial
factorial: (n) => {
    if (n <= 1) return 1
    return n * factorial(n - 1)
}

# Fibonacci
fibonacci: (n) => {
    if (n <= 1) return n
    return fibonacci(n - 1) + fibonacci(n - 2)
}

# Greatest Common Divisor
gcd: (a, b) => {
    if (b == 0) return a
    return gcd(b, a % b)
}

# Least Common Multiple
lcm: (a, b) => {
    return Math.abs(a * b) / gcd(a, b)
}

# Prime check
is_prime: (n) => {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    
    i: 5
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) return false
        i += 6
    }
    return true
}
```

## Statistical Functions

```tusk
# Mean (average)
mean: (numbers) => {
    return numbers.reduce((sum, n) => sum + n, 0) / numbers.length
}

# Median
median: (numbers) => {
    sorted: numbers.sort((a, b) => a - b)
    mid: Math.floor(sorted.length / 2)
    
    if (sorted.length % 2 == 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2
    }
    return sorted[mid]
}

# Standard deviation
std_dev: (numbers) => {
    avg: mean(numbers)
    squared_diffs: numbers.map(n => (n - avg) ** 2)
    variance: mean(squared_diffs)
    return Math.sqrt(variance)
}

# Percentile
percentile: (numbers, p) => {
    sorted: numbers.sort((a, b) => a - b)
    index: (p / 100) * (sorted.length - 1)
    lower: Math.floor(index)
    upper: Math.ceil(index)
    weight: index % 1
    
    return sorted[lower] * (1 - weight) + sorted[upper] * weight
}
```

## Bitwise Operations

```tusk
# AND
5 & 3       # 1 (0101 & 0011 = 0001)

# OR
5 | 3       # 7 (0101 | 0011 = 0111)

# XOR
5 ^ 3       # 6 (0101 ^ 0011 = 0110)

# NOT
~5          # -6 (bitwise NOT)

# Left shift
5 << 1      # 10 (0101 << 1 = 1010)

# Right shift
5 >> 1      # 2 (0101 >> 1 = 0010)

# Zero-fill right shift
-5 >>> 1    # 2147483645

# Check if power of 2
is_power_of_two: (n) => n > 0 && (n & (n - 1)) == 0

# Count set bits
count_bits: (n) => {
    count: 0
    while (n) {
        count += n & 1
        n >>= 1
    }
    return count
}
```

## Numeric Validation

```tusk
# Check if number
Number.isFinite(123)        # true
Number.isFinite(Infinity)   # false

# Check if integer
Number.isInteger(5)         # true
Number.isInteger(5.5)       # false

# Check if safe integer
Number.isSafeInteger(9007199254740991)  # true
Number.isSafeInteger(9007199254740992)  # false

# Check for NaN
Number.isNaN(NaN)           # true
Number.isNaN("NaN")         # false (string)

# Parse numbers safely
safe_parse_int: (value, default: 0) => {
    parsed: parseInt(value)
    return Number.isNaN(parsed) ? default : parsed
}

safe_parse_float: (value, default: 0.0) => {
    parsed: parseFloat(value)
    return Number.isNaN(parsed) ? default : parsed
}
```

## Best Practices

1. **Check for division by zero** - Prevent Infinity results
2. **Handle floating-point precision** - Use rounding for display
3. **Validate numeric inputs** - Check for NaN and Infinity
4. **Use appropriate data types** - Integer vs. float
5. **Consider performance** - Cache complex calculations
6. **Use Math constants** - Don't hardcode PI, E, etc.
7. **Handle edge cases** - Empty arrays, negative numbers
8. **Document units** - Specify radians/degrees, currency, etc.

## Related Topics

- `number-formatting` - Formatting numeric output
- `type-conversion` - Converting between types
- `validation` - Numeric validation
- `random-generation` - Random number generation
- `bigint-operations` - Arbitrary precision math
---

[String Operations in TuskLang]


TuskLang provides powerful string manipulation capabilities with intuitive syntax and comprehensive built-in functions for all your text processing needs.

## String Creation and Literals

```tusk
# Single quotes
single: 'Hello, World!'

# Double quotes
double: "Hello, World!"

# Template literals (backticks)
name: "TuskLang"
greeting: `Welcome to ${name}!`

# Multiline strings
multiline: """
This is a
multiline string
in TuskLang
"""

# Escaped characters
escaped: "Line 1\nLine 2\tTabbed"
quotes: "She said \"Hello\""
path: 'C:\\Users\\Documents'

# Unicode
emoji: "Hello 👋 World 🌍"
unicode: "\u0048\u0065\u006C\u006C\u006F"  # "Hello"
```

## String Concatenation

```tusk
# Plus operator
full_name: first_name + " " + last_name

# Template literals
message: `${greeting}, ${name}!`

# Join array
words: ["Hello", "World"]
sentence: words.join(" ")  # "Hello World"

# Concat method
str1: "Hello"
str2: str1.concat(" ", "World", "!")  # "Hello World!"

# String builder pattern
StringBuilder: {
    parts: []
    
    append: (str) => {
        this.parts.push(str)
        return this
    }
    
    toString: () => this.parts.join("")
}

builder: new StringBuilder()
result: builder.append("Hello")
               .append(" ")
               .append("World")
               .toString()
```

## String Length and Access

```tusk
# Length property
text: "Hello"
length: text.length  # 5

# Character access
first: text[0]       # "H"
last: text[text.length - 1]  # "o"

# charAt method
char: text.charAt(1)  # "e"

# charCodeAt for Unicode
code: text.charCodeAt(0)  # 72 (Unicode for 'H')

# Iterate over characters
for (char of text) {
    console.log(char)
}

# Convert to array
chars: Array.from(text)  # ["H", "e", "l", "l", "o"]
chars: [...text]         # Same result
```

## String Search Operations

```tusk
# indexOf - first occurrence
text: "Hello, World!"
index: text.indexOf("World")     # 7
not_found: text.indexOf("xyz")    # -1

# lastIndexOf - last occurrence
repeated: "Hello Hello"
last: repeated.lastIndexOf("Hello")  # 6

# includes - check presence
has_world: text.includes("World")    # true

# startsWith
is_greeting: text.startsWith("Hello") # true

# endsWith
is_exclaim: text.endsWith("!")        # true

# search with regex
pattern: /world/i
match_index: text.search(pattern)     # 7

# Custom search
find_all: (str, substr) => {
    indices: []
    index: str.indexOf(substr)
    
    while (index !== -1) {
        indices.push(index)
        index: str.indexOf(substr, index + 1)
    }
    
    return indices
}
```

## String Extraction

```tusk
text: "Hello, World!"

# substring(start, end)
sub1: text.substring(0, 5)    # "Hello"
sub2: text.substring(7)       # "World!"

# substr(start, length) - deprecated but common
sub3: text.substr(7, 5)       # "World"

# slice(start, end) - supports negative indices
slice1: text.slice(0, 5)      # "Hello"
slice2: text.slice(-6)        # "World!"
slice3: text.slice(-6, -1)    # "World"

# Extract between delimiters
extract_between: (str, start, end) => {
    start_index: str.indexOf(start)
    if (start_index === -1) return ""
    
    start_index += start.length
    end_index: str.indexOf(end, start_index)
    if (end_index === -1) return ""
    
    return str.substring(start_index, end_index)
}

# Example: extract_between("Hello [World]!", "[", "]") => "World"
```

## String Transformation

```tusk
text: "Hello, World!"

# Case conversion
upper: text.toUpperCase()      # "HELLO, WORLD!"
lower: text.toLowerCase()      # "hello, world!"

# Trim whitespace
padded: "  Hello  "
trimmed: padded.trim()         # "Hello"
trim_start: padded.trimStart() # "Hello  "
trim_end: padded.trimEnd()     # "  Hello"

# Replace
replaced: text.replace("World", "TuskLang")  # "Hello, TuskLang!"
replace_all: text.replaceAll("l", "L")       # "HeLLo, WorLd!"

# Replace with regex
no_vowels: text.replace(/[aeiou]/gi, "")     # "Hll, Wrld!"

# Repeat
repeated: "Ha".repeat(3)       # "HaHaHa"

# Pad
padded_start: "5".padStart(3, "0")   # "005"
padded_end: "Hello".padEnd(10, ".")  # "Hello....."
```

## String Splitting and Joining

```tusk
# Split string
csv: "apple,banana,orange"
fruits: csv.split(",")         # ["apple", "banana", "orange"]

# Split with limit
limited: csv.split(",", 2)     # ["apple", "banana,orange"]

# Split by regex
words: "Hello   World".split(/\s+/)  # ["Hello", "World"]

# Split into characters
chars: "Hello".split("")       # ["H", "e", "l", "l", "o"]

# Join array
array: ["Hello", "World"]
joined: array.join(" ")        # "Hello World"
custom: array.join(" - ")      # "Hello - World"

# Advanced splitting
smart_split: (str, delimiter, options: {}) => {
    { trim: true, remove_empty: true }: options
    
    parts: str.split(delimiter)
    
    if (trim) {
        parts: parts.map(p => p.trim())
    }
    
    if (remove_empty) {
        parts: parts.filter(p => p.length > 0)
    }
    
    return parts
}
```

## Regular Expressions

```tusk
# Create regex
pattern: /hello/i              # Case insensitive
global: /hello/gi              # Global + case insensitive

# Test pattern
is_email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test("user@example.com")

# Match
text: "Hello 123 World 456"
numbers: text.match(/\d+/g)    # ["123", "456"]

# Match with groups
email: "john@example.com"
parts: email.match(/^([^@]+)@(.+)$/)
username: parts[1]             # "john"
domain: parts[2]               # "example.com"

# Replace with function
capitalized: text.replace(/\b\w/g, (char) => char.toUpperCase())

# Split with regex
words: text.split(/\s+/)

# Advanced regex operations
extract_urls: (text) => {
    url_pattern: /(https?:\/\/[^\s]+)/g
    return text.match(url_pattern) || []
}
```

## String Comparison

```tusk
# Basic comparison
"apple" < "banana"             # true (lexicographic)
"Apple" < "apple"              # true (capitals first)

# Case-insensitive comparison
compare_ci: (a, b) => {
    return a.toLowerCase() === b.toLowerCase()
}

# localeCompare for proper sorting
"ä".localeCompare("z", "en")   # -1 (ä before z)
"ä".localeCompare("z", "sv")   # 1  (ä after z in Swedish)

# Natural sort comparison
natural_compare: (a, b) => {
    return a.localeCompare(b, undefined, {
        numeric: true,
        sensitivity: 'base'
    })
}

# Examples
["item2", "item10", "item1"].sort(natural_compare)
# Result: ["item1", "item2", "item10"]
```

## String Formatting

```tusk
# String interpolation
name: "John"
age: 30
formatted: `${name} is ${age} years old`

# Printf-style formatting (with helper)
sprintf: (format, ...args) => {
    i: 0
    return format.replace(/%[sdif]/g, (match) => {
        arg: args[i++]
        switch (match) {
            case '%s': return String(arg)
            case '%d': case '%i': return parseInt(arg)
            case '%f': return parseFloat(arg)
            default: return match
        }
    })
}

message: sprintf("Hello %s, you have %d points", "John", 100)

# Custom formatting
format_template: (template, data) => {
    return template.replace(/\{(\w+)\}/g, (match, key) => {
        return data[key] ?? match
    })
}

result: format_template("Hello {name}, welcome to {site}!", {
    name: "John",
    site: "TuskLang"
})
```

## String Validation

```tusk
# Empty check
is_empty: (str) => !str || str.length === 0

# Whitespace only
is_blank: (str) => !str || str.trim().length === 0

# Email validation
is_email: (email) => {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
}

# URL validation
is_url: (url) => {
    try {
        new URL(url)
        return true
    } catch {
        return false
    }
}

# Phone validation
is_phone: (phone) => {
    # Remove non-digits
    digits: phone.replace(/\D/g, "")
    return digits.length >= 10 && digits.length <= 15
}

# Custom validators
validators: {
    alpha: /^[a-zA-Z]+$/,
    alphanumeric: /^[a-zA-Z0-9]+$/,
    numeric: /^\d+$/,
    hex_color: /^#[0-9A-Fa-f]{6}$/
}

validate: (str, type) => validators[type]?.test(str) ?? false
```

## String Encoding

```tusk
# Base64 encoding
base64_encode: (str) => btoa(str)
base64_decode: (encoded) => atob(encoded)

# URL encoding
url_encode: (str) => encodeURIComponent(str)
url_decode: (encoded) => decodeURIComponent(encoded)

# HTML encoding
html_encode: (str) => {
    return str.replace(/[&<>"']/g, (char) => {
        entities: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        }
        return entities[char]
    })
}

# Custom encoding
rot13: (str) => {
    return str.replace(/[a-zA-Z]/g, (char) => {
        code: char.charCodeAt(0)
        base: code < 97 ? 65 : 97
        return String.fromCharCode((code - base + 13) % 26 + base)
    })
}
```

## Performance Tips

```tusk
# Use string builder for many concatenations
# Bad
result: ""
for (i: 0; i < 1000; i++) {
    result += "text"  # Creates new string each time
}

# Good
parts: []
for (i: 0; i < 1000; i++) {
    parts.push("text")
}
result: parts.join("")

# Cache regex patterns
email_pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
# Reuse pattern instead of creating new regex each time

# Use indexOf for simple searches
# Faster than regex for simple substring search
if (text.indexOf("search") !== -1) {
    # Found
}
```

## Best Practices

1. **Use template literals for interpolation** - Cleaner than concatenation
2. **Choose the right string method** - slice() vs substring() vs substr()
3. **Be careful with regex** - Can be slow on large strings
4. **Handle Unicode properly** - Consider multi-byte characters
5. **Validate and sanitize input** - Prevent injection attacks
6. **Use localeCompare for sorting** - Handles international characters
7. **Cache compiled regex** - Don't recreate patterns
8. **Consider memory with large strings** - Use streaming when possible

## Related Topics

- `regex-patterns` - Regular expression patterns
- `template-literals` - Advanced templating
- `unicode-handling` - Working with Unicode
- `string-encoding` - Character encodings
- `text-processing` - Advanced text manipulation
---

[Array Operations in TuskLang]


Arrays are fundamental data structures in TuskLang, providing ordered collections with powerful manipulation methods and intuitive syntax.

## Array Creation

```tusk
# Array literal
numbers: [1, 2, 3, 4, 5]
empty: []

# Mixed types
mixed: [1, "hello", true, null, {name: "John"}]

# Array constructor
arr1: new Array(5)       # Creates array with 5 empty slots
arr2: new Array(1, 2, 3) # Creates [1, 2, 3]

# Array.from()
from_string: Array.from("Hello")  # ["H", "e", "l", "l", "o"]
from_set: Array.from(new Set([1, 2, 3]))

# Array.of()
array_of: Array.of(7)    # [7] (not empty array of length 7)

# Range creation
range: (start, end) => {
    return Array.from({length: end - start + 1}, (_, i) => start + i)
}
numbers: range(1, 10)    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

## Accessing Elements

```tusk
fruits: ["apple", "banana", "orange", "grape"]

# Index access
first: fruits[0]         # "apple"
last: fruits[fruits.length - 1]  # "grape"

# Negative indexing (with helper)
at: (arr, index) => {
    return index < 0 ? arr[arr.length + index] : arr[index]
}
last_item: at(fruits, -1)  # "grape"

# Destructuring
[first, second, ...rest]: fruits
# first = "apple", second = "banana", rest = ["orange", "grape"]

# Slice for sub-arrays
subset: fruits.slice(1, 3)  # ["banana", "orange"]
last_two: fruits.slice(-2)  # ["orange", "grape"]
```

## Adding Elements

```tusk
arr: [1, 2, 3]

# push - add to end
arr.push(4)              # Returns 4 (new length)
arr.push(5, 6, 7)        # Can add multiple

# unshift - add to beginning
arr.unshift(0)           # Returns new length
arr.unshift(-2, -1)      # Can add multiple

# splice - add at specific position
arr.splice(2, 0, "inserted")  # Insert at index 2

# concat - create new array
combined: arr.concat([8, 9, 10])
multiple: [].concat(arr1, arr2, arr3)

# spread operator
merged: [...arr1, ...arr2]
with_elements: [...arr, 4, 5, 6]
```

## Removing Elements

```tusk
arr: [1, 2, 3, 4, 5]

# pop - remove from end
last: arr.pop()          # Returns removed element

# shift - remove from beginning
first: arr.shift()       # Returns removed element

# splice - remove at position
removed: arr.splice(1, 2)  # Remove 2 elements starting at index 1

# filter - create new array without elements
filtered: arr.filter(x => x !== 3)

# Remove by value
remove_value: (arr, value) => {
    index: arr.indexOf(value)
    if (index !== -1) {
        arr.splice(index, 1)
    }
    return arr
}

# Remove all occurrences
remove_all: (arr, value) => {
    return arr.filter(x => x !== value)
}
```

## Array Transformation

```tusk
numbers: [1, 2, 3, 4, 5]

# map - transform each element
doubled: numbers.map(x => x * 2)  # [2, 4, 6, 8, 10]
squared: numbers.map(x => x ** 2)  # [1, 4, 9, 16, 25]

# map with index
indexed: numbers.map((val, idx) => ({index: idx, value: val}))

# filter - select elements
evens: numbers.filter(x => x % 2 === 0)  # [2, 4]
adults: people.filter(p => p.age >= 18)

# reduce - aggregate values
sum: numbers.reduce((acc, val) => acc + val, 0)
product: numbers.reduce((acc, val) => acc * val, 1)

# Complex reduce
grouped: items.reduce((acc, item) => {
    key: item.category
    acc[key]: acc[key] || []
    acc[key].push(item)
    return acc
}, {})

# flatMap - map and flatten
nested: [[1, 2], [3, 4]]
flattened: nested.flatMap(x => x)  # [1, 2, 3, 4]

words: ["Hello World", "from TuskLang"]
all_words: words.flatMap(s => s.split(" "))
# ["Hello", "World", "from", "TuskLang"]
```

## Array Searching

```tusk
arr: [1, 2, 3, 4, 5]
users: [{id: 1, name: "John"}, {id: 2, name: "Jane"}]

# indexOf - find first index
index: arr.indexOf(3)    # 2
not_found: arr.indexOf(10)  # -1

# lastIndexOf - find last index
last_idx: [1, 2, 3, 2, 1].lastIndexOf(2)  # 3

# includes - check existence
has_three: arr.includes(3)  # true

# find - first element matching condition
first_even: arr.find(x => x % 2 === 0)  # 2
user: users.find(u => u.name === "John")

# findIndex - index of first match
even_index: arr.findIndex(x => x % 2 === 0)  # 1

# some - test if any element matches
has_even: arr.some(x => x % 2 === 0)  # true

# every - test if all elements match
all_positive: arr.every(x => x > 0)  # true

# Custom search
binary_search: (arr, target) => {
    left: 0
    right: arr.length - 1
    
    while (left <= right) {
        mid: Math.floor((left + right) / 2)
        if (arr[mid] === target) return mid
        if (arr[mid] < target) left = mid + 1
        else right = mid - 1
    }
    return -1
}
```

## Array Sorting

```tusk
# Default sort (lexicographic)
words: ["banana", "apple", "cherry"]
words.sort()  # ["apple", "banana", "cherry"]

# Numeric sort
numbers: [10, 5, 40, 25, 1000, 1]
numbers.sort((a, b) => a - b)  # [1, 5, 10, 25, 40, 1000]

# Reverse sort
numbers.sort((a, b) => b - a)  # [1000, 40, 25, 10, 5, 1]

# Object sorting
users: [
    {name: "John", age: 30},
    {name: "Jane", age: 25},
    {name: "Bob", age: 35}
]

# Sort by age
users.sort((a, b) => a.age - b.age)

# Sort by name
users.sort((a, b) => a.name.localeCompare(b.name))

# Multi-level sort
sort_by: (arr, ...keys) => {
    return arr.sort((a, b) => {
        for (key of keys) {
            if (a[key] < b[key]) return -1
            if (a[key] > b[key]) return 1
        }
        return 0
    })
}

# Stable sort
stable_sort: (arr, compare) => {
    return arr
        .map((item, index) => ({item, index}))
        .sort((a, b) => compare(a.item, b.item) || a.index - b.index)
        .map(({item}) => item)
}
```

## Array Iteration

```tusk
arr: [1, 2, 3, 4, 5]

# forEach - side effects only
arr.forEach(x => console.log(x))

# forEach with index
arr.forEach((val, idx) => {
    console.log(`${idx}: ${val}`)
})

# for...of loop
for (value of arr) {
    console.log(value)
}

# for...in loop (indices)
for (index in arr) {
    console.log(`${index}: ${arr[index]}`)
}

# Traditional for loop
for (i: 0; i < arr.length; i++) {
    console.log(arr[i])
}

# Reverse iteration
for (i: arr.length - 1; i >= 0; i--) {
    console.log(arr[i])
}

# entries() for index-value pairs
for ([index, value] of arr.entries()) {
    console.log(`${index}: ${value}`)
}
```

## Array Manipulation

```tusk
# reverse - mutates array
arr: [1, 2, 3]
arr.reverse()  # [3, 2, 1]

# Create reversed copy
reversed: [...arr].reverse()

# join - create string
words: ["Hello", "World"]
sentence: words.join(" ")  # "Hello World"
csv: words.join(",")       # "Hello,World"

# flat - flatten nested arrays
nested: [1, [2, 3], [4, [5, 6]]]
flat1: nested.flat()       # [1, 2, 3, 4, [5, 6]]
flat2: nested.flat(2)      # [1, 2, 3, 4, 5, 6]
flat_all: nested.flat(Infinity)  # Flatten all levels

# fill - fill with value
new_arr: new Array(5).fill(0)  # [0, 0, 0, 0, 0]
arr.fill("x", 1, 4)  # Fill indices 1-3 with "x"

# copyWithin
arr: [1, 2, 3, 4, 5]
arr.copyWithin(0, 3, 5)  # [4, 5, 3, 4, 5]
```

## Array Utilities

```tusk
# Check if array
is_array: Array.isArray([1, 2, 3])  # true
is_array: Array.isArray("hello")    # false

# Array equality
arrays_equal: (a, b) => {
    if (a.length !== b.length) return false
    return a.every((val, index) => val === b[index])
}

# Deep equality
deep_equal: (a, b) => {
    if (a === b) return true
    if (!a || !b) return false
    if (a.length !== b.length) return false
    
    return a.every((val, index) => {
        if (Array.isArray(val) && Array.isArray(b[index])) {
            return deep_equal(val, b[index])
        }
        return val === b[index]
    })
}

# Unique values
unique: (arr) => [...new Set(arr)]

# Intersection
intersect: (a, b) => a.filter(x => b.includes(x))

# Difference
diff: (a, b) => a.filter(x => !b.includes(x))

# Shuffle
shuffle: (arr) => {
    copy: [...arr]
    for (i: copy.length - 1; i > 0; i--) {
        j: Math.floor(Math.random() * (i + 1))
        [copy[i], copy[j]]: [copy[j], copy[i]]
    }
    return copy
}
```

## Array Performance

```tusk
# Pre-allocate for known size
# Good
arr: new Array(1000)
for (i: 0; i < 1000; i++) {
    arr[i]: i * 2
}

# Avoid repeated push for large arrays
# Better: collect then concat
chunks: []
while (has_more_data()) {
    chunk: process_chunk()
    chunks.push(chunk)
}
result: [].concat(...chunks)

# Use typed arrays for numeric data
float_array: new Float32Array(1000)
int_array: new Int32Array(1000)

# Avoid sparse arrays
# Bad
sparse: []
sparse[1000]: "value"  # Creates sparse array

# Good
dense: new Array(1001).fill(null)
dense[1000]: "value"
```

## Array Patterns

```tusk
# Chunk array
chunk: (arr, size) => {
    chunks: []
    for (i: 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size))
    }
    return chunks
}

# Zip arrays
zip: (...arrays) => {
    max_length: Math.max(...arrays.map(a => a.length))
    return Array.from({length: max_length}, (_, i) => {
        return arrays.map(a => a[i])
    })
}

# Rotate array
rotate: (arr, n) => {
    n: n % arr.length
    return arr.slice(n).concat(arr.slice(0, n))
}

# Partition array
partition: (arr, predicate) => {
    return arr.reduce((acc, val) => {
        acc[predicate(val) ? 0 : 1].push(val)
        return acc
    }, [[], []])
}
```

## Best Practices

1. **Use appropriate methods** - map() for transformation, filter() for selection
2. **Avoid mutating when possible** - Create new arrays for immutability
3. **Check array bounds** - Prevent undefined access
4. **Use typed arrays for numbers** - Better performance and memory usage
5. **Be careful with sort()** - It mutates and uses lexicographic order
6. **Prefer declarative methods** - map/filter/reduce over loops
7. **Handle empty arrays** - Many methods return undefined on empty
8. **Consider performance** - Some operations are O(n²)

## Related Topics

- `iterators` - Advanced iteration
- `destructuring` - Array destructuring
- `spread-operator` - Array spreading
- `typed-arrays` - Numeric arrays
- `collection-methods` - Advanced collection operations
---

[Object Operations in TuskLang]


Objects are key-value collections in TuskLang, providing flexible data structures with powerful manipulation methods and intuitive syntax.

## Object Creation

```tusk
# Object literal
person: {
    name: "John Doe"
    age: 30
    active: true
}

# Empty object
empty: {}

# Computed property names
key: "dynamicKey"
obj: {
    [key]: "value"
    ["prop_" + 42]: "computed"
}

# Object constructor
obj1: new Object()
obj2: Object.create(null)  # No prototype

# From entries
entries: [["name", "John"], ["age", 30]]
from_entries: Object.fromEntries(entries)

# Shorthand properties
name: "John"
age: 30
person: {name, age}  # Same as {name: name, age: age}

# Methods
user: {
    name: "John"
    greet() {
        return "Hello, " + this.name
    }
}
```

## Property Access

```tusk
person: {name: "John", age: 30, "special-key": "value"}

# Dot notation
name: person.name

# Bracket notation
age: person["age"]
special: person["special-key"]

# Dynamic property access
prop: "name"
value: person[prop]

# Optional chaining
city: person.address?.city  # undefined if address doesn't exist

# Nullish coalescing
display_name: person.nickname ?? person.name ?? "Anonymous"

# Destructuring
{name, age}: person
{name: userName, age: userAge}: person  # Rename

# Nested destructuring
user: {profile: {name: "John", settings: {theme: "dark"}}}
{profile: {name, settings: {theme}}}: user
```

## Adding and Modifying Properties

```tusk
obj: {a: 1}

# Add/modify properties
obj.b: 2
obj["c"]: 3

# Object.assign() - shallow merge
target: {a: 1}
source1: {b: 2}
source2: {c: 3, a: 10}
merged: Object.assign(target, source1, source2)
# target is modified: {a: 10, b: 2, c: 3}

# Spread operator - create new object
combined: {...obj1, ...obj2}
with_override: {...defaults, ...userConfig}

# Deep merge function
deep_merge: (target, source) => {
    for (key in source) {
        if (is_object(source[key]) && is_object(target[key])) {
            target[key]: deep_merge(target[key], source[key])
        } else {
            target[key]: source[key]
        }
    }
    return target
}

# Property descriptors
Object.defineProperty(obj, 'readonly', {
    value: 42,
    writable: false,
    enumerable: true,
    configurable: false
})
```

## Removing Properties

```tusk
obj: {a: 1, b: 2, c: 3}

# delete operator
delete obj.b
delete obj["c"]

# Create new object without properties
{b, ...rest}: obj  # rest contains all except b

# Remove multiple properties
omit: (obj, ...keys) => {
    result: {...obj}
    keys.forEach(key => delete result[key])
    return result
}

cleaned: omit(obj, "temp", "internal", "_private")

# Filter properties
pick: (obj, ...keys) => {
    result: {}
    keys.forEach(key => {
        if (key in obj) result[key]: obj[key]
    })
    return result
}

subset: pick(user, "id", "name", "email")
```

## Object Iteration

```tusk
obj: {name: "John", age: 30, city: "NYC"}

# for...in loop
for (key in obj) {
    console.log(key + ": " + obj[key])
}

# Object.keys()
keys: Object.keys(obj)  # ["name", "age", "city"]
keys.forEach(key => {
    console.log(key + ": " + obj[key])
})

# Object.values()
values: Object.values(obj)  # ["John", 30, "NYC"]

# Object.entries()
entries: Object.entries(obj)  # [["name", "John"], ["age", 30], ["city", "NYC"]]
for ([key, value] of entries) {
    console.log(key + ": " + value)
}

# hasOwnProperty check
for (key in obj) {
    if (obj.hasOwnProperty(key)) {
        # Own property, not inherited
    }
}

# Get own property names (including non-enumerable)
all_props: Object.getOwnPropertyNames(obj)
symbols: Object.getOwnPropertySymbols(obj)
```

## Object Transformation

```tusk
# Map object values
map_values: (obj, fn) => {
    result: {}
    for (key in obj) {
        result[key]: fn(obj[key], key)
    }
    return result
}

prices: {apple: 1.5, banana: 0.5}
with_tax: map_values(prices, price => price * 1.08)

# Map object keys
map_keys: (obj, fn) => {
    result: {}
    for (key in obj) {
        new_key: fn(key, obj[key])
        result[new_key]: obj[key]
    }
    return result
}

snake_case: map_keys(obj, key => key.replace(/([A-Z])/g, "_$1").toLowerCase())

# Filter object
filter_object: (obj, predicate) => {
    result: {}
    for (key in obj) {
        if (predicate(obj[key], key)) {
            result[key]: obj[key]
        }
    }
    return result
}

positive_only: filter_object(numbers, val => val > 0)

# Reduce object
reduce_object: (obj, fn, initial) => {
    result: initial
    for (key in obj) {
        result: fn(result, obj[key], key)
    }
    return result
}

sum: reduce_object(scores, (sum, score) => sum + score, 0)
```

## Object Comparison

```tusk
# Reference equality
obj1: {a: 1}
obj2: {a: 1}
obj3: obj1

obj1 === obj2  # false (different objects)
obj1 === obj3  # true (same reference)

# Shallow equality
shallow_equal: (a, b) => {
    keys_a: Object.keys(a)
    keys_b: Object.keys(b)
    
    if (keys_a.length !== keys_b.length) return false
    
    return keys_a.every(key => a[key] === b[key])
}

# Deep equality
deep_equal: (a, b) => {
    if (a === b) return true
    
    if (!a || !b) return false
    if (typeof a !== typeof b) return false
    
    if (typeof a !== 'object') return a === b
    
    keys_a: Object.keys(a)
    keys_b: Object.keys(b)
    
    if (keys_a.length !== keys_b.length) return false
    
    return keys_a.every(key => deep_equal(a[key], b[key]))
}

# Object diff
diff: (old_obj, new_obj) => {
    changes: {}
    
    # Check modified and removed
    for (key in old_obj) {
        if (!(key in new_obj)) {
            changes[key]: {type: 'removed', old: old_obj[key]}
        } else if (old_obj[key] !== new_obj[key]) {
            changes[key]: {type: 'modified', old: old_obj[key], new: new_obj[key]}
        }
    }
    
    # Check added
    for (key in new_obj) {
        if (!(key in old_obj)) {
            changes[key]: {type: 'added', new: new_obj[key]}
        }
    }
    
    return changes
}
```

## Object Cloning

```tusk
# Shallow clone
original: {a: 1, b: {c: 2}}

# Spread operator
clone1: {...original}

# Object.assign
clone2: Object.assign({}, original)

# Deep clone
deep_clone: (obj) => {
    if (obj === null || typeof obj !== 'object') return obj
    if (obj instanceof Date) return new Date(obj)
    if (obj instanceof Array) return obj.map(item => deep_clone(item))
    
    cloned: {}
    for (key in obj) {
        cloned[key]: deep_clone(obj[key])
    }
    return cloned
}

# JSON method (limited)
json_clone: JSON.parse(JSON.stringify(obj))
# Note: Loses functions, undefined, symbols

# Structured clone (if available)
structured: structuredClone(obj)
```

## Object Freezing and Sealing

```tusk
# Freeze - no modifications
obj: {a: 1, b: 2}
Object.freeze(obj)
obj.a: 3  # Silently fails (error in strict mode)
obj.c: 3  # Silently fails

# Check if frozen
is_frozen: Object.isFrozen(obj)

# Seal - no adding/deleting, but can modify
obj2: {x: 1, y: 2}
Object.seal(obj2)
obj2.x: 3  # Works
obj2.z: 3  # Fails
delete obj2.y  # Fails

# Prevent extensions only
obj3: {p: 1}
Object.preventExtensions(obj3)
obj3.p: 2  # Works
obj3.q: 2  # Fails

# Deep freeze
deep_freeze: (obj) => {
    Object.freeze(obj)
    
    Object.values(obj).forEach(value => {
        if (typeof value === 'object' && value !== null) {
            deep_freeze(value)
        }
    })
    
    return obj
}
```

## Object Patterns

```tusk
# Factory pattern
create_user: (name, email) => {
    return {
        id: generate_id(),
        name,
        email,
        created_at: new Date(),
        
        update(data) {
            Object.assign(this, data)
            this.updated_at: new Date()
        },
        
        to_json() {
            return JSON.stringify(this)
        }
    }
}

# Object pooling
object_pool: {
    pool: [],
    
    get() {
        return this.pool.pop() || this.create()
    },
    
    release(obj) {
        this.reset(obj)
        this.pool.push(obj)
    },
    
    create() {
        return {}
    },
    
    reset(obj) {
        for (key in obj) {
            delete obj[key]
        }
    }
}

# Proxy for validation
validated_object: (schema) => {
    return new Proxy({}, {
        set(target, prop, value) {
            if (schema[prop]) {
                if (!schema[prop](value)) {
                    throw new Error(`Invalid value for ${prop}`)
                }
            }
            target[prop]: value
            return true
        }
    })
}

user_schema: {
    age: val => typeof val === 'number' && val >= 0,
    email: val => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val)
}

user: validated_object(user_schema)
```

## Object Utilities

```tusk
# Check if object is empty
is_empty: (obj) => Object.keys(obj).length === 0

# Get nested value safely
get: (obj, path, default_value) => {
    keys: path.split('.')
    result: obj
    
    for (key of keys) {
        result: result?.[key]
        if (result === undefined) return default_value
    }
    
    return result
}

# Set nested value
set: (obj, path, value) => {
    keys: path.split('.')
    last: keys.pop()
    
    current: obj
    for (key of keys) {
        if (!(key in current) || typeof current[key] !== 'object') {
            current[key]: {}
        }
        current: current[key]
    }
    
    current[last]: value
    return obj
}

# Invert object
invert: (obj) => {
    result: {}
    for (key in obj) {
        result[obj[key]]: key
    }
    return result
}

# Group by property
group_by: (array, key) => {
    return array.reduce((acc, item) => {
        group_key: item[key]
        acc[group_key]: acc[group_key] || []
        acc[group_key].push(item)
        return acc
    }, {})
}
```

## Performance Considerations

```tusk
# Object vs Map for dynamic keys
# Use Map for frequent additions/deletions
map: new Map()
map.set(key, value)
map.delete(key)

# Use object for static structure
config: {
    api_url: "...",
    timeout: 5000
}

# Avoid delete in hot paths
# Instead of delete, set to undefined
obj.prop: undefined

# Or create new object without property
{unwanted, ...kept}: obj

# Pre-define object shape
# V8 optimizes objects with stable shape
user: {
    id: null,
    name: null,
    email: null
}
# Then fill values
```

## Best Practices

1. **Use const for objects** - Prevents reassignment, not mutation
2. **Prefer immutability** - Create new objects instead of mutating
3. **Use descriptive keys** - Make objects self-documenting
4. **Avoid delete in loops** - Performance impact
5. **Consider Map for dynamic keys** - Better performance
6. **Validate object shapes** - Use schemas or TypeScript
7. **Handle missing properties** - Use optional chaining
8. **Be careful with prototypes** - Can cause unexpected behavior

## Related Topics

- `destructuring` - Object destructuring
- `spread-operator` - Object spreading
- `json-operations` - JSON serialization
- `class-syntax` - Object-oriented patterns
- `prototypes` - Prototype chain
---

[Function Composition in TuskLang]


Function composition is a powerful paradigm in TuskLang that allows you to build complex operations by combining simple functions, promoting code reuse and clarity.

## Basic Composition

```tusk
# Simple function composition
add_one: (x) => x + 1
double: (x) => x * 2
square: (x) => x ** 2

# Manual composition
result: square(double(add_one(5)))  # ((5 + 1) * 2)² = 144

# Compose function
compose: (...fns) => {
    return (x) => fns.reduceRight((acc, fn) => fn(acc), x)
}

# Using compose (right to left)
calculate: compose(square, double, add_one)
result: calculate(5)  # 144

# Pipe function (left to right)
pipe: (...fns) => {
    return (x) => fns.reduce((acc, fn) => fn(acc), x)
}

# Using pipe
process: pipe(add_one, double, square)
result: process(5)  # 144
```

## Practical Examples

```tusk
# String processing pipeline
trim: (s) => s.trim()
lowercase: (s) => s.toLowerCase()
replace_spaces: (s) => s.replace(/\s+/g, '-')
remove_special: (s) => s.replace(/[^a-z0-9-]/g, '')

slugify: pipe(
    trim,
    lowercase,
    replace_spaces,
    remove_special
)

slug: slugify("  Hello World!  ")  # "hello-world"

# Data transformation
parse_int: (x) => parseInt(x)
validate_positive: (x) => x > 0 ? x : 0
add_tax: (x) => x * 1.08
format_currency: (x) => "$" + x.toFixed(2)

process_price: pipe(
    parse_int,
    validate_positive,
    add_tax,
    format_currency
)

price: process_price("100")  # "$108.00"
```

## Partial Application

```tusk
# Partial application for composition
multiply: (a) => (b) => a * b
add: (a) => (b) => a + b
divide: (a) => (b) => b / a

# Create specialized functions
double: multiply(2)
triple: multiply(3)
add_ten: add(10)
half: divide(2)

# Compose with partial functions
calculate: pipe(
    add_ten,      # x + 10
    double,       # (x + 10) * 2
    half          # ((x + 10) * 2) / 2
)

result: calculate(5)  # 15

# More complex example
filter_by: (predicate) => (array) => array.filter(predicate)
map_by: (fn) => (array) => array.map(fn)
reduce_by: (fn, initial) => (array) => array.reduce(fn, initial)

# Create pipeline
process_numbers: pipe(
    filter_by(x => x > 0),              # Keep positive
    map_by(x => x * 2),                 # Double them
    reduce_by((sum, x) => sum + x, 0)   # Sum them
)

total: process_numbers([1, -2, 3, -4, 5])  # 18
```

## Async Composition

```tusk
# Async pipe
pipe_async: (...fns) => {
    return async (x) => {
        result: x
        for (fn of fns) {
            result: await fn(result)
        }
        return result
    }
}

# Async functions
fetch_user: async (id) => {
    response: await fetch(`/api/users/${id}`)
    return response.json()
}

enrich_user: async (user) => {
    posts: await fetch(`/api/users/${user.id}/posts`).then(r => r.json())
    return {...user, posts}
}

format_user: async (user) => {
    return {
        name: user.name,
        email: user.email,
        post_count: user.posts.length
    }
}

# Compose async operations
get_user_summary: pipe_async(
    fetch_user,
    enrich_user,
    format_user
)

summary: await get_user_summary(123)
```

## Function Decorators

```tusk
# Logging decorator
with_logging: (fn) => {
    return (...args) => {
        console.log(`Calling ${fn.name} with`, args)
        result: fn(...args)
        console.log(`Result:`, result)
        return result
    }
}

# Timing decorator
with_timing: (fn) => {
    return (...args) => {
        start: performance.now()
        result: fn(...args)
        end: performance.now()
        console.log(`${fn.name} took ${end - start}ms`)
        return result
    }
}

# Memoization decorator
memoize: (fn) => {
    cache: new Map()
    
    return (...args) => {
        key: JSON.stringify(args)
        
        if (cache.has(key)) {
            return cache.get(key)
        }
        
        result: fn(...args)
        cache.set(key, result)
        return result
    }
}

# Compose decorators
enhance: compose(
    with_logging,
    with_timing,
    memoize
)

# Enhanced function
fibonacci: enhance((n) => {
    if (n <= 1) return n
    return fibonacci(n - 1) + fibonacci(n - 2)
})
```

## Monadic Composition

```tusk
# Maybe monad for null safety
Maybe: {
    of: (value) => ({
        value,
        map: (fn) => value != null ? Maybe.of(fn(value)) : Maybe.of(null),
        chain: (fn) => value != null ? fn(value) : Maybe.of(null),
        or_else: (default) => value != null ? value : default
    })
}

# Safe property access
safe_prop: (prop) => (obj) => Maybe.of(obj?.[prop])

# Compose with Maybe
get_city: pipe(
    Maybe.of,
    (m) => m.chain(safe_prop('address')),
    (m) => m.chain(safe_prop('city')),
    (m) => m.or_else('Unknown')
)

city: get_city(user)  # Safe even if address is null

# Result monad for error handling
Result: {
    ok: (value) => ({
        is_ok: true,
        value,
        map: (fn) => Result.ok(fn(value)),
        chain: (fn) => fn(value),
        or_else: () => value
    }),
    
    err: (error) => ({
        is_ok: false,
        error,
        map: () => Result.err(error),
        chain: () => Result.err(error),
        or_else: (fn) => fn(error)
    })
}

# Safe division
safe_divide: (a) => (b) => {
    if (b === 0) return Result.err("Division by zero")
    return Result.ok(a / b)
}

# Compose with Result
calculate_percentage: pipe(
    (x) => Result.ok(x),
    (r) => r.chain(x => safe_divide(x)(100)),
    (r) => r.map(x => x * 100),
    (r) => r.map(x => x.toFixed(2) + "%"),
    (r) => r.or_else(err => "Error: " + err)
)
```

## Transducers

```tusk
# Transducer pattern
mapping: (fn) => (reducer) => {
    return (acc, val) => reducer(acc, fn(val))
}

filtering: (predicate) => (reducer) => {
    return (acc, val) => predicate(val) ? reducer(acc, val) : acc
}

# Compose transducers
compose_transducers: compose

# Create transducer
xform: compose_transducers(
    filtering(x => x > 0),
    mapping(x => x * 2),
    mapping(x => x + 1)
)

# Use with reduce
result: [1, -2, 3, -4, 5].reduce(
    xform((acc, val) => [...acc, val]),
    []
)  # [3, 7, 11]

# Reuse with different reducers
sum: [1, -2, 3, -4, 5].reduce(
    xform((acc, val) => acc + val),
    0
)  # 21
```

## Functional Utilities

```tusk
# Identity function
identity: (x) => x

# Constant function
constant: (x) => () => x

# Flip arguments
flip: (fn) => (a) => (b) => fn(b)(a)

# Curry function
curry: (fn) => {
    return (...args) => {
        if (args.length >= fn.length) {
            return fn(...args)
        }
        return (...more) => curry(fn)(...args, ...more)
    }
}

# Uncurry function
uncurry: (fn) => (...args) => {
    result: fn
    for (arg of args) {
        result: result(arg)
    }
    return result
}

# Tap for debugging
tap: (fn) => (x) => {
    fn(x)
    return x
}

# Usage in pipeline
process: pipe(
    add_one,
    tap(x => console.log("After add:", x)),
    double,
    tap(x => console.log("After double:", x)),
    square
)
```

## Advanced Patterns

```tusk
# Kleisli composition for monads
kleisli_compose: (f, g) => (x) => f(x).chain(g)

# Contravariant composition
contramap: (fn) => (transform) => {
    return (x) => fn(transform(x))
}

# Bifunctor mapping
bimap: (f, g) => (either) => {
    return either.is_left 
        ? {...either, value: f(either.value)}
        : {...either, value: g(either.value)}
}

# Lens composition
lens: (getter, setter) => ({
    get: getter,
    set: setter,
    over: (fn) => (obj) => setter(fn(getter(obj)))(obj)
})

compose_lenses: (lens1, lens2) => lens(
    (obj) => lens2.get(lens1.get(obj)),
    (val) => (obj) => lens1.set(lens2.set(val)(lens1.get(obj)))(obj)
)

# Category theory inspired
class Category {
    constructor(compose, id) {
        this.compose: compose
        this.id: id
    }
    
    // Laws
    left_identity: (f) => this.compose(this.id, f) === f
    right_identity: (f) => this.compose(f, this.id) === f
    associativity: (f, g, h) => 
        this.compose(f, this.compose(g, h)) === 
        this.compose(this.compose(f, g), h)
}
```

## Performance Optimization

```tusk
# Lazy composition
lazy_compose: (...fns) => {
    return {
        add: (fn) => lazy_compose(...fns, fn),
        run: (x) => fns.reduceRight((acc, fn) => fn(acc), x)
    }
}

# Build pipeline incrementally
pipeline: lazy_compose()
    .add(validate)
    .add(transform)
    .add(format)

# Run when ready
result: pipeline.run(data)

# Compile composed function
compile_composition: (...fns) => {
    # Generate optimized code
    code: "return function(x) { return "
    
    for (i: fns.length - 1; i >= 0; i--) {
        code += `fns[${i}](`
    }
    
    code += "x"
    code += ")".repeat(fns.length)
    code += " }"
    
    return new Function("fns", code)(fns)
}

# Parallel composition for independent operations
parallel_compose: (...fns) => {
    return async (x) => {
        results: await Promise.all(fns.map(fn => fn(x)))
        return results
    }
}
```

## Best Practices

1. **Keep functions pure** - No side effects for predictability
2. **Single responsibility** - Each function does one thing
3. **Type consistency** - Ensure compatible input/output types
4. **Name meaningfully** - Composed functions should have clear names
5. **Test components** - Test individual functions and compositions
6. **Document pipelines** - Explain what the composition does
7. **Consider performance** - Deep composition can impact performance
8. **Use type hints** - Help with composition compatibility

## Related Topics

- `higher-order-functions` - Functions that operate on functions
- `partial-application` - Creating specialized functions
- `currying` - Function transformation
- `monads` - Compositional error handling
- `functional-programming` - FP concepts in TuskLang
---

[Hash (#) Directives Introduction]


Hash directives are special commands in TuskLang that define how your code should be executed, providing powerful meta-programming capabilities and execution contexts.

## What are Hash Directives?

Hash directives are instructions that start with `#` and tell TuskLang how to handle specific code blocks. They define execution contexts, routing rules, scheduling, and more.

```tusk
# Basic directive syntax
#directive_name optional_parameters {
    # Code block executed in this directive's context
}

# Example: Web endpoint
#web /hello {
    response: "Hello, World!"
}
```

## Core Directives Overview

```tusk
# Web endpoints
#web /api/users {
    # Handle HTTP requests
}

# API endpoints (JSON responses)
#api /api/data {
    # Automatically returns JSON
}

# Command-line interface
#cli process --file {
    # Handle CLI commands
}

# Scheduled tasks
#cron "0 * * * *" {
    # Run every hour
}

# Middleware
#middleware auth {
    # Process requests before handlers
}

# Database migrations
#migration create_users_table {
    # Database schema changes
}

# Tests
#test "user creation" {
    # Unit tests
}
```

## Directive Structure

```tusk
# Full directive syntax
#directive_type route_or_pattern optional_name {
    # Directive body
    
    # Access to special variables
    # @request - incoming request
    # @response - outgoing response
    # @params - route parameters
    # @context - execution context
}

# Nested directives
#web /admin {
    #auth required: true
    #role "admin"
    
    # Admin-only content
}
```

## Common Patterns

```tusk
# RESTful routes
#web /users {
    # GET /users - List users
    users: @User.all()
    @json(users)
}

#web /users/{id} {
    # GET /users/123 - Get specific user
    user: @User.find(@params.id)
    @json(user)
}

#api /users method: POST {
    # POST /users - Create user
    user: @User.create(@request.post)
    @json(user, 201)
}

# Grouped routes
#group /api/v1 {
    #web /users {
        # Routes to /api/v1/users
    }
    
    #web /posts {
        # Routes to /api/v1/posts
    }
}
```

## Directive Modifiers

```tusk
# Method specification
#web /users method: GET {
    # Only handles GET requests
}

#web /users method: [GET, POST] {
    # Handles both GET and POST
}

# Middleware application
#web /secure middleware: [auth, logging] {
    # Applies auth and logging middleware
}

# Conditional directives
#web /feature if: @feature_enabled("new_ui") {
    # Only active if feature is enabled
}

# Named directives
#web /home name: "home_route" {
    # Can be referenced by name
}
```

## Custom Directives

```tusk
# Define custom directive
#define_directive webhook {
    pattern: /^\/webhooks\/(.+)$/
    
    handler: (match, block) => {
        webhook_type: match[1]
        
        return {
            method: "POST"
            middleware: ["verify_webhook"]
            handler: () => {
                payload: @request.post
                signature: @request.headers.x-webhook-signature
                
                if (!@verify_signature(payload, signature)) {
                    @response.status: 401
                    return {error: "Invalid signature"}
                }
                
                return block({
                    type: webhook_type,
                    payload: payload
                })
            }
        }
    }
}

# Use custom directive
#webhook /github {
    # Handle GitHub webhooks
    event: @request.headers.x-github-event
    
    switch (event) {
        case "push":
            @handle_push(@payload)
        case "pull_request":
            @handle_pr(@payload)
    }
}
```

## Directive Context

```tusk
# Each directive provides context
#web /user/profile {
    # Available in web context:
    # @request - HTTP request object
    # @response - HTTP response object
    # @params - Route parameters
    # @session - Session data
    # @cookie - Cookie access
}

#cli backup --database {
    # Available in CLI context:
    # @args - Command line arguments
    # @options - Parsed options
    # @input - STDIN access
    # @output - STDOUT access
}

#cron "*/5 * * * *" {
    # Available in cron context:
    # @schedule - Cron schedule info
    # @last_run - Previous execution time
    # @next_run - Next scheduled time
}
```

## Directive Composition

```tusk
# Combine multiple directives
#authenticated {
    #web /dashboard {
        # Requires authentication
    }
    
    #api /user/data {
        # Also requires authentication
    }
}

# Directive inheritance
#base_api {
    #ratelimit 100/hour
    #cache 300
    
    #api /data {
        # Inherits rate limit and cache
    }
}

# Conditional composition
#if @env.FEATURE_X {
    #web /new-feature {
        # Only defined if feature is enabled
    }
}
```

## Directive Configuration

```tusk
# Global directive settings
#config {
    web: {
        prefix: "/app"
        middleware: ["logging", "cors"]
        error_handler: @handle_http_error
    }
    
    api: {
        version: "v1"
        format: "json"
        authentication: "bearer"
    }
    
    cli: {
        colors: true
        interactive: true
    }
}

# Override per directive
#web /special config: {middleware: []} {
    # No global middleware applied
}
```

## Error Handling in Directives

```tusk
# Directive-specific error handling
#web /risky {
    #on_error {
        @log.error("Web handler failed", @error)
        @response.status: 500
        @json({error: "Internal server error"})
    }
    
    # Risky operation
    result: @risky_operation()
}

# Global error handlers
#error_handler http {
    switch (@error.code) {
        case 404:
            @render("errors/404.tusk")
        case 500:
            @render("errors/500.tusk")
        default:
            @render("errors/generic.tusk", {error: @error})
    }
}
```

## Directive Metadata

```tusk
# Add metadata to directives
#web /api/users {
    #doc {
        description: "List all users"
        parameters: {
            page: "Page number (optional)"
            limit: "Items per page (optional)"
        }
        returns: "Array of user objects"
    }
    
    #deprecated "Use /api/v2/users instead"
    
    # Handler code
}

# Access directive metadata
routes: @get_directives("web")
for (route in routes) {
    if (route.metadata.deprecated) {
        @log.warning("Deprecated route in use", route)
    }
}
```

## Best Practices

1. **Use appropriate directives** - Choose the right directive for the context
2. **Keep handlers focused** - One responsibility per directive
3. **Use middleware** - Share common functionality
4. **Document directives** - Add descriptions and examples
5. **Handle errors** - Always consider failure cases
6. **Test directives** - Unit test your handlers
7. **Organize by feature** - Group related directives
8. **Version APIs** - Use versioning for backwards compatibility

## Common Patterns

```tusk
# RESTful resource
#resource users {
    # Generates all CRUD routes:
    # GET    /users       - index
    # GET    /users/{id}  - show
    # POST   /users       - create
    # PUT    /users/{id}  - update
    # DELETE /users/{id}  - destroy
}

# Nested resources
#resource posts {
    #resource comments {
        # Generates /posts/{post_id}/comments/{id} routes
    }
}

# API versioning
#version 1 {
    #api /users {
        # Version 1 implementation
    }
}

#version 2 {
    #api /users {
        # Version 2 implementation
    }
}
```

## Related Topics

- `hash-web-directive` - Web endpoints
- `hash-api-directive` - API endpoints
- `hash-cli-directive` - CLI commands
- `hash-cron-directive` - Scheduled tasks
- `hash-middleware-directive` - Request processing
---

[#api - API Endpoint Directive]


The `#api` directive creates RESTful API endpoints that automatically handle JSON serialization, deserialization, and HTTP response formatting.

## Basic Syntax

```tusk
# Simple API endpoint
#api /hello {
    message: "Hello, World!"
    # Automatically returns: {"message": "Hello, World!"}
}

# With explicit return
#api /users {
    users: @User.all()
    return users  # Returns JSON array of users
}

# Implicit JSON response
#api /status {
    # Last expression is returned as JSON
    {
        status: "online",
        timestamp: @now(),
        version: "1.0.0"
    }
}
```

## Route Parameters

```tusk
# Single parameter
#api /users/{id} {
    user: @User.find(@params.id)
    
    if (!user) {
        @response.status: 404
        return {error: "User not found"}
    }
    
    return user
}

# Multiple parameters
#api /posts/{year}/{month}/{day} {
    date: @params.year + "-" + @params.month + "-" + @params.day
    posts: @Post.whereDate("created_at", date).get()
    
    return {
        date: date,
        count: posts.length,
        posts: posts
    }
}

# Optional parameters
#api /search/{query}/{page?} {
    query: @params.query
    page: @params.page || 1
    
    results: @search(query, page)
    return results
}
```

## HTTP Methods

```tusk
# GET request (default)
#api /users {
    return @User.all()
}

# POST request
#api /users method: POST {
    # Access POST data via @request.post
    user_data: @request.post
    
    # Validate
    errors: @validate(user_data, {
        name: "required|string|max:255",
        email: "required|email|unique:users",
        password: "required|min:8"
    })
    
    if (errors) {
        @response.status: 422
        return {errors: errors}
    }
    
    # Create user
    user: @User.create(user_data)
    @response.status: 201
    
    return {
        message: "User created successfully",
        user: user
    }
}

# Multiple methods
#api /users/{id} method: [GET, PUT, DELETE] {
    switch (@request.method) {
        case "GET":
            return @User.find(@params.id)
            
        case "PUT":
            user: @User.find(@params.id)
            user.update(@request.post)
            return user
            
        case "DELETE":
            @User.destroy(@params.id)
            @response.status: 204
            return null
    }
}
```

## Request Handling

```tusk
# Access request data
#api /process {
    # Query parameters
    sort: @request.query.sort || "created_at"
    order: @request.query.order || "desc"
    
    # Headers
    auth_token: @request.headers.authorization
    content_type: @request.headers.content-type
    
    # POST/PUT data
    data: @request.post
    
    # Raw body
    raw_body: @request.body
    
    # Files
    uploaded_file: @request.files.document
    
    return {
        received: {
            query: @request.query,
            data: data,
            file: uploaded_file ? uploaded_file.name : null
        }
    }
}
```

## Response Control

```tusk
# Set status codes
#api /resource/{id} {
    resource: @Resource.find(@params.id)
    
    if (!resource) {
        @response.status: 404
        return {
            error: "Resource not found",
            id: @params.id
        }
    }
    
    @response.status: 200  # Default
    return resource
}

# Set headers
#api /download/{file} {
    file_path: @storage_path(@params.file)
    
    if (!@file_exists(file_path)) {
        @response.status: 404
        return {error: "File not found"}
    }
    
    @response.headers: {
        "Content-Type": "application/octet-stream",
        "Content-Disposition": `attachment; filename="${@params.file}"`,
        "Cache-Control": "no-cache"
    }
    
    return @file_get_contents(file_path)
}

# Custom response format
#api /custom {
    # Override JSON response
    @response.headers.content-type: "text/plain"
    @response.body: "Plain text response"
    @response.send()  # Bypass automatic JSON encoding
}
```

## Authentication

```tusk
# API authentication middleware
#api /protected middleware: [authenticate] {
    # @user is set by authenticate middleware
    return {
        message: "Welcome, " + @user.name,
        user: @user
    }
}

# Inline authentication
#api /admin/users {
    # Check authentication
    if (!@auth.check()) {
        @response.status: 401
        return {error: "Unauthenticated"}
    }
    
    # Check authorization
    if (!@auth.user.can("manage-users")) {
        @response.status: 403
        return {error: "Unauthorized"}
    }
    
    return @User.all()
}

# Token-based auth
#api /data {
    token: @request.headers.authorization?.replace("Bearer ", "")
    
    if (!token || !@verify_api_token(token)) {
        @response.status: 401
        return {error: "Invalid API token"}
    }
    
    return @get_sensitive_data()
}
```

## Validation

```tusk
# Input validation
#api /register method: POST {
    rules: {
        username: "required|alpha_num|min:3|max:20|unique:users",
        email: "required|email|unique:users",
        password: "required|min:8|confirmed",
        age: "required|integer|min:18",
        terms: "required|accepted"
    }
    
    validation: @validate(@request.post, rules)
    
    if (!validation.passes) {
        @response.status: 422
        return {
            message: "Validation failed",
            errors: validation.errors
        }
    }
    
    # Proceed with registration
    user: @User.create(validation.data)
    
    return {
        message: "Registration successful",
        user: user.only(["id", "username", "email"])
    }
}

# Custom validation
#api /booking method: POST {
    data: @request.post
    
    # Custom validation logic
    errors: {}
    
    if (data.start_date >= data.end_date) {
        errors.date: "End date must be after start date"
    }
    
    if (!@is_available(data.resource_id, data.start_date, data.end_date)) {
        errors.availability: "Resource not available for selected dates"
    }
    
    if (!@is_empty(errors)) {
        @response.status: 422
        return {errors: errors}
    }
    
    booking: @create_booking(data)
    return booking
}
```

## Pagination

```tusk
# Paginated responses
#api /posts {
    page: @request.query.page || 1
    per_page: @request.query.per_page || 20
    
    # Ensure reasonable limits
    per_page: @clamp(per_page, 1, 100)
    
    posts: @Post.paginate(per_page, page)
    
    return {
        data: posts.items,
        pagination: {
            current_page: posts.current_page,
            last_page: posts.last_page,
            per_page: posts.per_page,
            total: posts.total,
            from: posts.from,
            to: posts.to
        },
        links: {
            first: "/api/posts?page=1",
            last: "/api/posts?page=" + posts.last_page,
            prev: posts.prev_page_url,
            next: posts.next_page_url
        }
    }
}

# Cursor-based pagination
#api /feed {
    cursor: @request.query.cursor
    limit: @min(@request.query.limit || 20, 100)
    
    query: @Post.orderBy("created_at", "desc").limit(limit + 1)
    
    if (cursor) {
        query.where("created_at", "<", @decode_cursor(cursor))
    }
    
    posts: query.get()
    has_more: posts.length > limit
    
    if (has_more) {
        posts.pop()  # Remove extra item
    }
    
    return {
        data: posts,
        has_more: has_more,
        next_cursor: has_more ? @encode_cursor(posts.last().created_at) : null
    }
}
```

## Error Handling

```tusk
# Global API error handling
#api /risky {
    try {
        result: @risky_operation()
        return {success: true, data: result}
        
    } catch (ValidationException e) {
        @response.status: 422
        return {
            error: "Validation failed",
            details: e.errors
        }
        
    } catch (NotFoundException e) {
        @response.status: 404
        return {
            error: "Resource not found",
            resource: e.resource,
            id: e.id
        }
        
    } catch (Exception e) {
        @log.error("API error", {
            endpoint: @request.path,
            error: e.message,
            trace: e.trace
        })
        
        @response.status: 500
        return {
            error: "Internal server error",
            message: @env.debug ? e.message : "Something went wrong"
        }
    }
}

# Consistent error format
api_error: (message, code: 400, details: null) => {
    @response.status: code
    
    error: {
        message: message,
        code: code,
        timestamp: @timestamp()
    }
    
    if (details) {
        error.details: details
    }
    
    return error
}
```

## Rate Limiting

```tusk
# API rate limiting
#api /data middleware: [rate_limit:60,100] {
    # 100 requests per 60 minutes
    
    # Rate limit headers are automatically added:
    # X-RateLimit-Limit: 100
    # X-RateLimit-Remaining: 95
    # X-RateLimit-Reset: 1640000000
    
    return @get_data()
}

# Custom rate limiting
#api /expensive {
    key: @auth.user?.id || @request.ip
    limit: @auth.user ? 100 : 20  # Higher limit for authenticated
    
    if (!@rate_limiter.attempt(key, limit)) {
        @response.status: 429
        @response.headers["Retry-After"]: @rate_limiter.available_in(key)
        
        return {
            error: "Too many requests",
            retry_after: @rate_limiter.available_in(key)
        }
    }
    
    return @expensive_operation()
}
```

## API Versioning

```tusk
# Version in URL
#api /v1/users {
    # Version 1 implementation
    return @User.all(["id", "name", "email"])
}

#api /v2/users {
    # Version 2 with more fields
    return @User.all().map(user => {
        ...user,
        avatar_url: @storage_url(user.avatar),
        joined_date: user.created_at
    })
}

# Version in header
#api /users {
    version: @request.headers["api-version"] || "1.0"
    
    switch (version) {
        case "1.0":
            return @v1_response()
        case "2.0":
            return @v2_response()
        default:
            @response.status: 400
            return {error: "Unsupported API version"}
    }
}
```

## CORS Configuration

```tusk
# Enable CORS
#api /public middleware: [cors] {
    # CORS headers are automatically added
    return @public_data()
}

# Custom CORS settings
#api /data middleware: [cors:{origins:["https://app.example.com"],methods:["GET","POST"]}] {
    return @data()
}

# Manual CORS
#api /custom-cors {
    @response.headers: {
        "Access-Control-Allow-Origin": @request.headers.origin || "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
        "Access-Control-Max-Age": "86400"
    }
    
    if (@request.method == "OPTIONS") {
        @response.status: 204
        return null
    }
    
    return @data()
}
```

## Best Practices

1. **Use consistent response formats** - Standardize success and error responses
2. **Version your APIs** - Plan for backwards compatibility
3. **Implement proper authentication** - Secure sensitive endpoints
4. **Validate all inputs** - Never trust client data
5. **Handle errors gracefully** - Return meaningful error messages
6. **Use appropriate status codes** - Follow HTTP standards
7. **Document your APIs** - Include examples and schemas
8. **Rate limit endpoints** - Prevent abuse

## Related Topics

- `hash-web-directive` - Web page endpoints
- `hash-middleware-directive` - Request middleware
- `validation` - Input validation
- `authentication` - API authentication
- `rate-limiting` - Request throttling
---

[#web - Web Endpoint Directive]


The `#web` directive creates web endpoints for handling HTTP requests and rendering HTML responses, perfect for building web applications and sites.

## Basic Syntax

```tusk
# Simple web page
#web / {
    @render("home.tusk", {
        title: "Welcome",
        message: "Hello, World!"
    })
}

# Direct HTML response
#web /about {
    @response.body: """
    <html>
        <body>
            <h1>About Us</h1>
            <p>Welcome to our site!</p>
        </body>
    </html>
    """
}

# Dynamic content
#web /time {
    current_time: @date("Y-m-d H:i:s")
    @render("time.tusk", {time: current_time})
}
```

## Route Parameters

```tusk
# Single parameter
#web /user/{username} {
    user: @User.findBy("username", @params.username)
    
    if (!user) {
        @response.status: 404
        @render("errors/404.tusk", {
            message: "User not found"
        })
        return
    }
    
    @render("profile.tusk", {user: user})
}

# Multiple parameters
#web /blog/{year}/{month}/{slug} {
    post: @Post.where("year", @params.year)
                .where("month", @params.month)
                .where("slug", @params.slug)
                .first()
    
    @render("blog/post.tusk", {post: post})
}

# Optional parameters
#web /products/{category?} {
    products: @params.category 
        ? @Product.where("category", @params.category).get()
        : @Product.all()
    
    @render("products.tusk", {
        products: products,
        category: @params.category
    })
}

# Wildcard routes
#web /docs/{path*} {
    # Matches /docs/getting-started/installation
    doc_path: @params.path  # "getting-started/installation"
    @render_documentation(doc_path)
}
```

## HTTP Methods

```tusk
# GET request (default)
#web /contact {
    @render("contact-form.tusk")
}

# POST request
#web /contact method: POST {
    # Process form submission
    data: @request.post
    
    # Validate
    errors: @validate(data, {
        name: "required",
        email: "required|email",
        message: "required|min:10"
    })
    
    if (errors) {
        @render("contact-form.tusk", {
            errors: errors,
            old: data
        })
        return
    }
    
    # Send email
    @send_contact_email(data)
    
    # Redirect with success message
    @session.flash: "Thank you for your message!"
    @redirect("/contact")
}

# Multiple methods
#web /resource method: [GET, POST] {
    if (@request.method == "GET") {
        @render("form.tusk")
    } else {
        # Process POST
        @process_form(@request.post)
        @redirect("/success")
    }
}
```

## Templates and Rendering

```tusk
# Basic template rendering
#web /dashboard {
    user: @auth.user
    stats: @get_user_stats(user.id)
    
    @render("dashboard.tusk", {
        user: user,
        stats: stats,
        active_page: "dashboard"
    })
}

# Layout inheritance
#web /page {
    @render("pages/content.tusk", {
        layout: "layouts/main.tusk",
        title: "Page Title",
        content: @get_page_content()
    })
}

# Conditional rendering
#web /profile {
    if (!@auth.check()) {
        @redirect("/login")
        return
    }
    
    if (@auth.user.is_admin) {
        @render("admin/profile.tusk", {user: @auth.user})
    } else {
        @render("user/profile.tusk", {user: @auth.user})
    }
}

# Render with different engines
#web /markdown {
    content: @file.read("content.md")
    html: @markdown_to_html(content)
    
    @render("wrapper.tusk", {
        content: html,
        render_as_html: true
    })
}
```

## Form Handling

```tusk
# Display form
#web /register {
    @render("auth/register.tusk", {
        countries: @Country.all(),
        old: @session.old_input || {}
    })
}

# Process form submission
#web /register method: POST {
    data: @request.post
    
    # Validate
    validation: @validate(data, {
        username: "required|alpha_num|unique:users",
        email: "required|email|unique:users",
        password: "required|min:8|confirmed",
        country: "required|exists:countries,code"
    })
    
    if (!validation.passes) {
        @session.errors: validation.errors
        @session.old_input: data
        @redirect("/register")
        return
    }
    
    # Create user
    user: @User.create(validation.data)
    
    # Auto login
    @auth.login(user)
    
    # Redirect to dashboard
    @redirect("/dashboard")
}

# File upload form
#web /upload method: POST {
    file: @request.files.document
    
    if (!file) {
        @session.error: "Please select a file"
        @redirect("/upload-form")
        return
    }
    
    # Validate file
    if (!@in_array(file.extension, ["pdf", "doc", "docx"])) {
        @session.error: "Invalid file type"
        @redirect("/upload-form")
        return
    }
    
    # Store file
    path: @storage.put("documents", file)
    
    # Save to database
    @Document.create({
        name: file.name,
        path: path,
        size: file.size,
        user_id: @auth.id
    })
    
    @session.success: "File uploaded successfully"
    @redirect("/documents")
}
```

## Session and Cookies

```tusk
# Session management
#web /preferences method: POST {
    # Store in session
    @session.preferences: @request.post
    @session.flash("success", "Preferences updated")
    
    @redirect("/settings")
}

# Flash messages
#web /settings {
    @render("settings.tusk", {
        preferences: @session.preferences || @default_preferences(),
        flash: @session.pull("flash")  # Get and remove
    })
}

# Cookie handling
#web /theme/{theme} {
    if (@in_array(@params.theme, ["light", "dark", "auto"])) {
        @cookie.set("theme", @params.theme, {
            expires: 365 * 24 * 60 * 60,  # 1 year
            path: "/",
            secure: true,
            httponly: true
        })
    }
    
    @redirect(@request.headers.referer || "/")
}
```

## Authentication

```tusk
# Login page
#web /login {
    if (@auth.check()) {
        @redirect("/dashboard")
        return
    }
    
    @render("auth/login.tusk", {
        error: @session.pull("error"),
        intended: @session.get("url.intended")
    })
}

# Login processing
#web /login method: POST {
    credentials: {
        email: @request.post.email,
        password: @request.post.password
    }
    
    if (@auth.attempt(credentials, @request.post.remember)) {
        # Regenerate session
        @session.regenerate()
        
        # Redirect to intended URL or dashboard
        intended: @session.pull("url.intended", "/dashboard")
        @redirect(intended)
    } else {
        @session.flash("error", "Invalid credentials")
        @redirect("/login")
    }
}

# Protected routes
#web /admin/* middleware: [auth, admin] {
    # All /admin/* routes require authentication and admin role
    @handle_admin_request()
}

# Logout
#web /logout method: POST {
    @auth.logout()
    @session.invalidate()
    @redirect("/")
}
```

## Static Assets

```tusk
# Serve static files
#web /assets/{file*} {
    file_path: @public_path("assets/" + @params.file)
    
    if (!@file.exists(file_path)) {
        @response.status: 404
        return
    }
    
    # Set appropriate headers
    mime_type: @mime_type(file_path)
    @response.headers: {
        "Content-Type": mime_type,
        "Cache-Control": "public, max-age=31536000",
        "ETag": @md5_file(file_path)
    }
    
    # Check if not modified
    if (@request.headers["if-none-match"] == @response.headers.ETag) {
        @response.status: 304
        return
    }
    
    @response.body: @file.read(file_path)
}

# Asset versioning
#web /build/{hash}/{file*} {
    # Strip hash from URL and serve file
    @serve_static("build/" + @params.file, {
        cache: "1 year",
        immutable: true
    })
}
```

## AJAX Handling

```tusk
# Detect AJAX requests
#web /content/{section} {
    content: @get_section_content(@params.section)
    
    if (@request.is_ajax()) {
        # Return just the content for AJAX
        @response.body: content
    } else {
        # Return full page for regular requests
        @render("layout.tusk", {
            content: content,
            section: @params.section
        })
    }
}

# JSON responses for AJAX
#web /search {
    query: @request.query.q
    
    if (@request.wants_json()) {
        results: @search(query)
        @json(results)
    } else {
        @render("search.tusk", {
            query: query,
            results: @search(query)
        })
    }
}
```

## Error Handling

```tusk
# Custom error pages
#web /error/{code} {
    @response.status: @params.code
    
    @render("errors/" + @params.code + ".tusk", {
        message: @get_error_message(@params.code)
    })
}

# 404 handler
#web * {
    # Catch-all route (must be last)
    @response.status: 404
    @render("errors/404.tusk", {
        path: @request.path
    })
}

# Error handling in routes
#web /risky {
    try {
        data: @risky_operation()
        @render("success.tusk", {data: data})
        
    } catch (Exception e) {
        @log.error("Route error", {
            path: @request.path,
            error: e.message
        })
        
        @response.status: 500
        @render("errors/500.tusk", {
            message: @env.debug ? e.message : "Something went wrong"
        })
    }
}
```

## Middleware

```tusk
# Apply middleware to routes
#web /account/* middleware: [auth, verified] {
    # All account routes require auth and email verification
}

# Inline middleware logic
#web /premium {
    # Check subscription
    if (!@auth.check() || !@auth.user.has_active_subscription()) {
        @session.put("url.intended", @request.url)
        @redirect("/subscribe")
        return
    }
    
    @render("premium/content.tusk")
}

# Group middleware
#group middleware: [web, auth] {
    #web /dashboard {
        @render("dashboard.tusk")
    }
    
    #web /profile {
        @render("profile.tusk")
    }
}
```

## Response Types

```tusk
# HTML response (default)
#web /page {
    @render("page.tusk")
}

# File download
#web /download/{file} {
    file_path: @storage_path("downloads/" + @params.file)
    
    if (!@file.exists(file_path)) {
        abort(404)
    }
    
    @response.download(file_path, "document.pdf")
}

# Streaming response
#web /stream {
    @response.stream(() => {
        for (i: 0; i < 100; i++) {
            @response.write("Data chunk " + i + "\n")
            @flush()
            @sleep(0.1)
        }
    })
}

# Redirect response
#web /old-page {
    @redirect("/new-page", 301)  # Permanent redirect
}
```

## Best Practices

1. **Use semantic routes** - Make URLs meaningful and RESTful
2. **Validate all input** - Never trust user input
3. **Handle errors gracefully** - Provide helpful error pages
4. **Use CSRF protection** - Protect against cross-site attacks
5. **Implement proper authentication** - Secure sensitive pages
6. **Cache when possible** - Improve performance
7. **Follow PRG pattern** - POST-Redirect-GET for forms
8. **Use middleware** - Keep routes clean

## Related Topics

- `hash-api-directive` - API endpoints
- `templates` - Template rendering
- `forms` - Form handling
- `authentication` - User authentication
- `middleware` - Request middleware
---

[#cli - Command Line Interface Directive]


The `#cli` directive creates command-line interface commands for your TuskLang applications, enabling scripts, tools, and automation.

## Basic Syntax

```tusk
# Simple command
#cli hello {
    @output("Hello, World!")
}

# Run with: tusk hello

# Command with logic
#cli greet {
    name: @args[1] || "User"
    @output("Hello, " + name + "!")
}

# Run with: tusk greet John
```

## Command Arguments

```tusk
# Positional arguments
#cli deploy {
    environment: @args[1]
    version: @args[2] || "latest"
    
    if (!environment) {
        @error("Environment required: tusk deploy <environment> [version]")
        @exit(1)
    }
    
    @output("Deploying " + version + " to " + environment)
    @deploy_application(environment, version)
}

# Named command structure
#cli user:create {
    # Command: tusk user:create john@example.com "John Doe"
    email: @args[1]
    name: @args[2]
    
    if (!email || !name) {
        @error("Usage: tusk user:create <email> <name>")
        @exit(1)
    }
    
    user: @User.create({
        email: email,
        name: name,
        password: @generate_temp_password()
    })
    
    @success("User created with ID: " + user.id)
}

# Variable arguments
#cli concat {
    # Accepts any number of arguments
    result: @args.slice(1).join(" ")
    @output(result)
}
```

## Command Options

```tusk
# Options and flags
#cli migrate {
    # Parse options
    options: @parse_options({
        # Long and short options
        "force|f": "boolean",
        "step|s": "number",
        "seed": "boolean",
        "rollback|r": "boolean"
    })
    
    if (options.rollback) {
        steps: options.step || 1
        @output("Rolling back " + steps + " migration(s)...")
        @rollback_migrations(steps)
    } else {
        @output("Running migrations...")
        @run_migrations(options.force)
        
        if (options.seed) {
            @output("Seeding database...")
            @seed_database()
        }
    }
}

# Run with:
# tusk migrate
# tusk migrate --force --seed
# tusk migrate --rollback --step=3
# tusk migrate -r -s 3

# Complex options
#cli backup {
    options: @parse_options({
        "database|d": "string",
        "output|o": "string",
        "compress|c": "boolean",
        "exclude": "array",
        "include": "array",
        "quiet|q": "boolean",
        "verbose|v": "boolean"
    })
    
    # Set defaults
    database: options.database || @env.DB_DATABASE
    output: options.output || "backup_" + @date("Y-m-d_H-i-s") + ".sql"
    
    if (!options.quiet) {
        @output("Backing up database: " + database)
    }
    
    # Perform backup
    @backup_database(database, output, options)
    
    if (options.compress) {
        @compress_file(output)
        output += ".gz"
    }
    
    if (!options.quiet) {
        @success("Backup completed: " + output)
    }
}
```

## Interactive Commands

```tusk
# User input
#cli setup {
    @output("Welcome to TuskLang Setup")
    @output("=" * 30)
    
    # Ask questions
    app_name: @ask("Application name:")
    db_type: @choice("Database type:", ["mysql", "postgresql", "sqlite"])
    
    if (db_type != "sqlite") {
        db_host: @ask("Database host:", "localhost")
        db_name: @ask("Database name:")
        db_user: @ask("Database username:")
        db_pass: @secret("Database password:")
    }
    
    # Confirmation
    if (@confirm("Create application with these settings?")) {
        @create_application({
            name: app_name,
            database: {
                type: db_type,
                host: db_host,
                name: db_name,
                user: db_user,
                pass: db_pass
            }
        })
        
        @success("Application created successfully!")
    } else {
        @info("Setup cancelled")
    }
}

# Menu selection
#cli manage {
    action: @menu("What would you like to do?", {
        "1": "Clear cache",
        "2": "Run maintenance",
        "3": "View logs",
        "4": "Exit"
    })
    
    switch (action) {
        case "1":
            @clear_cache()
        case "2":
            @run_maintenance()
        case "3":
            @view_logs()
        case "4":
            @exit(0)
    }
}
```

## Output Formatting

```tusk
# Colored output
#cli status {
    @info("Checking system status...")
    
    services: [
        {name: "Database", status: @check_database()},
        {name: "Cache", status: @check_cache()},
        {name: "Queue", status: @check_queue()}
    ]
    
    @output("")  # Empty line
    @output("Service Status:")
    @output("-" * 20)
    
    for (service in services) {
        if (service.status) {
            @success("✓ " + service.name + ": Online")
        } else {
            @error("✗ " + service.name + ": Offline")
        }
    }
}

# Table output
#cli users:list {
    users: @User.all()
    
    @table(users, ["ID", "Name", "Email", "Created"], (user) => [
        user.id,
        user.name,
        user.email,
        user.created_at.format("Y-m-d")
    ])
}

# Progress bar
#cli import {
    file: @args[1]
    
    if (!file) {
        @error("Usage: tusk import <file>")
        @exit(1)
    }
    
    rows: @read_csv(file)
    total: rows.length
    
    @progress_start(total, "Importing records")
    
    for (i, row in rows) {
        @import_record(row)
        @progress_advance()
        
        # Update message every 10 records
        if (i % 10 == 0) {
            @progress_message("Processing: " + row.name)
        }
    }
    
    @progress_finish()
    @success("Imported " + total + " records")
}
```

## File Operations

```tusk
# File processing command
#cli process:files {
    options: @parse_options({
        "input|i": "string",
        "output|o": "string",
        "format|f": "string",
        "recursive|r": "boolean"
    })
    
    input_dir: options.input || "."
    output_dir: options.output || "processed"
    format: options.format || "json"
    
    # Find files
    files: @find_files(input_dir, {
        pattern: "*.csv",
        recursive: options.recursive
    })
    
    if (files.length == 0) {
        @warning("No files found")
        @exit(0)
    }
    
    @info("Found " + files.length + " files to process")
    
    # Process each file
    for (file in files) {
        @output("Processing: " + file)
        
        try {
            data: @read_csv(file)
            output_file: @path.join(output_dir, 
                @path.basename(file, ".csv") + "." + format)
            
            switch (format) {
                case "json":
                    @file.write_json(output_file, data)
                case "xml":
                    @file.write_xml(output_file, data)
                default:
                    @error("Unknown format: " + format)
            }
            
            @success("✓ Saved: " + output_file)
            
        } catch (e) {
            @error("✗ Failed: " + e.message)
        }
    }
}
```

## Background Jobs

```tusk
# Queue worker command
#cli queue:work {
    options: @parse_options({
        "queue": "string",
        "timeout": "number",
        "sleep": "number",
        "tries": "number",
        "daemon": "boolean"
    })
    
    queue_name: options.queue || "default"
    timeout: options.timeout || 60
    sleep: options.sleep || 3
    max_tries: options.tries || 3
    
    @info("Starting queue worker for: " + queue_name)
    
    # Handle signals
    @signal("SIGINT", () => {
        @info("Shutting down gracefully...")
        @exit(0)
    })
    
    while (true) {
        job: @queue.pop(queue_name)
        
        if (job) {
            @info("Processing job: " + job.id)
            
            try {
                @timeout(timeout, () => {
                    @process_job(job)
                })
                
                @success("Job completed: " + job.id)
                
            } catch (e) {
                @error("Job failed: " + job.id + " - " + e.message)
                
                if (job.attempts < max_tries) {
                    @queue.retry(job)
                } else {
                    @queue.failed(job, e)
                }
            }
        } else {
            if (!options.daemon) {
                break
            }
            @sleep(sleep)
        }
    }
}
```

## Scheduling

```tusk
# Scheduler command
#cli schedule:run {
    @info("Running scheduled tasks...")
    
    tasks: @get_scheduled_tasks()
    current_time: @now()
    
    for (task in tasks) {
        if (@should_run(task, current_time)) {
            @output("Running: " + task.name)
            
            try {
                @run_task(task)
                @update_last_run(task, current_time)
                @success("✓ " + task.name + " completed")
                
            } catch (e) {
                @error("✗ " + task.name + " failed: " + e.message)
                @log_task_failure(task, e)
            }
        }
    }
    
    @info("Scheduler run completed")
}

# This would typically be run by system cron:
# * * * * * tusk schedule:run
```

## Testing Commands

```tusk
# Run tests
#cli test {
    options: @parse_options({
        "filter": "string",
        "coverage": "boolean",
        "verbose|v": "boolean",
        "stop-on-failure": "boolean"
    })
    
    @output("TuskLang Test Runner")
    @output("=" * 40)
    
    # Find test files
    test_files: @find_files("tests", {
        pattern: "*Test.tusk",
        recursive: true
    })
    
    if (options.filter) {
        test_files: test_files.filter(f => f.includes(options.filter))
    }
    
    # Run tests
    results: {
        passed: 0,
        failed: 0,
        skipped: 0
    }
    
    for (file in test_files) {
        @output("\nRunning: " + file)
        
        result: @run_test_file(file, options)
        results.passed += result.passed
        results.failed += result.failed
        results.skipped += result.skipped
        
        if (result.failed > 0 && options["stop-on-failure"]) {
            break
        }
    }
    
    # Summary
    @output("\n" + "=" * 40)
    @success("Passed: " + results.passed)
    if (results.failed > 0) {
        @error("Failed: " + results.failed)
    }
    if (results.skipped > 0) {
        @warning("Skipped: " + results.skipped)
    }
    
    if (options.coverage) {
        @output("\nCode Coverage: " + @calculate_coverage() + "%")
    }
    
    @exit(results.failed > 0 ? 1 : 0)
}
```

## Command Composition

```tusk
# Main command with subcommands
#cli db {
    subcommand: @args[1]
    
    if (!subcommand) {
        @output("Database management commands:")
        @output("  db:create     Create database")
        @output("  db:drop       Drop database")
        @output("  db:migrate    Run migrations")
        @output("  db:seed       Seed database")
        @output("  db:backup     Backup database")
        @exit(0)
    }
    
    # Remove subcommand from args
    @args: @args.slice(1)
    
    switch (subcommand) {
        case "create":
            @call_command("db:create")
        case "drop":
            @call_command("db:drop")
        case "migrate":
            @call_command("migrate")
        case "seed":
            @call_command("db:seed")
        case "backup":
            @call_command("backup")
        default:
            @error("Unknown subcommand: " + subcommand)
            @exit(1)
    }
}

# Individual subcommands
#cli db:create {
    name: @args[1] || @env.DB_DATABASE
    
    if (@confirm("Create database '" + name + "'?")) {
        @create_database(name)
        @success("Database created: " + name)
    }
}
```

## Best Practices

1. **Provide help text** - Make commands self-documenting
2. **Validate arguments** - Check required parameters
3. **Use consistent naming** - Follow conventions (noun:verb)
4. **Handle errors gracefully** - Provide helpful error messages
5. **Add confirmation prompts** - For destructive operations
6. **Use appropriate exit codes** - 0 for success, non-zero for errors
7. **Support common options** - --help, --verbose, --quiet
8. **Make commands idempotent** - Safe to run multiple times

## Related Topics

- `hash-cron-directive` - Scheduled tasks
- `console-output` - Terminal formatting
- `process-management` - Background processes
- `file-operations` - File handling
- `database-operations` - Database commands
---

[#cron - Scheduled Task Directive]


The `#cron` directive creates scheduled tasks that run automatically at specified intervals, perfect for maintenance, cleanup, notifications, and recurring jobs.

## Basic Syntax

```tusk
# Run every minute
#cron "* * * * *" {
    @log("Task runs every minute")
}

# Run daily at midnight
#cron "0 0 * * *" {
    @cleanup_old_logs()
}

# Named cron job
#cron "0 2 * * *" name: "daily_backup" {
    @backup_database()
    @notify_admin("Backup completed")
}
```

## Cron Expression Format

```tusk
# Cron expression: "minute hour day month weekday"
# ┌───────────── minute (0-59)
# │ ┌───────────── hour (0-23)
# │ │ ┌───────────── day of month (1-31)
# │ │ │ ┌───────────── month (1-12)
# │ │ │ │ ┌───────────── day of week (0-7, Sunday=0 or 7)
# │ │ │ │ │
# * * * * *

# Examples:
#cron "0 0 * * *"      # Daily at midnight
#cron "*/5 * * * *"    # Every 5 minutes
#cron "0 */2 * * *"    # Every 2 hours
#cron "0 9 * * 1-5"    # Weekdays at 9 AM
#cron "0 0 1 * *"      # First day of month
#cron "0 0 * * 0"      # Every Sunday
```

## Common Schedules

```tusk
# Every minute
#cron "* * * * *" {
    @process_queue()
}

# Every 5 minutes
#cron "*/5 * * * *" {
    @check_health()
}

# Every hour on the hour
#cron "0 * * * *" {
    @generate_hourly_report()
}

# Every day at 3:30 AM
#cron "30 3 * * *" {
    @run_daily_maintenance()
}

# Every Monday at 9 AM
#cron "0 9 * * 1" {
    @send_weekly_newsletter()
}

# First day of month at noon
#cron "0 12 1 * *" {
    @generate_monthly_invoices()
}

# Every weekday at 6 PM
#cron "0 18 * * 1-5" {
    @send_daily_summary()
}

# Multiple times per day
#cron "0 9,12,15,18 * * *" {
    @sync_data()  # Runs at 9 AM, noon, 3 PM, and 6 PM
}
```

## Task Context

```tusk
# Access cron context
#cron "0 * * * *" name: "hourly_stats" {
    # Available context variables
    current_run: @cron.current_run      # Current execution time
    last_run: @cron.last_run           # Previous execution time
    next_run: @cron.next_run           # Next scheduled time
    job_name: @cron.name               # "hourly_stats"
    schedule: @cron.schedule           # "0 * * * *"
    
    @log("Job " + job_name + " started at " + current_run)
    
    # Calculate time since last run
    if (last_run) {
        duration: current_run - last_run
        @log("Time since last run: " + duration + " seconds")
    }
    
    # Do work
    @calculate_hourly_statistics()
}
```

## Preventing Overlaps

```tusk
# Single instance lock
#cron "*/5 * * * *" name: "data_sync" {
    # Acquire lock
    if (!@cron.lock()) {
        @log("Previous instance still running, skipping")
        return
    }
    
    try {
        # Long-running task
        @sync_large_dataset()
    } finally {
        # Always release lock
        @cron.unlock()
    }
}

# With timeout
#cron "0 * * * *" name: "hourly_process" {
    # Try to acquire lock with 5-minute timeout
    if (!@cron.lock(300)) {
        @alert("Hourly process stuck, could not acquire lock")
        return
    }
    
    try {
        @process_hourly_data()
    } finally {
        @cron.unlock()
    }
}

# Using Redis for distributed locking
#cron "*/10 * * * *" {
    lock_key: "cron:import_data"
    lock_ttl: 600  # 10 minutes
    
    if (!@redis.set(lock_key, @server_id, "NX", "EX", lock_ttl)) {
        @log("Another server is running this job")
        return
    }
    
    try {
        @import_external_data()
    } finally {
        @redis.del(lock_key)
    }
}
```

## Error Handling

```tusk
# Basic error handling
#cron "0 2 * * *" name: "daily_cleanup" {
    try {
        @cleanup_old_files()
        @optimize_database()
        @clear_cache()
        
        @log("Daily cleanup completed successfully")
        
    } catch (Exception e) {
        @log.error("Daily cleanup failed", {
            error: e.message,
            trace: e.trace
        })
        
        @notify_admin("Cron job failed: daily_cleanup", e)
    }
}

# Retry logic
#cron "*/30 * * * *" name: "api_sync" {
    max_retries: 3
    retry_count: 0
    
    while (retry_count < max_retries) {
        try {
            @sync_with_external_api()
            @log("API sync successful")
            break
            
        } catch (NetworkException e) {
            retry_count++
            @log.warning("API sync failed, attempt " + retry_count)
            
            if (retry_count < max_retries) {
                @sleep(60 * retry_count)  # Exponential backoff
            } else {
                @alert("API sync failed after " + max_retries + " attempts")
            }
        }
    }
}
```

## Database Maintenance

```tusk
# Daily database optimization
#cron "0 3 * * *" name: "db_maintenance" {
    @log("Starting database maintenance")
    
    # Clean old records
    deleted: @query("
        DELETE FROM logs 
        WHERE created_at < DATE_SUB(NOW(), INTERVAL 90 DAY)
    ").affected_rows()
    
    @log("Deleted " + deleted + " old log entries")
    
    # Optimize tables
    tables: ["users", "posts", "comments", "logs"]
    for (table in tables) {
        @query("OPTIMIZE TABLE " + table)
        @log("Optimized table: " + table)
    }
    
    # Update statistics
    @query("ANALYZE TABLE " + tables.join(", "))
    
    # Clean orphaned records
    @clean_orphaned_records()
    
    @log("Database maintenance completed")
}

# Backup database
#cron "0 4 * * *" name: "db_backup" {
    backup_file: "backup_" + @date("Y-m-d") + ".sql"
    
    # Create backup
    success: @exec("mysqldump -u {user} -p{pass} {db} > {file}", {
        user: @env.DB_USERNAME,
        pass: @env.DB_PASSWORD,
        db: @env.DB_DATABASE,
        file: @storage_path("backups/" + backup_file)
    })
    
    if (success) {
        # Compress backup
        @exec("gzip " + @storage_path("backups/" + backup_file))
        
        # Upload to S3
        @s3.upload(
            @storage_path("backups/" + backup_file + ".gz"),
            "backups/" + backup_file + ".gz"
        )
        
        # Keep only last 7 local backups
        @cleanup_old_backups(7)
        
        @log("Backup completed: " + backup_file)
    } else {
        @alert("Database backup failed!")
    }
}
```

## Reports and Notifications

```tusk
# Daily report generation
#cron "0 8 * * *" name: "daily_report" {
    yesterday: @date("Y-m-d", @strtotime("-1 day"))
    
    # Gather metrics
    metrics: {
        new_users: @User.whereDate("created_at", yesterday).count(),
        orders: @Order.whereDate("created_at", yesterday).count(),
        revenue: @Order.whereDate("created_at", yesterday).sum("total"),
        page_views: @Analytics.getPageViews(yesterday),
        bounce_rate: @Analytics.getBounceRate(yesterday)
    }
    
    # Generate report
    report_html: @render("emails/daily_report.tusk", {
        date: yesterday,
        metrics: metrics
    })
    
    # Send to admins
    admins: @User.where("role", "admin").get()
    for (admin in admins) {
        @email.send({
            to: admin.email,
            subject: "Daily Report - " + yesterday,
            html: report_html
        })
    }
    
    @log("Daily report sent to " + admins.length + " admins")
}

# Weekly digest
#cron "0 9 * * 1" name: "weekly_digest" {
    # Every Monday at 9 AM
    users: @User.where("receive_digest", true).get()
    
    for (user in users) {
        digest: @generate_user_digest(user, "week")
        
        @email.queue({
            to: user.email,
            subject: "Your Weekly Digest",
            template: "digest",
            data: digest
        })
    }
    
    @log("Queued " + users.length + " weekly digests")
}
```

## Cache Management

```tusk
# Clear expired cache
#cron "*/15 * * * *" name: "cache_cleanup" {
    # Clear expired cache entries
    expired: @cache.clear_expired()
    @log("Cleared " + expired + " expired cache entries")
    
    # Warm critical cache
    @cache.warm([
        "homepage_data",
        "navigation_menu",
        "featured_products"
    ])
}

# Rebuild cache
#cron "0 5 * * *" name: "cache_rebuild" {
    @log("Starting cache rebuild")
    
    # Clear all cache
    @cache.flush()
    
    # Rebuild essential caches
    caches: [
        {key: "categories", builder: @build_category_cache},
        {key: "products:featured", builder: @build_featured_products},
        {key: "stats:global", builder: @calculate_global_stats}
    ]
    
    for (cache in caches) {
        data: cache.builder()
        @cache.forever(cache.key, data)
        @log("Rebuilt cache: " + cache.key)
    }
}
```

## Queue Processing

```tusk
# Process failed jobs
#cron "0 * * * *" name: "retry_failed_jobs" {
    failed_jobs: @queue.failed()
    
    for (job in failed_jobs) {
        if (job.attempts < 3 && @should_retry(job)) {
            @queue.retry(job)
            @log("Retrying failed job: " + job.id)
        } else if (job.failed_at < @strtotime("-7 days")) {
            @queue.forget(job)
            @log("Removed old failed job: " + job.id)
        }
    }
}

# Monitor queue health
#cron "*/5 * * * *" name: "queue_monitor" {
    queues: ["default", "emails", "notifications"]
    
    for (queue_name in queues) {
        size: @queue.size(queue_name)
        
        if (size > 1000) {
            @alert("Queue " + queue_name + " has " + size + " pending jobs!")
        }
        
        # Start more workers if needed
        if (size > 500) {
            current_workers: @queue.workers(queue_name)
            if (current_workers < 5) {
                @scale_queue_workers(queue_name, 5)
            }
        }
    }
}
```

## System Monitoring

```tusk
# Health check
#cron "*/5 * * * *" name: "health_check" {
    checks: [
        {name: "Database", check: @check_database_connection},
        {name: "Redis", check: @check_redis_connection},
        {name: "Storage", check: @check_storage_space},
        {name: "Memory", check: @check_memory_usage},
        {name: "API", check: @check_external_api}
    ]
    
    failures: []
    
    for (service in checks) {
        if (!service.check()) {
            failures[] = service.name
            @log.error(service.name + " health check failed")
        }
    }
    
    if (failures.length > 0) {
        @alert("Health check failures: " + failures.join(", "))
        
        # Update status page
        @update_status_page(failures)
    }
}

# Disk space monitoring
#cron "0 * * * *" name: "disk_monitor" {
    threshold: 90  # Alert at 90% usage
    
    partitions: @get_disk_partitions()
    
    for (partition in partitions) {
        usage: @get_disk_usage(partition)
        
        if (usage.percent > threshold) {
            @alert("Disk space critical on " + partition, {
                used: usage.used_human,
                free: usage.free_human,
                percent: usage.percent
            })
            
            # Try to free space
            @cleanup_temp_files()
            @rotate_logs()
        }
    }
}
```

## Conditional Execution

```tusk
# Environment-specific crons
#cron "0 1 * * *" if: @env.APP_ENV == "production" {
    # Only runs in production
    @generate_analytics_report()
}

# Feature flag controlled
#cron "*/10 * * * *" if: @feature_enabled("auto_import") {
    @import_external_data()
}

# Dynamic scheduling
#cron "0 0 * * *" {
    # Check if should run today
    if (@is_holiday()) {
        @log("Skipping - today is a holiday")
        return
    }
    
    if (@is_weekend() && !@env.RUN_WEEKENDS) {
        @log("Skipping - weekend processing disabled")
        return
    }
    
    @process_daily_batch()
}
```

## Best Practices

1. **Use descriptive names** - Make cron jobs identifiable
2. **Add logging** - Track execution and results
3. **Prevent overlaps** - Use locking for long-running tasks
4. **Handle errors gracefully** - Don't let crons fail silently
5. **Monitor execution** - Track if crons are running as expected
6. **Set appropriate schedules** - Don't run more often than needed
7. **Consider timezones** - Crons run in server timezone
8. **Test thoroughly** - Cron errors can go unnoticed

## Related Topics

- `hash-cli-directive` - Command-line interface
- `queue-jobs` - Background job processing
- `task-scheduling` - Advanced scheduling
- `monitoring` - System monitoring
- `notifications` - Alert systems
---

[#middleware - Request Middleware Directive]


The `#middleware` directive creates reusable request processing logic that runs before your main handlers, perfect for authentication, logging, validation, and request transformation.

## Basic Syntax

```tusk
# Define middleware
#middleware auth {
    if (!@session.user_id) {
        @redirect("/login")
        return false  # Stop processing
    }
    
    # Set user context
    @request.user: @User.find(@session.user_id)
    return true  # Continue to next middleware/handler
}

# Use middleware in routes
#web /dashboard middleware: [auth] {
    # This only runs if auth middleware passes
    @render("dashboard.tusk", {user: @request.user})
}
```

## Middleware Flow

```tusk
# Middleware execution order
#middleware first {
    @log("First middleware - before")
    
    # Call next middleware/handler
    result: @next()
    
    @log("First middleware - after")
    return result
}

#middleware second {
    @log("Second middleware - before")
    result: @next()
    @log("Second middleware - after")
    return result
}

#web /test middleware: [first, second] {
    @log("Main handler")
    return "Done"
}

# Output order:
# First middleware - before
# Second middleware - before  
# Main handler
# Second middleware - after
# First middleware - after
```

## Request Modification

```tusk
# Add data to request
#middleware add_metadata {
    @request.request_id: @generate_uuid()
    @request.start_time: @microtime(true)
    @request.ip: @get_real_ip()
    
    # Add to all views
    @view.share({
        app_name: @config.app.name,
        user: @request.user,
        csrf_token: @csrf_token()
    })
    
    @next()
}

# Transform request data
#middleware sanitize_input {
    # Sanitize all input
    if (@request.method == "POST" || @request.method == "PUT") {
        @request.post: @sanitize_data(@request.post)
    }
    
    @request.query: @sanitize_data(@request.query)
    
    @next()
}

sanitize_data: (data) => {
    if (is_array(data)) {
        return data.map(item => @sanitize_data(item))
    } else if (is_object(data)) {
        result: {}
        for (key, value in data) {
            result[key]: @sanitize_data(value)
        }
        return result
    } else if (is_string(data)) {
        return @strip_tags(@trim(data))
    }
    return data
}
```

## Response Modification

```tusk
# Modify response headers
#middleware security_headers {
    # Process request
    @next()
    
    # Add security headers to response
    @response.headers["X-Content-Type-Options"]: "nosniff"
    @response.headers["X-Frame-Options"]: "SAMEORIGIN"
    @response.headers["X-XSS-Protection"]: "1; mode=block"
    @response.headers["Referrer-Policy"]: "strict-origin-when-cross-origin"
    
    if (@request.secure) {
        @response.headers["Strict-Transport-Security"]: 
            "max-age=31536000; includeSubDomains"
    }
}

# Compress response
#middleware compression {
    # Check if client accepts gzip
    accept_encoding: @request.headers["accept-encoding"] || ""
    
    if (!accept_encoding.includes("gzip")) {
        return @next()
    }
    
    # Process request
    @next()
    
    # Compress response body
    if (@response.body && @strlen(@response.body) > 1024) {
        compressed: @gzencode(@response.body, 6)
        @response.body: compressed
        @response.headers["Content-Encoding"]: "gzip"
        @response.headers["Vary"]: "Accept-Encoding"
    }
}
```

## Authentication Middleware

```tusk
# Basic authentication
#middleware auth {
    # Check session
    if (!@session.user_id) {
        # Check remember me cookie
        remember_token: @cookie.remember_me
        
        if (remember_token) {
            user: @validate_remember_token(remember_token)
            if (user) {
                @session.user_id: user.id
                @request.user: user
                return @next()
            }
        }
        
        # Not authenticated
        @session.intended_url: @request.url
        @redirect("/login")
        return false
    }
    
    # Load user
    @request.user: @User.find(@session.user_id)
    
    if (!@request.user) {
        @session.forget("user_id")
        @redirect("/login")
        return false
    }
    
    @next()
}

# Role-based access
#middleware role {
    required_role: @params.role || "user"
    
    if (!@request.user) {
        @response.status: 401
        return @json({error: "Unauthenticated"})
    }
    
    if (!@request.user.hasRole(required_role)) {
        @response.status: 403
        return @json({error: "Insufficient permissions"})
    }
    
    @next()
}

# API token authentication
#middleware api_auth {
    token: @request.headers.authorization?.replace("Bearer ", "")
    
    if (!token) {
        @response.status: 401
        return @json({error: "No token provided"})
    }
    
    # Validate token
    payload: @validate_jwt(token)
    
    if (!payload) {
        @response.status: 401
        return @json({error: "Invalid token"})
    }
    
    # Set user context
    @request.user: @User.find(payload.user_id)
    @request.token: payload
    
    @next()
}
```

## Rate Limiting

```tusk
# Rate limiting middleware
#middleware rate_limit {
    # Get limits from params or defaults
    max_attempts: @params.attempts || 60
    decay_minutes: @params.decay || 1
    
    # Generate key
    key: "rate_limit:" + @request.ip + ":" + @request.path
    
    # Check attempts
    attempts: @cache.get(key, 0)
    
    if (attempts >= max_attempts) {
        @response.status: 429
        @response.headers["Retry-After"]: decay_minutes * 60
        @response.headers["X-RateLimit-Limit"]: max_attempts
        @response.headers["X-RateLimit-Remaining"]: 0
        
        return @json({
            error: "Too many requests",
            retry_after: decay_minutes * 60
        })
    }
    
    # Increment attempts
    @cache.increment(key, 1, decay_minutes * 60)
    
    # Add headers
    @response.headers["X-RateLimit-Limit"]: max_attempts
    @response.headers["X-RateLimit-Remaining"]: max_attempts - attempts - 1
    
    @next()
}

# Per-user rate limiting
#middleware user_rate_limit {
    if (!@request.user) {
        return @next()  # Skip for non-authenticated
    }
    
    key: "user_rate:" + @request.user.id + ":" + @request.path
    limit: @request.user.isPremium() ? 1000 : 100
    
    attempts: @cache.get(key, 0)
    
    if (attempts >= limit) {
        @response.status: 429
        return @json({error: "Rate limit exceeded for user"})
    }
    
    @cache.increment(key, 1, 3600)  # 1 hour window
    @next()
}
```

## CORS Middleware

```tusk
# CORS handling
#middleware cors {
    origin: @request.headers.origin
    
    # Configure allowed origins
    allowed_origins: @params.origins || ["*"]
    allowed_methods: @params.methods || ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
    allowed_headers: @params.headers || ["Content-Type", "Authorization"]
    max_age: @params.max_age || 86400
    
    # Check origin
    if (allowed_origins[0] != "*" && !allowed_origins.includes(origin)) {
        return @next()  # Don't add CORS headers
    }
    
    # Set CORS headers
    @response.headers["Access-Control-Allow-Origin"]: 
        allowed_origins[0] == "*" ? "*" : origin
    @response.headers["Access-Control-Allow-Methods"]: 
        allowed_methods.join(", ")
    @response.headers["Access-Control-Allow-Headers"]: 
        allowed_headers.join(", ")
    @response.headers["Access-Control-Max-Age"]: max_age
    @response.headers["Access-Control-Allow-Credentials"]: "true"
    
    # Handle preflight
    if (@request.method == "OPTIONS") {
        @response.status: 204
        return  # Don't continue to handler
    }
    
    @next()
}
```

## Logging Middleware

```tusk
# Request logging
#middleware logging {
    start_time: @microtime(true)
    request_id: @generate_uuid()
    
    # Log request
    @log.info("Request started", {
        id: request_id,
        method: @request.method,
        path: @request.path,
        ip: @request.ip,
        user_id: @request.user?.id
    })
    
    # Process request
    @next()
    
    # Log response
    duration: @microtime(true) - start_time
    
    @log.info("Request completed", {
        id: request_id,
        status: @response.status,
        duration: duration,
        memory: @memory_get_peak_usage(true)
    })
    
    # Add timing header
    @response.headers["X-Response-Time"]: duration + "s"
    @response.headers["X-Request-ID"]: request_id
}

# Detailed logging for debugging
#middleware debug_logging if: @env.debug {
    @log.debug("Request details", {
        headers: @request.headers,
        query: @request.query,
        post: @request.post,
        cookies: @request.cookies
    })
    
    @next()
    
    @log.debug("Response details", {
        status: @response.status,
        headers: @response.headers,
        body_size: @strlen(@response.body)
    })
}
```

## Validation Middleware

```tusk
# Input validation
#middleware validate {
    rules: @params.rules || {}
    
    # Combine all input
    input: {...@request.query, ...@request.post}
    
    # Validate
    validation: @validator.make(input, rules)
    
    if (!validation.passes()) {
        @response.status: 422
        return @json({
            message: "Validation failed",
            errors: validation.errors()
        })
    }
    
    # Add validated data to request
    @request.validated: validation.validated()
    
    @next()
}

# Custom validation middleware
#middleware validate_json {
    if (@request.headers["content-type"] != "application/json") {
        @response.status: 400
        return @json({error: "Content-Type must be application/json"})
    }
    
    # Try to parse JSON body
    try {
        @request.json: @json_decode(@request.body)
    } catch {
        @response.status: 400
        return @json({error: "Invalid JSON in request body"})
    }
    
    @next()
}
```

## Cache Middleware

```tusk
# Page caching
#middleware cache {
    duration: @params.duration || 3600
    
    # Generate cache key
    key: "page:" + @request.method + ":" + @request.url
    
    # Check cache
    cached: @cache.get(key)
    
    if (cached) {
        @response.body: cached.body
        @response.headers: cached.headers
        @response.headers["X-Cache"]: "HIT"
        return  # Don't continue to handler
    }
    
    # Process request
    @next()
    
    # Cache successful responses
    if (@response.status == 200) {
        @cache.put(key, {
            body: @response.body,
            headers: @response.headers
        }, duration)
    }
    
    @response.headers["X-Cache"]: "MISS"
}

# Conditional caching
#middleware smart_cache {
    # Don't cache for authenticated users
    if (@request.user) {
        return @next()
    }
    
    # Don't cache POST requests
    if (@request.method != "GET") {
        return @next()
    }
    
    # Use standard cache middleware
    @apply_middleware("cache", {duration: 1800})
}
```

## Maintenance Mode

```tusk
# Maintenance mode middleware
#middleware maintenance {
    if (!@env.maintenance_mode) {
        return @next()
    }
    
    # Allow certain IPs
    allowed_ips: @config.maintenance.allowed_ips || []
    if (allowed_ips.includes(@request.ip)) {
        return @next()
    }
    
    # Allow certain routes
    allowed_routes: ["/maintenance", "/api/health"]
    if (allowed_routes.includes(@request.path)) {
        return @next()
    }
    
    @response.status: 503
    @response.headers["Retry-After"]: "3600"
    
    if (@request.wants_json()) {
        return @json({
            error: "Maintenance mode",
            message: "We'll be back soon!"
        })
    }
    
    @render("maintenance.tusk")
}
```

## Middleware Groups

```tusk
# Define middleware groups
middleware_groups: {
    web: [
        "session",
        "csrf",
        "security_headers"
    ],
    
    api: [
        "api_auth",
        "rate_limit:100,1",
        "cors"
    ],
    
    admin: [
        "auth",
        "role:admin",
        "logging"
    ]
}

# Apply group to routes
#web /admin/* middleware: @middleware_groups.admin {
    # All admin routes use admin middleware group
}

# Custom middleware pipeline
#middleware pipeline {
    middlewares: @params.middlewares || []
    
    # Execute each middleware
    for (mw in middlewares) {
        if (!@apply_middleware(mw)) {
            return false  # Stop if middleware fails
        }
    }
    
    @next()
}
```

## Testing Middleware

```tusk
# Test mode middleware
#middleware test_mode if: @env.testing {
    # Add test helpers
    @request.is_test: true
    
    # Allow test authentication
    if (@request.headers["x-test-user"]) {
        user_id: @request.headers["x-test-user"]
        @request.user: @User.find(user_id)
        @session.user_id: user_id
    }
    
    # Disable rate limiting
    @request.skip_rate_limit: true
    
    @next()
}

# Feature flag middleware
#middleware feature {
    feature: @params.feature
    
    if (!feature || !@features.enabled(feature)) {
        @response.status: 404
        return @json({error: "Feature not available"})
    }
    
    @next()
}
```

## Best Practices

1. **Keep middleware focused** - Single responsibility per middleware
2. **Order matters** - Place middleware in correct sequence
3. **Handle errors gracefully** - Don't break the request flow
4. **Use parameters** - Make middleware configurable
5. **Cache when possible** - Avoid repeated operations
6. **Test thoroughly** - Middleware affects many routes
7. **Document behavior** - Explain what middleware does
8. **Monitor performance** - Middleware runs on every request

## Related Topics

- `hash-web-directive` - Web endpoints
- `hash-api-directive` - API endpoints  
- `authentication` - Auth systems
- `rate-limiting` - Request throttling
- `cors` - Cross-origin requests
---

[#auth - Authentication Directive]


The `#auth` directive provides built-in authentication and authorization controls for routes, making it easy to protect resources and manage user access.

## Basic Syntax

```tusk
# Require authentication
#auth {
    #web /dashboard {
        @render("dashboard.tusk", {user: @auth.user})
    }
}

# Inline auth check
#web /profile {
    #auth required: true
    
    @render("profile.tusk", {user: @auth.user})
}

# With specific permissions
#web /admin {
    #auth role: "admin"
    
    @render("admin/dashboard.tusk")
}
```

## Authentication Guards

```tusk
# Different auth guards
#auth guard: "web" {
    # Session-based authentication (default)
    #web /account {
        @render("account.tusk")
    }
}

#auth guard: "api" {
    # Token-based authentication
    #api /user {
        return @auth.user
    }
}

#auth guard: "admin" {
    # Separate admin authentication
    #web /admin/dashboard {
        @render("admin/dashboard.tusk")
    }
}

# Custom guard
#auth guard: "customer" provider: "customers" {
    #web /customer/portal {
        @render("customer/portal.tusk")
    }
}
```

## Role-Based Access

```tusk
# Single role requirement
#auth role: "editor" {
    #web /posts/create {
        @render("posts/create.tusk")
    }
}

# Multiple roles (any)
#auth roles: ["admin", "moderator"] {
    #web /moderation {
        @render("moderation/dashboard.tusk")
    }
}

# Multiple roles (all required)
#auth roles: ["user", "verified"] require_all: true {
    #web /verified-only {
        @render("verified/content.tusk")
    }
}

# Dynamic role checking
#web /content/{id} {
    #auth can: "view-content" model: @Content.find(@params.id)
    
    @render("content/show.tusk", {
        content: @auth.model
    })
}
```

## Permission-Based Access

```tusk
# Single permission
#auth permission: "manage-users" {
    #web /users {
        users: @User.paginate(20)
        @render("users/index.tusk", {users})
    }
}

# Multiple permissions (any)
#auth permissions: ["create-posts", "edit-posts"] {
    #web /posts/new {
        @render("posts/form.tusk")
    }
}

# Multiple permissions (all required)
#auth permissions: ["view-reports", "export-data"] match: "all" {
    #web /reports/export {
        @export_reports()
    }
}

# Permission with context
#web /posts/{id}/edit {
    post: @Post.find(@params.id)
    
    #auth can: "edit" model: post
    
    @render("posts/edit.tusk", {post})
}
```

## Authentication Methods

```tusk
# Login implementation
#web /login method: POST {
    credentials: {
        email: @request.post.email
        password: @request.post.password
    }
    
    # Attempt login
    if (@auth.attempt(credentials)) {
        # Optional remember me
        if (@request.post.remember) {
            @auth.remember()
        }
        
        # Redirect to intended URL or default
        return @redirect(@auth.intended("/dashboard"))
    }
    
    # Failed login
    @back().with("error", "Invalid credentials")
}

# Logout
#web /logout method: POST {
    #auth required: true
    
    @auth.logout()
    @session.invalidate()
    @redirect("/")
}

# Registration
#web /register method: POST {
    # Validate input
    data: @validate(@request.post, {
        name: "required|string|max:255"
        email: "required|email|unique:users"
        password: "required|min:8|confirmed"
    })
    
    # Create user
    user: @User.create({
        name: data.name
        email: data.email
        password: @hash(data.password)
    })
    
    # Auto login
    @auth.login(user)
    
    # Send verification email
    @event("user.registered", user)
    
    @redirect("/dashboard")
}
```

## OAuth Integration

```tusk
# OAuth routes
#auth provider: "oauth" {
    # Redirect to provider
    #web /auth/{provider} {
        return @auth.driver(@params.provider).redirect()
    }
    
    # Handle callback
    #web /auth/{provider}/callback {
        try {
            user: @auth.driver(@params.provider).user()
            
            # Find or create user
            local_user: @User.firstOrCreate({
                email: user.email
            }, {
                name: user.name
                avatar: user.avatar
                provider: @params.provider
                provider_id: user.id
            })
            
            # Login
            @auth.login(local_user)
            
            @redirect("/dashboard")
            
        } catch (Exception e) {
            @redirect("/login").with("error", "Authentication failed")
        }
    }
}

# Supported providers
#web /login {
    @render("auth/login.tusk", {
        providers: ["google", "github", "facebook"]
    })
}
```

## API Authentication

```tusk
# API token authentication
#auth guard: "api" {
    #api /user {
        # Automatically authenticated via Bearer token
        return @auth.user
    }
    
    #api /user/update method: PUT {
        user: @auth.user
        user.update(@request.post)
        
        return {
            message: "Profile updated"
            user: user
        }
    }
}

# Generate API token
#web /settings/api method: POST {
    #auth required: true
    
    token: @auth.user.createToken("api-access", [
        "read-profile"
        "update-profile"
    ])
    
    @render("settings/token.tusk", {
        token: token.plainTextToken
    })
}

# Stateless token auth
#auth stateless: true {
    #api /data {
        # No session created
        return @sensitive_data()
    }
}
```

## Two-Factor Authentication

```tusk
# 2FA setup
#web /security/2fa {
    #auth required: true
    
    if (@request.method == "POST") {
        # Enable 2FA
        secret: @auth.user.createTwoFactorAuth()
        qr_code: @generate_qr_code(secret.uri)
        
        @render("security/2fa-setup.tusk", {
            secret: secret.secret
            qr_code: qr_code
        })
    } else {
        @render("security/2fa.tusk", {
            enabled: @auth.user.two_factor_enabled
        })
    }
}

# 2FA verification during login
#web /login/2fa method: POST {
    code: @request.post.code
    
    if (@auth.attemptWith2FA(code)) {
        @redirect(@auth.intended("/dashboard"))
    } else {
        @back().with("error", "Invalid authentication code")
    }
}

# Require 2FA for sensitive routes
#auth require_2fa: true {
    #web /settings/security {
        @render("settings/security.tusk")
    }
}
```

## Session Management

```tusk
# Session configuration
#auth session: {
    lifetime: 120  # minutes
    expire_on_close: false
    encrypt: true
    same_site: "lax"
} {
    #web /app/* {
        # All app routes use these session settings
    }
}

# Multiple sessions
#web /admin/* {
    #auth guard: "admin" session: "admin_session"
    
    # Separate session for admin area
}

# Session invalidation
#web /security/sessions {
    #auth required: true
    
    if (@request.method == "POST") {
        # Invalidate other sessions
        @auth.logoutOtherDevices(@request.post.password)
        
        @back().with("success", "Other sessions terminated")
    }
    
    sessions: @auth.user.sessions
    @render("security/sessions.tusk", {sessions})
}
```

## Custom Authentication

```tusk
# Custom auth provider
#auth provider: {
    # Retrieve user by credentials
    retrieve: (credentials) => {
        user: @User.where("email", credentials.email).first()
        
        if (user && @verify_password(credentials.password, user.password)) {
            return user
        }
        
        return null
    }
    
    # Validate credentials
    validate: (user, credentials) => {
        return @verify_password(credentials.password, user.password)
    }
} {
    #web /custom-login method: POST {
        if (@auth.attempt(@request.post)) {
            @redirect("/dashboard")
        }
    }
}

# Custom user provider
#auth user_provider: {
    model: "Customer"
    identifier: "username"
    password_field: "pass_hash"
} {
    #web /customer/* {
        # Uses custom customer authentication
    }
}
```

## Access Control Helpers

```tusk
# In routes
#web /posts/{id} {
    post: @Post.find(@params.id)
    
    # Manual auth check
    if (!@auth.check()) {
        @abort(401)
    }
    
    # Manual permission check
    if (!@auth.user.can("view", post)) {
        @abort(403)
    }
    
    @render("posts/show.tusk", {post})
}

# Policy-based authorization
#auth policy: PostPolicy {
    #web /posts/{id}/edit {
        # Automatically checks PostPolicy@edit
        @render("posts/edit.tusk", {
            post: @auth.model
        })
    }
}

# Gate definitions
gates: {
    "edit-post": (user, post) => {
        return user.id == post.author_id || user.isAdmin()
    }
    
    "delete-post": (user, post) => {
        return user.id == post.author_id && post.created_at > @days_ago(1)
    }
}

# Use gates
#web /posts/{id}/delete method: POST {
    post: @Post.find(@params.id)
    
    #auth can: "delete-post" model: post
    
    post.delete()
    @redirect("/posts")
}
```

## Authentication Events

```tusk
# Listen to auth events
#on auth.login {
    user: @event.user
    
    # Update last login
    user.update({
        last_login_at: @now()
        last_login_ip: @request.ip
    })
    
    # Log activity
    @activity("user.login", user)
}

#on auth.logout {
    # Clean up user data
    @cache.forget("user:" + @event.user.id)
}

#on auth.failed {
    # Log failed attempts
    @log.warning("Failed login attempt", {
        email: @event.credentials.email
        ip: @request.ip
    })
    
    # Check for brute force
    @security.check_failed_attempts(@event.credentials.email)
}

# Custom auth events
#auth events: {
    verified: (user) => {
        @notification.send(user, "EmailVerified")
        @grant_verified_benefits(user)
    }
    
    lockout: (request) => {
        @alert_security_team("Account lockout", request)
    }
}
```

## Best Practices

1. **Use appropriate guards** - Web for sessions, API for tokens
2. **Implement rate limiting** - Prevent brute force attacks
3. **Hash passwords properly** - Use bcrypt or argon2
4. **Validate permissions** - Don't rely on client-side checks
5. **Log auth events** - Track login attempts and changes
6. **Use HTTPS** - Protect credentials in transit
7. **Implement 2FA** - For sensitive applications
8. **Session security** - Regenerate IDs, set appropriate timeouts

## Related Topics

- `hash-middleware-directive` - Authentication middleware
- `session-management` - Session handling
- `password-hashing` - Secure password storage
- `oauth-integration` - Social login
- `api-authentication` - Token-based auth
---

[#cache - Caching Directive]


The `#cache` directive provides declarative caching for routes and code blocks, improving performance by storing computed results and responses.

## Basic Syntax

```tusk
# Cache route response for 1 hour
#cache 3600 {
    #web /expensive-page {
        data: @perform_expensive_computation()
        @render("page.tusk", {data})
    }
}

# Cache with custom key
#cache key: "homepage" duration: 7200 {
    #web / {
        @render("home.tusk", @get_homepage_data())
    }
}

# Cache forever
#cache forever: true key: "static-content" {
    content: @load_static_content()
    return content
}
```

## Cache Keys

```tusk
# Automatic cache key generation
#cache 3600 {
    #web /products {
        # Key auto-generated from: method + path + query string
        # e.g., "GET:/products?page=2&sort=price"
        products: @Product.paginate(20)
        @render("products.tusk", {products})
    }
}

# Custom cache key
#cache key: "products:{page}:{sort}" duration: 1800 {
    #web /products {
        page: @request.query.page || 1
        sort: @request.query.sort || "name"
        
        products: @Product.orderBy(sort).paginate(20, page)
        @render("products.tusk", {products})
    }
}

# Dynamic cache key
#cache key: () => "user:" + @auth.id + ":dashboard" duration: 600 {
    #web /dashboard {
        # Cached per user
        @render("dashboard.tusk", @get_user_dashboard_data())
    }
}

# Multiple key segments
#cache key: ["products", @request.query.category, @request.query.page] {
    # Creates key like: "products:electronics:2"
    @render_product_list()
}
```

## Cache Tags

```tusk
# Tag-based cache invalidation
#cache tags: ["products"] duration: 3600 {
    #web /products {
        @render("products.tusk", {
            products: @Product.all()
        })
    }
}

#cache tags: ["products", "homepage"] duration: 7200 {
    #web / {
        @render("home.tusk", {
            featured: @Product.featured()
        })
    }
}

# Invalidate by tag
#web /admin/products/update method: POST {
    @update_product(@request.post)
    
    # Clear all caches tagged with "products"
    @cache.tags("products").flush()
    
    @redirect("/admin/products")
}

# Multiple tags with specific items
#cache tags: () => ["user:" + @auth.id, "posts"] {
    #web /my-posts {
        posts: @auth.user.posts
        @render("posts/mine.tusk", {posts})
    }
}
```

## Conditional Caching

```tusk
# Cache only for guests
#cache when: !@auth.check() duration: 3600 {
    #web /public-content {
        @render("public.tusk")
    }
}

# Cache based on conditions
#cache when: @request.query.nocache != "1" {
    #web /data {
        @expensive_operation()
    }
}

# Dynamic cache duration
#cache duration: @auth.check() ? 300 : 3600 {
    #web /content {
        # 5 minutes for logged in users, 1 hour for guests
        @render("content.tusk")
    }
}

# Skip cache for certain conditions
#cache unless: @request.query.preview == "1" {
    #web /article/{slug} {
        article: @Article.findBySlug(@params.slug)
        @render("article.tusk", {article})
    }
}
```

## Cache Stores

```tusk
# Use specific cache store
#cache store: "redis" duration: 3600 {
    #web /api-data {
        @json(@fetch_external_api_data())
    }
}

# File-based cache
#cache store: "file" path: "pages" {
    #web /static-page {
        @render("static.tusk")
    }
}

# Memory cache (request-level)
#cache store: "array" {
    # Cached only for current request
    @expensive_calculation()
}

# Multiple stores (cache hierarchy)
#cache stores: ["array", "redis"] {
    # Checks array first, then redis
    # Stores in both when cache miss
    @complex_operation()
}
```

## Response Caching

```tusk
# Full response caching
#cache response: true duration: 3600 {
    #web /full-page {
        # Entire response including headers is cached
        @response.headers["X-Custom"]: "Value"
        @render("page.tusk")
    }
}

# Partial response caching
#cache response: {
    headers: ["Content-Type", "X-Custom"]
    status: true
} {
    #web /partial {
        @response.headers["X-Dynamic"]: @time()  # Not cached
        @response.headers["X-Custom"]: "Static"  # Cached
        @render("partial.tusk")
    }
}

# Cache with vary headers
#cache vary: ["Accept-Language", "Accept"] {
    #web /content {
        # Different cache entries for different Accept-Language headers
        lang: @request.headers["Accept-Language"]
        @render("content/" + lang + ".tusk")
    }
}
```

## Fragment Caching

```tusk
# Cache fragments within routes
#web /complex-page {
    # Cache expensive parts
    sidebar: #cache key: "sidebar" duration: 7200 {
        @render_sidebar()
    }
    
    # Cache with tags
    products: #cache tags: ["products"] duration: 3600 {
        @Product.featured().limit(10).get()
    }
    
    # Don't cache user-specific content
    user_data: @get_user_specific_data()
    
    @render("complex.tusk", {
        sidebar: sidebar
        products: products
        user_data: user_data
    })
}

# Nested caching
#cache key: "page:home" duration: 3600 {
    header: #cache key: "header" duration: 7200 {
        @render("partials/header.tusk")
    }
    
    content: #cache key: "home:content" duration: 1800 {
        @render("home/content.tusk")
    }
    
    @render("layout.tusk", {header, content})
}
```

## Cache Warming

```tusk
# Pre-warm cache
#cache warm: true key: "expensive-data" {
    @calculate_expensive_metrics()
}

# Warm cache on schedule
#cron "0 * * * *" {
    # Warm critical caches every hour
    #cache warm: true key: "homepage" {
        @render_homepage()
    }
    
    #cache warm: true key: "products:featured" {
        @Product.featured().get()
    }
}

# Warm cache after events
#on product.updated {
    product: @event.product
    
    # Re-warm related caches
    #cache warm: true key: "product:" + product.id {
        @render_product_page(product)
    }
    
    #cache warm: true tags: ["category:" + product.category_id] {
        @render_category_page(product.category)
    }
}
```

## Cache Locking

```tusk
# Prevent cache stampede
#cache lock: true lock_timeout: 30 {
    #web /popular-endpoint {
        # Only one process regenerates cache
        # Others wait or use stale data
        @expensive_operation()
    }
}

# Custom lock behavior
#cache lock: {
    timeout: 60
    wait: true  # Wait for lock
    stale: true  # Serve stale data while waiting
} {
    @heavy_computation()
}

# Async cache regeneration
#cache lock: false async: true {
    #web /data {
        # Returns stale data immediately
        # Regenerates cache in background
        @slow_data_fetch()
    }
}
```

## Cache Configuration

```tusk
# Cache with options
#cache {
    key: "custom-key"
    duration: 3600
    tags: ["api", "v2"]
    store: "redis"
    compress: true  # Compress large values
    serialize: "json"  # How to serialize data
} {
    @complex_data_structure()
}

# TTL with jitter (prevent simultaneous expiry)
#cache duration: 3600 jitter: 300 {
    # Expires between 3300-3900 seconds
    @api_call()
}

# Sliding expiration
#cache duration: 1800 sliding: true {
    # Extends TTL on each access
    @frequently_accessed_data()
}
```

## Debugging Cache

```tusk
# Debug mode
#cache debug: true {
    #web /test {
        # Logs cache hits/misses
        # Adds debug headers
        @render("test.tusk")
    }
}

# Skip cache in development
#cache unless: @env.debug {
    #web /page {
        @render("page.tusk")
    }
}

# Cache statistics
#cache track: true key: "tracked-operation" {
    @operation()
}

# Later: View cache stats
stats: @cache.stats("tracked-operation")
// {hits: 150, misses: 23, hit_rate: 0.867}
```

## Cache Invalidation

```tusk
# Manual invalidation
#web /admin/clear-cache {
    # Clear specific keys
    @cache.forget("homepage")
    @cache.forget(["products:1", "products:2"])
    
    # Clear by pattern
    @cache.forgetPattern("products:*")
    
    # Clear by tags
    @cache.tags(["products", "homepage"]).flush()
    
    # Clear everything
    @cache.flush()
}

# Automatic invalidation
#cache invalidate_on: ["product.created", "product.updated"] {
    #web /products {
        @render_product_list()
    }
}

# Time-based invalidation
#cache until: "tomorrow" {
    # Cache until midnight
    @daily_report()
}

#cache until: "2024-12-31 23:59:59" {
    # Cache until specific time
    @yearly_summary()
}
```

## Performance Optimization

```tusk
# Batch cache operations
#cache batch: true {
    // Multiple cache operations are batched
    data1: @cache.get("key1")
    data2: @cache.get("key2")
    data3: @cache.get("key3")
}

# Pipeline cache
#cache pipeline: true {
    @cache.put("key1", value1)
    @cache.put("key2", value2)
    @cache.increment("counter")
}

# Lazy cache loading
#cache lazy: true key: "expensive" {
    # Only loads if actually accessed
    @very_expensive_operation()
}
```

## Best Practices

1. **Choose appropriate TTLs** - Balance freshness vs performance
2. **Use cache tags** - Easier invalidation of related data
3. **Key naming conventions** - Use consistent, descriptive keys
4. **Monitor hit rates** - Track cache effectiveness
5. **Handle cache misses** - Always have fallback logic
6. **Compress large values** - Save memory and bandwidth
7. **Avoid caching user data** - Or use user-specific keys
8. **Test cache invalidation** - Ensure data consistency

## Related Topics

- `cache-operations` - Cache manipulation functions
- `performance-optimization` - Performance strategies
- `cache-drivers` - Different cache backends
- `cache-tags` - Tag-based invalidation
- `cache-warming` - Pre-loading cache
---

[#rate_limit - Rate Limiting Directive]


The `#rate_limit` directive provides request throttling to prevent abuse, protect resources, and ensure fair usage of your application.

## Basic Syntax

```tusk
# Basic rate limiting - 60 requests per minute
#rate_limit 60 {
    #api /search {
        results: @search(@request.query.q)
        return results
    }
}

# Custom window - 100 requests per hour
#rate_limit 100 per: "hour" {
    #api /data {
        return @fetch_data()
    }
}

# With custom key
#rate_limit 30 key: @request.ip {
    #web /download {
        @serve_file()
    }
}
```

## Rate Limit Configuration

```tusk
# Detailed configuration
#rate_limit {
    limit: 100           # Number of requests
    window: 3600         # Time window in seconds
    key: @auth.id || @request.ip  # Rate limit key
    message: "Too many requests"    # Error message
    response_code: 429   # HTTP status code
} {
    #api /endpoint {
        @process_request()
    }
}

# Per-minute limiting
#rate_limit 60 per: "minute" {
    #api /rapid-endpoint {
        return @quick_response()
    }
}

# Multiple windows
#rate_limit {
    limits: [
        {count: 10, window: 60},      # 10 per minute
        {count: 100, window: 3600},    # 100 per hour
        {count: 1000, window: 86400}   # 1000 per day
    ]
} {
    #api /tiered-limit {
        @handle_request()
    }
}
```

## User-Based Rate Limiting

```tusk
# Different limits for different users
#rate_limit {
    limit: () => {
        if (!@auth.check()) return 20  # Guests
        if (@auth.user.isPremium()) return 1000  # Premium users
        return 100  # Regular users
    }
    window: 3600
    key: @auth.id || @request.ip
} {
    #api /user-endpoint {
        @process()
    }
}

# Role-based limits
#rate_limit {
    limits: {
        guest: {count: 10, window: 3600},
        user: {count: 100, window: 3600},
        premium: {count: 1000, window: 3600},
        admin: null  # No limit
    }
    role: @auth.user?.role || "guest"
} {
    #api /role-based {
        @handle()
    }
}
```

## API Key Rate Limiting

```tusk
# Rate limit by API key
#rate_limit {
    key: @request.headers["X-API-Key"]
    limit: () => {
        api_key: @ApiKey.where("key", @request.headers["X-API-Key"]).first()
        return api_key?.rate_limit || 100
    }
    window: 3600
} {
    #api /external-api {
        @serve_api_request()
    }
}

# Tiered API limits
#rate_limit {
    key: @request.api_key
    limits: () => {
        tier: @get_api_tier(@request.api_key)
        
        return match tier {
            "free" => [{count: 100, window: 86400}]
            "basic" => [{count: 1000, window: 3600}]
            "pro" => [{count: 10000, window: 3600}]
            "enterprise" => []  # No limits
        }
    }
} {
    #api /v2/* {
        @handle_api_v2()
    }
}
```

## Route-Specific Limits

```tusk
# Different limits for different routes
#rate_limit {
    limit: match @request.path {
        "/api/search" => 30
        "/api/heavy-operation" => 5
        "/api/lightweight" => 200
        _ => 60  # Default
    }
    window: 3600
} {
    #api /* {
        @route_handler()
    }
}

# Method-based limits
#rate_limit {
    limit: match @request.method {
        "GET" => 100
        "POST" => 50
        "PUT" => 50
        "DELETE" => 20
    }
    window: 3600
} {
    #api /resources {
        @handle_resource()
    }
}
```

## Cost-Based Rate Limiting

```tusk
# Point-based system
#rate_limit {
    points: 1000  # Total points per window
    window: 3600
    
    # Different operations cost different points
    cost: () => {
        return match @request.path {
            "/api/simple" => 1
            "/api/moderate" => 10
            "/api/expensive" => 100
            "/api/ai-generate" => 500
        }
    }
} {
    #api /* {
        @handle_with_cost()
    }
}

# Dynamic cost calculation
#rate_limit {
    points: 10000
    window: 86400  # Daily limit
    
    cost: () => {
        # Calculate based on request complexity
        base_cost: 1
        
        if (@request.query.include_relations) {
            base_cost *= 2
        }
        
        if (@request.query.limit > 100) {
            base_cost *= 3
        }
        
        return base_cost
    }
} {
    #api /flexible-endpoint {
        @process_flexible()
    }
}
```

## Response Headers

```tusk
# Include rate limit headers
#rate_limit 100 per: "hour" headers: true {
    #api /with-headers {
        # Automatically adds:
        # X-RateLimit-Limit: 100
        # X-RateLimit-Remaining: 95
        # X-RateLimit-Reset: 1640995200
        
        return @data()
    }
}

# Custom headers
#rate_limit {
    limit: 60
    window: 3600
    headers: {
        limit: "X-Rate-Limit"
        remaining: "X-Rate-Remaining"
        reset: "X-Rate-Reset"
        retry_after: "Retry-After"  # On 429 response
    }
} {
    #api /custom-headers {
        @process()
    }
}
```

## Bypass and Whitelist

```tusk
# Bypass for certain conditions
#rate_limit {
    limit: 60
    bypass: () => {
        # Skip rate limiting for admins
        if (@auth.user?.isAdmin()) return true
        
        # Skip for internal IPs
        if (@in_array(@request.ip, @config.internal_ips)) return true
        
        # Skip for specific user agents
        if (@request.user_agent == "Internal-Monitor") return true
        
        return false
    }
} {
    #api /conditional {
        @handle()
    }
}

# Whitelist specific keys
#rate_limit {
    limit: 100
    whitelist: [
        "api_key_123abc",  # Specific API keys
        "192.168.1.1",     # Specific IPs
    ]
    key: @request.api_key || @request.ip
} {
    #api /whitelist-example {
        @process()
    }
}
```

## Storage Backends

```tusk
# Redis backend (default)
#rate_limit 100 store: "redis" {
    #api /redis-limited {
        @handle()
    }
}

# Database backend
#rate_limit 100 store: "database" table: "rate_limits" {
    #api /db-limited {
        @handle()
    }
}

# Memory backend (single server only)
#rate_limit 100 store: "memory" {
    #api /memory-limited {
        @handle()
    }
}

# Custom store
#rate_limit {
    limit: 100
    store: {
        get: (key) => @custom_store.get(key)
        increment: (key, window) => @custom_store.increment(key, window)
        reset: (key) => @custom_store.reset(key)
    }
} {
    #api /custom-store {
        @handle()
    }
}
```

## Distributed Rate Limiting

```tusk
# Sliding window with Redis
#rate_limit {
    limit: 1000
    window: 3600
    algorithm: "sliding_window"  # More accurate than fixed window
    store: "redis"
} {
    #api /precise-limit {
        @handle()
    }
}

# Token bucket algorithm
#rate_limit {
    capacity: 100      # Bucket size
    refill_rate: 10    # Tokens per second
    algorithm: "token_bucket"
} {
    #api /smooth-limit {
        @handle()
    }
}

# Distributed rate limiting across servers
#rate_limit {
    limit: 10000
    window: 3600
    store: "redis_cluster"
    sync_interval: 100  # Sync counts every 100ms
} {
    #api /distributed {
        @handle()
    }
}
```

## Error Handling

```tusk
# Custom error response
#rate_limit {
    limit: 60
    on_limit: () => {
        @response.status: 429
        @response.headers["Retry-After"]: @rate_limiter.retry_after()
        
        return @json({
            error: "Rate limit exceeded",
            message: "Please slow down your requests",
            retry_after: @rate_limiter.retry_after(),
            limit: @rate_limiter.limit(),
            window: @rate_limiter.window()
        })
    }
} {
    #api /custom-error {
        @handle()
    }
}

# Different responses for different clients
#rate_limit {
    limit: 100
    on_limit: () => {
        if (@request.wants_json()) {
            @response.status: 429
            return @json({
                error: "Too many requests",
                retry_after: @rate_limiter.retry_after()
            })
        } else {
            @response.status: 429
            return @render("errors/rate_limit.tusk", {
                retry_after: @rate_limiter.retry_after()
            })
        }
    }
} {
    #web /mixed-response {
        @handle()
    }
}
```

## Monitoring and Analytics

```tusk
# Log rate limit hits
#rate_limit {
    limit: 100
    on_limit: () => {
        @log.warning("Rate limit hit", {
            key: @rate_limiter.key(),
            path: @request.path,
            ip: @request.ip,
            user_id: @auth.id
        })
        
        # Track metrics
        @metrics.increment("rate_limit.hit", {
            path: @request.path,
            key_type: @auth.check() ? "user" : "ip"
        })
        
        # Standard 429 response
        @abort(429)
    }
    
    on_success: () => {
        # Track successful requests
        @metrics.increment("rate_limit.allowed", {
            path: @request.path,
            remaining: @rate_limiter.remaining()
        })
    }
} {
    #api /monitored {
        @handle()
    }
}

# Rate limit analytics
#api /admin/rate-limits {
    stats: @rate_limiter.stats({
        paths: ["/api/search", "/api/data"],
        period: "hour",
        group_by: "key"
    })
    
    return {
        top_consumers: stats.top_consumers,
        hit_rate: stats.hit_rate,
        patterns: stats.patterns
    }
}
```

## Testing Rate Limits

```tusk
# Disable in tests
#rate_limit {
    limit: 100
    enabled: @env.APP_ENV != "testing"
} {
    #api /testable {
        @handle()
    }
}

# Test mode with different limits
#rate_limit {
    limit: @env.APP_ENV == "testing" ? 10000 : 100
    window: @env.APP_ENV == "testing" ? 60 : 3600
} {
    #api /test-friendly {
        @handle()
    }
}
```

## Best Practices

1. **Choose appropriate limits** - Balance security and usability
2. **Use meaningful keys** - User ID > IP for authenticated routes
3. **Implement gradual limits** - Multiple windows prevent bursts
4. **Include headers** - Help clients manage their requests
5. **Log violations** - Monitor for abuse patterns
6. **Handle errors gracefully** - Provide clear feedback
7. **Consider costs** - Some operations are more expensive
8. **Test thoroughly** - Ensure limits work as expected

## Related Topics

- `hash-middleware-directive` - Request middleware
- `caching` - Response caching
- `security` - Application security
- `monitoring` - Performance monitoring
- `api-design` - API best practices
---

[Custom Directives in TuskLang]


TuskLang allows you to create custom directives to extend the language with domain-specific functionality, making your code more expressive and maintainable.

## Defining Custom Directives

```tusk
# Basic custom directive
@directive.define("log_execution") {
    pattern: /^(.*)$/  # Match any content
    
    handler: (match, code, context) => {
        # Add logging before and after
        return """
            @log.debug("Executing: {context.name}")
            start_time: @microtime(true)
            
            {code}
            
            duration: @microtime(true) - start_time
            @log.debug("Completed in {duration}s")
        """
    }
}

# Usage
#log_execution {
    result: @complex_calculation()
    @save_result(result)
}
```

## Directive Structure

```tusk
# Complete directive definition
@directive.define("feature") {
    # Pattern to match directive arguments
    pattern: /^(\w+)(?:\s+if:\s*(.+))?$/
    
    # Parse arguments
    parse: (match) => {
        return {
            name: match[1],
            condition: match[2] || "true"
        }
    }
    
    # Transform code
    handler: (args, code, context) => {
        return """
            if (@feature_enabled("{args.name}") && ({args.condition})) {
                {code}
            }
        """
    }
    
    # Metadata
    meta: {
        description: "Conditionally execute code based on feature flags"
        examples: [
            '#feature new_ui { @render("new_ui.tusk") }',
            '#feature beta if: @user.is_beta { @show_beta_features() }'
        ]
    }
}

# Usage
#feature dark_mode if: @user.preferences.theme == "dark" {
    @apply_dark_theme()
}
```

## Route-Style Directives

```tusk
# Custom route directive
@directive.define("websocket") {
    pattern: /^(\/[^\s]+)(?:\s+(.+))?$/
    
    parse: (match) => {
        path: match[1]
        options: @parse_options(match[2] || "")
        
        return {path, options}
    }
    
    handler: (args, code, context) => {
        # Register WebSocket handler
        @websocket.route(args.path, (ws, request) => {
            # Set up context
            @context.ws: ws
            @context.request: request
            
            # Execute directive code
            eval(code)
        })
        
        return ""  # No inline code generation
    }
}

# Usage
#websocket /chat {
    @ws.on("message", (data) => {
        message: @json.decode(data)
        @broadcast_to_room(message.room, message)
    })
    
    @ws.on("close", () => {
        @remove_from_room(@request.user)
    })
}
```

## Decorator Directives

```tusk
# Method decorator directive
@directive.define("cached") {
    pattern: /^(?:(\d+))?(?:\s+key:\s*(.+))?$/
    
    parse: (match) => {
        return {
            ttl: match[1] ? @int(match[1]) : 3600,
            key: match[2] || null
        }
    }
    
    handler: (args, code, context) => {
        # Extract function name from code
        func_match: code.match(/^(\w+):\s*\(([^)]*)\)\s*=>\s*{/)
        
        if (!func_match) {
            throw "Cached directive requires a function"
        }
        
        func_name: func_match[1]
        func_params: func_match[2]
        
        cache_key: args.key || `"{context.namespace}:{func_name}:" + @md5(@json_encode([{func_params}]))`
        
        return """
            {func_name}: ({func_params}) => {
                _cache_key: {cache_key}
                _cached: @cache.get(_cache_key)
                
                if (_cached !== null) {
                    return _cached
                }
                
                _result: (() => {
                    {code}
                })()
                
                @cache.put(_cache_key, _result, {args.ttl})
                return _result
            }
        """
    }
}

# Usage
#cached 7200 key: "user_stats:{user_id}" {
    get_user_stats: (user_id) => {
        stats: @db.query("SELECT ... expensive query ...")
        return @process_stats(stats)
    }
}
```

## Validation Directives

```tusk
# Input validation directive
@directive.define("validate") {
    pattern: /^(.+)$/
    
    parse: (match) => {
        # Parse validation rules
        rules: @parse_validation_rules(match[1])
        return {rules}
    }
    
    handler: (args, code, context) => {
        validation_code: ""
        
        for (field, rules in args.rules) {
            validation_code += """
                if (!@validate_field(@request.{field}, "{rules}")) {
                    @response.status: 422
                    return @json({
                        error: "Validation failed",
                        field: "{field}",
                        rules: "{rules}"
                    })
                }
            """
        }
        
        return validation_code + "\n" + code
    }
}

# Usage
#validate {
    name: "required|string|max:255"
    email: "required|email"
    age: "required|integer|min:18"
} {
    #api /users method: POST {
        # Validation runs first
        user: @User.create(@request.validated)
        return user
    }
}
```

## Async Directives

```tusk
# Async execution directive
@directive.define("async") {
    pattern: /^(?:pool:\s*(\w+))?(?:\s+timeout:\s*(\d+))?$/
    
    parse: (match) => {
        return {
            pool: match[1] || "default",
            timeout: match[2] ? @int(match[2]) : null
        }
    }
    
    handler: (args, code, context) => {
        return """
            @async.run({
                pool: "{args.pool}",
                timeout: {args.timeout || "null"},
                task: async () => {
                    {code}
                }
            })
        """
    }
}

# Usage
#async pool: heavy_tasks timeout: 30000 {
    result: await @expensive_async_operation()
    await @save_result(result)
}
```

## Testing Directives

```tusk
# Test case directive
@directive.define("test") {
    pattern: /^"([^"]+)"(?:\s+(\w+))?$/
    
    parse: (match) => {
        return {
            description: match[1],
            type: match[2] || "unit"
        }
    }
    
    handler: (args, code, context) => {
        test_name: @slugify(args.description)
        
        # Register test
        @test.register({
            name: test_name,
            description: args.description,
            type: args.type,
            file: context.file,
            line: context.line,
            run: () => {
                eval(code)
            }
        })
        
        return ""  # Tests are registered, not inline
    }
}

# Usage
#test "User can login with valid credentials" integration {
    user: @factory("user").create()
    
    response: @post("/login", {
        email: user.email,
        password: "password"
    })
    
    @assert.equals(response.status, 200)
    @assert.has(response.json(), "token")
}
```

## Monitoring Directives

```tusk
# Performance monitoring directive
@directive.define("monitor") {
    pattern: /^(\w+)(?:\s+alert:\s*(.+))?$/
    
    parse: (match) => {
        return {
            metric: match[1],
            alert_threshold: match[2] ? @float(match[2]) : null
        }
    }
    
    handler: (args, code, context) => {
        return """
            _monitor_start: @microtime(true)
            _monitor_memory: @memory_get_usage()
            
            try {
                _monitor_result: (() => {
                    {code}
                })()
                
                _monitor_duration: @microtime(true) - _monitor_start
                _monitor_memory_used: @memory_get_usage() - _monitor_memory
                
                @metrics.record("{args.metric}", {
                    duration: _monitor_duration,
                    memory: _monitor_memory_used,
                    success: true
                })
                
                if ({args.alert_threshold} && _monitor_duration > {args.alert_threshold}) {
                    @alert("Performance threshold exceeded for {args.metric}", {
                        duration: _monitor_duration,
                        threshold: {args.alert_threshold}
                    })
                }
                
                return _monitor_result
                
            } catch (e) {
                @metrics.record("{args.metric}", {
                    success: false,
                    error: e.message
                })
                throw e
            }
        """
    }
}

# Usage
#monitor database_query alert: 0.5 {
    results: @db.query("SELECT * FROM large_table WHERE complex_conditions")
    @process_results(results)
}
```

## Composition Directives

```tusk
# Compose multiple directives
@directive.define("authenticated_api") {
    pattern: /^(\/[^\s]+)(?:\s+roles:\s*\[([^\]]+)\])?$/
    
    parse: (match) => {
        return {
            path: match[1],
            roles: match[2] ? match[2].split(",").map(r => r.trim()) : []
        }
    }
    
    handler: (args, code, context) => {
        middleware: ["auth", "api"]
        
        if (args.roles.length > 0) {
            middleware.push(`role:${args.roles.join("|")}`)
        }
        
        return """
            #api {args.path} middleware: {middleware} {
                {code}
            }
        """
    }
}

# Usage
#authenticated_api /admin/users roles: [admin, super_admin] {
    users: @User.with("roles").paginate(20)
    return users
}
```

## Registering Directives

```tusk
# Register in bootstrap file
@app.boot(() => {
    # Load custom directives
    @directive.load_from_directory("app/directives")
    
    # Register individual directive
    @directive.register("my_directive", MyDirective)
    
    # Register from configuration
    for (name, config in @config.custom_directives) {
        @directive.define(name, config)
    }
})

# Directive class
class MyDirective {
    pattern: /^(.+)$/
    
    parse(match) {
        return {value: match[1]}
    }
    
    handler(args, code, context) {
        return @transform_code(code, args, context)
    }
    
    validate(args) {
        # Validate directive arguments
        if (!args.value) {
            throw "Value required for my_directive"
        }
    }
}
```

## Best Practices

1. **Keep directives focused** - Single responsibility
2. **Use clear naming** - Directive names should be intuitive
3. **Validate arguments** - Check directive parameters
4. **Document thoroughly** - Include examples and use cases
5. **Handle errors gracefully** - Provide helpful error messages
6. **Test directives** - Unit test transformation logic
7. **Consider performance** - Directives run at compile time
8. **Version carefully** - Changing directives can break code

## Related Topics

- `hash-directive-intro` - Directive basics
- `macro-system` - Code generation
- `metaprogramming` - Advanced techniques
- `compiler-hooks` - Compilation process
- `dsl-creation` - Domain-specific languages
---

[Database Overview in TuskLang]


TuskLang provides a powerful and intuitive database abstraction layer with an elegant ORM (Object-Relational Mapping) system that makes working with databases a pleasure.

## Database Connection

```tusk
# Database configuration in config.tsk
config: {
    database: {
        default: "mysql"
        connections: {
            mysql: {
                driver: "mysql"
                host: @env("DB_HOST", "localhost")
                port: @env("DB_PORT", 3306)
                database: @env("DB_DATABASE", "myapp")
                username: @env("DB_USERNAME", "root")
                password: @env("DB_PASSWORD", "")
                charset: "utf8mb4"
                collation: "utf8mb4_unicode_ci"
                prefix: ""
                strict: true
                engine: "InnoDB"
            }
            
            postgres: {
                driver: "pgsql"
                host: @env("PG_HOST", "localhost")
                port: @env("PG_PORT", 5432)
                database: @env("PG_DATABASE", "myapp")
                username: @env("PG_USERNAME", "postgres")
                password: @env("PG_PASSWORD", "")
                charset: "utf8"
                prefix: ""
                schema: "public"
                sslmode: "prefer"
            }
            
            sqlite: {
                driver: "sqlite"
                database: @env("SQLITE_DATABASE", "database/database.sqlite")
                prefix: ""
                foreign_key_constraints: true
            }
        }
    }
}
```

## Basic Database Operations

```tusk
# Direct database queries
users: @db.query("SELECT * FROM users WHERE active = ?", [true])

# Insert data
@db.insert("INSERT INTO users (name, email) VALUES (?, ?)", [
    "John Doe",
    "john@example.com"
])

# Update data
affected: @db.update(
    "UPDATE users SET last_login = ? WHERE id = ?",
    [@now(), user_id]
)

# Delete data
@db.delete("DELETE FROM sessions WHERE expired_at < ?", [@now()])

# Transaction
@db.transaction((tx) => {
    tx.insert("INSERT INTO orders (user_id, total) VALUES (?, ?)", [user.id, total])
    order_id: tx.lastInsertId()
    
    for (item in cart_items) {
        tx.insert(
            "INSERT INTO order_items (order_id, product_id, quantity) VALUES (?, ?, ?)",
            [order_id, item.product_id, item.quantity]
        )
    }
    
    tx.update("UPDATE inventory SET stock = stock - ? WHERE product_id = ?", [
        item.quantity,
        item.product_id
    ])
})
```

## Query Builder

```tusk
# Fluent query builder
users: @db.table("users")
    .where("active", true)
    .where("created_at", ">", @days_ago(30))
    .orderBy("name")
    .limit(10)
    .get()

# Complex queries
results: @db.table("posts")
    .select("posts.*", "users.name as author_name")
    .join("users", "posts.user_id", "=", "users.id")
    .leftJoin("categories", "posts.category_id", "=", "categories.id")
    .where("posts.published", true)
    .whereIn("posts.status", ["active", "featured"])
    .whereBetween("posts.created_at", [start_date, end_date])
    .groupBy("posts.id")
    .having("COUNT(comments.id)", ">", 5)
    .orderBy("posts.created_at", "desc")
    .paginate(20)

# Aggregates
count: @db.table("users").count()
avg_age: @db.table("users").avg("age")
max_price: @db.table("products").max("price")
total: @db.table("orders").sum("total")
```

## Model System

```tusk
# Define a model
class User extends Model {
    table: "users"
    
    # Attributes
    fillable: ["name", "email", "password"]
    hidden: ["password", "remember_token"]
    casts: {
        email_verified_at: "datetime"
        is_active: "boolean"
    }
    
    # Relationships
    posts() {
        return @hasMany(Post)
    }
    
    profile() {
        return @hasOne(Profile)
    }
    
    roles() {
        return @belongsToMany(Role, "user_roles")
    }
    
    # Scopes
    scopeActive(query) {
        return query.where("is_active", true)
    }
    
    # Accessors
    getFullNameAttribute() {
        return this.first_name + " " + this.last_name
    }
    
    # Mutators
    setPasswordAttribute(value) {
        this.attributes["password"] = @bcrypt(value)
    }
}

# Using models
user: @User.find(1)
users: @User.where("active", true).get()
newUser: @User.create({
    name: "Jane Doe",
    email: "jane@example.com",
    password: "secret"
})
```

## Database Migrations

```tusk
# Create migration
#migration create_users_table {
    up() {
        @schema.create("users", (table) => {
            table.id()
            table.string("name")
            table.string("email").unique()
            table.timestamp("email_verified_at").nullable()
            table.string("password")
            table.rememberToken()
            table.timestamps()
            
            table.index(["email"])
        })
    }
    
    down() {
        @schema.dropIfExists("users")
    }
}

# Run migrations
@migrate.run()
@migrate.rollback()
@migrate.fresh()
```

## Database Features

### Connection Management
```tusk
# Use specific connection
users: @db.connection("postgres").table("users").get()

# Multiple database operations
@db.connection("analytics").table("events").insert(event_data)
@db.connection("main").table("users").update(user_data)
```

### Raw Expressions
```tusk
# Raw expressions in queries
users: @db.table("users")
    .select(@db.raw("COUNT(*) as user_count, DATE(created_at) as date"))
    .whereRaw("age > ? AND status = ?", [18, "active"])
    .groupBy(@db.raw("DATE(created_at)"))
    .get()
```

### Database Events
```tusk
# Listen to query events
@db.listen((query) => {
    @log.debug("Query executed", {
        sql: query.sql,
        bindings: query.bindings,
        time: query.time
    })
})
```

## Performance Optimization

```tusk
# Eager loading
users: @User.with(["posts", "posts.comments"]).get()

# Chunk processing
@User.chunk(100, (users) => {
    for (user in users) {
        @process_user(user)
    }
})

# Query caching
users: @cache.remember("all_users", 3600, () => {
    return @User.all()
})
```

## Database Security

```tusk
# Parameterized queries (automatic with query builder)
user: @db.table("users")
    .where("email", unsafe_email)  # Automatically escaped
    .first()

# Manual escaping
safe_string: @db.escape(unsafe_input)

# Prepared statements
stmt: @db.prepare("SELECT * FROM users WHERE id = ?")
user: stmt.execute([user_id])
```

## Testing Database

```tusk
# Database testing utilities
#test "User can be created" {
    # Use database transactions for tests
    @db.beginTransaction()
    
    user: @User.create({
        name: "Test User",
        email: "test@example.com"
    })
    
    @assert.equals(user.name, "Test User")
    @assert.true(@User.where("email", "test@example.com").exists())
    
    @db.rollback()  # Clean up
}

# Database factories
factory User {
    name: @faker.name()
    email: @faker.unique().email()
    password: @bcrypt("password")
    created_at: @faker.dateTimeBetween("-1 year", "now")
}

# Seeding
seeder UserSeeder {
    run() {
        @factory(User).count(50).create()
    }
}
```

## Best Practices

1. **Use the ORM** - Prefer models over raw queries
2. **Parameterize queries** - Never concatenate user input
3. **Use transactions** - For related operations
4. **Index properly** - Add indexes for frequently queried columns
5. **Eager load relationships** - Avoid N+1 queries
6. **Use migrations** - Version control your schema
7. **Handle connections** - Close connections properly
8. **Monitor queries** - Log slow queries in production

## Related Topics

- `query-builder` - Fluent query interface
- `orm-models` - Model definition and usage
- `migrations` - Database schema versioning
- `relationships` - Model relationships
- `database-transactions` - Transaction handling
---

[Query Builder in TuskLang]


The TuskLang query builder provides a fluent, intuitive interface for creating and executing database queries. It uses method chaining to construct complex queries in a readable way.

## Basic Query Building

```tusk
# Select queries
users: @db.table("users").get()

# Select specific columns
users: @db.table("users")
    .select("id", "name", "email")
    .get()

# First record
user: @db.table("users")
    .where("email", "john@example.com")
    .first()

# Single column value
email: @db.table("users")
    .where("id", 1)
    .value("email")

# Pluck column values
emails: @db.table("users")
    .where("active", true)
    .pluck("email")

# Key-value pairs
user_names: @db.table("users")
    .pluck("name", "id")  # {1: "John", 2: "Jane", ...}
```

## Where Clauses

```tusk
# Basic where
users: @db.table("users")
    .where("status", "active")
    .get()

# Where with operator
users: @db.table("users")
    .where("age", ">", 18)
    .where("created_at", "<=", @now())
    .get()

# Multiple where conditions
users: @db.table("users")
    .where([
        ["status", "=", "active"],
        ["age", ">", 18],
        ["email_verified", "=", true]
    ])
    .get()

# Or where
users: @db.table("users")
    .where("role", "admin")
    .orWhere("role", "moderator")
    .get()

# Where in
users: @db.table("users")
    .whereIn("id", [1, 2, 3, 4, 5])
    .get()

# Where not in
users: @db.table("users")
    .whereNotIn("status", ["banned", "suspended"])
    .get()

# Where null
users: @db.table("users")
    .whereNull("deleted_at")
    .get()

# Where not null
users: @db.table("users")
    .whereNotNull("email_verified_at")
    .get()

# Where between
orders: @db.table("orders")
    .whereBetween("total", [100, 500])
    .get()

# Where date
orders: @db.table("orders")
    .whereDate("created_at", "2024-01-15")
    .get()

# Where month/year/day
birthdays: @db.table("users")
    .whereMonth("birthday", 12)
    .whereDay("birthday", 25)
    .get()
```

## Advanced Where Clauses

```tusk
# Where exists
users: @db.table("users")
    .whereExists((query) => {
        query.select("*")
            .from("orders")
            .whereColumn("orders.user_id", "users.id")
    })
    .get()

# Where column comparison
users: @db.table("users")
    .whereColumn("first_name", "last_name")
    .get()

# Complex where groups
users: @db.table("users")
    .where("active", true)
    .where((query) => {
        query.where("age", ">", 18)
            .orWhere("parental_consent", true)
    })
    .get()

# Where JSON contains
users: @db.table("users")
    .whereJsonContains("preferences->notifications", "email")
    .get()

# Where JSON length
users: @db.table("users")
    .whereJsonLength("tags", ">", 5)
    .get()

# Full text search
articles: @db.table("articles")
    .whereFullText(["title", "content"], "TuskLang database")
    .get()
```

## Joins

```tusk
# Inner join
users: @db.table("users")
    .join("contacts", "users.id", "=", "contacts.user_id")
    .select("users.*", "contacts.phone")
    .get()

# Left join
posts: @db.table("posts")
    .leftJoin("users", "posts.user_id", "=", "users.id")
    .select("posts.*", "users.name as author")
    .get()

# Right join
categories: @db.table("categories")
    .rightJoin("posts", "categories.id", "=", "posts.category_id")
    .get()

# Cross join
colors: @db.table("colors")
    .crossJoin("sizes")
    .get()

# Advanced join clauses
orders: @db.table("orders")
    .join("users", (join) => {
        join.on("orders.user_id", "=", "users.id")
            .where("users.active", true)
            .orOn("orders.guest_email", "=", "users.email")
    })
    .get()

# Multiple joins
data: @db.table("posts")
    .join("users", "posts.user_id", "=", "users.id")
    .join("categories", "posts.category_id", "=", "categories.id")
    .leftJoin("comments", "posts.id", "=", "comments.post_id")
    .select(
        "posts.title",
        "users.name as author",
        "categories.name as category",
        @db.raw("COUNT(comments.id) as comment_count")
    )
    .groupBy("posts.id")
    .get()
```

## Ordering and Grouping

```tusk
# Order by
users: @db.table("users")
    .orderBy("name")
    .get()

# Order by descending
users: @db.table("users")
    .orderBy("created_at", "desc")
    .get()

# Multiple order by
users: @db.table("users")
    .orderBy("last_name")
    .orderBy("first_name")
    .get()

# Latest/oldest
latest_posts: @db.table("posts").latest().limit(5).get()
oldest_posts: @db.table("posts").oldest("published_at").limit(5).get()

# Random order
random_user: @db.table("users").inRandomOrder().first()

# Group by
sales: @db.table("orders")
    .select("user_id", @db.raw("SUM(total) as total_sales"))
    .groupBy("user_id")
    .get()

# Having clause
high_value_customers: @db.table("orders")
    .select("user_id", @db.raw("SUM(total) as total_spent"))
    .groupBy("user_id")
    .having("total_spent", ">", 1000)
    .get()
```

## Pagination

```tusk
# Simple pagination
users: @db.table("users").paginate(15)

# Pagination with custom page
page: @request.query.page || 1
users: @db.table("users").paginate(15, page)

# Simple paginate (more efficient)
users: @db.table("users").simplePaginate(15)

# Cursor pagination
users: @db.table("users")
    .orderBy("id")
    .cursorPaginate(15)

# Offset and limit
users: @db.table("users")
    .offset(20)
    .limit(10)
    .get()

# Skip and take (aliases)
users: @db.table("users")
    .skip(20)
    .take(10)
    .get()
```

## Aggregates

```tusk
# Count
total_users: @db.table("users").count()
active_users: @db.table("users").where("active", true).count()

# Count distinct
unique_emails: @db.table("users").count("email", true)

# Sum
total_revenue: @db.table("orders").sum("total")

# Average
average_age: @db.table("users").avg("age")
average_order: @db.table("orders").average("total")  # Alias

# Min/Max
min_price: @db.table("products").min("price")
max_price: @db.table("products").max("price")

# Aggregate with conditions
avg_active_user_age: @db.table("users")
    .where("active", true)
    .avg("age")

# Multiple aggregates
stats: @db.table("products")
    .select(
        @db.raw("COUNT(*) as total"),
        @db.raw("AVG(price) as avg_price"),
        @db.raw("MIN(price) as min_price"),
        @db.raw("MAX(price) as max_price")
    )
    .first()
```

## Inserts

```tusk
# Single insert
@db.table("users").insert({
    name: "John Doe",
    email: "john@example.com",
    created_at: @now()
})

# Insert with ID return
user_id: @db.table("users").insertGetId({
    name: "Jane Doe",
    email: "jane@example.com"
})

# Multiple inserts
@db.table("users").insert([
    {name: "User 1", email: "user1@example.com"},
    {name: "User 2", email: "user2@example.com"},
    {name: "User 3", email: "user3@example.com"}
])

# Insert or ignore
@db.table("users").insertOrIgnore({
    email: "existing@example.com",
    name: "New User"
})

# Upsert
@db.table("users").upsert(
    [{email: "john@example.com", name: "John Updated"}],
    ["email"],  # Unique keys
    ["name"]    # Columns to update
)
```

## Updates

```tusk
# Update records
@db.table("users")
    .where("id", 1)
    .update({
        name: "Updated Name",
        updated_at: @now()
    })

# Increment/Decrement
@db.table("users")
    .where("id", 1)
    .increment("points", 10)

@db.table("products")
    .where("id", 5)
    .decrement("stock", 1)

# Update with additional columns
@db.table("users")
    .where("id", 1)
    .increment("points", 10, {
        updated_at: @now()
    })

# Update or insert
@db.table("users").updateOrInsert(
    {email: "john@example.com"},  # Search conditions
    {name: "John Doe", active: true}  # Values
)

# JSON updates
@db.table("users")
    .where("id", 1)
    .update({
        "preferences->theme": "dark",
        "preferences->notifications->email": true
    })
```

## Deletes

```tusk
# Delete records
@db.table("users")
    .where("active", false)
    .delete()

# Soft deletes (if model uses SoftDeletes)
@db.table("posts")
    .where("id", 1)
    .update({deleted_at: @now()})

# Truncate table
@db.table("temp_data").truncate()
```

## Raw Queries

```tusk
# Raw expressions in select
users: @db.table("users")
    .select(
        "name",
        @db.raw("CONCAT(first_name, ' ', last_name) as full_name"),
        @db.raw("YEAR(CURDATE()) - YEAR(birth_date) as age")
    )
    .get()

# Raw where clauses
users: @db.table("users")
    .whereRaw("age > ? AND status = ?", [18, "active"])
    .get()

# Raw order by
users: @db.table("users")
    .orderByRaw("FIELD(status, 'premium', 'active', 'inactive')")
    .get()

# Completely raw queries
results: @db.select("SELECT * FROM users WHERE id = :id", {id: 1})
@db.statement("DROP TABLE old_table")
```

## Query Debugging

```tusk
# Get SQL query
query: @db.table("users")
    .where("active", true)
    .orderBy("name")

sql: query.toSql()
bindings: query.getBindings()

# Dump and die
@db.table("users")
    .where("active", true)
    .dd()  # Dumps query and stops execution

# Dump and continue
@db.table("users")
    .where("active", true)
    .dump()  # Dumps query but continues
    .get()

# Explain query
explanation: @db.table("users")
    .where("active", true)
    .explain()
```

## Advanced Features

```tusk
# Subqueries
users: @db.table("users")
    .select("*")
    .whereIn("id", (query) => {
        query.select("user_id")
            .from("orders")
            .where("total", ">", 100)
    })
    .get()

# Conditional clauses
users: @db.table("users")
    .when(search_term, (query, value) => {
        query.where("name", "like", "%" + value + "%")
    })
    .when(only_active, (query) => {
        query.where("active", true)
    })
    .get()

# Unions
first: @db.table("users").where("active", true)
second: @db.table("users").where("premium", true)

users: first.union(second).get()

# Clone query
base_query: @db.table("users").where("active", true)

admins: base_query.clone().where("role", "admin").get()
moderators: base_query.clone().where("role", "moderator").get()
```

## Best Practices

1. **Use parameter binding** - Never concatenate values into queries
2. **Select only needed columns** - Don't use SELECT * in production
3. **Use indexes** - Ensure WHERE columns are indexed
4. **Limit results** - Always paginate large datasets
5. **Avoid N+1 queries** - Use joins or eager loading
6. **Use transactions** - For multiple related operations
7. **Monitor slow queries** - Log queries over threshold
8. **Cache when possible** - Cache expensive queries

## Related Topics

- `database-overview` - Database configuration
- `orm-models` - Using Eloquent models
- `database-transactions` - Transaction handling
- `raw-queries` - Raw SQL execution
- `query-optimization` - Performance tips
---

[ORM Models in TuskLang]


TuskLang's ORM (Object-Relational Mapping) provides an elegant ActiveRecord implementation for working with your database. Each database table has a corresponding "Model" which is used to interact with that table.

## Defining Models

```tusk
# Basic model definition
class User extends Model {
    # Table name (optional, defaults to plural of class name)
    table: "users"
    
    # Primary key (optional, defaults to 'id')
    primaryKey: "id"
    
    # Indicates if the model should be timestamped
    timestamps: true
    
    # The attributes that are mass assignable
    fillable: ["name", "email", "password"]
    
    # The attributes that should be hidden for arrays/JSON
    hidden: ["password", "remember_token"]
    
    # The attributes that should be cast
    casts: {
        email_verified_at: "datetime",
        is_admin: "boolean",
        preferences: "array",
        metadata: "json"
    }
    
    # Default attribute values
    attributes: {
        is_active: true,
        role: "user"
    }
}
```

## Basic CRUD Operations

```tusk
# Create
# Method 1: Using create
user: @User.create({
    name: "John Doe",
    email: "john@example.com",
    password: "secret"
})

# Method 2: Using save
user: new User()
user.name: "Jane Doe"
user.email: "jane@example.com"
user.password: "secret"
user.save()

# Method 3: Using fill
user: new User()
user.fill({
    name: "Bob Smith",
    email: "bob@example.com"
}).save()

# Read
# Find by primary key
user: @User.find(1)
users: @User.find([1, 2, 3])  # Multiple

# Find with exception if not found
user: @User.findOrFail(1)

# First record
user: @User.first()
user: @User.where("email", "john@example.com").first()

# All records
users: @User.all()

# Update
# Method 1: Update on instance
user: @User.find(1)
user.name: "Updated Name"
user.save()

# Method 2: Mass update
user.update({
    name: "New Name",
    email: "newemail@example.com"
})

# Method 3: Update multiple
@User.where("active", false)
    .update({last_notified_at: @now()})

# Delete
# Delete single
user: @User.find(1)
user.delete()

# Delete multiple
@User.where("created_at", "<", @days_ago(365)).delete()

# Soft delete (if model uses SoftDeletes)
user.delete()  # Sets deleted_at timestamp
user.forceDelete()  # Permanent delete
```

## Querying Models

```tusk
# Where conditions
users: @User.where("status", "active").get()
users: @User.where("age", ">", 18).get()

# Multiple conditions
users: @User.where("status", "active")
    .where("age", ">", 18)
    .get()

# Or conditions
users: @User.where("role", "admin")
    .orWhere("role", "moderator")
    .get()

# Advanced queries
users: @User.whereIn("id", [1, 2, 3])
    .whereNotNull("email_verified_at")
    .orderBy("created_at", "desc")
    .limit(10)
    .get()

# Conditional queries
users: @User
    .when(request.active_only, (query) => {
        query.where("active", true)
    })
    .when(request.search, (query, search) => {
        query.where("name", "like", "%" + search + "%")
    })
    .get()
```

## Eloquent Collections

```tusk
# Collections provide powerful array-like methods
users: @User.all()

# Filter
active_users: users.filter(user => user.active)

# Map
user_names: users.map(user => user.name)

# Reduce
total_age: users.reduce((sum, user) => sum + user.age, 0)

# Pluck
emails: users.pluck("email")

# Group by
users_by_role: users.groupBy("role")

# Sort
sorted_users: users.sortBy("created_at")

# Chunk
users.chunk(100).each(chunk => {
    @process_users(chunk)
})
```

## Model Relationships

```tusk
class User extends Model {
    # One to One
    profile() {
        return @hasOne(Profile)
    }
    
    # One to Many
    posts() {
        return @hasMany(Post)
    }
    
    # Many to Many
    roles() {
        return @belongsToMany(Role, "user_roles")
            .withPivot("assigned_at")
            .withTimestamps()
    }
    
    # Has Many Through
    comments() {
        return @hasManyThrough(Comment, Post)
    }
    
    # Polymorphic Relations
    notifications() {
        return @morphMany(Notification, "notifiable")
    }
}

class Post extends Model {
    # Inverse relationships
    author() {
        return @belongsTo(User, "user_id")
    }
    
    comments() {
        return @hasMany(Comment)
    }
    
    tags() {
        return @belongsToMany(Tag)
    }
}

# Using relationships
user: @User.find(1)
posts: user.posts  # Lazy load
user: @User.with("posts").find(1)  # Eager load

# Query relationships
users_with_posts: @User.has("posts").get()
users_with_many_posts: @User.has("posts", ">", 5).get()
users_without_posts: @User.doesntHave("posts").get()

# Query relationship existence with conditions
users: @User.whereHas("posts", (query) => {
    query.where("published", true)
}).get()
```

## Eager Loading

```tusk
# Basic eager loading
users: @User.with("posts").get()

# Multiple relationships
users: @User.with(["posts", "profile"]).get()

# Nested eager loading
users: @User.with("posts.comments").get()

# Conditional eager loading
users: @User.with(["posts" => (query) => {
    query.where("published", true)
}]).get()

# Lazy eager loading
users: @User.all()
users.load("posts")  # Load after retrieval

# Count eager loading
users: @User.withCount("posts").get()
// Access via user.posts_count
```

## Model Scopes

```tusk
class User extends Model {
    # Local scopes
    scopeActive(query) {
        return query.where("active", true)
    }
    
    scopeOfRole(query, role) {
        return query.where("role", role)
    }
    
    scopeRegisteredBetween(query, start, end) {
        return query.whereBetween("created_at", [start, end])
    }
    
    # Global scopes
    boot() {
        super.boot()
        
        # Apply to all queries
        @addGlobalScope("active", (query) => {
            query.where("active", true)
        })
    }
}

# Using scopes
active_users: @User.active().get()
admins: @User.ofRole("admin").get()
recent: @User.registeredBetween(start_date, end_date).get()

# Combining scopes
active_admins: @User.active().ofRole("admin").get()

# Remove global scopes
all_users: @User.withoutGlobalScope("active").get()
```

## Accessors and Mutators

```tusk
class User extends Model {
    # Accessor - modify attribute when retrieving
    getFullNameAttribute() {
        return this.first_name + " " + this.last_name
    }
    
    getAgeAttribute() {
        return @date_diff(this.birth_date, @now(), "years")
    }
    
    # Mutator - modify attribute when setting
    setPasswordAttribute(value) {
        this.attributes.password: @bcrypt(value)
    }
    
    setEmailAttribute(value) {
        this.attributes.email: value.toLowerCase()
    }
    
    # Date mutators
    dates: ["created_at", "updated_at", "published_at"]
    
    # Custom date format
    dateFormat: "Y-m-d H:i:s"
}

# Using accessors
user: @User.find(1)
full_name: user.full_name  # Calls getFullNameAttribute()
age: user.age

# Using mutators
user.password: "newsecret"  # Automatically hashed
user.email: "JOHN@EXAMPLE.COM"  # Stored as lowercase
```

## Model Events

```tusk
class User extends Model {
    # Boot method for registering events
    boot() {
        super.boot()
        
        # Before creating
        @creating((user) => {
            user.uuid: @generate_uuid()
            user.api_token: @generate_token()
        })
        
        # After creating
        @created((user) => {
            @send_welcome_email(user)
            @create_default_settings(user)
        })
        
        # Before saving
        @saving((user) => {
            user.slug: @slugify(user.name)
        })
        
        # After deleting
        @deleted((user) => {
            @cleanup_user_data(user)
        })
    }
}

# Available events:
# - creating, created
# - updating, updated  
# - saving, saved
# - deleting, deleted
# - restoring, restored (soft deletes)

# Using observers
class UserObserver {
    creating(user) {
        @log.info("Creating user: " + user.email)
    }
    
    updated(user) {
        if (user.isDirty("email")) {
            @send_email_change_notification(user)
        }
    }
    
    deleting(user) {
        if (user.posts().count() > 0) {
            throw "Cannot delete user with posts"
        }
    }
}

# Register observer
@User.observe(UserObserver)
```

## Advanced Model Features

```tusk
# Soft deletes
class Post extends Model {
    use SoftDeletes
    
    dates: ["deleted_at"]
}

# Query soft deleted models
all_posts: @Post.withTrashed().get()
only_trashed: @Post.onlyTrashed().get()

# Restore soft deleted
post: @Post.withTrashed().find(1)
post.restore()

# Model replication
user: @User.find(1)
new_user: user.replicate()
new_user.email: "new@example.com"
new_user.save()

# Model comparison
if (user.is(another_user)) {
    // Same model instance
}

if (user.isNot(another_user)) {
    // Different model instances
}

# Dirty checking
user: @User.find(1)
user.name: "New Name"

if (user.isDirty()) {
    // Model has unsaved changes
    dirty_fields: user.getDirty()
}

if (user.isDirty("name")) {
    original: user.getOriginal("name")
}

# Mass assignment protection
user: @User.find(1)
user.forceFill({
    name: "Admin Override",
    is_admin: true  // Even if not in fillable
})
```

## Model Serialization

```tusk
# Convert to array
user: @User.find(1)
array: user.toArray()

# Convert to JSON
json: user.toJson()

# Customize serialization
class User extends Model {
    # Hide attributes
    hidden: ["password", "remember_token"]
    
    # Make visible conditionally
    makeVisible(attributes) {
        if (@auth.user?.is_admin) {
            return super.makeVisible(["email", "phone"])
        }
        return this
    }
    
    # Append custom attributes
    appends: ["full_name", "age"]
    
    # Custom serialization
    toArray() {
        data: super.toArray()
        
        // Add computed fields
        data.posts_count: this.posts().count()
        data.is_premium: this.isPremium()
        
        return data
    }
}
```

## Best Practices

1. **Use mass assignment protection** - Define fillable attributes
2. **Leverage relationships** - Define and use proper relationships
3. **Use scopes** - Encapsulate common queries
4. **Implement accessors/mutators** - Handle data transformation
5. **Use eager loading** - Prevent N+1 queries
6. **Handle model events** - Centralize business logic
7. **Use transactions** - Ensure data integrity
8. **Cache expensive operations** - Improve performance

## Related Topics

- `database-overview` - Database setup and configuration
- `query-builder` - Query builder methods
- `relationships` - Detailed relationship types
- `model-events` - Model lifecycle events
- `model-factories` - Testing with factories
---

[Database Migrations in TuskLang]


Migrations are version control for your database, allowing you to define and share your application's database schema. They work hand-in-hand with TuskLang's schema builder to manage your database structure.

## Creating Migrations

```tusk
# Basic migration structure
#migration create_users_table {
    # Run the migration
    up() {
        @schema.create("users", (table) => {
            table.id()
            table.string("name")
            table.string("email").unique()
            table.string("password")
            table.timestamps()
        })
    }
    
    # Reverse the migration
    down() {
        @schema.dropIfExists("users")
    }
}

# Migration with custom timestamp
#migration 2024_01_15_120000_create_posts_table {
    up() {
        @schema.create("posts", (table) => {
            table.id()
            table.string("title")
            table.text("content")
            table.unsignedBigInteger("user_id")
            table.foreign("user_id").references("users.id")
            table.timestamps()
        })
    }
    
    down() {
        @schema.dropIfExists("posts")
    }
}
```

## Table Operations

```tusk
# Creating tables
#migration create_products_table {
    up() {
        @schema.create("products", (table) => {
            table.id()
            table.string("name", 100)
            table.text("description").nullable()
            table.decimal("price", 10, 2)
            table.integer("stock").default(0)
            table.boolean("active").default(true)
            table.timestamps()
            
            # Indexes
            table.index("name")
            table.index(["active", "created_at"])
        })
    }
    
    down() {
        @schema.drop("products")
    }
}

# Modifying tables
#migration add_fields_to_users_table {
    up() {
        @schema.table("users", (table) => {
            table.string("phone").nullable().after("email")
            table.date("birth_date").nullable()
            table.enum("role", ["user", "admin", "moderator"]).default("user")
            table.json("preferences").nullable()
        })
    }
    
    down() {
        @schema.table("users", (table) => {
            table.dropColumn(["phone", "birth_date", "role", "preferences"])
        })
    }
}

# Renaming tables
#migration rename_products_to_items {
    up() {
        @schema.rename("products", "items")
    }
    
    down() {
        @schema.rename("items", "products")
    }
}
```

## Column Types

```tusk
#migration create_comprehensive_table {
    up() {
        @schema.create("examples", (table) => {
            # Numeric types
            table.id()  # Auto-incrementing UNSIGNED BIGINT
            table.integer("count")
            table.tinyInteger("status")
            table.smallInteger("quantity")
            table.mediumInteger("size")
            table.bigInteger("views")
            table.unsignedInteger("positive_only")
            table.float("percentage", 8, 2)
            table.double("amount", 15, 2)
            table.decimal("price", 10, 2)
            
            # String types
            table.char("code", 10)
            table.string("name", 255)  # VARCHAR
            table.text("description")
            table.mediumText("content")
            table.longText("body")
            
            # Date/Time types
            table.date("birth_date")
            table.dateTime("published_at", 0)  # Precision
            table.dateTimeTz("scheduled_at", 0)
            table.time("duration", 0)
            table.timeTz("meeting_time", 0)
            table.timestamp("created_at", 0)
            table.timestampTz("updated_at", 0)
            table.timestamps()  # created_at and updated_at
            table.timestampsTz()
            table.year("birth_year")
            
            # Binary types
            table.binary("data")
            table.blob("file_content")
            
            # Boolean
            table.boolean("is_active")
            
            # JSON
            table.json("metadata")
            table.jsonb("settings")  # Binary JSON (PostgreSQL)
            
            # UUID
            table.uuid("uuid")
            
            # IP Address
            table.ipAddress("visitor_ip")
            table.macAddress("device_mac")
            
            # Geometry (MySQL/PostgreSQL)
            table.geometry("position")
            table.point("location")
            table.lineString("route")
            table.polygon("area")
            
            # Special columns
            table.rememberToken()  # remember_token VARCHAR(100)
            table.morphs("taggable")  # taggable_type, taggable_id
            table.uuidMorphs("tokenable")  # UUID morphs
            table.softDeletes()  # deleted_at timestamp
            table.softDeletesTz()  # deleted_at timestampTz
        })
    }
    
    down() {
        @schema.dropIfExists("examples")
    }
}
```

## Column Modifiers

```tusk
#migration create_table_with_modifiers {
    up() {
        @schema.create("users", (table) => {
            # Modifiers
            table.string("email").unique()
            table.string("username").nullable()
            table.integer("age").unsigned()
            table.decimal("balance").default(0.00)
            table.text("bio").comment("User biography")
            table.timestamp("verified_at").useCurrent()
            table.timestamp("updated_at").useCurrentOnUpdate()
            
            # Column placement
            table.string("middle_name").after("first_name")
            table.boolean("is_admin").first()  # Place first
            
            # Multiple modifiers
            table.string("status")
                .default("pending")
                .nullable()
                .comment("User account status")
            
            # Invisible columns (MySQL 8.0.23+)
            table.string("secret_key").invisible()
            
            # Virtual/Stored columns
            table.string("full_name").virtualAs("CONCAT(first_name, ' ', last_name)")
            table.integer("age").storedAs("YEAR(CURDATE()) - YEAR(birth_date)")
        })
    }
    
    down() {
        @schema.dropIfExists("users")
    }
}
```

## Indexes and Constraints

```tusk
#migration create_indexes_and_constraints {
    up() {
        @schema.create("posts", (table) => {
            table.id()
            table.string("slug")
            table.string("title")
            table.text("content")
            table.unsignedBigInteger("user_id")
            table.unsignedBigInteger("category_id").nullable()
            table.integer("views").default(0)
            table.boolean("published").default(false)
            table.timestamps()
            
            # Simple index
            table.index("slug")
            
            # Named index
            table.index("user_id", "posts_author_index")
            
            # Composite index
            table.index(["published", "created_at"])
            
            # Unique index
            table.unique("slug")
            
            # Spatial index (MySQL/PostgreSQL)
            table.spatialIndex("location")
            
            # Full text index (MySQL)
            table.fullText(["title", "content"])
            
            # Foreign key constraints
            table.foreign("user_id")
                .references("id")
                .on("users")
                .onDelete("cascade")
                .onUpdate("cascade")
            
            table.foreign("category_id")
                .references("id")
                .on("categories")
                .onDelete("set null")
        })
    }
    
    down() {
        @schema.table("posts", (table) => {
            # Drop foreign keys first
            table.dropForeign(["user_id"])
            table.dropForeign(["category_id"])
        })
        
        @schema.dropIfExists("posts")
    }
}

# Adding/dropping indexes to existing tables
#migration add_indexes_to_users {
    up() {
        @schema.table("users", (table) => {
            # Add indexes
            table.index("email", "users_email_index")
            table.unique(["email", "deleted_at"], "unique_active_email")
        })
    }
    
    down() {
        @schema.table("users", (table) => {
            # Drop indexes
            table.dropIndex("users_email_index")
            table.dropUnique("unique_active_email")
        })
    }
}
```

## Modifying Columns

```tusk
#migration modify_users_table {
    up() {
        @schema.table("users", (table) => {
            # Change column type
            table.string("name", 200).change()
            
            # Add nullable
            table.date("birth_date").nullable().change()
            
            # Remove nullable
            table.string("email").nullable(false).change()
            
            # Change default
            table.boolean("active").default(true).change()
            
            # Rename column
            table.renameColumn("name", "full_name")
            
            # Drop column
            table.dropColumn("unnecessary_field")
            
            # Drop multiple columns
            table.dropColumn(["field1", "field2", "field3"])
            
            # Drop timestamps
            table.dropTimestamps()
            
            # Drop soft deletes
            table.dropSoftDeletes()
        })
    }
    
    down() {
        @schema.table("users", (table) => {
            # Reverse changes
            table.string("full_name", 255).change()
            table.date("birth_date").nullable(false).change()
            table.string("email").nullable().change()
            table.boolean("active").default(false).change()
            table.renameColumn("full_name", "name")
            table.string("unnecessary_field")
            table.timestamps()
            table.softDeletes()
        })
    }
}
```

## Advanced Migration Features

```tusk
# Conditional migrations
#migration conditional_changes {
    up() {
        # Only create if doesn't exist
        if (!@schema.hasTable("settings")) {
            @schema.create("settings", (table) => {
                table.id()
                table.string("key").unique()
                table.text("value")
            })
        }
        
        # Only add column if doesn't exist
        if (!@schema.hasColumn("users", "avatar")) {
            @schema.table("users", (table) => {
                table.string("avatar").nullable()
            })
        }
    }
    
    down() {
        @schema.dropIfExists("settings")
        
        if (@schema.hasColumn("users", "avatar")) {
            @schema.table("users", (table) => {
                table.dropColumn("avatar")
            })
        }
    }
}

# Database-specific operations
#migration database_specific {
    up() {
        # PostgreSQL specific
        if (@db.getDriverName() == "pgsql") {
            @db.statement("CREATE EXTENSION IF NOT EXISTS 'uuid-ossp'")
            
            @schema.create("documents", (table) => {
                table.uuid("id").primary().default(@db.raw("uuid_generate_v4()"))
                table.jsonb("data")
                table.tsvector("search_vector")
            })
        }
        
        # MySQL specific
        if (@db.getDriverName() == "mysql") {
            @db.statement("SET FOREIGN_KEY_CHECKS=0")
            // Perform operations
            @db.statement("SET FOREIGN_KEY_CHECKS=1")
        }
    }
    
    down() {
        @schema.dropIfExists("documents")
    }
}

# Data migrations
#migration migrate_user_data {
    up() {
        # Add new column
        @schema.table("users", (table) => {
            table.string("full_name").nullable()
        })
        
        # Migrate data
        users: @db.table("users").get()
        for (user in users) {
            @db.table("users")
                .where("id", user.id)
                .update({
                    full_name: user.first_name + " " + user.last_name
                })
        }
        
        # Drop old columns
        @schema.table("users", (table) => {
            table.dropColumn(["first_name", "last_name"])
        })
    }
    
    down() {
        # Reverse the process
        @schema.table("users", (table) => {
            table.string("first_name").nullable()
            table.string("last_name").nullable()
        })
        
        users: @db.table("users").get()
        for (user in users) {
            parts: user.full_name?.split(" ") || ["", ""]
            @db.table("users")
                .where("id", user.id)
                .update({
                    first_name: parts[0],
                    last_name: parts[1] || ""
                })
        }
        
        @schema.table("users", (table) => {
            table.dropColumn("full_name")
        })
    }
}
```

## Running Migrations

```tusk
# CLI commands
@cli.command("migrate", () => {
    @migrate.run()
})

@cli.command("migrate:rollback", () => {
    @migrate.rollback()
})

@cli.command("migrate:fresh", () => {
    @migrate.fresh()  # Drop all tables and re-run
})

@cli.command("migrate:status", () => {
    @migrate.status()  # Show migration status
})

# Programmatic usage
#web /admin/migrate {
    #auth role: "super-admin"
    
    if (@request.method == "POST") {
        try {
            @migrate.run()
            @flash("success", "Migrations completed successfully")
        } catch (e) {
            @flash("error", "Migration failed: " + e.message)
        }
    }
    
    status: @migrate.getStatus()
    @render("admin/migrations.tusk", {status})
}
```

## Migration Batches and Rollback

```tusk
# Migrations are run in batches
# Each run creates a new batch number
# Rollback removes the last batch

# Custom batch handling
#migration complex_migration {
    batch: 5  # Force specific batch number
    
    up() {
        // Migration logic
    }
    
    down() {
        // Rollback logic
    }
}

# Step-by-step rollback
@migrate.rollback({steps: 3})  # Rollback last 3 migrations

# Rollback to specific batch
@migrate.rollbackTo({batch: 5})
```

## Best Practices

1. **Always provide down() method** - Make migrations reversible
2. **Test migrations** - Run up and down in development
3. **Keep migrations focused** - One concern per migration
4. **Use descriptive names** - Clear migration purpose
5. **Don't modify old migrations** - Create new ones instead
6. **Handle data carefully** - Backup before data migrations
7. **Consider performance** - Large tables need careful handling
8. **Use transactions** - Wrap complex operations

## Related Topics

- `database-overview` - Database configuration
- `schema-builder` - Schema building methods
- `seeding` - Database seeding
- `testing-databases` - Testing with migrations
- `deployment` - Migration strategies
---

[Model Relationships in TuskLang]


TuskLang's ORM provides a rich set of relationship types to express how your database tables relate to each other. Relationships are defined as methods on your model classes.

## One To One Relationships

```tusk
# User has one Profile
class User extends Model {
    profile() {
        return @hasOne(Profile)
    }
    
    # With custom foreign key
    address() {
        return @hasOne(Address, "user_id")
    }
    
    # With custom foreign and local keys
    passport() {
        return @hasOne(Passport, "citizen_id", "national_id")
    }
}

# Inverse relationship
class Profile extends Model {
    user() {
        return @belongsTo(User)
    }
    
    # With custom keys
    owner() {
        return @belongsTo(User, "user_id", "id")
    }
}

# Usage
user: @User.find(1)
profile: user.profile  # Lazy load

# Eager loading
user: @User.with("profile").find(1)

# Create related model
user.profile().create({
    bio: "Software developer",
    website: "example.com"
})

# Update related model
user.profile().update({
    bio: "Senior software developer"
})
```

## One To Many Relationships

```tusk
# User has many Posts
class User extends Model {
    posts() {
        return @hasMany(Post)
    }
    
    # With constraints
    publishedPosts() {
        return @hasMany(Post).where("published", true)
    }
    
    # With ordering
    recentPosts() {
        return @hasMany(Post)
            .orderBy("created_at", "desc")
            .limit(5)
    }
}

# Inverse relationship
class Post extends Model {
    author() {
        return @belongsTo(User, "user_id")
    }
}

# Usage
user: @User.find(1)
posts: user.posts  # Collection of posts

# Add conditions
recent_posts: user.posts.where("created_at", ">", @days_ago(7)).get()

# Count related
post_count: user.posts.count()

# Create related
new_post: user.posts().create({
    title: "New Post",
    content: "Post content..."
})

# Create multiple
user.posts().createMany([
    {title: "Post 1", content: "Content 1"},
    {title: "Post 2", content: "Content 2"}
])

# Attach existing
existing_post: @Post.find(5)
user.posts().save(existing_post)
```

## Many To Many Relationships

```tusk
# User belongs to many Roles
class User extends Model {
    roles() {
        return @belongsToMany(Role)
        # Uses 'user_roles' pivot table
    }
    
    # With custom pivot table
    groups() {
        return @belongsToMany(Group, "group_members")
    }
    
    # With custom keys
    projects() {
        return @belongsToMany(
            Project,
            "project_members",  # Pivot table
            "member_id",        # Foreign key on pivot
            "project_id",       # Related key on pivot
            "id",               # Local key
            "id"                # Related key
        )
    }
    
    # With pivot data
    teams() {
        return @belongsToMany(Team)
            .withPivot(["role", "joined_at"])
            .withTimestamps()
            .wherePivot("active", true)
    }
}

# Inverse relationship
class Role extends Model {
    users() {
        return @belongsToMany(User)
    }
}

# Usage
user: @User.find(1)
roles: user.roles

# Attach relationships
user.roles().attach(role_id)
user.roles().attach(role_id, {expires_at: @days_from_now(30)})
user.roles().attach({
    1: {expires_at: @days_from_now(30)},
    2: {expires_at: @days_from_now(60)}
})

# Detach relationships
user.roles().detach(role_id)
user.roles().detach([1, 2, 3])
user.roles().detach()  # Detach all

# Sync relationships
user.roles().sync([1, 2, 3])  # Only these roles
user.roles().sync({
    1: {expires_at: @days_from_now(30)},
    2: {expires_at: @days_from_now(60)}
})
user.roles().syncWithoutDetaching([1, 2])  # Add without removing

# Toggle relationships
user.roles().toggle([1, 2, 3])  # Attach if not attached, detach if attached

# Access pivot data
for (role in user.roles) {
    role_name: role.name
    assigned_at: role.pivot.created_at
    expires_at: role.pivot.expires_at
    role_in_team: role.pivot.role
}

# Query pivot table
active_roles: user.roles()
    .wherePivot("active", true)
    .wherePivot("expires_at", ">", @now())
    .get()
```

## Has One/Many Through

```tusk
# Country has many Posts through Users
class Country extends Model {
    posts() {
        return @hasManyThrough(Post, User)
    }
    
    # With custom keys
    comments() {
        return @hasManyThrough(
            Comment,           # Final model
            User,             # Intermediate model
            "country_id",     # Foreign key on intermediate
            "user_id",        # Foreign key on final
            "id",             # Local key
            "id"              # Local key on intermediate
        )
    }
}

# Mechanic has one Car Owner through Car
class Mechanic extends Model {
    carOwner() {
        return @hasOneThrough(Owner, Car)
    }
}

# Usage
country: @Country.find(1)
posts: country.posts  # All posts by users in this country

# With conditions
recent_posts: country.posts()
    .where("published", true)
    .orderBy("created_at", "desc")
    .get()
```

## Polymorphic Relationships

```tusk
# One-to-Many Polymorphic
# Multiple models can have comments
class Comment extends Model {
    # Get the parent commentable model
    commentable() {
        return @morphTo()
    }
}

class Post extends Model {
    comments() {
        return @morphMany(Comment, "commentable")
    }
}

class Video extends Model {
    comments() {
        return @morphMany(Comment, "commentable")
    }
}

# Usage
post: @Post.find(1)
comments: post.comments

video: @Video.find(1)
comments: video.comments

# Create polymorphic relation
post.comments().create({
    body: "Great post!"
})

# Get parent from polymorphic model
comment: @Comment.find(1)
parent: comment.commentable  # Post or Video instance

# Many-to-Many Polymorphic
# Multiple models can have tags
class Tag extends Model {
    posts() {
        return @morphedByMany(Post, "taggable")
    }
    
    videos() {
        return @morphedByMany(Video, "taggable")
    }
}

class Post extends Model {
    tags() {
        return @morphToMany(Tag, "taggable")
    }
}

class Video extends Model {
    tags() {
        return @morphToMany(Tag, "taggable")
    }
}

# One-to-One Polymorphic
class Image extends Model {
    imageable() {
        return @morphTo()
    }
}

class User extends Model {
    image() {
        return @morphOne(Image, "imageable")
    }
}

class Post extends Model {
    image() {
        return @morphOne(Image, "imageable")
    }
}
```

## Eager Loading

```tusk
# Basic eager loading
users: @User.with("posts").get()

# Multiple relationships
users: @User.with(["posts", "profile"]).get()

# Nested eager loading
users: @User.with("posts.comments").get()

# Eager load with constraints
users: @User.with(["posts" => (query) => {
    query.where("published", true)
        .orderBy("created_at", "desc")
}]).get()

# Eager load counts
users: @User.withCount("posts").get()
// Access via user.posts_count

# Multiple counts with constraints
users: @User.withCount([
    "posts",
    "posts as published_posts_count" => (query) => {
        query.where("published", true)
    }
]).get()

# Lazy eager loading
users: @User.all()
users.load("posts")  # Load after retrieval

# Conditional eager loading
users: @User.all()
if (include_posts) {
    users.load("posts")
}
```

## Querying Relationships

```tusk
# Query existence
users_with_posts: @User.has("posts").get()
users_with_many_posts: @User.has("posts", ">", 5).get()
users_without_posts: @User.doesntHave("posts").get()

# Query with conditions
users: @User.whereHas("posts", (query) => {
    query.where("published", true)
}).get()

# Count constraint
users: @User.whereHas("posts", (query) => {
    query.where("published", true)
}, ">", 10).get()

# Or conditions
users: @User.whereHas("posts")
    .orWhereHas("comments")
    .get()

# Nested relationship queries
users: @User.whereHas("posts.comments", (query) => {
    query.where("approved", true)
}).get()

# Query missing relationships
users: @User.whereDoesntHave("posts", (query) => {
    query.where("published", true)
}).get()

# Polymorphic queries
comments: @Comment.whereHasMorph(
    "commentable",
    [Post, Video],
    (query) => {
        query.where("active", true)
    }
).get()
```

## Advanced Relationship Features

```tusk
# Default models
class User extends Model {
    profile() {
        return @hasOne(Profile).withDefault()
    }
    
    settings() {
        return @hasOne(Settings).withDefault({
            theme: "light",
            notifications: true
        })
    }
}

# Touching parent timestamps
class Comment extends Model {
    touches: ["post"]  # Update post's updated_at when comment changes
    
    post() {
        return @belongsTo(Post)
    }
}

# Counting related models
class Post extends Model {
    boot() {
        super.boot()
        
        # Automatically maintain comment count
        @hasMany(Comment).countingTo("comment_count")
    }
}

# Custom relationship classes
class HasManyPremium extends HasMany {
    construct() {
        super.construct()
        @where("is_premium", true)
    }
}

class User extends Model {
    premiumPosts() {
        return new HasManyPremium(Post, "user_id")
    }
}

# Relationship events
user.posts().creating((post) => {
    post.slug: @slugify(post.title)
})

user.roles().attaching((role_id, pivot_data) => {
    @log("Attaching role", {user: user.id, role: role_id})
})

user.roles().detached((role_ids) => {
    @cache.forget("user." + user.id + ".permissions")
})
```

## Performance Optimization

```tusk
# Prevent N+1 queries
# Bad
users: @User.all()
for (user in users) {
    posts: user.posts  # N+1 query problem
}

# Good
users: @User.with("posts").get()
for (user in users) {
    posts: user.posts  # Already loaded
}

# Optimize counts
# Bad
users: @User.all()
for (user in users) {
    count: user.posts.count()  # N queries
}

# Good
users: @User.withCount("posts").get()
for (user in users) {
    count: user.posts_count  # Already loaded
}

# Chunk large datasets
@User.with("posts").chunk(100, (users) => {
    for (user in users) {
        @process_user(user)
    }
})

# Use existence queries instead of count
# Bad
if (user.posts.count() > 0) {
    // Has posts
}

# Good
if (user.posts.exists()) {
    // Has posts
}
```

## Best Practices

1. **Always define inverse relationships** - Makes queries more flexible
2. **Use eager loading** - Prevent N+1 query problems
3. **Name relationships clearly** - Use descriptive, intuitive names
4. **Add constraints to relationships** - Filter data at the relationship level
5. **Use withDefault() for optional relationships** - Avoid null checks
6. **Index foreign keys** - Improve join performance
7. **Use existence queries** - More efficient than counting
8. **Monitor queries** - Watch for N+1 problems in logs

## Related Topics

- `orm-models` - Model basics
- `eager-loading` - Loading strategies
- `query-optimization` - Performance tips
- `polymorphic-relations` - Advanced polymorphism
- `pivot-tables` - Many-to-many details
---

[Database Transactions in TuskLang]


Database transactions ensure data integrity by grouping multiple database operations into a single atomic unit. If any operation fails, all changes are rolled back.

## Basic Transactions

```tusk
# Automatic transaction handling
@db.transaction((tx) => {
    # All operations use the transaction connection
    user: tx.table("users").insert({
        name: "John Doe",
        email: "john@example.com"
    })
    
    account: tx.table("accounts").insert({
        user_id: user.id,
        balance: 1000.00
    })
    
    tx.table("logs").insert({
        action: "user_created",
        user_id: user.id,
        created_at: @now()
    })
    
    # If any operation fails, all are rolled back
})

# With return value
result: @db.transaction((tx) => {
    user: @User.create({
        name: "Jane Doe",
        email: "jane@example.com"
    })
    
    profile: user.profile().create({
        bio: "New user"
    })
    
    return {user, profile}
})
```

## Manual Transaction Control

```tusk
# Begin transaction manually
@db.beginTransaction()

try {
    # Perform operations
    @User.create({name: "Test User"})
    @Post.create({title: "Test Post"})
    
    # Commit if successful
    @db.commit()
    
} catch (Exception e) {
    # Rollback on error
    @db.rollback()
    throw e
}

# Using specific connection
connection: @db.connection("mysql")
connection.beginTransaction()

try {
    connection.table("users").insert(data)
    connection.commit()
} catch (e) {
    connection.rollback()
}
```

## Transaction Isolation Levels

```tusk
# Set isolation level
@db.transaction((tx) => {
    # Operations with specific isolation
}, {isolation: "read_committed"})

# Available isolation levels:
# - read_uncommitted
# - read_committed (default)
# - repeatable_read  
# - serializable

# Example with serializable isolation
@db.transaction((tx) => {
    # Highest isolation level - prevents all phenomena
    balance: tx.table("accounts")
        .where("id", account_id)
        .lockForUpdate()
        .value("balance")
    
    if (balance >= amount) {
        tx.table("accounts")
            .where("id", account_id)
            .decrement("balance", amount)
        
        tx.table("transactions").insert({
            account_id: account_id,
            amount: -amount,
            type: "withdrawal"
        })
    } else {
        throw "Insufficient funds"
    }
}, {isolation: "serializable"})
```

## Nested Transactions

```tusk
# Using savepoints for nested transactions
@db.transaction((tx) => {
    tx.table("users").insert({name: "Parent"})
    
    # Nested transaction using savepoint
    try {
        tx.transaction((nested) => {
            nested.table("posts").insert({title: "Nested"})
            
            # This might fail
            if (some_condition) {
                throw "Nested transaction failed"
            }
        })
    } catch (e) {
        # Only nested transaction is rolled back
        @log.error("Nested failed: " + e.message)
    }
    
    # Parent transaction continues
    tx.table("logs").insert({message: "Parent continues"})
})

# Manual savepoint management
@db.beginTransaction()

@db.table("users").insert({name: "User 1"})

# Create savepoint
@db.savepoint("before_risky_operation")

try {
    # Risky operation
    @db.table("critical").update({status: "processing"})
    
    if (operation_failed) {
        # Rollback to savepoint
        @db.rollbackToSavepoint("before_risky_operation")
    }
} catch (e) {
    @db.rollbackToSavepoint("before_risky_operation")
}

@db.commit()
```

## Pessimistic Locking

```tusk
# Lock for update - prevents other transactions from reading
@db.transaction((tx) => {
    user: tx.table("users")
        .where("id", user_id)
        .lockForUpdate()
        .first()
    
    # Other transactions wait until this completes
    user.balance += amount
    
    tx.table("users")
        .where("id", user_id)
        .update({balance: user.balance})
})

# Shared lock - allows reads but prevents updates
@db.transaction((tx) => {
    products: tx.table("products")
        .where("category_id", category_id)
        .sharedLock()
        .get()
    
    # Can read but not update these products
    total_value: products.sum(p => p.price * p.stock)
    
    tx.table("reports").insert({
        category_id: category_id,
        total_value: total_value
    })
})

# Skip locked rows
@db.transaction((tx) => {
    # Get next available job, skip locked ones
    job: tx.table("jobs")
        .where("status", "pending")
        .lockForUpdate()
        .skipLocked()
        .first()
    
    if (job) {
        # Process job
        tx.table("jobs")
            .where("id", job.id)
            .update({status: "processing"})
    }
})
```

## Optimistic Locking

```tusk
# Using version column
class Product extends Model {
    # Enable optimistic locking
    uses: [OptimisticLocking]
    
    # Version column (default: 'version')
    versionColumn: "version"
}

# Usage
product: @Product.find(1)
original_version: product.version

# Simulate concurrent update
product.price: 99.99

try {
    product.save()  # Checks version hasn't changed
} catch (StaleModelException e) {
    # Another process updated the record
    # Reload and retry
    product.refresh()
    product.price: 99.99
    product.save()
}

# Manual optimistic locking
@db.transaction((tx) => {
    product: tx.table("products")
        .where("id", product_id)
        .first()
    
    original_version: product.version
    
    # Perform calculations
    new_price: calculate_price(product)
    
    # Update with version check
    affected: tx.table("products")
        .where("id", product_id)
        .where("version", original_version)
        .update({
            price: new_price,
            version: original_version + 1
        })
    
    if (affected == 0) {
        throw "Product was modified by another process"
    }
})
```

## Distributed Transactions

```tusk
# Two-phase commit across multiple databases
@db.distributedTransaction([
    "mysql" => (tx) => {
        tx.table("orders").insert(order_data)
    },
    
    "postgres" => (tx) => {
        tx.table("inventory").decrement("stock", quantity)
    },
    
    "mongodb" => (tx) => {
        tx.collection("analytics").insert(analytics_data)
    }
])

# Manual distributed transaction
mysql_tx: @db.connection("mysql").beginTransaction()
postgres_tx: @db.connection("postgres").beginTransaction()

try {
    # Phase 1: Prepare
    mysql_tx.prepare()
    postgres_tx.prepare()
    
    # Phase 2: Commit
    mysql_tx.commit()
    postgres_tx.commit()
    
} catch (e) {
    # Rollback all
    mysql_tx.rollback()
    postgres_tx.rollback()
    throw e
}
```

## Transaction Events and Hooks

```tusk
# Transaction events
@db.beforeTransaction((connection) => {
    @log.info("Transaction starting", {
        connection: connection.getName()
    })
})

@db.afterCommit((connection) => {
    @log.info("Transaction committed")
    @cache.flush()  # Clear cache after successful transaction
})

@db.afterRollback((connection, exception) => {
    @log.error("Transaction rolled back", {
        error: exception.message
    })
    @alert.send("Transaction failure", exception)
})

# Model transaction hooks
class Order extends Model {
    boot() {
        super.boot()
        
        # Only execute after transaction commits
        @afterCommit((order) => {
            @queue.push("process_order", order)
            @email.send("order_confirmation", order)
        })
        
        # Clean up on rollback
        @afterRollback((order) => {
            @storage.delete(order.temp_files)
        })
    }
}
```

## Deadlock Handling

```tusk
# Automatic retry on deadlock
@db.transactionWithRetry((tx) => {
    # Complex operations that might deadlock
    account1: tx.table("accounts")
        .where("id", from_id)
        .lockForUpdate()
        .first()
    
    account2: tx.table("accounts")
        .where("id", to_id)
        .lockForUpdate()
        .first()
    
    # Transfer funds
    tx.table("accounts")
        .where("id", from_id)
        .decrement("balance", amount)
    
    tx.table("accounts")
        .where("id", to_id)
        .increment("balance", amount)
}, {
    retries: 3,
    delay: 100,  # milliseconds
    on_retry: (attempt, error) => {
        @log.warning("Deadlock detected, retry " + attempt)
    }
})

# Manual deadlock handling
max_retries: 3
attempt: 0

while (attempt < max_retries) {
    try {
        @db.transaction((tx) => {
            # Transaction logic
        })
        break  # Success
        
    } catch (DeadlockException e) {
        attempt++
        if (attempt >= max_retries) {
            throw e
        }
        @sleep(attempt * 100)  # Exponential backoff
    }
}
```

## Transaction Performance

```tusk
# Batch operations in transaction
@db.transaction((tx) => {
    # Bad: Individual inserts
    // for (user in users) {
    //     tx.table("users").insert(user)
    // }
    
    # Good: Batch insert
    tx.table("users").insert(users)
    
    # For large datasets, chunk
    users.chunk(1000).each(chunk => {
        tx.table("users").insert(chunk)
    })
})

# Connection pooling for transactions
@db.transactionPool({
    connections: 5,
    handler: (tx, item) => {
        # Process item in parallel transactions
        tx.table("processed").insert({
            data: @process(item),
            processed_at: @now()
        })
    },
    items: large_dataset
})

# Read-only transactions
@db.readTransaction((tx) => {
    # Optimized for read operations
    # May use read replicas
    report_data: tx.table("sales")
        .select(@db.raw("DATE(created_at) as date, SUM(amount) as total"))
        .groupBy("date")
        .get()
    
    return report_data
})
```

## Testing with Transactions

```tusk
# Wrap tests in transactions
#test "User creation" {
    @db.beginTransaction()
    
    user: @User.create({
        name: "Test User",
        email: "test@example.com"
    })
    
    @assert.true(user.exists)
    @assert.equals(user.name, "Test User")
    
    # Rollback to keep database clean
    @db.rollback()
}

# Test helper
testInTransaction: (callback) => {
    @db.beginTransaction()
    
    try {
        result: callback()
        return result
    } finally {
        @db.rollback()
    }
}

#test "Complex operation" {
    testInTransaction(() => {
        # All database changes will be rolled back
        order: @create_order_with_items()
        @assert.equals(order.items.count(), 3)
    })
}
```

## Best Practices

1. **Keep transactions short** - Hold locks for minimal time
2. **Order operations consistently** - Prevent deadlocks
3. **Use appropriate isolation level** - Balance consistency and performance
4. **Handle failures gracefully** - Always have rollback logic
5. **Avoid user interaction** - Don't wait for input during transaction
6. **Test transaction boundaries** - Ensure atomicity
7. **Monitor long transactions** - Set timeouts and alerts
8. **Use read replicas** - For read-only transactions

## Related Topics

- `database-overview` - Database configuration
- `query-builder` - Building queries
- `orm-models` - Model transactions
- `pessimistic-locking` - Locking strategies
- `database-performance` - Optimization tips
---

[Database Seeding in TuskLang]


Database seeding allows you to populate your database with test data. This is useful for development, testing, and setting up initial application data.

## Creating Seeders

```tusk
# Basic seeder structure
#seeder UserSeeder {
    run() {
        # Create multiple users
        for (i in 1..10) {
            @User.create({
                name: "User " + i,
                email: "user" + i + "@example.com",
                password: @bcrypt("password")
            })
        }
    }
}

# Seeder with relationships
#seeder BlogSeeder {
    run() {
        users: @User.all()
        
        for (user in users) {
            # Create posts for each user
            post_count: @random(1, 5)
            
            for (i in 1..post_count) {
                post: user.posts().create({
                    title: "Post " + i + " by " + user.name,
                    content: @faker.paragraphs(3),
                    published: @random_bool(0.8)  # 80% published
                })
                
                # Create comments
                comment_count: @random(0, 10)
                for (j in 1..comment_count) {
                    commenter: users.random()
                    post.comments().create({
                        user_id: commenter.id,
                        body: @faker.sentence()
                    })
                }
            }
        }
    }
}
```

## Using Faker for Realistic Data

```tusk
#seeder CustomerSeeder {
    run() {
        for (i in 1..100) {
            customer: @Customer.create({
                # Personal info
                first_name: @faker.firstName(),
                last_name: @faker.lastName(),
                email: @faker.unique().safeEmail(),
                phone: @faker.phoneNumber(),
                
                # Address
                address: @faker.streetAddress(),
                city: @faker.city(),
                state: @faker.state(),
                country: @faker.country(),
                postal_code: @faker.postcode(),
                
                # Additional data
                company: @faker.company(),
                website: @faker.url(),
                bio: @faker.paragraph(),
                avatar: @faker.imageUrl(200, 200, "people"),
                
                # Dates
                birth_date: @faker.dateTimeBetween("-60 years", "-18 years"),
                joined_at: @faker.dateTimeBetween("-2 years", "now"),
                
                # Status
                is_active: @faker.boolean(0.9),  # 90% active
                credit_limit: @faker.randomFloat(2, 1000, 50000)
            })
            
            # Create related data
            @seed_customer_orders(customer)
        }
    }
    
    seed_customer_orders(customer) {
        order_count: @faker.numberBetween(0, 20)
        
        for (i in 1..order_count) {
            order: customer.orders().create({
                order_number: @faker.unique().numerify("ORD-####-####"),
                status: @faker.randomElement(["pending", "processing", "shipped", "delivered", "cancelled"]),
                total: 0,  # Will calculate
                ordered_at: @faker.dateTimeBetween(customer.joined_at, "now")
            })
            
            # Add order items
            item_count: @faker.numberBetween(1, 5)
            total: 0
            
            for (j in 1..item_count) {
                product: @Product.inRandomOrder().first()
                quantity: @faker.numberBetween(1, 3)
                price: product.price
                
                order.items().create({
                    product_id: product.id,
                    quantity: quantity,
                    price: price,
                    total: price * quantity
                })
                
                total += price * quantity
            }
            
            order.update({total: total})
        }
    }
}
```

## Model Factories

```tusk
# Define a factory
#factory User {
    name: @faker.name()
    email: @faker.unique().safeEmail()
    email_verified_at: @faker.optional(0.7).dateTime()  # 70% verified
    password: @bcrypt("password")
    remember_token: @str_random(60)
    created_at: @faker.dateTimeBetween("-1 year", "now")
    
    # States
    state("admin") {
        role: "admin"
        email_verified_at: @now()
    }
    
    state("unverified") {
        email_verified_at: null
    }
    
    state("suspended") {
        suspended_at: @now()
        suspension_reason: @faker.sentence()
    }
    
    # After creating hook
    afterCreating(user) {
        user.profile().create(@factory(Profile).make())
    }
}

#factory Post {
    title: @faker.sentence()
    slug: @faker.slug()
    content: @faker.paragraphs(5, true)
    excerpt: @faker.paragraph()
    published: @faker.boolean(0.8)
    published_at: @faker.optional(0.8).dateTimeBetween("-6 months", "now")
    views: @faker.numberBetween(0, 10000)
    
    # Relationships
    user_id: @factory(User)
    category_id: @factory(Category)
    
    # States
    state("draft") {
        published: false
        published_at: null
    }
    
    state("popular") {
        views: @faker.numberBetween(10000, 100000)
        comments_count: @faker.numberBetween(50, 200)
    }
}

# Using factories in seeders
#seeder FactorySeeder {
    run() {
        # Create single
        user: @factory(User).create()
        
        # Create multiple
        users: @factory(User).count(50).create()
        
        # Create with state
        admin: @factory(User).state("admin").create()
        
        # Create with attributes
        john: @factory(User).create({
            name: "John Doe",
            email: "john@example.com"
        })
        
        # Create with relationships
        users_with_posts: @factory(User)
            .count(10)
            .has(@factory(Post).count(5))  # Each user has 5 posts
            .create()
        
        # Complex relationships
        @factory(Post)
            .count(20)
            .state("popular")
            .has(@factory(Comment).count(10))  # Each post has 10 comments
            .for(@factory(User).state("admin"))  # All posts by admin user
            .create()
        
        # Make without persisting
        user_data: @factory(User).make()  # Returns attributes array
        custom_user: @User.create({...user_data, custom_field: "value"})
    }
}
```

## Conditional and Smart Seeding

```tusk
#seeder SmartSeeder {
    run() {
        # Only seed if empty
        if (@User.count() == 0) {
            @call(UserSeeder)
        }
        
        # Conditional seeding based on environment
        if (@env.app_env == "local") {
            @seed_test_data()
        } else if (@env.app_env == "staging") {
            @seed_demo_data()
        }
        
        # Ensure minimum data exists
        @ensure_roles_exist()
        @ensure_admin_user()
        @ensure_categories()
    }
    
    ensure_roles_exist() {
        roles: ["admin", "editor", "user"]
        
        for (role_name in roles) {
            @Role.firstOrCreate(
                {name: role_name},
                {
                    name: role_name,
                    description: @str_title(role_name) + " role"
                }
            )
        }
    }
    
    ensure_admin_user() {
        admin: @User.where("email", "admin@example.com").first()
        
        if (!admin) {
            admin: @User.create({
                name: "Admin User",
                email: "admin@example.com",
                password: @bcrypt(@env("ADMIN_PASSWORD", "secret")),
                email_verified_at: @now()
            })
            
            admin_role: @Role.where("name", "admin").first()
            admin.roles().attach(admin_role)
        }
    }
    
    ensure_categories() {
        categories: [
            {name: "Technology", slug: "technology", color: "#3498db"},
            {name: "Business", slug: "business", color: "#2ecc71"},
            {name: "Health", slug: "health", color: "#e74c3c"},
            {name: "Education", slug: "education", color: "#f39c12"},
            {name: "Entertainment", slug: "entertainment", color: "#9b59b6"}
        ]
        
        for (cat in categories) {
            @Category.firstOrCreate(
                {slug: cat.slug},
                cat
            )
        }
    }
}
```

## CSV and JSON Data Import

```tusk
#seeder ImportSeeder {
    run() {
        # Import from CSV
        @import_from_csv("database/seeds/data/products.csv")
        
        # Import from JSON
        @import_from_json("database/seeds/data/categories.json")
        
        # Import from API
        @import_from_api("https://api.example.com/sample-data")
    }
    
    import_from_csv(file_path) {
        csv: @file.read_csv(file_path, {headers: true})
        
        for (row in csv) {
            @Product.updateOrCreate(
                {sku: row.sku},
                {
                    name: row.name,
                    description: row.description,
                    price: @float(row.price),
                    stock: @int(row.stock),
                    category: row.category
                }
            )
        }
    }
    
    import_from_json(file_path) {
        data: @file.json(file_path)
        
        for (item in data.categories) {
            category: @Category.create({
                name: item.name,
                slug: item.slug,
                parent_id: item.parent_id
            })
            
            # Import subcategories recursively
            if (item.children) {
                @import_subcategories(category, item.children)
            }
        }
    }
    
    import_from_api(url) {
        response: @http.get(url)
        
        if (response.successful()) {
            data: response.json()
            
            for (user in data.users) {
                @User.firstOrCreate(
                    {email: user.email},
                    {
                        name: user.name,
                        email: user.email,
                        external_id: user.id
                    }
                )
            }
        }
    }
}
```

## Performance Optimization

```tusk
#seeder LargeDataSeeder {
    run() {
        # Disable query logging for performance
        @db.disableQueryLog()
        
        # Chunk inserts for large datasets
        users: []
        
        for (i in 1..100000) {
            users.push({
                name: @faker.name(),
                email: @faker.unique().email(),
                password: @bcrypt("password"),
                created_at: @now(),
                updated_at: @now()
            })
            
            # Insert in chunks
            if (users.length >= 1000) {
                @User.insert(users)
                users: []  # Reset array
                
                # Show progress
                if (i % 10000 == 0) {
                    @console.info("Inserted " + i + " users...")
                }
            }
        }
        
        # Insert remaining
        if (users.length > 0) {
            @User.insert(users)
        }
        
        # Re-enable query logging
        @db.enableQueryLog()
    }
    
    # Use database transactions for consistency
    run_with_transaction() {
        @db.transaction((tx) => {
            # All operations in transaction
            for (i in 1..1000) {
                user: tx.table("users").insertGetId({
                    name: "User " + i,
                    email: "user" + i + "@example.com"
                })
                
                tx.table("profiles").insert({
                    user_id: user,
                    bio: @faker.paragraph()
                })
            }
        })
    }
}
```

## Seeder Management

```tusk
# Master seeder
#seeder DatabaseSeeder {
    run() {
        # Call seeders in order
        @call([
            RoleSeeder,
            UserSeeder,
            CategorySeeder,
            ProductSeeder,
            OrderSeeder
        ])
        
        # Conditional seeding
        if (@env.seed_test_data) {
            @call(TestDataSeeder)
        }
        
        # Environment-specific
        seeders: match @env.app_env {
            "local" => [DevelopmentSeeder]
            "staging" => [StagingSeeder]
            "production" => [ProductionSeeder]
            _ => []
        }
        
        @call(seeders)
    }
    
    # Call seeder with progress
    call_with_progress(seeder_class, count) {
        @console.info("Running " + seeder_class.name + "...")
        
        progress: @console.progress(count)
        
        seeder: new seeder_class()
        seeder.on("progress", (current) => {
            progress.advance()
        })
        
        seeder.run()
        progress.finish()
    }
}

# Running seeders via CLI
@cli.command("db:seed", (args) => {
    seeder_class: args.class || "DatabaseSeeder"
    
    @console.info("Seeding database...")
    start: @microtime(true)
    
    seeder: @resolve(seeder_class)
    seeder.run()
    
    duration: @microtime(true) - start
    @console.success("Database seeding completed in " + duration + "s")
})
```

## Testing with Seeders

```tusk
# Test-specific seeder
#seeder TestSeeder {
    run() {
        # Create predictable test data
        @User.create({
            id: 1,
            name: "Test User",
            email: "test@example.com",
            password: @bcrypt("password")
        })
        
        @Product.create({
            id: 1,
            name: "Test Product",
            price: 99.99,
            stock: 100
        })
    }
}

# Use in tests
#test "Order creation" {
    # Seed test data
    @seed(TestSeeder)
    
    user: @User.find(1)
    product: @Product.find(1)
    
    order: @Order.create({
        user_id: user.id,
        total: product.price
    })
    
    @assert.equals(order.user_id, 1)
    @assert.equals(order.total, 99.99)
}

# Refresh database between tests
#test "Fresh database" {
    @refresh_database()
    @seed(TestSeeder)
    
    # Test with fresh seeded data
}
```

## Best Practices

1. **Use factories for flexibility** - Define reusable data patterns
2. **Make seeders idempotent** - Running twice shouldn't duplicate data
3. **Use faker for realistic data** - Better testing and demos
4. **Chunk large inserts** - Prevent memory issues
5. **Environment-specific seeding** - Different data for dev/staging/prod
6. **Document seed data** - Explain what each seeder creates
7. **Version control seeders** - Track changes over time
8. **Test seeders** - Ensure they work correctly

## Related Topics

- `model-factories` - Factory pattern details
- `faker-library` - Fake data generation
- `database-testing` - Testing with seed data
- `migrations` - Schema management
- `data-import` - Importing external data
---

[Model Factories in TuskLang]


Model factories provide a convenient way to generate fake data for your models. They're essential for testing, seeding databases, and creating sample data during development.

## Defining Factories

```tusk
# Basic factory definition
#factory User {
    name: @faker.name()
    email: @faker.unique().safeEmail()
    password: @bcrypt("password")
    remember_token: @str_random(60)
    created_at: @faker.dateTimeBetween("-1 year", "now")
    updated_at: @now()
}

# Factory with computed attributes
#factory Product {
    name: @faker.productName()
    slug: (attributes) => @str_slug(attributes.name)
    description: @faker.paragraph()
    price: @faker.randomFloat(2, 10, 1000)
    cost: (attributes) => attributes.price * 0.6
    sku: @faker.unique().bothify("???-#####")
    stock: @faker.numberBetween(0, 100)
    
    # Conditional attributes
    sale_price: (attributes) => {
        if (@faker.boolean(0.3)) {  # 30% on sale
            return attributes.price * @faker.randomFloat(2, 0.7, 0.9)
        }
        return null
    }
}

# Factory with relationships
#factory Post {
    title: @faker.sentence()
    content: @faker.paragraphs(5, true)
    published: @faker.boolean(0.8)
    
    # Belongs to relationship
    user_id: @factory(User)
    
    # Or use existing model
    category_id: () => @Category.inRandomOrder().first()?.id || @factory(Category)
}
```

## Factory States

```tusk
#factory User {
    # Default attributes
    name: @faker.name()
    email: @faker.unique().safeEmail()
    password: @bcrypt("password")
    active: true
    role: "user"
    
    # Define states
    state("admin") {
        role: "admin"
        permissions: ["*"]
        email: (attributes) => "admin-" + attributes.email
    }
    
    state("inactive") {
        active: false
        deactivated_at: @faker.dateTimeBetween("-30 days", "now")
    }
    
    state("premium") {
        subscription_type: "premium"
        subscription_expires: @faker.dateTimeBetween("now", "+1 year")
        credit_limit: @faker.numberBetween(5000, 50000)
    }
    
    state("verified") {
        email_verified_at: @faker.dateTimeBetween("-6 months", "now")
        phone_verified: true
    }
    
    # Multiple states can be combined
    state("banned") {
        banned: true
        banned_at: @now()
        ban_reason: @faker.randomElement([
            "Terms violation",
            "Spam",
            "Abusive behavior"
        ])
    }
}

# Using states
admin: @factory(User).state("admin").create()
inactive_users: @factory(User).state("inactive").count(5).create()
premium_admin: @factory(User).states(["admin", "premium"]).create()
```

## Factory Sequences

```tusk
#factory User {
    # Auto-incrementing sequences
    username: @faker.sequence((n) => "user" + n)
    employee_id: @faker.sequence((n) => "EMP" + @str_pad(n, 5, "0", STR_PAD_LEFT))
    
    # Custom sequence starting point
    customer_number: @faker.sequence((n) => n + 1000)
    
    # Reset sequences
    email: @faker.sequence((n) => {
        if (n > 1000) {
            @faker.resetSequence("email")
            n: 1
        }
        return "test" + n + "@example.com"
    })
}

# Named sequences shared across factories
#factory Order {
    order_number: @faker.sequence("order_number", (n) => {
        year: @date("Y")
        return year + "-" + @str_pad(n, 6, "0", STR_PAD_LEFT)
    })
}

#factory Invoice {
    invoice_number: @faker.sequence("invoice_number", (n) => {
        return "INV-" + @date("Ym") + "-" + @str_pad(n, 4, "0", STR_PAD_LEFT)
    })
}
```

## Factory Callbacks

```tusk
#factory User {
    name: @faker.name()
    email: @faker.unique().safeEmail()
    
    # Configure callback
    configure() {
        # Runs when factory is defined
        @faker.seed(12345)  # Consistent random data
    }
    
    # After making (before create)
    afterMaking(user, faker) {
        # Set computed values
        user.display_name: user.display_name || user.name
        user.slug: @str_slug(user.name)
    }
    
    # After creating (after save)
    afterCreating(user, faker) {
        # Create related models
        user.profile().create({
            bio: faker.paragraph(),
            avatar: faker.imageUrl(200, 200, "people", true, user.name)
        })
        
        # Assign roles
        if (user.role == "admin") {
            admin_role: @Role.where("name", "admin").first()
            user.roles().attach(admin_role)
        }
        
        # Send notifications
        if (@env.factory_notifications) {
            @event("user.created", user)
        }
    }
}

# State-specific callbacks
#factory Post {
    title: @faker.sentence()
    content: @faker.paragraphs(3, true)
    
    state("published") {
        published: true
        published_at: @faker.dateTimeBetween("-6 months", "now")
        
        afterCreating(post, faker) {
            # Generate SEO data for published posts
            post.seo().create({
                meta_title: post.title,
                meta_description: @str_limit(post.content, 160),
                keywords: faker.words(5).join(", ")
            })
            
            # Generate social media previews
            @queue("generate_social_previews", post)
        }
    }
}
```

## Complex Factory Relationships

```tusk
#factory User {
    name: @faker.name()
    email: @faker.unique().safeEmail()
    
    # Has many relationship
    afterCreating(user, faker) {
        # Create related posts
        @factory(Post)
            .count(faker.numberBetween(0, 10))
            .create({user_id: user.id})
    }
}

# Using has() method
users_with_posts: @factory(User)
    .count(5)
    .has(@factory(Post).count(3))  # Each user has 3 posts
    .create()

# Nested relationships
users: @factory(User)
    .count(3)
    .has(
        @factory(Post)
            .count(5)
            .has(@factory(Comment).count(10))  # Each post has 10 comments
    )
    .create()

# For() method for belongs-to
posts: @factory(Post)
    .count(10)
    .for(@factory(User).state("premium"))  # All posts belong to premium user
    .create()

# Many-to-many relationships
#factory User {
    afterCreating(user, faker) {
        # Attach random roles
        roles: @Role.inRandomOrder().limit(faker.numberBetween(1, 3)).get()
        user.roles().attach(roles)
        
        # Attach with pivot data
        teams: @factory(Team).count(2).create()
        for (team in teams) {
            user.teams().attach(team, {
                role: faker.randomElement(["member", "leader", "admin"]),
                joined_at: faker.dateTimeBetween("-1 year", "now")
            })
        }
    }
}
```

## Factory Inheritance

```tusk
# Base factory
#factory Person {
    first_name: @faker.firstName()
    last_name: @faker.lastName()
    birth_date: @faker.dateTimeBetween("-80 years", "-18 years")
    phone: @faker.phoneNumber()
    address: @faker.streetAddress()
    city: @faker.city()
    country: @faker.country()
}

# Extend base factory
#factory Employee extends Person {
    employee_id: @faker.unique().numerify("EMP-####")
    department: @faker.randomElement(["Sales", "Engineering", "HR", "Marketing"])
    position: @faker.jobTitle()
    salary: @faker.numberBetween(30000, 150000)
    hired_at: @faker.dateTimeBetween("-5 years", "now")
    
    state("executive") {
        department: "Executive"
        position: @faker.randomElement(["CEO", "CTO", "CFO", "COO"])
        salary: @faker.numberBetween(200000, 500000)
    }
}

#factory Customer extends Person {
    customer_number: @faker.unique().numerify("CUST-######")
    credit_limit: @faker.numberBetween(1000, 50000)
    preferred_payment: @faker.randomElement(["credit_card", "paypal", "bank_transfer"])
    registered_at: @faker.dateTimeBetween("-3 years", "now")
}
```

## Advanced Factory Usage

```tusk
# Raw attributes (not creating model)
user_data: @factory(User).raw()  # Returns array
user_data: @factory(User).count(5).raw()  # Returns array of arrays

# Make models without persisting
user: @factory(User).make()  # Returns model instance without saving
users: @factory(User).count(5).make()  # Returns collection

# Custom connection
user: @factory(User).connection("mysql").create()

# Recursive factories
#factory Category {
    name: @faker.word()
    slug: (attr) => @str_slug(attr.name)
    
    # Create with children
    afterCreating(category, faker) {
        if (faker.boolean(0.5)) {  # 50% have children
            child_count: faker.numberBetween(1, 5)
            
            for (i in 1..child_count) {
                @factory(Category).create({
                    parent_id: category.id
                })
            }
        }
    }
}

# Conditional factory logic
#factory Order {
    status: @faker.randomElement(["pending", "processing", "completed", "cancelled"])
    total: @faker.randomFloat(2, 50, 5000)
    
    afterMaking(order, faker) {
        # Set date based on status
        match order.status {
            "completed" => {
                order.completed_at: faker.dateTimeBetween("-30 days", "now")
                order.shipped_at: faker.dateTimeBetween("-35 days", order.completed_at)
            }
            "cancelled" => {
                order.cancelled_at: faker.dateTimeBetween("-30 days", "now")
                order.cancellation_reason: faker.sentence()
            }
            "processing" => {
                order.processing_started_at: faker.dateTimeBetween("-2 days", "now")
            }
        }
    }
}
```

## Factory Macros and Helpers

```tusk
# Define factory macros
@Factory.macro("withAddress", () => {
    return @tap((factory) => {
        factory.merge({
            address_line_1: @faker.streetAddress(),
            address_line_2: @faker.boolean(0.3) ? @faker.secondaryAddress() : null,
            city: @faker.city(),
            state: @faker.stateAbbr(),
            postal_code: @faker.postcode(),
            country: @faker.countryCode()
        })
    })
})

@Factory.macro("withPhone", (type = "mobile") => {
    return @tap((factory) => {
        factory.merge({
            phone_type: type,
            phone_number: type == "mobile" ? @faker.cellNumber() : @faker.phoneNumber(),
            phone_verified: @faker.boolean(0.8)
        })
    })
})

# Use macros
user: @factory(User)
    .withAddress()
    .withPhone("mobile")
    .create()

# Factory helper functions
helpers: {
    generate_username: (first_name, last_name) => {
        base: @str_lower(first_name + "." + last_name)
        suffix: @faker.numberBetween(1, 999)
        return base + suffix
    }
    
    generate_company_email: (name, company) => {
        first: @str_lower(@str_before(name, " "))
        domain: @str_slug(company)
        return first + "@" + domain + ".com"
    }
}

#factory Employee {
    first_name: @faker.firstName()
    last_name: @faker.lastName()
    company: @faker.company()
    
    username: (attr) => helpers.generate_username(attr.first_name, attr.last_name)
    email: (attr) => helpers.generate_company_email(attr.first_name + " " + attr.last_name, attr.company)
}
```

## Testing with Factories

```tusk
#test "User can create posts" {
    # Create test data
    user: @factory(User).create()
    
    # Act
    post: user.posts().create({
        title: "Test Post",
        content: "Test content"
    })
    
    # Assert
    @assert.equals(post.user_id, user.id)
    @assert.equals(user.posts.count(), 1)
}

#test "Premium users have higher limits" {
    regular_user: @factory(User).create()
    premium_user: @factory(User).state("premium").create()
    
    @assert.true(premium_user.credit_limit > regular_user.credit_limit)
    @assert.notNull(premium_user.subscription_expires)
}

# Test helper using factories
testAs(user_factory, callback) {
    user: user_factory.create()
    @actingAs(user)
    callback(user)
}

#test "Admin can access dashboard" {
    testAs(@factory(User).state("admin"), (admin) => {
        response: @get("/admin/dashboard")
        response.assertOk()
        response.assertSee("Admin Dashboard")
    })
}
```

## Best Practices

1. **Use faker for realistic data** - Makes testing more reliable
2. **Define states for variations** - Avoid duplicating factories
3. **Keep factories focused** - One factory per model
4. **Use callbacks wisely** - Don't create too many related models
5. **Make data deterministic when needed** - Use seeds for consistent tests
6. **Extract common patterns** - Use inheritance or macros
7. **Document complex factories** - Explain relationships and states
8. **Clean up after tests** - Use database transactions in tests

## Related Topics

- `faker-methods` - Available faker methods
- `database-seeding` - Using factories in seeders
- `testing` - Testing with factories
- `model-relationships` - Defining relationships
- `factory-patterns` - Advanced patterns
---

[Query Optimization in TuskLang]


Optimizing database queries is crucial for application performance. TuskLang provides tools and techniques to identify and resolve common performance issues.

## Understanding Query Performance

```tusk
# Enable query logging
@db.enableQueryLog()

# Run your queries
users: @User.with("posts").get()

# Get executed queries
queries: @db.getQueryLog()

for (query in queries) {
    @log.info("Query", {
        sql: query.sql,
        bindings: query.bindings,
        time: query.time + "ms"
    })
}

# Query profiling
@db.listen((query) => {
    if (query.time > 100) {  # Log slow queries (>100ms)
        @log.warning("Slow query detected", {
            sql: query.sql,
            time: query.time,
            backtrace: @debug_backtrace()
        })
    }
})

# Explain query execution plan
explanation: @User.where("active", true)
    .join("posts", "users.id", "=", "posts.user_id")
    .explain()

# Database-specific explain
if (@db.getDriverName() == "mysql") {
    detailed: @db.select("EXPLAIN EXTENDED " + query.toSql())
} else if (@db.getDriverName() == "pgsql") {
    analyze: @db.select("EXPLAIN ANALYZE " + query.toSql())
}
```

## Preventing N+1 Queries

```tusk
# Bad: N+1 query problem
users: @User.all()  # 1 query

for (user in users) {
    posts_count: user.posts.count()  # N queries (one per user)
    @display_user(user, posts_count)
}

# Good: Eager loading
users: @User.with("posts").get()  # 2 queries total

for (user in users) {
    posts_count: user.posts.count()  # No additional queries
    @display_user(user, posts_count)
}

# Better: Using withCount
users: @User.withCount("posts").get()  # 1 query with JOIN

for (user in users) {
    posts_count: user.posts_count  # Already loaded
    @display_user(user, posts_count)
}

# Multiple relationships
users: @User.with([
    "profile",
    "posts" => (query) => {
        query.where("published", true)
            .orderBy("created_at", "desc")
            .limit(5)
    },
    "posts.comments" => (query) => {
        query.where("approved", true)
    }
]).get()

# Conditional eager loading
users: @User.all()

if (include_posts) {
    users.load("posts")
}

if (include_stats) {
    users.loadCount(["posts", "comments"])
}
```

## Index Optimization

```tusk
# Check existing indexes
indexes: @db.select("""
    SELECT 
        TABLE_NAME,
        INDEX_NAME,
        GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as COLUMNS
    FROM information_schema.STATISTICS
    WHERE TABLE_SCHEMA = DATABASE()
    GROUP BY TABLE_NAME, INDEX_NAME
""")

# Migration with proper indexes
#migration optimize_users_table {
    up() {
        @schema.table("users", (table) => {
            # Single column indexes
            table.index("email")  # For WHERE email = ?
            table.index("created_at")  # For ORDER BY created_at
            
            # Composite indexes (order matters!)
            table.index(["status", "created_at"])  # For WHERE status = ? ORDER BY created_at
            table.index(["country", "city"])  # For WHERE country = ? AND city = ?
            
            # Partial indexes (PostgreSQL)
            if (@db.getDriverName() == "pgsql") {
                @db.statement("""
                    CREATE INDEX active_users_email 
                    ON users(email) 
                    WHERE deleted_at IS NULL
                """)
            }
            
            # Full-text indexes (MySQL)
            if (@db.getDriverName() == "mysql") {
                table.fullText(["name", "bio"])  # For full-text search
            }
        })
    }
}

# Query using indexes effectively
# Good: Uses index on (status, created_at)
users: @User.where("status", "active")
    .orderBy("created_at", "desc")
    .limit(10)
    .get()

# Bad: Can't use the index effectively
users: @User.orderBy("created_at")  # Missing WHERE on status
    .where("city", "New York")  # Different column
    .get()
```

## Query Optimization Techniques

```tusk
# Select only needed columns
# Bad
users: @User.all()  # SELECT * FROM users

# Good
users: @User.select("id", "name", "email").get()

# Use exists() instead of count()
# Bad
if (@User.where("email", email).count() > 0) {
    // Email exists
}

# Good
if (@User.where("email", email).exists()) {
    // Email exists
}

# Chunk large datasets
# Bad: Loads all into memory
users: @User.all()
for (user in users) {
    @process(user)
}

# Good: Process in chunks
@User.chunk(1000, (users) => {
    for (user in users) {
        @process(user)
    }
})

# Even better: Use cursor for very large datasets
@User.cursor().each((user) => {
    @process(user)
})

# Avoid using whereIn with large arrays
# Bad
user_ids: @get_large_array_of_ids()  # 10000+ IDs
users: @User.whereIn("id", user_ids).get()

# Good: Use joins or chunk the IDs
user_ids.chunk(1000).each(chunk => {
    users: @User.whereIn("id", chunk).get()
    @process_users(users)
})
```

## Caching Strategies

```tusk
# Cache expensive queries
users: @cache.remember("active_users", 3600, () => {
    return @User.where("active", true)
        .with("profile")
        .orderBy("created_at", "desc")
        .get()
})

# Cache with tags for easy invalidation
products: @cache.tags(["products"]).remember("featured_products", 3600, () => {
    return @Product.where("featured", true)
        .with("category")
        .get()
})

# Invalidate when data changes
#on product.saved {
    @cache.tags(["products"]).flush()
}

# Query result caching at model level
class User extends Model {
    # Cache relationship counts
    cachedPostsCount() {
        return @cache.remember("user." + this.id + ".posts_count", 3600, () => {
            return this.posts().count()
        })
    }
    
    # Cache expensive calculations
    totalSpent() {
        return @cache.remember("user." + this.id + ".total_spent", 3600, () => {
            return this.orders()
                .where("status", "completed")
                .sum("total")
        })
    }
}
```

## Database-Specific Optimizations

```tusk
# MySQL specific
if (@db.getDriverName() == "mysql") {
    # Force index usage
    users: @db.table("users")
        .from(@db.raw("users FORCE INDEX (status_created_at_index)"))
        .where("status", "active")
        .get()
    
    # Optimize group by
    @db.statement("SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''))")
    
    # Buffer pool warming
    @db.statement("SELECT COUNT(*) FROM users")  # Load into buffer pool
}

# PostgreSQL specific
if (@db.getDriverName() == "pgsql") {
    # Use CTEs for complex queries
    results: @db.select("""
        WITH active_users AS (
            SELECT * FROM users WHERE active = true
        ),
        user_stats AS (
            SELECT user_id, COUNT(*) as post_count
            FROM posts
            GROUP BY user_id
        )
        SELECT u.*, s.post_count
        FROM active_users u
        LEFT JOIN user_stats s ON u.id = s.user_id
    """)
    
    # Parallel queries
    @db.statement("SET max_parallel_workers_per_gather = 4")
}
```

## Aggregation Optimization

```tusk
# Use database aggregation instead of collection methods
# Bad: PHP/Application-level aggregation
orders: @Order.where("created_at", ">", @days_ago(30)).get()
total: orders.sum(order => order.total)  # Processes in memory

# Good: Database-level aggregation  
total: @Order.where("created_at", ">", @days_ago(30))
    .sum("total")  # Calculated by database

# Complex aggregations
stats: @db.table("orders")
    .select(
        @db.raw("DATE(created_at) as date"),
        @db.raw("COUNT(*) as order_count"),
        @db.raw("SUM(total) as revenue"),
        @db.raw("AVG(total) as avg_order_value")
    )
    .where("created_at", ">", @days_ago(30))
    .groupBy("date")
    .orderBy("date", "desc")
    .get()

# Window functions for advanced analytics
ranked_users: @db.select("""
    SELECT 
        *,
        ROW_NUMBER() OVER (ORDER BY total_spent DESC) as rank,
        PERCENT_RANK() OVER (ORDER BY total_spent DESC) as percentile
    FROM (
        SELECT 
            users.*,
            COALESCE(SUM(orders.total), 0) as total_spent
        FROM users
        LEFT JOIN orders ON users.id = orders.user_id
        GROUP BY users.id
    ) as user_totals
""")
```

## Join Optimization

```tusk
# Optimize join order and type
# Use specific join types
results: @db.table("users")
    .join("profiles", "users.id", "=", "profiles.user_id")  # INNER JOIN
    .leftJoin("posts", "users.id", "=", "posts.user_id")   # LEFT JOIN
    .where("users.active", true)
    .select("users.*", "profiles.bio", @db.raw("COUNT(posts.id) as post_count"))
    .groupBy("users.id")
    .get()

# Avoid unnecessary joins
# Bad: Join just to check existence
users: @db.table("users")
    .join("posts", "users.id", "=", "posts.user_id")
    .where("posts.id", "!=", null)
    .distinct()
    .get()

# Good: Use whereExists
users: @db.table("users")
    .whereExists((query) => {
        query.select("id")
            .from("posts")
            .whereColumn("posts.user_id", "users.id")
    })
    .get()

# Denormalization for read-heavy queries
#migration add_post_count_to_users {
    up() {
        @schema.table("users", (table) => {
            table.integer("posts_count").default(0)
        })
        
        # Update existing data
        @db.statement("""
            UPDATE users 
            SET posts_count = (
                SELECT COUNT(*) 
                FROM posts 
                WHERE posts.user_id = users.id
            )
        """)
    }
}
```

## Monitoring and Profiling

```tusk
# Query performance monitoring
class QueryMonitor {
    static monitor() {
        queries: []
        
        @db.listen((query) => {
            queries.push({
                sql: query.sql,
                time: query.time,
                memory: @memory_get_usage()
            })
        })
        
        @app.terminating(() => {
            slow_queries: queries.filter(q => q.time > 100)
            
            if (slow_queries.length > 0) {
                @log.warning("Slow queries detected", {
                    count: slow_queries.length,
                    queries: slow_queries
                })
            }
            
            @metrics.gauge("query.average_time", 
                queries.avg(q => q.time)
            )
        })
    }
}

# Database query analyzer
analyzer: {
    analyze_query: (query) => {
        # Get query plan
        plan: query.explain()
        
        # Check for common issues
        issues: []
        
        if (plan.contains("Using filesort")) {
            issues.push("Query uses filesort - consider adding index")
        }
        
        if (plan.contains("Using temporary")) {
            issues.push("Query uses temporary table - optimize GROUP BY")
        }
        
        if (!plan.contains("Using index")) {
            issues.push("Query doesn't use index - add appropriate index")
        }
        
        return {
            plan: plan,
            issues: issues,
            estimated_rows: @extract_row_count(plan)
        }
    }
}
```

## Query Builder Macros

```tusk
# Define reusable query optimizations
@Builder.macro("optimize", () => {
    return @tap((query) => {
        # Add query hints
        if (@db.getDriverName() == "mysql") {
            query.hint("SQL_NO_CACHE")
        }
        
        # Set fetch mode
        query.setFetchMode(PDO::FETCH_ASSOC)
        
        # Enable query caching
        query.remember(300)  # 5 minutes
    })
})

# Use optimization macro
users: @User.where("active", true)
    .optimize()
    .get()

# Create scope for commonly optimized queries
class User extends Model {
    scopeOptimized(query) {
        return query
            .select("id", "name", "email", "created_at")  # Only needed columns
            .with(["profile:id,user_id,avatar"])  # Minimal eager loading
            .remember(300)  # Cache for 5 minutes
    }
}

users: @User.optimized().active().get()
```

## Best Practices

1. **Monitor query performance** - Log and analyze slow queries
2. **Use indexes wisely** - Index columns used in WHERE, ORDER BY, GROUP BY
3. **Avoid N+1 queries** - Use eager loading
4. **Select only needed data** - Don't use SELECT *
5. **Cache expensive queries** - Use query result caching
6. **Optimize at the database level** - Use proper data types and constraints
7. **Profile in production** - Real data reveals real problems
8. **Regular maintenance** - Update statistics, rebuild indexes

## Related Topics

- `database-indexes` - Index strategies
- `eager-loading` - Relationship loading
- `query-caching` - Caching strategies
- `database-monitoring` - Performance monitoring
- `query-profiling` - Profiling tools
---

[Database Security in TuskLang]


Database security is critical for protecting your application's data. TuskLang provides multiple layers of security to prevent common vulnerabilities and protect sensitive information.

## SQL Injection Prevention

```tusk
# ALWAYS use parameter binding
# Good: Automatic escaping with query builder
email: @request.input("email")
user: @User.where("email", email).first()  # Safe

# Good: Parameter binding with raw queries
user_id: @request.input("user_id")
results: @db.select(
    "SELECT * FROM users WHERE id = ? AND active = ?",
    [user_id, true]
)  # Safe

# Bad: NEVER concatenate user input
// DON'T DO THIS
// query: "SELECT * FROM users WHERE email = '" + email + "'"
// results: @db.select(query)  # VULNERABLE!

# Good: Named bindings
results: @db.select(
    "SELECT * FROM posts WHERE user_id = :user AND status = :status",
    {
        user: user_id,
        status: "published"
    }
)

# Safe use of raw expressions
sort_column: @request.input("sort", "created_at")

# Validate column name against whitelist
allowed_columns: ["created_at", "updated_at", "name"]
if (!allowed_columns.includes(sort_column)) {
    sort_column: "created_at"
}

users: @User.orderBy(@db.raw(sort_column)).get()  # Safe after validation
```

## Mass Assignment Protection

```tusk
# Define fillable attributes in models
class User extends Model {
    # Only these can be mass assigned
    fillable: ["name", "email", "bio"]
    
    # Never mass assignable
    guarded: ["id", "is_admin", "password"]
    
    # Or guard everything except specified
    guarded: ["*"]  # Guard all
    fillable: ["name", "email"]  # Except these
}

# Safe mass assignment
user: @User.create(@request.only(["name", "email"]))  # Safe

# Unsafe mass assignment attempts are blocked
// user: @User.create(@request.all())  # Could include is_admin!

# Force fill for admin operations only
if (@auth.user.isAdmin()) {
    user: new User()
    user.forceFill({
        name: "Admin User",
        is_admin: true  # Bypasses protection
    })
    user.save()
}

# Validation before mass assignment
validated: @validate(@request.all(), {
    name: "required|string|max:255",
    email: "required|email|unique:users",
    password: "required|min:8|confirmed"
})

user: @User.create(validated)  # Only validated data
```

## Data Encryption

```tusk
# Encrypt sensitive data at rest
class User extends Model {
    # Automatically encrypt/decrypt attributes
    encrypted: ["ssn", "credit_card", "bank_account"]
    
    # Custom encryption
    setApiKeyAttribute(value) {
        this.attributes.api_key: @encrypt(value)
    }
    
    getApiKeyAttribute(value) {
        return value ? @decrypt(value) : null
    }
}

# Database field encryption
#migration add_encrypted_fields {
    up() {
        @schema.table("users", (table) => {
            # Store encrypted data as text
            table.text("ssn_encrypted").nullable()
            table.text("credit_card_encrypted").nullable()
            
            # Store encryption metadata
            table.string("encryption_key_id").nullable()
        })
    }
}

# Searchable encryption
class Document extends Model {
    # Blind index for searching encrypted data
    blindIndexes: {
        email: {
            column: "email_bidx",
            key: @env("BLIND_INDEX_KEY")
        }
    }
    
    # Search encrypted fields
    scopeWhereEmail(query, email) {
        bidx: @generate_blind_index(email)
        return query.where("email_bidx", bidx)
    }
}

# Full database encryption (transparent)
config.database.connections.mysql.options: {
    PDO::MYSQL_ATTR_SSL_CA: "/path/to/ca.pem",
    PDO::MYSQL_ATTR_SSL_CERT: "/path/to/cert.pem",
    PDO::MYSQL_ATTR_SSL_KEY: "/path/to/key.pem"
}
```

## Access Control

```tusk
# Row-level security with global scopes
class Document extends Model {
    boot() {
        super.boot()
        
        # Only show documents user has access to
        @addGlobalScope("access", (query) => {
            if (!@auth.check()) {
                query.where("public", true)
            } else if (!@auth.user.isAdmin()) {
                query.where((q) => {
                    q.where("user_id", @auth.id)
                        .orWhere("public", true)
                        .orWhereHas("sharedWith", (q2) => {
                            q2.where("user_id", @auth.id)
                        })
                })
            }
            # Admins see everything
        })
    }
}

# Policy-based authorization
class PostPolicy {
    view(user, post) {
        return post.published || 
               post.user_id == user.id ||
               user.isAdmin()
    }
    
    update(user, post) {
        return post.user_id == user.id && !post.locked
    }
    
    delete(user, post) {
        return user.isAdmin() || 
               (post.user_id == user.id && post.created_at > @days_ago(1))
    }
}

# Use policies in routes
#web /posts/{id}/edit {
    post: @Post.findOrFail(@params.id)
    
    @authorize("update", post)  # Throws 403 if unauthorized
    
    @render("posts.edit", {post})
}
```

## Audit Logging

```tusk
# Audit trait for models
trait Auditable {
    boot() {
        # Log creates
        @creating((model) => {
            @audit.log("create", {
                model: model.constructor.name,
                user_id: @auth.id,
                ip: @request.ip,
                data: model.toArray()
            })
        })
        
        # Log updates with changes
        @updating((model) => {
            @audit.log("update", {
                model: model.constructor.name,
                model_id: model.id,
                user_id: @auth.id,
                ip: @request.ip,
                changes: model.getDirty(),
                original: model.getOriginal()
            })
        })
        
        # Log deletes
        @deleting((model) => {
            @audit.log("delete", {
                model: model.constructor.name,
                model_id: model.id,
                user_id: @auth.id,
                ip: @request.ip,
                data: model.toArray()
            })
        })
    }
}

# Audit log model
class AuditLog extends Model {
    fillable: ["action", "model", "model_id", "user_id", "ip", "data", "created_at"]
    
    casts: {
        data: "json"
    }
    
    # Query scopes
    scopeForModel(query, model) {
        return query.where("model", model.constructor.name)
            .where("model_id", model.id)
    }
    
    scopeByUser(query, user_id) {
        return query.where("user_id", user_id)
    }
    
    scopeSuspicious(query) {
        return query.where((q) => {
            q.where("action", "delete")
                .orWhere("ip", "in", @get_suspicious_ips())
                .orWhereRaw("created_at > NOW() - INTERVAL 1 MINUTE")
                .having(@db.raw("COUNT(*)"), ">", 100)
        })
    }
}
```

## Sensitive Data Handling

```tusk
# Hide sensitive attributes in responses
class User extends Model {
    hidden: ["password", "remember_token", "api_secret", "ssn"]
    
    # Conditionally hide attributes
    makeVisible(attributes) {
        if (@auth.user?.isAdmin()) {
            return super.makeVisible(["api_secret"])
        }
        return this
    }
    
    # Redact sensitive data
    toArray() {
        data: super.toArray()
        
        # Partially mask sensitive data
        if (data.ssn) {
            data.ssn: "***-**-" + data.ssn.slice(-4)
        }
        
        if (data.credit_card) {
            data.credit_card: "**** **** **** " + data.credit_card.slice(-4)
        }
        
        return data
    }
}

# Secure password handling
class AuthController {
    register(request) {
        # Validate password strength
        validated: @validate(request.all(), {
            password: [
                "required",
                "min:12",  # Minimum length
                "regex:/[a-z]/",  # Lowercase
                "regex:/[A-Z]/",  # Uppercase  
                "regex:/[0-9]/",  # Number
                "regex:/[@$!%*?&]/",  # Special char
                "not_in:" + @get_common_passwords(),  # Not common
                "different:email"  # Not same as email
            ]
        })
        
        # Hash password with strong algorithm
        user: @User.create({
            ...validated,
            password: @password.hash(validated.password, {
                algorithm: PASSWORD_ARGON2ID,
                memory_cost: 65536,
                time_cost: 4,
                threads: 3
            })
        })
        
        # Don't return password in response
        return user.makeHidden(["password"])
    }
}
```

## Database Connection Security

```tusk
# Secure connection configuration
config.database: {
    connections: {
        mysql: {
            # Use environment variables
            host: @env("DB_HOST"),
            username: @env("DB_USERNAME"),
            password: @env("DB_PASSWORD"),
            
            # SSL/TLS encryption
            options: {
                PDO::MYSQL_ATTR_SSL_CA: @env("DB_SSL_CA"),
                PDO::MYSQL_ATTR_SSL_VERIFY_SERVER_CERT: true,
                PDO::ATTR_TIMEOUT: 10,
                PDO::ATTR_PERSISTENT: false  # Avoid persistent connections
            },
            
            # Strict mode
            strict: true,
            
            # Character set
            charset: "utf8mb4",
            collation: "utf8mb4_unicode_ci"
        }
    }
}

# Connection lifecycle management
class DatabaseSecurity {
    static configure() {
        # Limit connections
        @db.setMaxConnections(100)
        
        # Close idle connections
        @db.setIdleTimeout(300)  # 5 minutes
        
        # Monitor failed connections
        @db.failed((connection, exception) => {
            @log.critical("Database connection failed", {
                host: connection.getHost(),
                error: exception.message
            })
            
            # Alert on repeated failures
            if (@cache.increment("db.failures", 1) > 5) {
                @alert.database_down()
            }
        })
    }
}
```

## Query Monitoring and Anomaly Detection

```tusk
# Monitor for suspicious queries
class QuerySecurityMonitor {
    static monitor() {
        @db.listen((query) => {
            # Check for suspicious patterns
            if (@is_suspicious_query(query.sql)) {
                @log.warning("Suspicious query detected", {
                    sql: query.sql,
                    bindings: query.bindings,
                    user: @auth.id,
                    ip: @request.ip,
                    trace: @debug_backtrace()
                })
                
                # Block if critical
                if (@is_critical_threat(query.sql)) {
                    throw "Security violation: Query blocked"
                }
            }
            
            # Monitor data access patterns
            @track_data_access(query)
        })
    }
    
    static is_suspicious_query(sql) {
        patterns: [
            /UNION.*SELECT/i,  # Union-based injection
            /OR.*=.*/i,  # OR-based injection
            /';\s*DROP/i,  # Drop table attempts
            /xp_cmdshell/i,  # Command execution
            /LOAD_FILE/i,  # File access
            /INTO\s+OUTFILE/i  # File write
        ]
        
        for (pattern in patterns) {
            if (pattern.test(sql)) {
                return true
            }
        }
        
        return false
    }
    
    static track_data_access(query) {
        # Track access to sensitive tables
        sensitive_tables: ["users", "payments", "api_keys"]
        
        for (table in sensitive_tables) {
            if (query.sql.includes(table)) {
                @metrics.increment("db.sensitive_access", {
                    table: table,
                    user: @auth.id
                })
                
                # Alert on unusual access patterns
                access_count: @cache.increment(
                    "user." + @auth.id + ".access." + table,
                    1,
                    300  # 5 minute window
                )
                
                if (access_count > 100) {
                    @alert.excessive_data_access({
                        user: @auth.id,
                        table: table,
                        count: access_count
                    })
                }
            }
        }
    }
}
```

## Security Best Practices

```tusk
# Regular security tasks
#cron "0 2 * * *" {  # Daily at 2 AM
    # Rotate encryption keys
    @security.rotate_encryption_keys()
    
    # Clean up old audit logs
    @AuditLog.where("created_at", "<", @days_ago(90))
        .chunk(1000, (logs) => {
            # Archive before deleting
            @archive.store("audit-logs", logs)
            logs.delete()
        })
    
    # Check for weak passwords
    users_with_weak_passwords: @db.select("""
        SELECT id, email 
        FROM users 
        WHERE password IN (
            SELECT password 
            FROM users 
            GROUP BY password 
            HAVING COUNT(*) > 1
        )
    """)
    
    if (users_with_weak_passwords.length > 0) {
        @alert.weak_passwords_found(users_with_weak_passwords)
    }
}

# Security headers for database exports
#web /admin/export/users {
    #auth role: "admin"
    
    # Log export access
    @audit.log("export", {
        model: "User",
        user_id: @auth.id,
        ip: @request.ip
    })
    
    # Rate limit exports
    #rate_limit 5 per: "hour"
    
    # Export with redacted sensitive data
    users: @User.all().map(user => {
        data: user.toArray()
        delete data.password
        delete data.remember_token
        delete data.api_secret
        return data
    })
    
    @response.headers["Content-Security-Policy"]: "default-src 'none'"
    @response.download("users.csv", @generate_csv(users))
}
```

## Best Practices Summary

1. **Always use parameter binding** - Never concatenate user input into queries
2. **Implement mass assignment protection** - Use fillable/guarded properties
3. **Encrypt sensitive data** - Both in transit and at rest
4. **Use row-level security** - Implement proper access control
5. **Audit database access** - Log all sensitive operations
6. **Monitor for anomalies** - Detect unusual query patterns
7. **Rotate credentials regularly** - Database passwords and encryption keys
8. **Validate all input** - Before it reaches the database
9. **Use least privilege** - Database users should have minimal permissions
10. **Regular security audits** - Review and update security measures

## Related Topics

- `authentication` - User authentication
- `authorization` - Access control
- `encryption` - Data encryption
- `validation` - Input validation
- `security-headers` - HTTP security
---

[Macros in TuskLang]


Macros in TuskLang provide powerful metaprogramming capabilities, allowing you to generate code at compile time and create domain-specific languages (DSLs).

## Basic Macro Definition

```tusk
# Simple macro
@macro hello(name) {
    return "@console.log('Hello, " + name + "!')"
}

# Usage
@hello("World")  # Expands to: @console.log('Hello, World!')

# Macro with multiple parameters
@macro debug(variable, label = null) {
    if (label) {
        return "@console.log('" + label + ":', " + variable + ")"
    }
    return "@console.log('" + variable + ":', " + variable + ")"
}

# Usage
@debug(user.name)  # @console.log('user.name:', user.name)
@debug(total, "Total Amount")  # @console.log('Total Amount:', total)

# Block macros
@macro benchmark(code) {
    return """
        _benchmark_start: @microtime(true)
        {code}
        _benchmark_end: @microtime(true)
        @console.log('Execution time:', _benchmark_end - _benchmark_start)
    """
}

# Usage
@benchmark {
    result: @expensive_operation()
    @process_result(result)
}
```

## Code Generation Macros

```tusk
# Generate getter/setter methods
@macro property(name, type = "mixed") {
    return """
        private _{name}: {type}
        
        get{name.capitalize()}() {
            return this._{name}
        }
        
        set{name.capitalize()}(value: {type}) {
            this._{name} = value
            return this
        }
    """
}

# Usage in class
class User {
    @property("name", "string")
    @property("email", "string")
    @property("age", "int")
}

# Generates:
# private _name: string
# getName() { return this._name }
# setName(value: string) { this._name = value; return this }
# ... and so on

# Generate CRUD operations
@macro crud(model, table) {
    return """
        static all() {
            return @db.table("{table}").get()
        }
        
        static find(id) {
            return @db.table("{table}").where("id", id).first()
        }
        
        save() {
            if (this.id) {
                return @db.table("{table}")
                    .where("id", this.id)
                    .update(this)
            } else {
                this.id = @db.table("{table}").insertGetId(this)
                return this.id
            }
        }
        
        delete() {
            return @db.table("{table}")
                .where("id", this.id)
                .delete()
        }
    """
}

# Usage
class Product {
    @crud("Product", "products")
}
```

## AST Manipulation Macros

```tusk
# Macro that manipulates Abstract Syntax Tree
@macro memoize(method) {
    # Parse the method AST
    ast: @parse_method(method)
    method_name: ast.name
    params: ast.params.join(", ")
    
    return """
        {method_name}({params}) {
            _cache_key: "{method_name}:" + @json_encode([{params}])
            
            if (@cache.has(_cache_key)) {
                return @cache.get(_cache_key)
            }
            
            _result: (() => {
                {ast.body}
            })()
            
            @cache.put(_cache_key, _result, 3600)
            return _result
        }
    """
}

# Usage
class Calculator {
    @memoize
    fibonacci(n) {
        if (n <= 1) return n
        return this.fibonacci(n - 1) + this.fibonacci(n - 2)
    }
}

# Macro for automatic dependency injection
@macro inject(dependencies) {
    injections: ""
    
    for (name, type in dependencies) {
        injections += "this.{name} = @container.make('{type}')\n"
    }
    
    return """
        constructor() {
            {injections}
        }
    """
}

# Usage
class UserService {
    @inject({
        db: "Database",
        cache: "Cache",
        logger: "Logger"
    })
    
    getUser(id) {
        return this.cache.remember("user." + id, 3600, () => {
            this.logger.info("Fetching user", {id})
            return this.db.table("users").find(id)
        })
    }
}
```

## Conditional Compilation Macros

```tusk
# Environment-based code generation
@macro env_specific(code_map) {
    env: @compile_env("APP_ENV", "production")
    
    if (code_map[env]) {
        return code_map[env]
    }
    
    return code_map.default || ""
}

# Usage
class Logger {
    @env_specific({
        development: """
            log(message, context = {}) {
                @console.log('[DEV]', message, context)
                @file.append('debug.log', @json_encode({message, context, time: @now()}))
            }
        """,
        
        production: """
            log(message, context = {}) {
                @sentry.captureMessage(message, context)
            }
        """,
        
        testing: """
            log(message, context = {}) {
                @test_logs.push({message, context})
            }
        """
    })
}

# Feature flag macros
@macro feature(flag, enabled_code, disabled_code = "") {
    if (@compile_config("features." + flag, false)) {
        return enabled_code
    }
    return disabled_code
}

# Usage
class PaymentProcessor {
    @feature("stripe_payment", """
        processStripePayment(amount, token) {
            return @stripe.charges.create({
                amount: amount,
                source: token,
                currency: 'usd'
            })
        }
    """)
    
    @feature("crypto_payment", """
        processCryptoPayment(amount, wallet) {
            return @crypto.transfer({
                to: wallet,
                amount: amount,
                coin: 'BTC'
            })
        }
    """, """
        processCryptoPayment(amount, wallet) {
            throw "Crypto payments not enabled"
        }
    """)
}
```

## DSL Creation with Macros

```tusk
# Create a routing DSL
@macro route(path, options = {}) {
    method: options.method || "GET"
    middleware: options.middleware || []
    name: options.name || path.replace("/", ".").trim(".")
    
    return """
        @router.{method.toLowerCase()}('{path}', {{
            middleware: {middleware},
            name: '{name}',
            handler: (request, response) => {{
                {options.handler}
            }}
        }})
    """
}

# Usage
@route("/users", {
    method: "GET",
    middleware: ["auth", "throttle:60,1"],
    name: "users.index",
    handler: """
        users: @User.paginate(20)
        return @view('users.index', {users})
    """
})

# Create a validation DSL
@macro validate(rules) {
    validations: []
    
    for (field, rule in rules) {
        validations.push("""
            if (!@validator.{rule}(@request.{field})) {
                errors.{field} = @validator.getError('{rule}', '{field}')
            }
        """)
    }
    
    return """
        errors: {}
        {validations.join("\n")}
        
        if (Object.keys(errors).length > 0) {
            throw @ValidationException(errors)
        }
    """
}

# Usage
function createUser(request) {
    @validate({
        name: "required|string|min:3",
        email: "required|email|unique:users",
        age: "required|integer|min:18"
    })
    
    # Validation passed, create user
    return @User.create(request)
}
```

## Compile-Time Optimization Macros

```tusk
# Inline constant expressions
@macro const_eval(expression) {
    # Evaluate at compile time
    result: @compile_eval(expression)
    return @stringify(result)
}

# Usage
config: {
    max_items: @const_eval(1024 * 10),  # Compiles to: 10240
    cache_ttl: @const_eval(60 * 60 * 24),  # Compiles to: 86400
    api_version: @const_eval("v" + 2 + "." + 1)  # Compiles to: "v2.1"
}

# Loop unrolling macro
@macro unroll(count, code) {
    unrolled: ""
    
    for (i in 0..count-1) {
        unrolled += code.replace(/\{i\}/g, i) + "\n"
    }
    
    return unrolled
}

# Usage
function processPixels(image) {
    @unroll(4, """
        pixel{i}: image.data[offset + {i}]
        image.data[offset + {i}] = transform(pixel{i})
    """)
    # Generates:
    # pixel0: image.data[offset + 0]
    # image.data[offset + 0] = transform(pixel0)
    # pixel1: image.data[offset + 1]
    # image.data[offset + 1] = transform(pixel1)
    # ... etc
}
```

## Hygienic Macros

```tusk
# Hygienic macro with gensym
@macro swap(a, b) {
    temp_var: @gensym("temp")  # Generate unique variable name
    
    return """
        {temp_var}: {a}
        {a} = {b}
        {b} = {temp_var}
    """
}

# Usage - no variable name conflicts
x: 10
y: 20
temp: "don't conflict"

@swap(x, y)  # Works correctly, uses generated temp variable

# Macro with lexical scope preservation
@macro with_transaction(code) {
    tx_var: @gensym("tx")
    
    return """
        {tx_var}: @db.beginTransaction()
        try {
            @bind_context(tx: {tx_var})
            {code}
            {tx_var}.commit()
        } catch (e) {
            {tx_var}.rollback()
            throw e
        }
    """
}
```

## Advanced Macro Patterns

```tusk
# Recursive macros
@macro match(value, cases) {
    conditions: []
    
    for (pattern, code in cases) {
        if (pattern == "_") {
            conditions.push("else { " + code + " }")
        } else {
            conditions.push("if ({value} == {pattern}) { " + code + " }")
        }
    }
    
    return conditions.join(" else ")
}

# Macro composition
@macro compose(...macros) {
    return (code) => {
        result: code
        for (macro in macros.reverse()) {
            result: macro(result)
        }
        return result
    }
}

# Usage
@macro logged(code) {
    return "@log.info('Executing'); " + code
}

@macro timed(code) {
    return "start: @now(); " + code + "; @log.info('Time:', @now() - start)"
}

composed: @compose(logged, timed)

@composed {
    result: @complex_operation()
}

# Variadic macros
@macro pipeline(...steps) {
    code: "_pipeline_result: input\n"
    
    for (step in steps) {
        code += "_pipeline_result = {step}(_pipeline_result)\n"
    }
    
    code += "return _pipeline_result"
    
    return "(input) => {\n" + code + "\n}"
}

# Usage
transform: @pipeline(
    "@trim",
    "@lowercase",
    "@slugify",
    "(s) => s.replace(/-+/g, '-')"
)

slug: transform("  Hello WORLD!!!  ")  # "hello-world"
```

## Macro Debugging

```tusk
# Debug macro expansion
@macro debug_expand(macro_call) {
    expanded: @expand_macro(macro_call)
    
    @console.log("Macro expansion:")
    @console.log("Original:", @stringify(macro_call))
    @console.log("Expanded:", expanded)
    
    return expanded
}

# Macro profiling
@macro profile_macro(name, macro_def) {
    return """
        @macro {name}(...args) {
            _start: @compile_time()
            _result: ({macro_def})(...args)
            _duration: @compile_time() - _start
            
            @compile_log('{name} macro took ' + _duration + 'ms')
            
            return _result
        }
    """
}
```

## Best Practices

1. **Keep macros simple** - Complex macros are hard to debug
2. **Use hygienic macros** - Avoid variable name conflicts
3. **Document macro behavior** - Explain what code is generated
4. **Validate macro inputs** - Check parameters at compile time
5. **Consider alternatives** - Sometimes functions are better
6. **Test macro expansion** - Verify generated code
7. **Use meaningful names** - Make macro purpose clear
8. **Limit macro scope** - Don't overuse macros

## Related Topics

- `metaprogramming` - Advanced metaprogramming
- `code-generation` - Code generation techniques
- `compile-time-evaluation` - Compile-time features
- `dsl-creation` - Domain-specific languages
- `macro-hygiene` - Hygienic macro patterns
---

[Metaprogramming in TuskLang]


Metaprogramming allows you to write code that manipulates code, enabling powerful abstractions and dynamic behavior. TuskLang provides comprehensive metaprogramming capabilities.

## Reflection and Introspection

```tusk
# Class introspection
class User {
    name: string
    email: string
    private password: string
    
    getName() { return this.name }
    setName(value) { this.name = value }
    
    static findAll() { return @db.table("users").get() }
}

# Get class information
user_class: @reflect(User)

# Class properties
properties: user_class.getProperties()
for (prop in properties) {
    @console.log("Property:", {
        name: prop.name,
        type: prop.type,
        visibility: prop.visibility,
        value: prop.defaultValue
    })
}

# Class methods
methods: user_class.getMethods()
for (method in methods) {
    @console.log("Method:", {
        name: method.name,
        parameters: method.parameters,
        returnType: method.returnType,
        isStatic: method.isStatic
    })
}

# Instance introspection
user: new User()
user_meta: @reflect(user)

# Check if property exists
if (user_meta.hasProperty("email")) {
    email_prop: user_meta.getProperty("email")
    current_value: email_prop.getValue()
    email_prop.setValue("new@example.com")
}

# Call methods dynamically
method: user_meta.getMethod("getName")
result: method.invoke(user, [])

# Check inheritance
if (user_meta.isInstanceOf(User)) {
    @console.log("Is a User instance")
}
```

## Dynamic Method Creation

```tusk
# Add methods at runtime
class DynamicModel {
    constructor() {
        this._attributes: {}
    }
    
    # Define getter/setter dynamically
    defineAttribute(name, type = "mixed") {
        # Create getter
        this["get" + @str_studly(name)] = () => {
            return this._attributes[name]
        }
        
        # Create setter with validation
        this["set" + @str_studly(name)] = (value) => {
            if (!@validate_type(value, type)) {
                throw "Invalid type for " + name
            }
            this._attributes[name] = value
            return this
        }
    }
    
    # Method missing handler
    __call(method, args) {
        # Handle dynamic finders
        if (method.startsWith("findBy")) {
            field: @str_snake(method.substring(6))
            return @db.table(this.table)
                .where(field, args[0])
                .first()
        }
        
        # Handle dynamic scopes
        if (method.startsWith("scope")) {
            scope_name: method.substring(5)
            return this._scopes[scope_name]?.apply(this, args)
        }
        
        throw "Method " + method + " not found"
    }
}

# Usage
model: new DynamicModel()
model.defineAttribute("title", "string")
model.defineAttribute("price", "float")

model.setTitle("Product Name")
model.setPrice(29.99)

# Dynamic finder
product: model.findByTitle("Product Name")
```

## Code Generation at Runtime

```tusk
# Generate classes dynamically
function createModelClass(name, fields) {
    # Build class code
    code: "class " + name + " extends Model {\n"
    
    # Add properties
    for (field in fields) {
        code += "    " + field.name + ": " + field.type + "\n"
    }
    
    # Add validation rules
    code += "\n    rules() {\n        return {\n"
    for (field in fields) {
        if (field.validation) {
            code += "            " + field.name + ": '" + field.validation + "',\n"
        }
    }
    code += "        }\n    }\n"
    
    # Add relationships
    code += "\n    relationships() {\n        return {\n"
    for (field in fields) {
        if (field.relationship) {
            code += "            " + field.name + ": " + field.relationship + ",\n"
        }
    }
    code += "        }\n    }\n"
    
    code += "}\n"
    
    # Evaluate the code
    return @eval(code)
}

# Create a model dynamically
ProductModel: createModelClass("Product", [
    {name: "name", type: "string", validation: "required|min:3"},
    {name: "price", type: "float", validation: "required|numeric|min:0"},
    {name: "category_id", type: "int", relationship: "@belongsTo(Category)"},
    {name: "tags", type: "array", relationship: "@belongsToMany(Tag)"}
])

# Use the generated class
product: new ProductModel()
product.name: "Dynamic Product"
product.save()
```

## Attribute Handlers

```tusk
# Custom attribute system
class AttributeHandler {
    static handlers: {}
    
    static define(name, handler) {
        this.handlers[name] = handler
    }
    
    static apply(target, attributes) {
        for (attr in attributes) {
            if (this.handlers[attr.name]) {
                this.handlers[attr.name](target, attr.params)
            }
        }
    }
}

# Define custom attributes
AttributeHandler.define("Logged", (target, params) => {
    original_method: target[params.method]
    
    target[params.method] = function(...args) {
        @log.info("Calling " + params.method, {args})
        result: original_method.apply(this, args)
        @log.info("Result from " + params.method, {result})
        return result
    }
})

AttributeHandler.define("Cached", (target, params) => {
    original_method: target[params.method]
    ttl: params.ttl || 3600
    
    target[params.method] = function(...args) {
        cache_key: params.method + ":" + @json_encode(args)
        
        cached: @cache.get(cache_key)
        if (cached !== null) {
            return cached
        }
        
        result: original_method.apply(this, args)
        @cache.put(cache_key, result, ttl)
        return result
    }
})

# Apply attributes
class Service {
    @Logged(method: "process")
    @Cached(method: "process", ttl: 300)
    process(data) {
        # Expensive operation
        return @transform(data)
    }
}

# Attributes are applied at class definition
AttributeHandler.apply(Service.prototype, [
    {name: "Logged", params: {method: "process"}},
    {name: "Cached", params: {method: "process", ttl: 300}}
])
```

## Proxy Objects

```tusk
# Create proxy for object interception
class ModelProxy {
    constructor(target) {
        return new Proxy(target, {
            get: (obj, prop) => {
                # Log property access
                @metrics.increment("model.access", {prop})
                
                # Transform snake_case to camelCase
                if (prop.includes("_")) {
                    camel_prop: @str_camel(prop)
                    if (camel_prop in obj) {
                        return obj[camel_prop]
                    }
                }
                
                # Return original
                return obj[prop]
            },
            
            set: (obj, prop, value) => {
                # Validate before setting
                if (obj.rules && obj.rules[prop]) {
                    if (!@validate(value, obj.rules[prop])) {
                        throw "Validation failed for " + prop
                    }
                }
                
                # Track changes
                if (obj[prop] !== value) {
                    obj._changed = obj._changed || {}
                    obj._changed[prop] = {
                        from: obj[prop],
                        to: value
                    }
                }
                
                obj[prop] = value
                return true
            },
            
            has: (obj, prop) => {
                # Check both snake_case and camelCase
                return prop in obj || @str_camel(prop) in obj
            },
            
            deleteProperty: (obj, prop) => {
                # Prevent deletion of required fields
                if (obj.required && obj.required.includes(prop)) {
                    throw "Cannot delete required property: " + prop
                }
                delete obj[prop]
                return true
            }
        })
    }
}

# Usage
model: new ModelProxy({
    firstName: "John",
    lastName: "Doe",
    rules: {
        firstName: "string|min:2",
        email: "email"
    },
    required: ["firstName", "lastName"]
})

# Access with different naming conventions
name: model.first_name  # Works via proxy
email: model.email = "john@example.com"  # Validated via proxy
```

## Method Interception and AOP

```tusk
# Aspect-Oriented Programming
class AspectWeaver {
    static before(target, method, advice) {
        original: target[method]
        target[method] = function(...args) {
            advice.apply(this, args)
            return original.apply(this, args)
        }
    }
    
    static after(target, method, advice) {
        original: target[method]
        target[method] = function(...args) {
            result: original.apply(this, args)
            advice.call(this, result, ...args)
            return result
        }
    }
    
    static around(target, method, advice) {
        original: target[method]
        target[method] = function(...args) {
            return advice.call(this, original.bind(this), ...args)
        }
    }
    
    static throwing(target, method, advice) {
        original: target[method]
        target[method] = function(...args) {
            try {
                return original.apply(this, args)
            } catch (error) {
                return advice.call(this, error, ...args)
            }
        }
    }
}

# Apply aspects
class OrderService {
    createOrder(items, user) {
        # Business logic
        order: @Order.create({
            user_id: user.id,
            items: items,
            total: @calculateTotal(items)
        })
        return order
    }
}

# Add cross-cutting concerns
service: new OrderService()

# Logging aspect
AspectWeaver.before(service, "createOrder", (items, user) => {
    @log.info("Creating order", {user_id: user.id, item_count: items.length})
})

# Performance monitoring
AspectWeaver.around(service, "createOrder", (proceed, items, user) => {
    start: @microtime(true)
    result: proceed(items, user)
    duration: @microtime(true) - start
    @metrics.timing("order.create", duration)
    return result
})

# Error handling
AspectWeaver.throwing(service, "createOrder", (error, items, user) => {
    @log.error("Order creation failed", {error, user_id: user.id})
    @notify.admin("Order failure", {error, user})
    throw error
})
```

## Dynamic Type System

```tusk
# Runtime type checking and coercion
class TypeSystem {
    static types: {
        string: {
            check: (v) => typeof v === "string",
            coerce: (v) => String(v)
        },
        int: {
            check: (v) => Number.isInteger(v),
            coerce: (v) => parseInt(v)
        },
        float: {
            check: (v) => typeof v === "number",
            coerce: (v) => parseFloat(v)
        },
        bool: {
            check: (v) => typeof v === "boolean",
            coerce: (v) => !!v
        },
        array: {
            check: (v) => Array.isArray(v),
            coerce: (v) => Array.from(v)
        },
        object: {
            check: (v) => v && typeof v === "object" && !Array.isArray(v),
            coerce: (v) => Object(v)
        }
    }
    
    static define(name, definition) {
        this.types[name] = definition
    }
    
    static check(value, type) {
        if (this.types[type]) {
            return this.types[type].check(value)
        }
        return false
    }
    
    static coerce(value, type) {
        if (this.types[type]) {
            return this.types[type].coerce(value)
        }
        return value
    }
    
    static validate(value, type) {
        # Handle union types
        if (type.includes("|")) {
            types: type.split("|")
            return types.some(t => this.check(value, t.trim()))
        }
        
        # Handle nullable types
        if (type.endsWith("?")) {
            if (value === null || value === undefined) {
                return true
            }
            type: type.slice(0, -1)
        }
        
        # Handle array types
        if (type.endsWith("[]")) {
            if (!Array.isArray(value)) return false
            element_type: type.slice(0, -2)
            return value.every(item => this.validate(item, element_type))
        }
        
        return this.check(value, type)
    }
}

# Define custom types
TypeSystem.define("email", {
    check: (v) => /^[^@]+@[^@]+\.[^@]+$/.test(v),
    coerce: (v) => String(v).toLowerCase().trim()
})

TypeSystem.define("uuid", {
    check: (v) => /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v),
    coerce: (v) => String(v).toLowerCase()
})

# Typed property decorator
function typed(type) {
    return (target, property) => {
        private_prop: "_" + property
        
        Object.defineProperty(target, property, {
            get() {
                return this[private_prop]
            },
            set(value) {
                if (!TypeSystem.validate(value, type)) {
                    throw `Invalid type for ${property}: expected ${type}`
                }
                this[private_prop] = TypeSystem.coerce(value, type)
            }
        })
    }
}

# Usage
class User {
    @typed("string")
    name: string
    
    @typed("email")
    email: string
    
    @typed("int?")
    age: int?
    
    @typed("string[]")
    tags: string[]
}
```

## Code Analysis and Transformation

```tusk
# AST manipulation
class CodeTransformer {
    static analyze(code) {
        ast: @parse_code(code)
        
        return {
            functions: @extract_functions(ast),
            variables: @extract_variables(ast),
            imports: @extract_imports(ast),
            complexity: @calculate_complexity(ast)
        }
    }
    
    static transform(code, transformations) {
        ast: @parse_code(code)
        
        for (transform in transformations) {
            ast: transform(ast)
        }
        
        return @generate_code(ast)
    }
    
    static instrument(code, callbacks) {
        ast: @parse_code(code)
        
        # Add instrumentation
        @walk_ast(ast, (node) => {
            if (node.type === "FunctionCall") {
                # Wrap function calls
                node.transform((call) => {
                    return {
                        type: "Block",
                        body: [
                            callbacks.beforeCall(call),
                            call,
                            callbacks.afterCall(call)
                        ]
                    }
                })
            }
        })
        
        return @generate_code(ast)
    }
}

# Usage - Code coverage tool
instrumented: CodeTransformer.instrument(source_code, {
    beforeCall: (call) => {
        return @ast.statement(
            "@coverage.mark('" + call.location + "', 'called')"
        )
    },
    afterCall: (call) => {
        return @ast.statement(
            "@coverage.mark('" + call.location + "', 'completed')"
        )
    }
})
```

## Self-Modifying Code

```tusk
# Class that modifies itself based on usage
class AdaptiveClass {
    static method_calls: {}
    
    constructor() {
        # Monitor method usage
        this._monitor_usage()
    }
    
    _monitor_usage() {
        for (method in @get_methods(this)) {
            if (method.startsWith("_")) continue
            
            original: this[method]
            this[method] = (...args) => {
                # Track usage
                AdaptiveClass.method_calls[method] = 
                    (AdaptiveClass.method_calls[method] || 0) + 1
                
                # Optimize hot paths
                if (AdaptiveClass.method_calls[method] > 100) {
                    this._optimize_method(method)
                }
                
                return original.apply(this, args)
            }
        }
    }
    
    _optimize_method(method) {
        # Replace with optimized version
        if (method === "calculate" && !this._optimized_calculate) {
            # JIT compile or cache results
            original: this[method]
            cache: {}
            
            this[method] = (input) => {
                key: @json_encode(input)
                if (cache[key]) {
                    return cache[key]
                }
                
                result: original.call(this, input)
                cache[key] = result
                return result
            }
            
            this._optimized_calculate = true
            @log.info("Optimized method: calculate")
        }
    }
    
    # Add methods dynamically based on usage patterns
    _adapt_interface() {
        # Analyze usage patterns
        patterns: @analyze_usage_patterns(AdaptiveClass.method_calls)
        
        # Create convenience methods
        for (pattern in patterns) {
            if (pattern.type === "sequential_calls") {
                # Create combined method
                this[pattern.suggested_name] = (...args) => {
                    result: args
                    for (method in pattern.methods) {
                        result = this[method](...result)
                    }
                    return result
                }
            }
        }
    }
}
```

## Best Practices

1. **Use metaprogramming judiciously** - It can make code harder to understand
2. **Document dynamic behavior** - Explain what happens at runtime
3. **Provide type hints** - Even for dynamic code
4. **Test thoroughly** - Dynamic code needs more testing
5. **Consider performance** - Runtime generation has overhead
6. **Maintain debugging support** - Dynamic code is harder to debug
7. **Use established patterns** - Follow known metaprogramming patterns
8. **Keep it simple** - Don't be too clever

## Related Topics

- `reflection` - Runtime introspection
- `dynamic-types` - Dynamic type system
- `code-generation` - Generating code
- `aspect-oriented` - AOP patterns
- `proxy-pattern` - Object proxies
---

[Async Operations in TuskLang]


TuskLang provides comprehensive support for asynchronous programming, allowing you to write efficient, non-blocking code for I/O operations, concurrent tasks, and parallel processing.

## Basic Async/Await

```tusk
# Define async function
async function fetchUserData(userId) {
    # Await promise-based operations
    user: await @db.table("users").where("id", userId).first()
    
    # Parallel async operations
    [profile, posts, settings]: await Promise.all([
        @db.table("profiles").where("user_id", userId).first(),
        @db.table("posts").where("user_id", userId).get(),
        @db.table("settings").where("user_id", userId).first()
    ])
    
    return {
        user,
        profile,
        posts,
        settings
    }
}

# Call async function
try {
    data: await fetchUserData(123)
    @console.log("User data:", data)
} catch (error) {
    @console.error("Failed to fetch user data:", error)
}

# Async arrow functions
processItems: async (items) => {
    results: []
    
    for (item in items) {
        result: await @processItem(item)
        results.push(result)
    }
    
    return results
}

# Async class methods
class DataService {
    async getData(id) {
        cache_key: "data:" + id
        
        # Try cache first
        cached: await @cache.get(cache_key)
        if (cached) return cached
        
        # Fetch from API
        response: await @http.get("/api/data/" + id)
        data: response.json()
        
        # Cache for future
        await @cache.put(cache_key, data, 3600)
        
        return data
    }
}
```

## Promise Handling

```tusk
# Creating promises
function delay(ms) {
    return new Promise((resolve) => {
        @setTimeout(resolve, ms)
    })
}

# Promise with resolve and reject
function fetchWithTimeout(url, timeout = 5000) {
    return new Promise((resolve, reject) => {
        timer: @setTimeout(() => {
            reject(new Error("Request timeout"))
        }, timeout)
        
        @http.get(url)
            .then((response) => {
                @clearTimeout(timer)
                resolve(response)
            })
            .catch((error) => {
                @clearTimeout(timer)
                reject(error)
            })
    })
}

# Promise chaining
@fetchUser(userId)
    .then(user => @fetchPosts(user.id))
    .then(posts => @enrichPosts(posts))
    .then(enrichedPosts => {
        @console.log("Posts loaded:", enrichedPosts)
    })
    .catch(error => {
        @console.error("Error in chain:", error)
    })
    .finally(() => {
        @console.log("Operation complete")
    })

# Promise combinators
# Promise.all - Wait for all
results: await Promise.all([
    @fetchUser(1),
    @fetchUser(2),
    @fetchUser(3)
])

# Promise.allSettled - Get all results (success or failure)
results: await Promise.allSettled([
    @fetchUser(1),
    @fetchUser(2),
    @fetchUser(999)  # Might fail
])

for (result in results) {
    if (result.status === "fulfilled") {
        @console.log("Success:", result.value)
    } else {
        @console.log("Failed:", result.reason)
    }
}

# Promise.race - First to complete
fastest: await Promise.race([
    @fetchFromPrimary(),
    @fetchFromSecondary(),
    @fetchFromCache()
])

# Promise.any - First successful
result: await Promise.any([
    @attemptMethod1(),
    @attemptMethod2(),
    @attemptMethod3()
]).catch(errors => {
    @console.error("All attempts failed:", errors)
})
```

## Async Patterns

```tusk
# Sequential vs Parallel execution
# Sequential (slower)
async function processSequential(items) {
    results: []
    
    for (item in items) {
        result: await @processItem(item)  # Wait for each
        results.push(result)
    }
    
    return results
}

# Parallel (faster)
async function processParallel(items) {
    promises: items.map(item => @processItem(item))
    return await Promise.all(promises)
}

# Batch processing with concurrency limit
async function processBatched(items, batchSize = 5) {
    results: []
    
    for (i: 0; i < items.length; i += batchSize) {
        batch: items.slice(i, i + batchSize)
        batch_results: await Promise.all(
            batch.map(item => @processItem(item))
        )
        results.push(...batch_results)
    }
    
    return results
}

# Async queue with concurrency control
class AsyncQueue {
    constructor(concurrency = 5) {
        this.concurrency: concurrency
        this.running: 0
        this.queue: []
    }
    
    async add(task) {
        return new Promise((resolve, reject) => {
            this.queue.push({task, resolve, reject})
            this.process()
        })
    }
    
    async process() {
        while (this.running < this.concurrency && this.queue.length > 0) {
            item: this.queue.shift()
            this.running++
            
            item.task()
                .then(item.resolve)
                .catch(item.reject)
                .finally(() => {
                    this.running--
                    this.process()
                })
        }
    }
}

# Usage
queue: new AsyncQueue(3)  # Max 3 concurrent

for (url in urls) {
    queue.add(async () => {
        response: await @http.get(url)
        return response.json()
    })
}
```

## Error Handling in Async Code

```tusk
# Try-catch with async/await
async function riskyOperation() {
    try {
        result: await @doSomethingRisky()
        return result
    } catch (error) {
        @log.error("Operation failed:", error)
        
        # Retry logic
        if (error.code === "NETWORK_ERROR") {
            await @delay(1000)
            return await riskyOperation()  # Retry
        }
        
        throw error  # Re-throw if can't handle
    }
}

# Error handling utilities
async function withRetry(fn, maxAttempts = 3, delay = 1000) {
    lastError: null
    
    for (attempt: 1; attempt <= maxAttempts; attempt++) {
        try {
            return await fn()
        } catch (error) {
            lastError: error
            @log.warning(`Attempt ${attempt} failed:`, error)
            
            if (attempt < maxAttempts) {
                await @delay(delay * attempt)  # Exponential backoff
            }
        }
    }
    
    throw lastError
}

# Usage
result: await withRetry(async () => {
    return await @unreliableApi.getData()
})

# Async error boundaries
class AsyncErrorBoundary {
    static async wrap(fn, fallback = null) {
        try {
            return await fn()
        } catch (error) {
            @log.error("Async operation failed:", error)
            @metrics.increment("async.errors")
            
            if (fallback) {
                return typeof fallback === "function" 
                    ? await fallback(error)
                    : fallback
            }
            
            return null
        }
    }
}

# Usage
data: await AsyncErrorBoundary.wrap(
    async () => await @fetchCriticalData(),
    async (error) => {
        // Fallback to cache on error
        return await @cache.get("critical_data_backup")
    }
)
```

## Async Generators and Streams

```tusk
# Async generator function
async function* fetchPages(totalPages) {
    for (page: 1; page <= totalPages; page++) {
        data: await @api.getPage(page)
        yield data
        
        # Add delay to avoid rate limiting
        await @delay(100)
    }
}

# Consume async generator
async function processAllPages() {
    pages: fetchPages(10)
    
    for await (pageData of pages) {
        @console.log("Processing page:", pageData.page)
        await @processPageData(pageData)
    }
}

# Async stream processing
class AsyncStream {
    constructor(source) {
        this.source: source
        this.transforms: []
    }
    
    map(fn) {
        this.transforms.push(async (item) => await fn(item))
        return this
    }
    
    filter(fn) {
        this.transforms.push(async (item) => {
            return await fn(item) ? item : Symbol.skip
        })
        return this
    }
    
    async* [Symbol.asyncIterator]() {
        for await (item of this.source) {
            result: item
            
            for (transform of this.transforms) {
                result: await transform(result)
                if (result === Symbol.skip) break
            }
            
            if (result !== Symbol.skip) {
                yield result
            }
        }
    }
    
    async collect() {
        results: []
        for await (item of this) {
            results.push(item)
        }
        return results
    }
}

# Usage
stream: new AsyncStream(fetchPages(5))
    .map(async (page) => await @enrichPageData(page))
    .filter(async (page) => page.items.length > 0)

processedPages: await stream.collect()
```

## Web Workers and Parallel Processing

```tusk
# Worker pool for CPU-intensive tasks
class WorkerPool {
    constructor(workerScript, poolSize = 4) {
        this.workers: []
        this.queue: []
        this.busy: new Set()
        
        # Create worker pool
        for (i: 0; i < poolSize; i++) {
            worker: new Worker(workerScript)
            worker.id: i
            this.workers.push(worker)
        }
    }
    
    async execute(data) {
        return new Promise((resolve, reject) => {
            # Find available worker
            worker: this.getAvailableWorker()
            
            if (!worker) {
                # Queue if all busy
                this.queue.push({data, resolve, reject})
                return
            }
            
            # Mark as busy
            this.busy.add(worker.id)
            
            # Setup handlers
            worker.onmessage: (e) => {
                this.busy.delete(worker.id)
                resolve(e.data)
                this.processQueue()
            }
            
            worker.onerror: (error) => {
                this.busy.delete(worker.id)
                reject(error)
                this.processQueue()
            }
            
            # Send work to worker
            worker.postMessage(data)
        })
    }
    
    getAvailableWorker() {
        return this.workers.find(w => !this.busy.has(w.id))
    }
    
    processQueue() {
        if (this.queue.length === 0) return
        
        worker: this.getAvailableWorker()
        if (!worker) return
        
        task: this.queue.shift()
        this.execute(task.data)
            .then(task.resolve)
            .catch(task.reject)
    }
    
    async terminate() {
        await Promise.all(
            this.workers.map(w => w.terminate())
        )
    }
}

# Usage
pool: new WorkerPool("/workers/image-processor.js", 4)

# Process images in parallel
images: await Promise.all(
    imagePaths.map(path => 
        pool.execute({action: "resize", path, width: 800})
    )
)

await pool.terminate()
```

## Async Event Handling

```tusk
# Async event emitter
class AsyncEventEmitter {
    constructor() {
        this.events: {}
    }
    
    on(event, handler) {
        if (!this.events[event]) {
            this.events[event]: []
        }
        this.events[event].push(handler)
        return this
    }
    
    async emit(event, ...args) {
        if (!this.events[event]) return
        
        # Run handlers in parallel
        promises: this.events[event].map(handler => 
            Promise.resolve(handler(...args))
        )
        
        return await Promise.allSettled(promises)
    }
    
    async emitSerial(event, ...args) {
        if (!this.events[event]) return
        
        # Run handlers sequentially
        for (handler of this.events[event]) {
            await handler(...args)
        }
    }
}

# Usage
emitter: new AsyncEventEmitter()

emitter.on("user.created", async (user) => {
    await @sendWelcomeEmail(user)
})

emitter.on("user.created", async (user) => {
    await @createDefaultSettings(user)
})

emitter.on("user.created", async (user) => {
    await @notifyAdmins(user)
})

# Emit event
await emitter.emit("user.created", newUser)
```

## Async Resource Management

```tusk
# Async resource with automatic cleanup
class AsyncResource {
    static async using(resourceFactory, callback) {
        resource: await resourceFactory()
        
        try {
            return await callback(resource)
        } finally {
            if (resource.cleanup) {
                await resource.cleanup()
            }
        }
    }
}

# Database connection pool
class AsyncConnectionPool {
    constructor(config) {
        this.config: config
        this.connections: []
        this.available: []
        this.pending: []
    }
    
    async acquire() {
        # Return available connection
        if (this.available.length > 0) {
            return this.available.pop()
        }
        
        # Create new if under limit
        if (this.connections.length < this.config.maxConnections) {
            conn: await this.createConnection()
            this.connections.push(conn)
            return conn
        }
        
        # Wait for available connection
        return new Promise((resolve) => {
            this.pending.push(resolve)
        })
    }
    
    async release(connection) {
        # Check if anyone waiting
        if (this.pending.length > 0) {
            resolver: this.pending.shift()
            resolver(connection)
        } else {
            this.available.push(connection)
        }
    }
    
    async withConnection(callback) {
        conn: await this.acquire()
        
        try {
            return await callback(conn)
        } finally {
            await this.release(conn)
        }
    }
    
    async drain() {
        # Close all connections
        await Promise.all(
            this.connections.map(conn => conn.close())
        )
        
        this.connections: []
        this.available: []
    }
}

# Usage
pool: new AsyncConnectionPool({maxConnections: 10})

result: await pool.withConnection(async (conn) => {
    return await conn.query("SELECT * FROM users")
})
```

## Async Testing

```tusk
# Async test utilities
class AsyncTest {
    static async waitFor(condition, timeout = 5000, interval = 100) {
        start: Date.now()
        
        while (Date.now() - start < timeout) {
            if (await condition()) {
                return true
            }
            await @delay(interval)
        }
        
        throw new Error("Timeout waiting for condition")
    }
    
    static async expectAsync(asyncFn) {
        return {
            toResolve: async () => {
                try {
                    await asyncFn()
                    return true
                } catch {
                    throw new Error("Expected promise to resolve")
                }
            },
            
            toReject: async () => {
                try {
                    await asyncFn()
                    throw new Error("Expected promise to reject")
                } catch {
                    return true
                }
            },
            
            toRejectWith: async (expectedError) => {
                try {
                    await asyncFn()
                    throw new Error("Expected promise to reject")
                } catch (error) {
                    if (error.message !== expectedError.message) {
                        throw new Error(`Expected error: ${expectedError.message}, got: ${error.message}`)
                    }
                    return true
                }
            }
        }
    }
}

# Async test example
#test "Async operation completes successfully" async {
    result: await @performAsyncOperation()
    @assert.equals(result.status, "success")
    
    # Wait for side effect
    await AsyncTest.waitFor(async () => {
        cached: await @cache.get("operation_result")
        return cached !== null
    })
    
    # Test rejection
    await AsyncTest.expectAsync(
        async () => await @failingOperation()
    ).toReject()
}
```

## Best Practices

1. **Always handle errors** - Use try-catch or .catch()
2. **Avoid blocking operations** - Keep async functions truly async
3. **Use Promise.all() for parallel operations** - Don't await in loops
4. **Set timeouts for network operations** - Prevent hanging
5. **Clean up resources** - Use finally blocks
6. **Avoid callback hell** - Use async/await instead
7. **Test async code thoroughly** - Including error cases
8. **Monitor async performance** - Track execution times

## Related Topics

- `promises` - Promise fundamentals
- `event-loop` - Understanding the event loop
- `web-workers` - Parallel processing
- `streaming` - Stream processing
- `error-handling` - Async error patterns
---

[Plugin System in TuskLang]


TuskLang's plugin system allows you to extend the language and framework with reusable packages, creating a modular and extensible architecture for your applications.

## Creating Plugins

```tusk
# Basic plugin structure
class MyPlugin extends Plugin {
    # Plugin metadata
    name: "my-plugin"
    version: "1.0.0"
    description: "A sample TuskLang plugin"
    author: "Your Name"
    
    # Plugin dependencies
    requires: [
        "tusk-core >= 2.0",
        "another-plugin >= 1.5"
    ]
    
    # Plugin configuration schema
    config_schema: {
        api_key: {
            type: "string",
            required: true,
            description: "API key for external service"
        },
        cache_ttl: {
            type: "integer",
            default: 3600,
            description: "Cache time-to-live in seconds"
        },
        features: {
            type: "object",
            properties: {
                advanced_mode: {type: "boolean", default: false},
                max_retries: {type: "integer", default: 3}
            }
        }
    }
    
    # Initialize plugin
    install(app, config) {
        this.app: app
        this.config: @validate_config(config)
        
        # Register services
        @register_services()
        
        # Register middleware
        @register_middleware()
        
        # Register commands
        @register_commands()
        
        # Hook into lifecycle
        @register_hooks()
    }
    
    # Clean up on uninstall
    uninstall() {
        @cleanup_resources()
        @remove_hooks()
    }
}

# Register plugin
@app.use(MyPlugin, {
    api_key: @env("MY_PLUGIN_API_KEY"),
    cache_ttl: 7200,
    features: {
        advanced_mode: true
    }
})
```

## Service Provider Pattern

```tusk
# Advanced plugin with service provider
class AuthenticationPlugin extends Plugin {
    name: "auth-plugin"
    
    # Register services in the container
    register() {
        # Bind interface to implementation
        @app.bind("Auth", () => {
            return new AuthManager({
                driver: this.config.driver || "jwt",
                secret: this.config.secret
            })
        })
        
        # Singleton binding
        @app.singleton("AuthGuard", () => {
            return new AuthGuard(@app.make("Auth"))
        })
        
        # Tagged bindings
        @app.tag([JwtDriver, SessionDriver], "auth.drivers")
    }
    
    # Boot services after all plugins registered
    boot() {
        auth: @app.make("Auth")
        
        # Add custom guards
        auth.extend("api", () => {
            return new ApiGuard(this.config.api)
        })
        
        # Add macros
        @Request.macro("user", function() {
            return auth.user(this)
        })
        
        # Register middleware
        @app.middleware.register("auth", AuthMiddleware)
        @app.middleware.register("auth.api", ApiAuthMiddleware)
    }
    
    # Provide plugin API
    provides() {
        return {
            authenticate: (credentials) => {
                return @app.make("Auth").attempt(credentials)
            },
            
            check: () => {
                return @app.make("Auth").check()
            },
            
            guard: (name) => {
                return @app.make("Auth").guard(name)
            }
        }
    }
}
```

## Plugin Hooks and Events

```tusk
# Plugin with extensive hook system
class CachePlugin extends Plugin {
    name: "cache-plugin"
    
    install(app, config) {
        this.cache_manager: new CacheManager(config)
        
        # Hook into request lifecycle
        app.hook("request.before", async (request) => {
            if (this.should_cache(request)) {
                cached: await this.get_cached_response(request)
                if (cached) {
                    return cached  # Short-circuit request
                }
            }
        })
        
        app.hook("response.after", async (request, response) => {
            if (this.should_cache(request) && response.status === 200) {
                await this.cache_response(request, response)
            }
        })
        
        # Database query hooks
        app.hook("db.query.before", (query) => {
            if (query.cache_key) {
                cached: this.cache_manager.get(query.cache_key)
                if (cached) {
                    query.skip: true
                    query.result: cached
                }
            }
        })
        
        app.hook("db.query.after", (query, result) => {
            if (query.cache_key && !query.skip) {
                this.cache_manager.put(query.cache_key, result, query.cache_ttl)
            }
        })
        
        # Custom plugin events
        app.on("cache.clear", (tags) => {
            this.cache_manager.tags(tags).flush()
        })
        
        app.on("cache.warm", async (keys) => {
            for (key of keys) {
                await this.warm_cache(key)
            }
        })
    }
    
    # Define available hooks for other plugins
    hooks() {
        return {
            "cache.before.get": "Before retrieving from cache",
            "cache.after.get": "After retrieving from cache",
            "cache.before.put": "Before storing in cache",
            "cache.after.put": "After storing in cache",
            "cache.before.flush": "Before flushing cache",
            "cache.after.flush": "After flushing cache"
        }
    }
}
```

## Plugin CLI Commands

```tusk
# Plugin that adds CLI commands
class MigrationPlugin extends Plugin {
    name: "migration-plugin"
    
    register_commands() {
        # Register main command
        @app.command("migrate", {
            description: "Run database migrations",
            options: {
                "--force": "Force run in production",
                "--step": "Number of migrations to run",
                "--rollback": "Rollback migrations"
            },
            handler: this.handle_migrate.bind(this)
        })
        
        # Register sub-commands
        @app.command("make:migration", {
            description: "Create a new migration",
            arguments: {
                name: "Migration name"
            },
            handler: this.handle_make_migration.bind(this)
        })
        
        # Command with interactive prompts
        @app.command("migrate:fresh", {
            description: "Drop all tables and re-run migrations",
            handler: async (args, options) => {
                if (@app.env === "production" && !options.force) {
                    confirm: await @prompt.confirm(
                        "This will delete all data. Are you sure?"
                    )
                    
                    if (!confirm) {
                        @console.error("Migration cancelled")
                        return 1
                    }
                }
                
                await this.fresh_migrate()
                return 0
            }
        })
    }
    
    async handle_migrate(args, options) {
        @console.info("Running migrations...")
        
        if (options.rollback) {
            await this.rollback(options.step || 1)
        } else {
            await this.migrate(options.step)
        }
        
        @console.success("Migrations complete")
    }
}
```

## Plugin Middleware

```tusk
# Plugin providing middleware
class SecurityPlugin extends Plugin {
    name: "security-plugin"
    
    middleware() {
        return {
            # CORS middleware
            cors: (options = {}) => {
                return async (request, next) => {
                    origin: request.headers.origin
                    allowed: options.origins || ["*"]
                    
                    if (allowed[0] === "*" || allowed.includes(origin)) {
                        @response.headers["Access-Control-Allow-Origin"]: origin
                        @response.headers["Access-Control-Allow-Methods"]: 
                            options.methods || "GET,POST,PUT,DELETE,OPTIONS"
                        @response.headers["Access-Control-Allow-Headers"]: 
                            options.headers || "Content-Type,Authorization"
                    }
                    
                    if (request.method === "OPTIONS") {
                        return @response.status(204)
                    }
                    
                    return await next()
                }
            },
            
            # Rate limiting middleware
            throttle: (requests = 60, minutes = 1) => {
                limits: new Map()
                
                return async (request, next) => {
                    key: options.by || request.ip
                    limit_key: `throttle:${key}`
                    
                    current: limits.get(limit_key) || {count: 0, reset: Date.now() + minutes * 60000}
                    
                    if (Date.now() > current.reset) {
                        current: {count: 0, reset: Date.now() + minutes * 60000}
                    }
                    
                    if (current.count >= requests) {
                        return @response.status(429).json({
                            error: "Too many requests"
                        })
                    }
                    
                    current.count++
                    limits.set(limit_key, current)
                    
                    return await next()
                }
            },
            
            # Security headers
            secure: () => {
                return async (request, next) => {
                    response: await next()
                    
                    response.headers["X-Content-Type-Options"]: "nosniff"
                    response.headers["X-Frame-Options"]: "DENY"
                    response.headers["X-XSS-Protection"]: "1; mode=block"
                    response.headers["Referrer-Policy"]: "strict-origin-when-cross-origin"
                    
                    if (request.secure) {
                        response.headers["Strict-Transport-Security"]: 
                            "max-age=31536000; includeSubDomains"
                    }
                    
                    return response
                }
            }
        }
    }
}
```

## Plugin Assets and Resources

```tusk
# Plugin with assets and views
class UIPlugin extends Plugin {
    name: "ui-plugin"
    
    install(app, config) {
        # Register view paths
        @app.view.addPath(@plugin_path("views"))
        
        # Register asset publishing
        @app.assets.publish({
            from: @plugin_path("assets"),
            to: "plugins/ui",
            files: ["css/**", "js/**", "images/**"]
        })
        
        # Register components
        @app.view.component("ui-button", @plugin_path("components/button.tusk"))
        @app.view.component("ui-modal", @plugin_path("components/modal.tusk"))
        
        # Add global view data
        @app.view.share({
            ui_version: this.version,
            ui_config: config.ui || {}
        })
        
        # Register routes for plugin UI
        @app.router.group({
            prefix: "/admin/ui",
            middleware: ["auth", "admin"]
        }, (router) => {
            router.get("/", this.show_dashboard)
            router.get("/components", this.show_components)
            router.post("/settings", this.update_settings)
        })
    }
    
    # Helper to get plugin paths
    plugin_path(relative = "") {
        return @path.join(@plugins_path(), this.name, relative)
    }
}
```

## Plugin Testing

```tusk
# Testable plugin structure
class TestablePlugin extends Plugin {
    name: "testable-plugin"
    
    # Provide test helpers
    testing() {
        return {
            # Mock services
            mock: (service, implementation) => {
                @app.instance(service, implementation)
            },
            
            # Test data factories
            factory: (model) => {
                return this.factories[model] || null
            },
            
            # Assertions
            assertions: {
                assertPluginLoaded: (name) => {
                    loaded: @app.plugins.has(name)
                    @assert.true(loaded, `Plugin ${name} not loaded`)
                },
                
                assertServiceBound: (service) => {
                    bound: @app.bound(service)
                    @assert.true(bound, `Service ${service} not bound`)
                }
            }
        }
    }
}

# Plugin test
#test "Plugin loads correctly" {
    # Create test app
    app: @create_test_app()
    
    # Load plugin with test config
    app.use(TestablePlugin, {
        test_mode: true
    })
    
    # Get testing helpers
    plugin_test: app.plugin("testable-plugin").testing()
    
    # Test plugin loaded
    plugin_test.assertions.assertPluginLoaded("testable-plugin")
    
    # Test services registered
    plugin_test.assertions.assertServiceBound("TestService")
    
    # Mock external service
    plugin_test.mock("ExternalApi", {
        fetch: async () => ({data: "test"})
    })
    
    # Test functionality
    result: await app.make("TestService").process()
    @assert.equals(result.data, "test")
}
```

## Plugin Distribution

```tusk
# Plugin package.tsk file
{
    name: "awesome-plugin",
    version: "2.1.0",
    description: "An awesome TuskLang plugin",
    keywords: ["tusk", "plugin", "awesome"],
    
    # Plugin metadata
    plugin: {
        class: "AwesomePlugin",
        category: "utilities",
        compatibility: "^3.0"
    },
    
    # Dependencies
    dependencies: {
        "tusk-framework": "^3.0",
        "another-package": "^1.2"
    },
    
    # Dev dependencies
    devDependencies: {
        "tusk-test": "^3.0"
    },
    
    # Auto-discovery
    extra: {
        tusk: {
            providers: [
                "AwesomePlugin"
            ],
            aliases: {
                "Awesome": "AwesomeFacade"
            }
        }
    },
    
    # Scripts
    scripts: {
        test: "tusk test",
        "post-install": "tusk plugin:publish --tag=assets"
    }
}

# Publishing plugin
@console.command("plugin:publish", async () => {
    # Validate plugin
    validation: await @validate_plugin()
    if (!validation.valid) {
        @console.error("Plugin validation failed:", validation.errors)
        return 1
    }
    
    # Build plugin
    await @build_plugin({
        minify: true,
        sourcemaps: false
    })
    
    # Publish to registry
    await @publish_to_registry({
        registry: @config.plugin_registry,
        token: @env("PLUGIN_REGISTRY_TOKEN")
    })
    
    @console.success("Plugin published successfully!")
})
```

## Plugin Best Practices

```tusk
# Well-structured plugin
class BestPracticePlugin extends Plugin {
    name: "best-practice"
    
    # Version compatibility
    compatible_versions: ["3.0", "3.1", "3.2"]
    
    # Feature detection
    install(app, config) {
        # Check for required features
        if (!app.has_feature("async_hooks")) {
            throw "This plugin requires async_hooks feature"
        }
        
        # Graceful degradation
        if (app.has_feature("advanced_cache")) {
            this.cache_strategy: "advanced"
        } else {
            this.cache_strategy: "basic"
        }
        
        # Namespace isolation
        this.namespace: `plugin:${this.name}:`
        
        # Error boundaries
        this.wrap_errors(() => {
            this.initialize_services()
        })
    }
    
    # Provide upgrade path
    upgrade(from_version, to_version) {
        if (from_version < "2.0" && to_version >= "2.0") {
            # Migrate configuration
            @migrate_v1_config_to_v2()
        }
    }
    
    # Clean uninstall
    uninstall() {
        # Remove all plugin data
        @cache.forget_pattern(this.namespace + "*")
        @db.table("plugin_data").where("plugin", this.name).delete()
        
        # Unregister all services
        for (service of this.registered_services) {
            @app.forget(service)
        }
        
        # Remove event listeners
        @app.off(this.event_listeners)
    }
    
    # Debugging support
    debug_info() {
        return {
            version: this.version,
            config: @sanitize_config(this.config),
            services: this.registered_services,
            stats: this.get_usage_stats()
        }
    }
}
```

## Best Practices

1. **Follow naming conventions** - Use clear, descriptive names
2. **Version your plugins** - Use semantic versioning
3. **Document configuration** - Provide schema and examples
4. **Handle errors gracefully** - Don't crash the host app
5. **Clean up on uninstall** - Remove all traces
6. **Test thoroughly** - Include unit and integration tests
7. **Minimize dependencies** - Keep plugins lightweight
8. **Provide migration paths** - Support upgrades

## Related Topics

- `dependency-injection` - Service container
- `event-system` - Event handling
- `middleware` - Middleware system
- `package-management` - Package distribution
- `testing-plugins` - Plugin testing
---

[Testing Framework in TuskLang]


TuskLang includes a comprehensive testing framework that makes it easy to write and run tests for your applications, ensuring code quality and preventing regressions.

## Writing Tests

```tusk
# Basic test structure
#test "User can be created" {
    user: @User.create({
        name: "John Doe",
        email: "john@example.com"
    })
    
    @assert.equals(user.name, "John Doe")
    @assert.equals(user.email, "john@example.com")
    @assert.true(user.exists)
}

# Async tests
#test "API returns user data" async {
    response: await @http.get("/api/user/1")
    
    @assert.equals(response.status, 200)
    @assert.hasProperty(response.json(), "name")
    @assert.equals(response.json().id, 1)
}

# Test with setup and teardown
#test "Order calculation" {
    # Setup
    @beforeEach(() => {
        @db.beginTransaction()
        
        this.user: @factory(User).create()
        this.products: @factory(Product).count(3).create()
    })
    
    # Teardown
    @afterEach(() => {
        @db.rollback()
    })
    
    # Test
    order: @Order.create({
        user_id: this.user.id,
        items: this.products.map(p => ({product_id: p.id, quantity: 2}))
    })
    
    expected_total: this.products.sum(p => p.price * 2)
    @assert.equals(order.total, expected_total)
}
```

## Test Suites and Organization

```tusk
# Group related tests
#suite "User Authentication" {
    # Suite-level setup
    @beforeAll(() => {
        this.auth_service: new AuthService()
        this.test_users: @factory(User).count(5).create()
    })
    
    @afterAll(() => {
        @cleanup_test_data()
    })
    
    #test "Valid credentials authenticate successfully" {
        user: this.test_users[0]
        result: this.auth_service.attempt({
            email: user.email,
            password: "password"
        })
        
        @assert.true(result.success)
        @assert.equals(result.user.id, user.id)
    }
    
    #test "Invalid credentials fail authentication" {
        result: this.auth_service.attempt({
            email: "wrong@example.com",
            password: "wrongpassword"
        })
        
        @assert.false(result.success)
        @assert.equals(result.error, "Invalid credentials")
    }
    
    #test "Account lockout after failed attempts" {
        user: this.test_users[1]
        
        # Make multiple failed attempts
        for (i in 1..5) {
            this.auth_service.attempt({
                email: user.email,
                password: "wrong"
            })
        }
        
        # Should be locked out
        result: this.auth_service.attempt({
            email: user.email,
            password: "password"  # Even correct password fails
        })
        
        @assert.false(result.success)
        @assert.equals(result.error, "Account locked")
    }
}

# Nested test suites
#suite "E-commerce" {
    #suite "Shopping Cart" {
        #test "Add items to cart" {
            cart: new Cart()
            product: @factory(Product).create()
            
            cart.add(product, 2)
            
            @assert.equals(cart.count(), 1)
            @assert.equals(cart.quantity(product), 2)
        }
        
        #test "Remove items from cart" {
            // Test implementation
        }
    }
    
    #suite "Checkout Process" {
        #test "Calculate shipping" {
            // Test implementation
        }
        
        #test "Apply discounts" {
            // Test implementation
        }
    }
}
```

## Assertions

```tusk
# Basic assertions
@assert.true(value)
@assert.false(value)
@assert.equals(actual, expected)
@assert.notEquals(actual, expected)
@assert.strictEquals(actual, expected)  # === comparison
@assert.null(value)
@assert.notNull(value)
@assert.undefined(value)
@assert.notUndefined(value)

# Type assertions
@assert.isString(value)
@assert.isNumber(value)
@assert.isBoolean(value)
@assert.isArray(value)
@assert.isObject(value)
@assert.isFunction(value)
@assert.instanceOf(object, Class)

# Comparison assertions
@assert.greaterThan(actual, expected)
@assert.greaterThanOrEqual(actual, expected)
@assert.lessThan(actual, expected)
@assert.lessThanOrEqual(actual, expected)
@assert.between(value, min, max)

# String assertions
@assert.contains(haystack, needle)
@assert.notContains(haystack, needle)
@assert.startsWith(string, prefix)
@assert.endsWith(string, suffix)
@assert.matches(string, pattern)  # Regex

# Array/Object assertions
@assert.includes(array, item)
@assert.notIncludes(array, item)
@assert.hasProperty(object, property)
@assert.hasProperties(object, [prop1, prop2])
@assert.deepEquals(actual, expected)  # Deep comparison
@assert.isEmpty(collection)
@assert.isNotEmpty(collection)
@assert.lengthOf(collection, length)

# Exception assertions
@assert.throws(() => {
    @risky_operation()
})

@assert.throws(() => {
    @risky_operation()
}, "Expected error message")

@assert.throws(() => {
    @risky_operation()
}, ErrorClass)

@assert.doesNotThrow(() => {
    @safe_operation()
})

# Async assertions
@assert.rejects(async () => {
    await @failing_async_operation()
})

@assert.resolves(async () => {
    await @successful_async_operation()
})

# Custom assertions
@assert.custom(value, (v) => {
    return v > 0 && v < 100
}, "Value must be between 0 and 100")
```

## Mocking and Stubbing

```tusk
# Create mocks
#test "Service uses repository" {
    # Create mock
    mock_repo: @mock(UserRepository)
    
    # Set expectations
    mock_repo.expects("find")
        .withArgs(1)
        .once()
        .returns({id: 1, name: "Test User"})
    
    # Use mock
    service: new UserService(mock_repo)
    user: service.getUser(1)
    
    # Verify expectations
    @assert.equals(user.name, "Test User")
    mock_repo.verify()  # Verify all expectations met
}

# Partial mocks (spies)
#test "Method calls tracked" {
    service: new EmailService()
    
    # Spy on method
    spy: @spy(service, "send")
    
    # Use service normally
    service.sendWelcomeEmail("user@example.com")
    service.sendPasswordReset("user@example.com")
    
    # Verify calls
    @assert.equals(spy.callCount(), 2)
    @assert.true(spy.calledWith("user@example.com"))
    @assert.equals(spy.firstCall().args[0], "user@example.com")
}

# Stub external services
#test "API client handles responses" {
    # Stub HTTP requests
    @stub(@http, "get")
        .withArgs("/api/users")
        .returns({
            status: 200,
            json: () => [{id: 1, name: "User 1"}]
        })
    
    client: new ApiClient()
    users: await client.getUsers()
    
    @assert.lengthOf(users, 1)
    @assert.equals(users[0].name, "User 1")
}

# Time mocking
#test "Cache expires after TTL" {
    # Freeze time
    @clock.freeze("2024-01-01 12:00:00")
    
    cache: new Cache()
    cache.put("key", "value", 3600)  # 1 hour TTL
    
    # Advance time
    @clock.advance(3601)  # 1 hour + 1 second
    
    @assert.null(cache.get("key"))
    
    # Restore real time
    @clock.restore()
}
```

## HTTP Testing

```tusk
# Test HTTP endpoints
#test "GET /users returns user list" {
    response: @get("/users")
    
    response.assertOk()
    response.assertJson()
    response.assertJsonCount(10)
    response.assertJsonStructure([
        "*" => ["id", "name", "email"]
    ])
}

#test "POST /users creates user" {
    response: @post("/users", {
        name: "New User",
        email: "new@example.com",
        password: "secret123"
    })
    
    response.assertCreated()
    response.assertJson({
        name: "New User",
        email: "new@example.com"
    })
    
    # Verify in database
    @assertDatabaseHas("users", {
        email: "new@example.com"
    })
}

# Test with authentication
#test "Protected route requires auth" {
    # Without auth
    response: @get("/admin/dashboard")
    response.assertUnauthorized()
    
    # With auth
    user: @factory(User).create({role: "admin"})
    response: @actingAs(user).get("/admin/dashboard")
    response.assertOk()
    response.assertSee("Admin Dashboard")
}

# Test file uploads
#test "File upload endpoint" {
    file: @UploadedFile.fake().image("avatar.jpg", 100, 100)
    
    response: @post("/upload", {
        avatar: file
    })
    
    response.assertOk()
    response.assertJson({
        filename: "avatar.jpg",
        size: file.size()
    })
    
    # Verify file stored
    @assertFileExists("uploads/avatar.jpg")
}

# Test API with headers
#test "API requires valid token" {
    token: "Bearer valid-api-token"
    
    response: @withHeaders({
        "Authorization": token,
        "Accept": "application/json"
    }).get("/api/protected")
    
    response.assertOk()
}
```

## Database Testing

```tusk
# Database assertions
#test "User registration saves to database" {
    # Start with clean state
    @assertDatabaseCount("users", 0)
    
    # Register user
    @post("/register", {
        name: "Test User",
        email: "test@example.com",
        password: "password123"
    })
    
    # Verify database state
    @assertDatabaseHas("users", {
        email: "test@example.com"
    })
    
    @assertDatabaseMissing("users", {
        email: "other@example.com"
    })
    
    @assertDatabaseCount("users", 1)
}

# Test transactions
#test "Failed payment rolls back order" {
    @expectsTransaction(() => {
        order: @Order.create({
            user_id: 1,
            total: 100
        })
        
        # This will fail and trigger rollback
        @PaymentService.charge(order, invalid_card)
    })
    
    # Verify rollback
    @assertDatabaseCount("orders", 0)
}

# Seeded database testing
#test "Query scope returns correct results" {
    # Seed test data
    @seed(UserSeeder, {count: 10})
    @factory(User).state("inactive").count(5).create()
    
    # Test scope
    active_users: @User.active().get()
    
    @assert.lengthOf(active_users, 10)
}
```

## Test Doubles and Fakes

```tusk
# Create test doubles
class FakeMailer extends Mailer {
    sent: []
    
    send(to, subject, body) {
        this.sent.push({to, subject, body})
        return true
    }
    
    assertSent(to, subject = null) {
        found: this.sent.find(mail => {
            return mail.to === to && 
                   (!subject || mail.subject === subject)
        })
        
        @assert.notNull(found, `Mail not sent to ${to}`)
    }
    
    assertNotSent(to) {
        found: this.sent.find(mail => mail.to === to)
        @assert.null(found, `Mail was sent to ${to}`)
    }
    
    assertSentCount(count) {
        @assert.equals(this.sent.length, count)
    }
}

# Use fake in tests
#test "Welcome email sent on registration" {
    fake_mailer: new FakeMailer()
    @app.instance(Mailer, fake_mailer)
    
    # Register user
    @post("/register", {
        email: "new@example.com",
        name: "New User"
    })
    
    # Verify email sent
    fake_mailer.assertSent("new@example.com", "Welcome to our app!")
    fake_mailer.assertSentCount(1)
}

# In-memory implementations
class InMemoryCache extends Cache {
    data: {}
    
    get(key) {
        return this.data[key]?.value || null
    }
    
    put(key, value, ttl) {
        this.data[key] = {
            value,
            expires: Date.now() + ttl * 1000
        }
    }
    
    forget(key) {
        delete this.data[key]
    }
    
    flush() {
        this.data = {}
    }
}
```

## Browser Testing

```tusk
# Browser automation tests
#test "User can complete checkout" browser {
    # Visit page
    @visit("/shop")
    
    # Interact with page
    @click("Add to Cart").on(".product:first-child")
    @click("Checkout")
    
    # Fill form
    @type("Test User").into("#name")
    @type("test@example.com").into("#email")
    @type("4242 4242 4242 4242").into("#card-number")
    
    # Submit
    @click("Complete Order")
    
    # Assert results
    @assertSee("Order Confirmed")
    @assertUrlIs("/order-success")
    @assertPresent(".order-number")
}

# JavaScript testing
#test "Modal opens and closes" browser {
    @visit("/page-with-modal")
    
    # Assert hidden initially
    @assertNotVisible("#modal")
    
    # Open modal
    @click("[data-open-modal]")
    @assertVisible("#modal")
    
    # Close modal
    @click("[data-close-modal]")
    @assertNotVisible("#modal")
    
    # Test escape key
    @click("[data-open-modal]")
    @press("Escape")
    @assertNotVisible("#modal")
}

# Wait for dynamic content
#test "Ajax content loads" browser {
    @visit("/ajax-page")
    
    @click("#load-more")
    
    # Wait for content
    @waitFor(".new-content", 5000)
    @assertSee("Loaded content")
    
    # Wait for text
    @waitForText("Loading complete")
    
    # Wait for custom condition
    @waitUntil(() => {
        return @elements(".item").length >= 10
    }, 10000)
}
```

## Test Configuration

```tusk
# test.config.tsk
{
    # Test directories
    test_paths: [
        "tests/unit",
        "tests/integration",
        "tests/browser"
    ],
    
    # Test environment
    environment: {
        APP_ENV: "testing",
        DB_CONNECTION: "sqlite",
        DB_DATABASE: ":memory:",
        CACHE_DRIVER: "array",
        QUEUE_DRIVER: "sync"
    },
    
    # Coverage settings
    coverage: {
        enabled: true,
        include: ["app/**"],
        exclude: ["app/tests/**", "app/vendor/**"],
        reporters: ["html", "text", "clover"],
        threshold: {
            statements: 80,
            branches: 75,
            functions: 80,
            lines: 80
        }
    },
    
    # Parallel execution
    parallel: {
        enabled: true,
        workers: 4
    },
    
    # Retry flaky tests
    retry: {
        times: 3,
        delay: 1000
    },
    
    # Global timeout
    timeout: 30000,
    
    # Before/after hooks
    setup: "tests/setup.tsk",
    teardown: "tests/teardown.tsk"
}
```

## Running Tests

```tusk
# CLI commands
# Run all tests
@test

# Run specific file
@test tests/unit/UserTest.tsk

# Run specific suite
@test --suite "User Authentication"

# Run with pattern
@test --grep "login"

# Run with coverage
@test --coverage

# Run in watch mode
@test --watch

# Run specific test method
@test tests/UserTest.tsk::test_user_creation

# Parallel execution
@test --parallel --workers=8

# With specific environment
@test --env=testing.ci
```

## Best Practices

1. **Write tests first** - TDD improves design
2. **Keep tests focused** - One assertion per test
3. **Use descriptive names** - Test names should explain what they test
4. **Mock external services** - Tests should be fast and isolated
5. **Clean up after tests** - Don't leave test data
6. **Test edge cases** - Not just happy paths
7. **Maintain test coverage** - Aim for 80%+ coverage
8. **Run tests frequently** - Catch issues early

## Related Topics

- `mocking` - Mock object patterns
- `test-doubles` - Fakes, stubs, spies
- `browser-testing` - Browser automation
- `continuous-integration` - CI/CD setup
- `test-driven-development` - TDD practices
---

[Debugging Tools in TuskLang]


TuskLang provides a comprehensive suite of debugging tools to help you identify and fix issues in your code quickly and efficiently.

## Built-in Debugger

```tusk
# Set breakpoints in code
function processUser(user) {
    @debugger()  # Execution stops here
    
    # Step through code
    validated: @validateUser(user)
    
    @debugger.if(user.role === "admin")  # Conditional breakpoint
    
    # Continue execution
    return @saveUser(validated)
}

# Debug with context
@debug({
    user: user,
    validated: validated,
    stack: @debug_backtrace()
})

# Interactive debugging
@debug.interactive()  # Opens REPL at this point

# Debug only in development
if (@env.debug) {
    @debug.dump(complexObject)
    @debug.trace("Processing user: " + user.id)
}
```

## Logging and Output

```tusk
# Console logging with levels
@console.log("Basic message")
@console.info("Information", {context: data})
@console.warn("Warning message")
@console.error("Error occurred", error)
@console.debug("Debug info", {verbose: true})

# Formatted output
@console.table([
    {name: "John", age: 30, role: "admin"},
    {name: "Jane", age: 25, role: "user"}
])

@console.group("User Processing")
@console.log("Starting...")
@console.log("Validating...")
@console.log("Saving...")
@console.groupEnd()

# Timing operations
@console.time("operation")
// ... expensive operation
@console.timeEnd("operation")  # Outputs: operation: 123.45ms

# Pretty printing
@dd(complexObject)  # Dump and die
@dump(complexObject)  # Dump and continue

# Structured logging
logger: @logger("app.users")

logger.info("User created", {
    user_id: user.id,
    email: user.email,
    ip: @request.ip
})

logger.error("Failed to save user", {
    error: exception.message,
    trace: exception.trace,
    user_data: user
})
```

## Stack Traces and Error Information

```tusk
# Get current stack trace
stack: @debug_backtrace()

for (frame in stack) {
    @console.log("File:", frame.file)
    @console.log("Line:", frame.line)
    @console.log("Function:", frame.function)
    @console.log("Class:", frame.class)
    @console.log("Args:", frame.args)
}

# Enhanced error information
try {
    @risky_operation()
} catch (Exception e) {
    # Get detailed error info
    error_info: @debug.exception(e)
    
    @console.error("Exception Details:", {
        message: error_info.message,
        file: error_info.file,
        line: error_info.line,
        trace: error_info.trace,
        previous: error_info.previous,
        context: error_info.context  # Code around error
    })
    
    # Log to error tracking service
    @sentry.captureException(e, {
        user: @auth.user,
        tags: {
            module: "payment",
            severity: "high"
        }
    })
}

# Custom error handler
@error.handler((exception, request) => {
    # Development: Show detailed error page
    if (@env.debug) {
        return @render("errors.debug", {
            exception: exception,
            request: request,
            stack: @format_stack_trace(exception.trace),
            source: @get_source_context(exception.file, exception.line)
        })
    }
    
    # Production: Log and show generic error
    @log.error("Unhandled exception", {
        exception: exception,
        url: request.url,
        user: @auth.id
    })
    
    return @render("errors.500")
})
```

## Variable Inspection

```tusk
# Inspect variable details
user: @User.find(1)

# Get variable info
info: @debug.inspect(user)
@console.log("Type:", info.type)
@console.log("Class:", info.class)
@console.log("Properties:", info.properties)
@console.log("Methods:", info.methods)
@console.log("Memory:", info.memory_usage)

# Watch variables for changes
@debug.watch("user.status", (old_value, new_value) => {
    @console.log("Status changed from", old_value, "to", new_value)
    @debug.trace()
})

# Deep object inspection
@debug.dump(user, {
    depth: 5,  # Max nesting depth
    show_hidden: true,  # Include private properties
    show_methods: true,  # Include method signatures
    circular: "[Circular]"  # Handle circular references
})

# Memory profiling
memory_before: @memory_get_usage()
// ... operation
memory_after: @memory_get_usage()

@console.log("Memory used:", memory_after - memory_before)
@console.log("Peak memory:", @memory_get_peak_usage())
```

## Query Debugging

```tusk
# Enable query logging
@db.enableQueryLog()

// ... run queries
users: @User.where("active", true)->get()

# Get executed queries
queries: @db.getQueryLog()

for (query in queries) {
    @console.log("SQL:", query.sql)
    @console.log("Bindings:", query.bindings)
    @console.log("Time:", query.time + "ms")
}

# Query debugging helper
@db.listen((query) => {
    # Log slow queries
    if (query.time > 100) {
        @logger.warning("Slow query detected", {
            sql: query.sql,
            time: query.time,
            backtrace: @debug_backtrace()
        })
    }
    
    # Debug specific tables
    if (query.sql.includes("users")) {
        @console.debug("User query:", query)
    }
})

# Explain queries
query: @User.where("age", ">", 18)->orderBy("created_at")

# Get query plan
explanation: query.explain()
@console.table(explanation)

# Get raw SQL
@console.log("SQL:", query.toSql())
@console.log("Bindings:", query.getBindings())
```

## HTTP Request/Response Debugging

```tusk
# Debug incoming requests
@middleware.debug_request((request) => {
    @console.group("Incoming Request")
    @console.log("Method:", request.method)
    @console.log("URL:", request.url)
    @console.log("Headers:", request.headers)
    @console.log("Query:", request.query)
    @console.log("Body:", request.post)
    @console.log("Files:", request.files)
    @console.groupEnd()
})

# Debug outgoing responses
@middleware.debug_response((response) => {
    @console.group("Outgoing Response")
    @console.log("Status:", response.status)
    @console.log("Headers:", response.headers)
    @console.log("Body preview:", @str_limit(response.body, 500))
    @console.groupEnd()
})

# HTTP client debugging
client: @http.debug()  # Enable debug mode

response: await client.post("https://api.example.com/users", {
    name: "Test User"
})

# Outputs full request/response details
```

## Performance Profiling

```tusk
# Profile code sections
@profile.start("user-processing")

// ... code to profile
users: @User.all()
for (user in users) {
    @process_user(user)
}

@profile.end("user-processing")

# Get profile results
results: @profile.get("user-processing")
@console.log("Total time:", results.duration)
@console.log("Memory used:", results.memory)
@console.log("Calls:", results.calls)

# Automatic profiling
@profile.auto("UserService::processAll", () => {
    return @UserService.processAll()
})

# Profile with annotations
class UserService {
    @profile
    processUser(user) {
        // Method automatically profiled
    }
    
    @profile("batch-process")
    processBatch(users) {
        // Custom profile name
    }
}

# Flame graph generation
@profile.start_trace()
// ... application code
flame_data: @profile.end_trace()
@file.write("flame.json", flame_data)
```

## Memory Debugging

```tusk
# Track memory leaks
memory_tracker: @debug.memory_tracker()

# Mark checkpoint
memory_tracker.checkpoint("before_operation")

// ... potentially leaky code
for (i in 1..1000) {
    data: @fetch_large_data(i)
    @process_data(data)
}

# Check for leaks
leaks: memory_tracker.check_leaks("before_operation")
if (leaks.found) {
    @console.error("Memory leak detected!", {
        leaked: leaks.bytes,
        objects: leaks.objects,
        types: leaks.types
    })
}

# Object reference tracking
@debug.track_references(suspicious_object)

// ... later
refs: @debug.get_references(suspicious_object)
@console.log("Object referenced by:", refs)

# Garbage collection debugging
@gc.collect()  # Force garbage collection
stats: @gc.stats()
@console.log("GC stats:", stats)
```

## Remote Debugging

```tusk
# Enable remote debugging
@debug.remote.enable({
    host: "0.0.0.0",
    port: 9229,
    wait: false  # Wait for debugger to attach
})

# Debugging webhooks
@debug.webhook("https://debug.example.com/hook", {
    events: ["error", "warning", "slow_query"],
    include: {
        stack_trace: true,
        variables: true,
        system_info: true
    }
})

# Remote REPL
@debug.remote_repl.start({
    port: 9230,
    auth: @env("DEBUG_TOKEN")
})

# Debug API endpoint
#api /debug if: @env.debug {
    return {
        routes: @router.getRoutes(),
        config: @config.all(),
        services: @container.bindings(),
        queries: @db.getQueryLog(),
        cache_stats: @cache.stats(),
        queue_status: @queue.status()
    }
}
```

## Testing and Debug Helpers

```tusk
# Debug test failures
#test "Complex operation" {
    @debug.test.capture()  # Capture all debug info
    
    try {
        result: @complex_operation()
        @assert.equals(result, expected)
    } catch (AssertionError e) {
        # Output captured debug info on failure
        @debug.test.dump()
        throw e
    }
}

# Snapshot debugging
@debug.snapshot("before_refactor", {
    users: @User.all(),
    settings: @config.all(),
    cache: @cache.all()
})

// ... refactored code

@debug.compare_snapshot("before_refactor", {
    users: @User.all(),
    settings: @config.all(),
    cache: @cache.all()
})

# Time travel debugging
recorder: @debug.recorder()
recorder.start()

// ... application flow

# Replay execution
recorder.replay({
    speed: 0.5,  # Half speed
    breakpoints: ["UserService.save"],
    watch: ["user.status"]
})
```

## Debug Configuration

```tusk
# debug.config.tsk
{
    # Debug settings
    debug: {
        enabled: @env("APP_DEBUG", false),
        
        # Error display
        display_errors: true,
        error_detail: "high",  # low, medium, high
        
        # Logging
        log_level: "debug",
        log_queries: true,
        log_requests: true,
        
        # Profiling
        profile: {
            enabled: true,
            sample_rate: 0.1,  # 10% of requests
            slow_threshold: 1000  # ms
        },
        
        # Remote debugging
        remote: {
            enabled: false,
            allowed_ips: ["127.0.0.1"],
            port: 9229
        },
        
        # Debug bar
        debug_bar: {
            enabled: true,
            collectors: [
                "queries",
                "requests",
                "exceptions",
                "timeline",
                "memory",
                "cache"
            ]
        }
    }
}
```

## Debug Toolbar

```tusk
# Enable debug toolbar
@app.use(DebugToolbar, {
    enabled: @env.debug,
    
    # Collectors
    collectors: [
        QueryCollector,
        TimelineCollector,
        MemoryCollector,
        RequestCollector,
        CacheCollector,
        EventCollector
    ],
    
    # Storage
    storage: FileStorage,
    storage_path: "storage/debugbar",
    
    # JavaScript
    include_vendors: true,
    
    # Authorization
    authorize: () => {
        return @env.debug || @auth.user?.isAdmin()
    }
})

# Custom collector
class CustomCollector extends Collector {
    name: "custom"
    
    collect() {
        return {
            data: @my_debug_data(),
            count: @my_metric_count()
        }
    }
    
    getWidgets() {
        return {
            "custom": {
                icon: "bug",
                widget: "PhpDebugBar.Widgets.VariableListWidget",
                map: "custom.data",
                default: "{}"
            },
            "custom:badge": {
                map: "custom.count",
                default: 0
            }
        }
    }
}
```

## Best Practices

1. **Remove debug code in production** - Use environment checks
2. **Use appropriate log levels** - Don't log everything as errors
3. **Structure debug output** - Use groups and tables
4. **Include context** - Add relevant data to debug messages
5. **Use conditional debugging** - Debug specific scenarios
6. **Monitor performance** - Debugging can impact performance
7. **Secure debug endpoints** - Don't expose sensitive data
8. **Clean up debug files** - Remove logs and dumps regularly

## Related Topics

- `logging` - Logging strategies
- `error-handling` - Error management
- `profiling` - Performance profiling
- `monitoring` - Application monitoring
- `testing` - Testing and debugging
---

[Performance Optimization in TuskLang]


Optimizing performance is crucial for building scalable and responsive applications. TuskLang provides various tools and techniques to identify bottlenecks and improve performance.

## Performance Monitoring

```tusk
# Basic performance monitoring
class PerformanceMonitor {
    static start(name) {
        @metrics.timer(name).start()
        @memory.mark(name)
    }
    
    static end(name) {
        duration: @metrics.timer(name).stop()
        memory: @memory.since(name)
        
        @log.info("Performance:", {
            operation: name,
            duration: duration + "ms",
            memory: memory + "MB",
            peak_memory: @memory_get_peak_usage(true)
        })
        
        return {duration, memory}
    }
    
    static measure(name, callback) {
        this.start(name)
        result: callback()
        this.end(name)
        return result
    }
}

# Usage
PerformanceMonitor.start("user_processing")
// ... expensive operation
stats: PerformanceMonitor.end("user_processing")

# Or with callback
result: PerformanceMonitor.measure("database_query", () => {
    return @User.with("posts").get()
})

# Automatic instrumentation
@instrument
class UserService {
    @measure
    processUsers(users) {
        # Automatically measured
        for (user in users) {
            this.processUser(user)
        }
    }
    
    @measure("user_validation")
    validateUser(user) {
        # Custom measurement name
        return @validator.validate(user)
    }
}
```

## Memory Optimization

```tusk
# Memory-efficient data processing
class DataProcessor {
    # Process large datasets in chunks
    processLargeDataset(filename) {
        chunk_size: 1000
        
        @file.chunk(filename, chunk_size, (chunk) => {
            # Process chunk and free memory
            processed: @transform_data(chunk)
            @output_data(processed)
            
            # Explicit cleanup
            chunk: null
            processed: null
            
            # Force garbage collection periodically
            if (@chunks_processed % 100 === 0) {
                @gc.collect()
            }
        })
    }
    
    # Use generators for lazy evaluation
    *generateData(count) {
        for (i in 1..count) {
            # Generate data on-demand
            yield @create_data_item(i)
        }
    }
    
    # Memory-efficient array operations
    processArray(large_array) {
        # Bad: Creates intermediate arrays
        // result: large_array.map(transform).filter(valid).slice(0, 100)
        
        # Good: Process without intermediate arrays
        result: []
        count: 0
        
        for (item in large_array) {
            if (count >= 100) break
            
            transformed: @transform(item)
            if (@is_valid(transformed)) {
                result.push(transformed)
                count++
            }
        }
        
        return result
    }
}

# Memory pooling for objects
class ObjectPool {
    constructor(factory, reset_fn, initial_size = 10) {
        this.factory: factory
        this.reset: reset_fn
        this.pool: []
        
        # Pre-allocate objects
        for (i in 0..initial_size) {
            this.pool.push(factory())
        }
    }
    
    acquire() {
        if (this.pool.length > 0) {
            return this.pool.pop()
        }
        return this.factory()
    }
    
    release(obj) {
        this.reset(obj)
        this.pool.push(obj)
    }
}

# Usage
user_pool: new ObjectPool(
    () => new User(),
    (user) => {
        user.clear()
        user.reset_state()
    }
)

user: user_pool.acquire()
# ... use user
user_pool.release(user)
```

## Caching Strategies

```tusk
# Multi-level caching
class CacheManager {
    constructor() {
        this.l1: new Map()  # In-memory cache
        this.l2: @redis()   # Redis cache
        this.l3: @db()      # Database cache
    }
    
    async get(key) {
        # Check L1 (memory)
        if (this.l1.has(key)) {
            @metrics.increment("cache.l1.hit")
            return this.l1.get(key)
        }
        
        # Check L2 (Redis)
        value: await this.l2.get(key)
        if (value) {
            @metrics.increment("cache.l2.hit")
            this.l1.set(key, value)
            return value
        }
        
        # Check L3 (Database)
        value: await this.l3.get(key)
        if (value) {
            @metrics.increment("cache.l3.hit")
            await this.l2.set(key, value, 3600)
            this.l1.set(key, value)
            return value
        }
        
        @metrics.increment("cache.miss")
        return null
    }
    
    async set(key, value, ttl = 3600) {
        # Set in all levels
        this.l1.set(key, value)
        await this.l2.set(key, value, ttl)
        await this.l3.set(key, value, ttl * 24)  # Longer TTL for DB
    }
}

# Smart caching with invalidation
class SmartCache {
    dependencies: {}
    
    remember(key, dependencies, ttl, callback) {
        # Track dependencies
        this.dependencies[key]: dependencies
        
        return @cache.remember(key, ttl, callback)
    }
    
    invalidate(dependency) {
        # Find all keys that depend on this
        to_invalidate: []
        
        for (key, deps in this.dependencies) {
            if (deps.includes(dependency)) {
                to_invalidate.push(key)
            }
        }
        
        # Invalidate dependent caches
        for (key in to_invalidate) {
            @cache.forget(key)
            delete this.dependencies[key]
        }
    }
}

# Usage
smart_cache: new SmartCache()

# Cache with dependencies
user_data: smart_cache.remember(
    "user_profile_" + user_id,
    ["user:" + user_id, "profile"],
    3600,
    () => @get_user_profile(user_id)
)

# Invalidate when user changes
@on("user.updated", (user) => {
    smart_cache.invalidate("user:" + user.id)
})
```

## Database Optimization

```tusk
# Query optimization
class QueryOptimizer {
    # Batch loading to prevent N+1
    static loadUsersWithPosts(user_ids) {
        # Instead of loading posts for each user separately
        users: @User.whereIn("id", user_ids).get()
        posts: @Post.whereIn("user_id", user_ids).get()
        
        # Group posts by user_id
        posts_by_user: posts.groupBy("user_id")
        
        # Assign posts to users
        for (user in users) {
            user.posts: posts_by_user[user.id] || []
        }
        
        return users
    }
    
    # Selective loading
    static getPostsForListing() {
        return @Post
            .select("id", "title", "excerpt", "created_at", "user_id")
            .with("user:id,name")
            .where("published", true)
            .orderBy("created_at", "desc")
            .limit(20)
            .get()
    }
    
    # Efficient counting
    static getPostStats() {
        return @Post
            .select(
                @db.raw("COUNT(*) as total"),
                @db.raw("COUNT(CASE WHEN published = 1 THEN 1 END) as published"),
                @db.raw("COUNT(CASE WHEN published = 0 THEN 1 END) as drafts")
            )
            .first()
    }
}

# Connection pooling
class DatabasePool {
    constructor(config) {
        this.connections: []
        this.available: []
        this.max_connections: config.max || 10
        this.min_connections: config.min || 2
        
        # Pre-create minimum connections
        for (i in 0..this.min_connections) {
            conn: @create_connection(config)
            this.connections.push(conn)
            this.available.push(conn)
        }
    }
    
    async acquire() {
        if (this.available.length > 0) {
            return this.available.pop()
        }
        
        if (this.connections.length < this.max_connections) {
            conn: await @create_connection(this.config)
            this.connections.push(conn)
            return conn
        }
        
        # Wait for available connection
        return await this.wait_for_connection()
    }
    
    release(connection) {
        this.available.push(connection)
    }
}
```

## Algorithm Optimization

```tusk
# Efficient data structures
class OptimizedDataStructures {
    # Use Map for O(1) lookups instead of array search
    static createLookupMap(items, key_field) {
        lookup: new Map()
        
        for (item in items) {
            lookup.set(item[key_field], item)
        }
        
        return lookup
    }
    
    # Efficient sorting for large datasets
    static sortLargeDataset(items, compare_fn) {
        # Use native sort for small datasets
        if (items.length < 1000) {
            return items.sort(compare_fn)
        }
        
        # Use merge sort for larger datasets
        return @merge_sort(items, compare_fn)
    }
    
    # Memoization for expensive calculations
    static memoize(fn) {
        cache: new Map()
        
        return (...args) => {
            key: @json_encode(args)
            
            if (cache.has(key)) {
                return cache.get(key)
            }
            
            result: fn(...args)
            cache.set(key, result)
            return result
        }
    }
}

# Optimized algorithms
class Algorithms {
    # Binary search for sorted arrays
    static binarySearch(array, target, compare_fn) {
        left: 0
        right: array.length - 1
        
        while (left <= right) {
            mid: Math.floor((left + right) / 2)
            comparison: compare_fn(array[mid], target)
            
            if (comparison === 0) return mid
            if (comparison < 0) {
                left: mid + 1
            } else {
                right: mid - 1
            }
        }
        
        return -1
    }
    
    # Debounced function calls
    static debounce(fn, delay) {
        timer: null
        
        return (...args) => {
            clearTimeout(timer)
            timer: setTimeout(() => fn(...args), delay)
        }
    }
    
    # Throttled function calls
    static throttle(fn, interval) {
        last_call: 0
        
        return (...args) => {
            now: Date.now()
            
            if (now - last_call >= interval) {
                last_call: now
                return fn(...args)
            }
        }
    }
}
```

## Asset Optimization

```tusk
# Asset compilation and optimization
class AssetOptimizer {
    static optimizeImages(source_dir, dest_dir) {
        images: @glob(source_dir + "/**/*.{jpg,jpeg,png,gif,webp}")
        
        for (image in images) {
            # Compress image
            compressed: @image_compress(image, {
                quality: 85,
                progressive: true
            })
            
            # Generate multiple sizes
            sizes: [320, 640, 1024, 1920]
            for (size in sizes) {
                resized: @image_resize(compressed, size)
                dest_path: @get_dest_path(image, dest_dir, size)
                @file_put_contents(dest_path, resized)
            }
            
            # Generate WebP version
            webp: @image_to_webp(compressed)
            webp_path: @change_extension(dest_path, "webp")
            @file_put_contents(webp_path, webp)
        }
    }
    
    static optimizeCSS(source_files) {
        combined: ""
        
        for (file in source_files) {
            content: @file_get_contents(file)
            
            # Process CSS
            processed: @css_process(content, {
                autoprefixer: true,
                minify: true,
                remove_unused: true
            })
            
            combined += processed
        }
        
        # Generate hash for cache busting
        hash: @md5(combined)
        filename: "app-" + hash + ".css"
        
        @file_put_contents("public/css/" + filename, combined)
        
        return filename
    }
    
    static optimizeJS(source_files) {
        # Bundle and minify JavaScript
        bundled: @js_bundle(source_files, {
            minify: true,
            source_maps: @env.debug,
            tree_shaking: true,
            code_splitting: true
        })
        
        return bundled
    }
}
```

## Async Performance

```tusk
# Parallel processing
class ParallelProcessor {
    static async processInParallel(items, processor, concurrency = 5) {
        results: []
        
        # Process in batches
        for (i: 0; i < items.length; i += concurrency) {
            batch: items.slice(i, i + concurrency)
            
            # Process batch in parallel
            batch_results: await Promise.all(
                batch.map(item => processor(item))
            )
            
            results.push(...batch_results)
        }
        
        return results
    }
    
    static async processWithWorkers(items, worker_script, worker_count = 4) {
        # Create worker pool
        workers: []
        for (i in 0..worker_count) {
            worker: new Worker(worker_script)
            workers.push(worker)
        }
        
        # Distribute work
        chunk_size: Math.ceil(items.length / worker_count)
        promises: []
        
        for (i: 0; i < worker_count; i++) {
            start: i * chunk_size
            end: Math.min(start + chunk_size, items.length)
            chunk: items.slice(start, end)
            
            promise: @send_to_worker(workers[i], chunk)
            promises.push(promise)
        }
        
        # Collect results
        results: await Promise.all(promises)
        
        # Cleanup workers
        workers.forEach(w => w.terminate())
        
        return results.flat()
    }
}

# Stream processing
class StreamProcessor {
    static processLargeFile(filename, processor) {
        stream: @fs.createReadStream(filename)
        
        return new Promise((resolve, reject) => {
            results: []
            
            stream
                .pipe(@split_lines())
                .pipe(@transform_stream(processor))
                .on("data", (result) => {
                    results.push(result)
                })
                .on("end", () => resolve(results))
                .on("error", reject)
        })
    }
}
```

## Performance Testing

```tusk
# Benchmark functions
class Benchmark {
    static measure(fn, iterations = 1000) {
        start: @hrtime()
        
        for (i in 0..iterations) {
            fn()
        }
        
        end: @hrtime(start)
        total_ms: (end[0] * 1000) + (end[1] / 1000000)
        
        return {
            total: total_ms,
            average: total_ms / iterations,
            iterations: iterations
        }
    }
    
    static compare(functions) {
        results: {}
        
        for (name, fn in functions) {
            results[name]: this.measure(fn)
        }
        
        # Sort by performance
        sorted: Object.entries(results)
            .sort((a, b) => a[1].average - b[1].average)
        
        @console.table(sorted)
        
        return sorted
    }
}

# Usage
Benchmark.compare({
    "Array.map": () => array.map(x => x * 2),
    "For loop": () => {
        result: []
        for (x in array) {
            result.push(x * 2)
        }
        return result
    },
    "While loop": () => {
        result: []
        i: 0
        while (i < array.length) {
            result.push(array[i] * 2)
            i++
        }
        return result
    }
})

# Load testing
class LoadTester {
    static async stress_test(endpoint, options = {}) {
        concurrent_users: options.users || 100
        duration: options.duration || 60  # seconds
        
        results: {
            requests: 0,
            errors: 0,
            response_times: []
        }
        
        start_time: Date.now()
        end_time: start_time + (duration * 1000)
        
        # Create concurrent users
        users: []
        for (i in 0..concurrent_users) {
            user: this.simulate_user(endpoint, end_time, results)
            users.push(user)
        }
        
        # Wait for all users to complete
        await Promise.all(users)
        
        # Calculate statistics
        avg_response: results.response_times.reduce((a, b) => a + b, 0) / results.response_times.length
        error_rate: (results.errors / results.requests) * 100
        
        return {
            total_requests: results.requests,
            errors: results.errors,
            error_rate: error_rate + "%",
            average_response_time: avg_response + "ms",
            requests_per_second: results.requests / duration
        }
    }
}
```

## Best Practices

1. **Measure before optimizing** - Profile to find real bottlenecks
2. **Optimize the right layer** - Database, application, or frontend
3. **Use appropriate data structures** - Choose the right algorithm
4. **Cache strategically** - Cache expensive operations
5. **Optimize database queries** - Use indexes and efficient queries
6. **Minimize memory allocations** - Reuse objects when possible
7. **Use async operations** - Don't block the main thread
8. **Monitor in production** - Track performance metrics

## Related Topics

- `caching-strategies` - Caching patterns
- `database-optimization` - Database performance
- `async-programming` - Asynchronous patterns
- `monitoring` - Performance monitoring
- `profiling` - Code profiling
---

[Security Best Practices in TuskLang]


Security is paramount in modern applications. TuskLang provides comprehensive security features and follows industry best practices to protect your applications from common vulnerabilities.

## Input Validation and Sanitization

```tusk
# Input validation
class InputValidator {
    static validate(data, rules) {
        errors: {}
        
        for (field, rule in rules) {
            value: data[field]
            
            # Required validation
            if (rule.includes("required") && (!value || value === "")) {
                errors[field]: "Field is required"
                continue
            }
            
            # Type validation
            if (rule.includes("email") && !@is_valid_email(value)) {
                errors[field]: "Invalid email format"
            }
            
            # Length validation
            if (rule.includes("min:")) {
                min_length: @extract_rule_value(rule, "min")
                if (value.length < min_length) {
                    errors[field]: `Minimum length is ${min_length}`
                }
            }
            
            # Pattern validation
            if (rule.includes("pattern:")) {
                pattern: @extract_rule_pattern(rule)
                if (!pattern.test(value)) {
                    errors[field]: "Invalid format"
                }
            }
        }
        
        return {valid: Object.keys(errors).length === 0, errors}
    }
    
    static sanitize(input, type = "string") {
        match type {
            "string" => @strip_tags(@trim(input))
            "html" => @purify_html(input)  # Allow safe HTML only
            "sql" => @escape_sql(input)
            "url" => @filter_url(input)
            "int" => @int(input)
            "float" => @float(input)
            "email" => @filter_email(input)
            "filename" => @sanitize_filename(input)
            _ => input
        }
    }
}

# Secure request handling
#web /user/update method: POST {
    # Validate CSRF token
    @csrf.verify(@request.post._token)
    
    # Validate input
    validation: InputValidator.validate(@request.post, {
        name: "required|min:2|max:100",
        email: "required|email",
        bio: "max:500|pattern:^[a-zA-Z0-9\s.,!?-]*$"
    })
    
    if (!validation.valid) {
        return @json({errors: validation.errors}, 422)
    }
    
    # Sanitize input
    clean_data: {
        name: InputValidator.sanitize(@request.post.name, "string"),
        email: InputValidator.sanitize(@request.post.email, "email"),
        bio: InputValidator.sanitize(@request.post.bio, "html")
    }
    
    # Update user
    @auth.user.update(clean_data)
    
    return @json({message: "Profile updated"})
}
```

## SQL Injection Prevention

```tusk
# Always use parameterized queries
class UserRepository {
    # Good: Parameterized query
    findByEmail(email) {
        return @db.select(
            "SELECT * FROM users WHERE email = ? AND active = ?",
            [email, true]
        ).first()
    }
    
    # Good: Query builder (automatically escaped)
    searchUsers(term) {
        return @User.where("name", "like", "%" + term + "%")
            .where("active", true)
            .get()
    }
    
    # When using raw SQL, validate inputs
    customQuery(user_id, status) {
        # Validate inputs
        if (!@is_numeric(user_id)) {
            throw "Invalid user ID"
        }
        
        if (!@in_array(status, ["active", "inactive", "pending"])) {
            throw "Invalid status"
        }
        
        return @db.select(
            "SELECT * FROM users WHERE id = ? AND status = ?",
            [user_id, status]
        )
    }
    
    # Safe dynamic queries
    buildDynamicQuery(filters) {
        query: @User.query()
        
        # Whitelist allowed filters
        allowed_filters: ["name", "email", "status", "created_at"]
        
        for (field, value in filters) {
            if (!allowed_filters.includes(field)) {
                continue  # Skip unauthorized filters
            }
            
            query.where(field, value)
        }
        
        return query.get()
    }
}
```

## Cross-Site Scripting (XSS) Prevention

```tusk
# Template escaping
# In TuskLang templates, output is escaped by default
#template user_profile {
    <h1>{user.name}</h1>  <!-- Automatically escaped -->
    <p>Bio: {user.bio}</p>  <!-- Automatically escaped -->
    
    <!-- Raw output (use with caution) -->
    <div class="content">{! trusted_content !}</div>
    
    <!-- Specific escaping functions -->
    <script>
        var userName = {@js(user.name)};  // JavaScript escaping
        var userBio = {@attr(user.bio)};  // Attribute escaping
    </script>
}

# Content Security Policy
class SecurityHeaders {
    static apply(response) {
        response.headers["Content-Security-Policy"]: 
            "default-src 'self'; " +
            "script-src 'self' 'unsafe-inline' cdn.example.com; " +
            "style-src 'self' 'unsafe-inline' fonts.googleapis.com; " +
            "img-src 'self' data: cdn.example.com; " +
            "connect-src 'self' api.example.com; " +
            "font-src 'self' fonts.gstatic.com; " +
            "object-src 'none'; " +
            "base-uri 'self';"
        
        response.headers["X-Content-Type-Options"]: "nosniff"
        response.headers["X-Frame-Options"]: "DENY"
        response.headers["X-XSS-Protection"]: "1; mode=block"
        response.headers["Referrer-Policy"]: "strict-origin-when-cross-origin"
        
        return response
    }
}

# Apply security headers middleware
@middleware.global(SecurityHeaders::apply)

# Safe HTML processing
class HtmlSanitizer {
    static clean(html, options = {}) {
        allowed_tags: options.tags || [
            "p", "br", "strong", "em", "ul", "ol", "li", "h1", "h2", "h3"
        ]
        
        allowed_attributes: options.attributes || {
            "a": ["href", "title"],
            "img": ["src", "alt", "title"]
        }
        
        return @html_purifier(html, {
            allowed_tags: allowed_tags,
            allowed_attributes: allowed_attributes,
            remove_blank: true,
            encode_entities: true
        })
    }
}
```

## Cross-Site Request Forgery (CSRF) Protection

```tusk
# CSRF token generation and validation
class CsrfProtection {
    static generate_token() {
        token: @random_bytes(32)
        @session.put("_csrf_token", token)
        return @base64_encode(token)
    }
    
    static verify_token(token) {
        if (!token) {
            throw "CSRF token missing"
        }
        
        session_token: @session.get("_csrf_token")
        if (!session_token) {
            throw "No CSRF token in session"
        }
        
        if (!@hash_equals(session_token, @base64_decode(token))) {
            throw "CSRF token mismatch"
        }
        
        return true
    }
    
    static middleware() {
        return (request, next) => {
            # Skip verification for safe methods
            if (@in_array(request.method, ["GET", "HEAD", "OPTIONS"])) {
                return next()
            }
            
            # Verify token from header or form
            token: request.headers["X-CSRF-TOKEN"] || request.post._token
            
            try {
                this.verify_token(token)
                return next()
            } catch (error) {
                return @response.status(419).json({
                    message: "CSRF token mismatch"
                })
            }
        }
    }
}

# Apply CSRF protection to forms
@middleware.web(CsrfProtection.middleware())

# In templates
#template form {
    <form method="POST" action="/user/update">
        <input type="hidden" name="_token" value="{@csrf_token()}">
        <!-- form fields -->
    </form>
}
```

## Authentication and Authorization

```tusk
# Secure password handling
class PasswordSecurity {
    static hash(password) {
        # Use strong hashing algorithm
        return @password_hash(password, PASSWORD_ARGON2ID, {
            memory_cost: 65536,  # 64 MB
            time_cost: 4,        # 4 iterations
            threads: 3           # 3 threads
        })
    }
    
    static verify(password, hash) {
        return @password_verify(password, hash)
    }
    
    static validate_strength(password) {
        errors: []
        
        if (password.length < 12) {
            errors.push("Password must be at least 12 characters")
        }
        
        if (!/[a-z]/.test(password)) {
            errors.push("Password must contain lowercase letters")
        }
        
        if (!/[A-Z]/.test(password)) {
            errors.push("Password must contain uppercase letters")
        }
        
        if (!/\d/.test(password)) {
            errors.push("Password must contain numbers")
        }
        
        if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
            errors.push("Password must contain special characters")
        }
        
        # Check against common passwords
        if (@is_common_password(password)) {
            errors.push("Password is too common")
        }
        
        return {valid: errors.length === 0, errors}
    }
}

# Secure session management
class SessionSecurity {
    static configure() {
        @session.configure({
            # Use secure session ID generation
            entropy_length: 64,
            
            # Regenerate session ID on login
            regenerate_on_login: true,
            
            # Session timeout
            lifetime: 120,  # 2 hours
            
            # Secure cookies
            cookie: {
                secure: @env.app_env === "production",
                httponly: true,
                samesite: "strict"
            },
            
            # IP validation
            validate_ip: true,
            
            # User agent validation
            validate_user_agent: true
        })
    }
    
    static validate_session() {
        # Check session fingerprint
        expected_fingerprint: @hash([
            @request.ip,
            @request.user_agent,
            @env.app_key
        ])
        
        session_fingerprint: @session.get("_fingerprint")
        
        if (!@hash_equals(expected_fingerprint, session_fingerprint)) {
            @session.invalidate()
            throw "Session validation failed"
        }
    }
}

# Role-based access control
class RoleBasedAccess {
    static check_permission(user, resource, action) {
        # Check direct permissions
        permission: user.permissions.find(p => 
            p.resource === resource && p.action === action
        )
        
        if (permission) {
            return permission.granted
        }
        
        # Check role permissions
        for (role in user.roles) {
            permission: role.permissions.find(p => 
                p.resource === resource && p.action === action
            )
            
            if (permission && permission.granted) {
                return true
            }
        }
        
        return false
    }
    
    static middleware(resource, action) {
        return (request, next) => {
            if (!@auth.check()) {
                return @response.status(401).json({
                    message: "Authentication required"
                })
            }
            
            if (!this.check_permission(@auth.user, resource, action)) {
                return @response.status(403).json({
                    message: "Insufficient permissions"
                })
            }
            
            return next()
        }
    }
}
```

## API Security

```tusk
# Rate limiting
class ApiRateLimit {
    static middleware(requests = 60, window = 60) {
        return (request, next) => {
            key: "rate_limit:" + (request.user?.id || request.ip)
            
            current: @cache.get(key, 0)
            
            if (current >= requests) {
                return @response.status(429).json({
                    message: "Rate limit exceeded",
                    retry_after: window
                })
            }
            
            @cache.increment(key, 1, window)
            
            # Add rate limit headers
            @response.headers["X-RateLimit-Limit"]: requests
            @response.headers["X-RateLimit-Remaining"]: requests - current - 1
            @response.headers["X-RateLimit-Reset"]: Date.now() + window * 1000
            
            return next()
        }
    }
}

# API key authentication
class ApiKeyAuth {
    static middleware() {
        return async (request, next) => {
            api_key: request.headers["x-api-key"]
            
            if (!api_key) {
                return @response.status(401).json({
                    message: "API key required"
                })
            }
            
            # Validate API key
            key_data: await @ApiKey.where("key", api_key)
                .where("active", true)
                .where("expires_at", ">", @now())
                .first()
            
            if (!key_data) {
                return @response.status(401).json({
                    message: "Invalid API key"
                })
            }
            
            # Check rate limits for this key
            if (key_data.rate_limit) {
                rate_key: "api_key_rate:" + key_data.id
                usage: @cache.get(rate_key, 0)
                
                if (usage >= key_data.rate_limit) {
                    return @response.status(429).json({
                        message: "API key rate limit exceeded"
                    })
                }
                
                @cache.increment(rate_key, 1, 3600)
            }
            
            # Log API usage
            @log.info("API key used", {
                key_id: key_data.id,
                endpoint: request.path,
                ip: request.ip
            })
            
            request.api_key: key_data
            return next()
        }
    }
}

# JWT token security
class JwtSecurity {
    static generate(payload, expires_in = 3600) {
        return @jwt.sign(payload, @env.jwt_secret, {
            algorithm: "HS256",
            expiresIn: expires_in,
            issuer: @env.app_name,
            audience: @env.app_url
        })
    }
    
    static verify(token) {
        try {
            return @jwt.verify(token, @env.jwt_secret, {
                algorithms: ["HS256"],
                issuer: @env.app_name,
                audience: @env.app_url
            })
        } catch (error) {
            throw "Invalid token: " + error.message
        }
    }
    
    static blacklist(token) {
        # Add token to blacklist
        decoded: @jwt.decode(token, {complete: true})
        jti: decoded.payload.jti
        exp: decoded.payload.exp
        
        @cache.put("blacklist:" + jti, true, exp - Date.now())
    }
    
    static is_blacklisted(token) {
        decoded: @jwt.decode(token, {complete: true})
        jti: decoded.payload.jti
        
        return @cache.has("blacklist:" + jti)
    }
}
```

## File Upload Security

```tusk
# Secure file upload handling
class SecureFileUpload {
    static validate(file, options = {}) {
        errors: []
        
        # Check file size
        max_size: options.max_size || 10 * 1024 * 1024  # 10MB
        if (file.size > max_size) {
            errors.push("File too large")
        }
        
        # Check file type
        allowed_types: options.allowed_types || ["image/jpeg", "image/png", "image/gif"]
        if (!allowed_types.includes(file.type)) {
            errors.push("File type not allowed")
        }
        
        # Check file extension
        allowed_extensions: options.allowed_extensions || [".jpg", ".jpeg", ".png", ".gif"]
        extension: @path.extname(file.name).toLowerCase()
        if (!allowed_extensions.includes(extension)) {
            errors.push("File extension not allowed")
        }
        
        # Verify MIME type matches extension
        if (!@verify_mime_type(file.type, extension)) {
            errors.push("File type mismatch")
        }
        
        return {valid: errors.length === 0, errors}
    }
    
    static sanitize_filename(filename) {
        # Remove dangerous characters
        clean: filename.replace(/[^a-zA-Z0-9._-]/g, "")
        
        # Prevent directory traversal
        clean: clean.replace(/\.\.+/g, ".")
        
        # Ensure extension is safe
        extension: @path.extname(clean)
        name: @path.basename(clean, extension)
        
        # Limit length
        if (name.length > 100) {
            name: name.substring(0, 100)
        }
        
        return name + extension
    }
    
    static scan_for_malware(file_path) {
        # Integrate with antivirus scanner
        return @clamav.scan(file_path)
    }
    
    static process_upload(file, destination) {
        # Validate file
        validation: this.validate(file)
        if (!validation.valid) {
            throw "File validation failed: " + validation.errors.join(", ")
        }
        
        # Generate safe filename
        safe_name: this.sanitize_filename(file.name)
        unique_name: @uuid() + "_" + safe_name
        
        # Store outside web root
        secure_path: @path.join(destination, unique_name)
        
        # Move file
        @move_uploaded_file(file.tmp_name, secure_path)
        
        # Scan for malware
        if (!this.scan_for_malware(secure_path)) {
            @unlink(secure_path)
            throw "File failed security scan"
        }
        
        # Store file metadata securely
        return {
            original_name: file.name,
            stored_name: unique_name,
            path: secure_path,
            size: file.size,
            type: file.type
        }
    }
}
```

## Security Monitoring and Logging

```tusk
# Security event logging
class SecurityLogger {
    static log_security_event(event_type, details) {
        @log.security(event_type, {
            timestamp: @now(),
            ip: @request.ip,
            user_id: @auth.id,
            user_agent: @request.user_agent,
            session_id: @session.id,
            ...details
        })
        
        # Send to SIEM if critical
        if (@is_critical_event(event_type)) {
            @siem.send(event_type, details)
        }
    }
    
    static log_failed_login(email, reason) {
        this.log_security_event("failed_login", {
            email: email,
            reason: reason
        })
        
        # Track failed attempts
        key: "failed_login:" + @request.ip
        attempts: @cache.increment(key, 1, 900)  # 15 minutes
        
        # Block IP after multiple failures
        if (attempts >= 5) {
            @cache.put("blocked_ip:" + @request.ip, true, 3600)
            this.log_security_event("ip_blocked", {
                reason: "Multiple failed login attempts"
            })
        }
    }
    
    static log_privilege_escalation(user, attempted_action) {
        this.log_security_event("privilege_escalation", {
            user_id: user.id,
            current_roles: user.roles.pluck("name"),
            attempted_action: attempted_action
        })
    }
}

# Intrusion detection
class IntrusionDetection {
    static monitor_requests() {
        return (request, next) => {
            # Check for SQL injection patterns
            if (@detect_sql_injection(request)) {
                SecurityLogger.log_security_event("sql_injection_attempt", {
                    url: request.url,
                    payload: request.all()
                })
                
                return @response.status(400).json({
                    message: "Malicious request detected"
                })
            }
            
            # Check for XSS patterns
            if (@detect_xss_attempt(request)) {
                SecurityLogger.log_security_event("xss_attempt", {
                    url: request.url,
                    payload: request.all()
                })
            }
            
            # Check for path traversal
            if (@detect_path_traversal(request)) {
                SecurityLogger.log_security_event("path_traversal_attempt", {
                    url: request.url
                })
                
                return @response.status(400).json({
                    message: "Invalid request path"
                })
            }
            
            return next()
        }
    }
}
```

## Best Practices Summary

1. **Input Validation** - Validate and sanitize all user input
2. **SQL Injection Prevention** - Use parameterized queries
3. **XSS Protection** - Escape output and use CSP headers
4. **CSRF Protection** - Use tokens for state-changing operations
5. **Authentication Security** - Strong passwords and secure sessions
6. **Authorization** - Implement proper access controls
7. **HTTPS Everywhere** - Use encryption for all communications
8. **Security Headers** - Implement comprehensive security headers
9. **File Upload Security** - Validate and scan uploaded files
10. **Security Monitoring** - Log and monitor security events

## Related Topics

- `authentication` - User authentication systems
- `authorization` - Access control patterns
- `encryption` - Data encryption techniques
- `security-headers` - HTTP security headers
- `penetration-testing` - Security testing
---

[Deployment Strategies in TuskLang]


TuskLang provides comprehensive deployment tools and strategies to deploy your applications safely and efficiently across different environments.

## Environment Configuration

```tusk
# Environment-specific configuration
# config/environments/production.tsk
{
    app: {
        env: "production",
        debug: false,
        url: "https://yourapp.com",
        timezone: "UTC"
    },
    
    database: {
        connections: {
            mysql: {
                read: [
                    {host: "read-replica-1.db.cluster"},
                    {host: "read-replica-2.db.cluster"}
                ],
                write: {
                    host: "master.db.cluster",
                    port: 3306,
                    database: @env("DB_DATABASE"),
                    username: @env("DB_USERNAME"),
                    password: @env("DB_PASSWORD")
                },
                pool: {
                    min: 5,
                    max: 20
                }
            }
        }
    },
    
    cache: {
        default: "redis",
        stores: {
            redis: {
                driver: "redis",
                cluster: true,
                options: {
                    cluster: [
                        {host: "cache-1.cluster", port: 6379},
                        {host: "cache-2.cluster", port: 6379},
                        {host: "cache-3.cluster", port: 6379}
                    ]
                }
            }
        }
    },
    
    logging: {
        level: "info",
        channels: {
            stack: {
                driver: "stack",
                channels: ["daily", "sentry"]
            },
            daily: {
                driver: "daily",
                path: "/var/log/app/tusk.log",
                days: 14
            },
            sentry: {
                driver: "sentry",
                dsn: @env("SENTRY_DSN"),
                level: "error"
            }
        }
    }
}

# Staging environment
# config/environments/staging.tsk
{
    extends: "production",  # Inherit from production
    
    app: {
        url: "https://staging.yourapp.com",
        debug: true  # Enable debug on staging
    },
    
    database: {
        connections: {
            mysql: {
                host: "staging.db.server",
                database: "app_staging"
            }
        }
    }
}
```

## Build Process

```tusk
# build.tsk - Build configuration
{
    # Build steps
    steps: [
        "install_dependencies",
        "compile_assets",
        "optimize_code",
        "run_tests",
        "generate_docs",
        "create_package"
    ],
    
    # Asset compilation
    assets: {
        css: {
            source: "resources/css/**/*.css",
            output: "public/css/app.css",
            minify: true,
            autoprefixer: true
        },
        js: {
            source: "resources/js/**/*.js",
            output: "public/js/app.js",
            minify: true,
            source_maps: false,
            tree_shaking: true
        },
        images: {
            source: "resources/images/**/*",
            output: "public/images/",
            optimize: true,
            formats: ["webp", "original"]
        }
    },
    
    # Code optimization
    optimization: {
        cache_config: true,
        precompile_routes: true,
        optimize_autoloader: true,
        remove_dev_dependencies: true
    }
}

# Build script
class Builder {
    static build(environment = "production") {
        @console.info("Starting build for " + environment)
        
        # Set environment
        @env.set("APP_ENV", environment)
        
        # Install dependencies
        this.install_dependencies()
        
        # Compile assets
        this.compile_assets()
        
        # Optimize application
        this.optimize_application()
        
        # Run tests
        if (environment !== "production") {
            this.run_tests()
        }
        
        # Create deployment package
        this.create_package()
        
        @console.success("Build completed successfully")
    }
    
    static install_dependencies() {
        @exec("composer install --no-dev --optimize-autoloader")
        @exec("npm ci --production")
    }
    
    static compile_assets() {
        @exec("npm run build")
        @exec("tusk asset:publish")
    }
    
    static optimize_application() {
        @exec("tusk config:cache")
        @exec("tusk route:cache")
        @exec("tusk view:cache")
    }
    
    static create_package() {
        version: @git.get_current_tag() || @git.get_commit_hash()
        
        @archive.create("releases/app-" + version + ".tar.gz", {
            include: [
                "app/**",
                "public/**",
                "config/**",
                "vendor/**",
                "bootstrap/**"
            ],
            exclude: [
                "**/.git/**",
                "**/tests/**",
                "**/node_modules/**",
                "**/.env*"
            ]
        })
    }
}
```

## Container Deployment

```tusk
# Dockerfile
Dockerfile: """
FROM php:8.2-fpm-alpine

# Install system dependencies
RUN apk add --no-cache \
    nginx \
    supervisor \
    redis \
    mysql-client \
    nodejs \
    npm

# Install PHP extensions
RUN docker-php-ext-install \
    pdo_mysql \
    redis \
    opcache

# Configure PHP
COPY docker/php.ini /usr/local/etc/php/conf.d/app.ini
COPY docker/opcache.ini /usr/local/etc/php/conf.d/opcache.ini

# Configure Nginx
COPY docker/nginx.conf /etc/nginx/nginx.conf
COPY docker/site.conf /etc/nginx/conf.d/default.conf

# Configure Supervisor
COPY docker/supervisord.conf /etc/supervisord.conf

# Copy application
COPY . /var/www/html
WORKDIR /var/www/html

# Install dependencies
RUN composer install --no-dev --optimize-autoloader
RUN npm ci --production && npm run build

# Set permissions
RUN chown -R www-data:www-data /var/www/html
RUN chmod -R 755 /var/www/html/storage

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost/health || exit 1

EXPOSE 80

CMD ["/usr/bin/supervisord", "-c", "/etc/supervisord.conf"]
"""

# Docker Compose for production
docker_compose_prod: """
version: '3.8'

services:
  app:
    image: yourapp:latest
    restart: unless-stopped
    environment:
      - APP_ENV=production
      - DB_HOST=db
      - REDIS_HOST=redis
    volumes:
      - app_storage:/var/www/html/storage
      - app_logs:/var/log/app
    networks:
      - app_network
    depends_on:
      - db
      - redis
  
  db:
    image: mysql:8.0
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_USER: ${DB_USERNAME}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    volumes:
      - db_data:/var/lib/mysql
      - ./docker/mysql.cnf:/etc/mysql/conf.d/app.cnf
    networks:
      - app_network
  
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    volumes:
      - redis_data:/data
    networks:
      - app_network
  
  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./docker/nginx-prod.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    networks:
      - app_network
    depends_on:
      - app

volumes:
  db_data:
  redis_data:
  app_storage:
  app_logs:

networks:
  app_network:
    driver: bridge
"""
```

## Blue-Green Deployment

```tusk
# Blue-Green deployment strategy
class BlueGreenDeployment {
    constructor(config) {
        this.blue_env: config.blue_environment
        this.green_env: config.green_environment
        this.load_balancer: config.load_balancer
        this.health_check: config.health_check_url
    }
    
    async deploy(version) {
        @console.info("Starting blue-green deployment for version " + version)
        
        # Determine current and target environments
        current: await this.get_active_environment()
        target: current === "blue" ? "green" : "blue"
        
        @console.info("Current: " + current + ", Target: " + target)
        
        try {
            # Deploy to target environment
            await this.deploy_to_environment(target, version)
            
            # Run health checks
            await this.verify_deployment(target)
            
            # Switch traffic
            await this.switch_traffic(target)
            
            # Verify switch
            await this.verify_switch(target)
            
            @console.success("Deployment completed successfully")
            
        } catch (error) {
            @console.error("Deployment failed: " + error.message)
            
            # Rollback
            await this.rollback(current)
            throw error
        }
    }
    
    async deploy_to_environment(env, version) {
        @console.info("Deploying to " + env + " environment")
        
        # Update container image
        await @kubectl.set_image(
            "deployment/app-" + env,
            "app=yourapp:" + version
        )
        
        # Wait for rollout
        await @kubectl.rollout_status("deployment/app-" + env)
    }
    
    async verify_deployment(env) {
        @console.info("Verifying deployment on " + env)
        
        # Health check with retries
        max_attempts: 30
        for (attempt in 1..max_attempts) {
            try {
                response: await @http.get(this.health_check + "?env=" + env, {
                    timeout: 5000
                })
                
                if (response.status === 200) {
                    @console.success("Health check passed")
                    return true
                }
                
            } catch (error) {
                @console.warn("Health check attempt " + attempt + " failed")
            }
            
            await @sleep(10000)  # Wait 10 seconds
        }
        
        throw "Health check failed after " + max_attempts + " attempts"
    }
    
    async switch_traffic(target_env) {
        @console.info("Switching traffic to " + target_env)
        
        # Update load balancer configuration
        await this.load_balancer.update_backend(target_env)
        
        # Gradual traffic shifting
        await this.gradual_traffic_shift(target_env)
    }
    
    async gradual_traffic_shift(target_env) {
        percentages: [10, 25, 50, 75, 100]
        
        for (percentage in percentages) {
            @console.info("Shifting " + percentage + "% traffic to " + target_env)
            
            await this.load_balancer.set_traffic_split({
                [target_env]: percentage,
                [this.get_other_env(target_env)]: 100 - percentage
            })
            
            # Monitor for issues
            await this.monitor_metrics(60)  # Monitor for 1 minute
            
            # Check error rate
            error_rate: await this.get_error_rate()
            if (error_rate > 5) {  # 5% error threshold
                throw "High error rate detected: " + error_rate + "%"
            }
        }
    }
}
```

## Rolling Deployment

```tusk
# Rolling deployment strategy
class RollingDeployment {
    constructor(config) {
        this.instances: config.instances
        this.batch_size: config.batch_size || 2
        this.health_check: config.health_check_url
        this.rollback_on_failure: config.rollback_on_failure || true
    }
    
    async deploy(version) {
        @console.info("Starting rolling deployment for version " + version)
        
        total_instances: this.instances.length
        batches: @array_chunk(this.instances, this.batch_size)
        deployed_instances: []
        
        try {
            for (batch_index, batch in batches) {
                @console.info(`Deploying batch ${batch_index + 1}/${batches.length}`)
                
                # Deploy to batch
                await this.deploy_batch(batch, version)
                
                # Health check batch
                await this.verify_batch(batch)
                
                deployed_instances.push(...batch)
                
                # Wait between batches
                if (batch_index < batches.length - 1) {
                    @console.info("Waiting before next batch...")
                    await @sleep(30000)  # 30 seconds
                }
            }
            
            @console.success("Rolling deployment completed successfully")
            
        } catch (error) {
            @console.error("Rolling deployment failed: " + error.message)
            
            if (this.rollback_on_failure && deployed_instances.length > 0) {
                await this.rollback_instances(deployed_instances)
            }
            
            throw error
        }
    }
    
    async deploy_batch(instances, version) {
        # Deploy to instances in parallel
        promises: instances.map(instance => 
            this.deploy_to_instance(instance, version)
        )
        
        await Promise.all(promises)
    }
    
    async deploy_to_instance(instance, version) {
        @console.info("Deploying to instance " + instance.id)
        
        # Remove from load balancer
        await this.remove_from_load_balancer(instance)
        
        # Update instance
        await @ssh.exec(instance.host, [
            "docker pull yourapp:" + version,
            "docker stop app-container",
            "docker run -d --name app-container yourapp:" + version
        ])
        
        # Wait for startup
        await @sleep(10000)
        
        # Add back to load balancer
        await this.add_to_load_balancer(instance)
    }
}
```

## Canary Deployment

```tusk
# Canary deployment strategy
class CanaryDeployment {
    constructor(config) {
        this.canary_percentage: config.canary_percentage || 5
        this.monitoring_duration: config.monitoring_duration || 600  # 10 minutes
        this.success_metrics: config.success_metrics
    }
    
    async deploy(version) {
        @console.info("Starting canary deployment for version " + version)
        
        try {
            # Deploy canary
            await this.deploy_canary(version)
            
            # Route traffic to canary
            await this.route_canary_traffic()
            
            # Monitor canary
            metrics: await this.monitor_canary()
            
            # Evaluate metrics
            if (this.evaluate_metrics(metrics)) {
                # Promote canary
                await this.promote_canary(version)
                @console.success("Canary deployment successful")
            } else {
                # Rollback canary
                await this.rollback_canary()
                throw "Canary metrics failed evaluation"
            }
            
        } catch (error) {
            @console.error("Canary deployment failed: " + error.message)
            await this.rollback_canary()
            throw error
        }
    }
    
    async monitor_canary() {
        @console.info("Monitoring canary for " + this.monitoring_duration + " seconds")
        
        metrics: {
            error_rate: [],
            response_time: [],
            throughput: []
        }
        
        end_time: Date.now() + (this.monitoring_duration * 1000)
        
        while (Date.now() < end_time) {
            # Collect metrics
            current_metrics: await this.collect_metrics()
            
            metrics.error_rate.push(current_metrics.error_rate)
            metrics.response_time.push(current_metrics.response_time)
            metrics.throughput.push(current_metrics.throughput)
            
            await @sleep(30000)  # Collect every 30 seconds
        }
        
        return metrics
    }
    
    evaluate_metrics(metrics) {
        # Calculate averages
        avg_error_rate: metrics.error_rate.reduce((a, b) => a + b, 0) / metrics.error_rate.length
        avg_response_time: metrics.response_time.reduce((a, b) => a + b, 0) / metrics.response_time.length
        
        @console.info("Canary metrics - Error rate: " + avg_error_rate + "%, Response time: " + avg_response_time + "ms")
        
        # Check against thresholds
        if (avg_error_rate > this.success_metrics.max_error_rate) {
            @console.error("Error rate too high: " + avg_error_rate + "%")
            return false
        }
        
        if (avg_response_time > this.success_metrics.max_response_time) {
            @console.error("Response time too high: " + avg_response_time + "ms")
            return false
        }
        
        return true
    }
}
```

## Deployment Automation

```tusk
# CI/CD Pipeline
class DeploymentPipeline {
    static setup_github_actions() {
        workflow: """
name: Deploy to Production

on:
  push:
    tags:
      - 'v*'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: |
          composer install
          npm ci
      - name: Run tests
        run: |
          php artisan test
          npm test
      - name: Security scan
        run: |
          composer audit
          npm audit
  
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: |
          docker build -t ${{ github.repository }}:${{ github.ref_name }} .
          docker push ${{ github.repository }}:${{ github.ref_name }}
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/app app=${{ github.repository }}:${{ github.ref_name }}
          kubectl rollout status deployment/app
      - name: Run health checks
        run: |
          curl -f https://yourapp.com/health
      - name: Notify team
        run: |
          slack-notify "Deployment ${{ github.ref_name }} completed successfully"
"""
        
        @file.write(".github/workflows/deploy.yml", workflow)
    }
    
    static setup_deployment_hooks() {
        # Pre-deployment hooks
        @hook("deployment.before", () => {
            # Backup database
            @db.backup("pre_deployment_" + @now())
            
            # Scale up resources
            @cloud.scale_up("app", {instances: 10})
            
            # Enable maintenance mode
            @maintenance.enable()
        })
        
        # Post-deployment hooks
        @hook("deployment.after", () => {
            # Run migrations
            @migrate.run()
            
            # Clear caches
            @cache.flush()
            
            # Warm up caches
            @cache.warm_critical()
            
            # Disable maintenance mode
            @maintenance.disable()
            
            # Send notifications
            @notify.deployment_success()
        })
        
        # Rollback hooks
        @hook("deployment.rollback", () => {
            # Restore database
            @db.restore_latest_backup()
            
            # Scale down resources
            @cloud.scale_down("app")
            
            # Send alert
            @alert.deployment_failed()
        })
    }
}
```

## Monitoring and Rollback

```tusk
# Deployment monitoring
class DeploymentMonitor {
    static monitor_deployment(deployment_id) {
        metrics: {
            error_rate: @prometheus.query("rate(http_requests_total{status=~'5..'}[5m])"),
            response_time: @prometheus.query("histogram_quantile(0.95, http_request_duration_seconds)"),
            throughput: @prometheus.query("rate(http_requests_total[5m])"),
            cpu_usage: @prometheus.query("rate(cpu_usage_total[5m])"),
            memory_usage: @prometheus.query("memory_usage_bytes")
        }
        
        # Check thresholds
        if (metrics.error_rate > 0.05) {  # 5% error rate
            @alert.high_error_rate(deployment_id)
            return false
        }
        
        if (metrics.response_time > 2000) {  # 2 second response time
            @alert.high_response_time(deployment_id)
            return false
        }
        
        return true
    }
    
    static auto_rollback(deployment_id) {
        @console.warn("Initiating automatic rollback for deployment " + deployment_id)
        
        # Get previous version
        previous_version: @deployment.get_previous_version(deployment_id)
        
        # Rollback
        @deployment.rollback(previous_version)
        
        # Verify rollback
        if (this.monitor_deployment("rollback-" + deployment_id)) {
            @console.success("Rollback completed successfully")
        } else {
            @alert.rollback_failed(deployment_id)
        }
    }
}
```

## Best Practices

1. **Automate everything** - Use CI/CD pipelines
2. **Test thoroughly** - Run tests before deployment
3. **Use gradual rollouts** - Blue-green, canary, or rolling deployments
4. **Monitor deployments** - Track metrics and health
5. **Have rollback plans** - Quick rollback strategies
6. **Use infrastructure as code** - Version control infrastructure
7. **Separate environments** - Dev, staging, production
8. **Security scanning** - Scan for vulnerabilities

## Related Topics

- `containerization` - Docker and Kubernetes
- `ci-cd-pipelines` - Continuous integration/deployment
- `monitoring` - Application monitoring
- `infrastructure-as-code` - Infrastructure management
- `load-balancing` - Traffic distribution
---

[Scaling Applications in TuskLang]


Scaling TuskLang applications involves strategies for handling increased load, optimizing performance, and maintaining reliability as your application grows.

## Horizontal Scaling

```tusk
# Load balancer configuration
class LoadBalancer {
    constructor(config) {
        this.algorithm: config.algorithm || "round_robin"
        this.health_check: config.health_check
        this.servers: config.servers
        this.sticky_sessions: config.sticky_sessions || false
    }
    
    route_request(request) {
        # Get available servers
        available_servers: this.get_healthy_servers()
        
        if (available_servers.length === 0) {
            throw "No healthy servers available"
        }
        
        # Route based on algorithm
        server: match this.algorithm {
            "round_robin" => this.round_robin_select(available_servers)
            "least_connections" => this.least_connections_select(available_servers)
            "weighted" => this.weighted_select(available_servers)
            "ip_hash" => this.ip_hash_select(available_servers, request.ip)
            _ => available_servers[0]
        }
        
        # Handle sticky sessions
        if (this.sticky_sessions && request.session_id) {
            sticky_server: this.get_sticky_server(request.session_id)
            if (sticky_server && available_servers.includes(sticky_server)) {
                server: sticky_server
            }
        }
        
        return server
    }
    
    get_healthy_servers() {
        healthy: []
        
        for (server in this.servers) {
            if (this.check_health(server)) {
                healthy.push(server)
            }
        }
        
        return healthy
    }
    
    check_health(server) {
        try {
            response: @http.get(server.url + this.health_check.path, {
                timeout: this.health_check.timeout || 5000
            })
            
            return response.status === 200
        } catch {
            return false
        }
    }
}

# Auto-scaling based on metrics
class AutoScaler {
    constructor(config) {
        this.min_instances: config.min_instances || 2
        this.max_instances: config.max_instances || 20
        this.target_cpu: config.target_cpu || 70  # Percentage
        this.target_memory: config.target_memory || 80  # Percentage
        this.scale_up_threshold: config.scale_up_threshold || 5  # Minutes
        this.scale_down_threshold: config.scale_down_threshold || 10  # Minutes
    }
    
    async monitor_and_scale() {
        while (true) {
            metrics: await this.collect_metrics()
            decision: this.make_scaling_decision(metrics)
            
            if (decision.action === "scale_up") {
                await this.scale_up(decision.instances)
            } else if (decision.action === "scale_down") {
                await this.scale_down(decision.instances)
            }
            
            await @sleep(60000)  # Check every minute
        }
    }
    
    async collect_metrics() {
        return {
            cpu_usage: await @prometheus.query("avg(cpu_usage_percent)"),
            memory_usage: await @prometheus.query("avg(memory_usage_percent)"),
            request_rate: await @prometheus.query("rate(http_requests_total[5m])"),
            response_time: await @prometheus.query("avg(response_time_seconds)"),
            instance_count: await @kubernetes.get_replica_count()
        }
    }
    
    make_scaling_decision(metrics) {
        current_instances: metrics.instance_count
        
        # Scale up conditions
        if ((metrics.cpu_usage > this.target_cpu || 
             metrics.memory_usage > this.target_memory) &&
            current_instances < this.max_instances) {
            
            new_instances: Math.min(
                current_instances + Math.ceil(current_instances * 0.5),
                this.max_instances
            )
            
            return {
                action: "scale_up",
                instances: new_instances,
                reason: "High resource usage"
            }
        }
        
        # Scale down conditions
        if (metrics.cpu_usage < this.target_cpu * 0.5 &&
            metrics.memory_usage < this.target_memory * 0.5 &&
            current_instances > this.min_instances) {
            
            new_instances: Math.max(
                current_instances - Math.ceil(current_instances * 0.3),
                this.min_instances
            )
            
            return {
                action: "scale_down",
                instances: new_instances,
                reason: "Low resource usage"
            }
        }
        
        return {action: "none"}
    }
}
```

## Database Scaling

```tusk
# Database read/write splitting
class DatabaseScaler {
    constructor(config) {
        this.write_connection: config.write_connection
        this.read_connections: config.read_connections
        this.read_strategy: config.read_strategy || "round_robin"
    }
    
    get_connection(operation_type) {
        if (operation_type === "write") {
            return this.write_connection
        }
        
        # Select read replica
        return this.select_read_connection()
    }
    
    select_read_connection() {
        match this.read_strategy {
            "round_robin" => {
                index: @cache.increment("read_connection_index") % this.read_connections.length
                return this.read_connections[index]
            }
            "least_load" => {
                loads: this.read_connections.map(conn => conn.get_load())
                min_index: loads.indexOf(Math.min(...loads))
                return this.read_connections[min_index]
            }
            "geographic" => {
                user_location: @get_user_location()
                return this.get_nearest_read_replica(user_location)
            }
        }
    }
}

# Database sharding
class DatabaseSharding {
    constructor(config) {
        this.shards: config.shards
        this.shard_key: config.shard_key || "id"
        this.strategy: config.strategy || "hash"
    }
    
    get_shard(data) {
        key_value: data[this.shard_key]
        
        match this.strategy {
            "hash" => {
                hash: @hash(key_value.toString())
                shard_index: hash % this.shards.length
                return this.shards[shard_index]
            }
            "range" => {
                for (shard in this.shards) {
                    if (key_value >= shard.min && key_value <= shard.max) {
                        return shard
                    }
                }
                throw "No shard found for key: " + key_value
            }
            "directory" => {
                return this.shard_directory[key_value] || this.shards[0]
            }
        }
    }
    
    execute_query(query, data) {
        if (query.affects_multiple_shards()) {
            # Cross-shard query
            return this.execute_cross_shard_query(query, data)
        }
        
        shard: this.get_shard(data)
        return shard.execute(query)
    }
    
    execute_cross_shard_query(query, data) {
        results: []
        
        # Execute on all shards in parallel
        promises: this.shards.map(shard => {
            return shard.execute(query.for_shard(shard))
        })
        
        shard_results: await Promise.all(promises)
        
        # Merge results
        return this.merge_shard_results(shard_results, query)
    }
}

# Connection pooling
class ConnectionPool {
    constructor(config) {
        this.min_connections: config.min || 5
        this.max_connections: config.max || 20
        this.idle_timeout: config.idle_timeout || 300000  # 5 minutes
        this.connection_factory: config.factory
        
        this.available: []
        this.busy: new Set()
        this.total: 0
        
        # Pre-create minimum connections
        this.ensure_minimum_connections()
    }
    
    async acquire() {
        # Return available connection
        if (this.available.length > 0) {
            connection: this.available.pop()
            this.busy.add(connection)
            return connection
        }
        
        # Create new connection if under limit
        if (this.total < this.max_connections) {
            connection: await this.create_connection()
            this.busy.add(connection)
            return connection
        }
        
        # Wait for available connection
        return this.wait_for_connection()
    }
    
    release(connection) {
        this.busy.delete(connection)
        
        # Check if connection is still healthy
        if (connection.is_healthy()) {
            this.available.push(connection)
        } else {
            this.destroy_connection(connection)
        }
    }
    
    async create_connection() {
        connection: await this.connection_factory()
        connection.created_at: Date.now()
        this.total++
        return connection
    }
    
    cleanup_idle_connections() {
        now: Date.now()
        
        this.available: this.available.filter(conn => {
            if (now - conn.last_used > this.idle_timeout) {
                this.destroy_connection(conn)
                return false
            }
            return true
        })
    }
}
```

## Caching Strategies

```tusk
# Multi-level caching
class CacheStrategy {
    constructor() {
        this.l1: new Map()  # Application cache
        this.l2: @redis()   # Distributed cache
        this.l3: @cdn()     # CDN cache
    }
    
    async get(key, fetcher) {
        # Level 1: Application memory
        if (this.l1.has(key)) {
            @metrics.increment("cache.l1.hit")
            return this.l1.get(key)
        }
        
        # Level 2: Redis
        value: await this.l2.get(key)
        if (value) {
            @metrics.increment("cache.l2.hit")
            this.l1.set(key, value)
            return value
        }
        
        # Level 3: Fetch from source
        @metrics.increment("cache.miss")
        value: await fetcher()
        
        # Store in all levels
        this.l1.set(key, value)
        await this.l2.set(key, value, 3600)
        
        return value
    }
    
    async invalidate(pattern) {
        # Clear from all levels
        this.l1.clear()
        await this.l2.deletePattern(pattern)
        await this.l3.purge(pattern)
    }
}

# Cache warming
class CacheWarmer {
    constructor(cache) {
        this.cache: cache
        this.warming_queue: []
    }
    
    async warm_critical_data() {
        critical_keys: [
            "homepage_data",
            "navigation_menu",
            "popular_products",
            "featured_content"
        ]
        
        for (key in critical_keys) {
            await this.warm_key(key)
        }
    }
    
    async warm_key(key) {
        @console.info("Warming cache for key: " + key)
        
        try {
            data: await this.get_data_for_key(key)
            await this.cache.set(key, data)
        } catch (error) {
            @console.error("Failed to warm cache for " + key + ": " + error.message)
        }
    }
    
    schedule_warming() {
        # Warm cache every hour
        @cron("0 * * * *", () => {
            this.warm_critical_data()
        })
        
        # Warm before peak hours
        @cron("0 7 * * *", () => {
            this.warm_all_data()
        })
    }
}
```

## Queue and Background Job Scaling

```tusk
# Scalable queue system
class QueueScaler {
    constructor(config) {
        this.queues: config.queues
        this.workers: config.workers
        this.scaling_rules: config.scaling_rules
    }
    
    async monitor_queues() {
        while (true) {
            for (queue_name in this.queues) {
                queue_stats: await this.get_queue_stats(queue_name)
                scaling_decision: this.evaluate_scaling(queue_name, queue_stats)
                
                if (scaling_decision.action === "scale_up") {
                    await this.scale_workers_up(queue_name, scaling_decision.workers)
                } else if (scaling_decision.action === "scale_down") {
                    await this.scale_workers_down(queue_name, scaling_decision.workers)
                }
            }
            
            await @sleep(30000)  # Check every 30 seconds
        }
    }
    
    evaluate_scaling(queue_name, stats) {
        rules: this.scaling_rules[queue_name] || this.scaling_rules.default
        current_workers: this.workers[queue_name].length
        
        # Scale up if queue is growing
        if (stats.pending_jobs > rules.scale_up_threshold &&
            stats.avg_processing_time > rules.max_processing_time) {
            
            new_workers: Math.min(
                current_workers + rules.scale_increment,
                rules.max_workers
            )
            
            return {
                action: "scale_up",
                workers: new_workers - current_workers
            }
        }
        
        # Scale down if queue is idle
        if (stats.pending_jobs < rules.scale_down_threshold &&
            current_workers > rules.min_workers) {
            
            new_workers: Math.max(
                current_workers - rules.scale_decrement,
                rules.min_workers
            )
            
            return {
                action: "scale_down",
                workers: current_workers - new_workers
            }
        }
        
        return {action: "none"}
    }
    
    async scale_workers_up(queue_name, count) {
        @console.info(`Scaling up ${count} workers for queue ${queue_name}`)
        
        for (i in 1..count) {
            worker: await this.create_worker(queue_name)
            this.workers[queue_name].push(worker)
        }
    }
    
    async scale_workers_down(queue_name, count) {
        @console.info(`Scaling down ${count} workers for queue ${queue_name}`)
        
        workers_to_remove: this.workers[queue_name].splice(-count)
        
        for (worker in workers_to_remove) {
            await worker.graceful_shutdown()
        }
    }
}

# Distributed job processing
class DistributedJobProcessor {
    constructor(config) {
        this.redis: config.redis_connection
        this.processor_id: @uuid()
        this.heartbeat_interval: config.heartbeat_interval || 30000
    }
    
    async start_processing(queue_name) {
        # Register processor
        await this.register_processor()
        
        # Start heartbeat
        this.start_heartbeat()
        
        # Process jobs
        while (true) {
            try {
                job: await this.claim_job(queue_name)
                
                if (job) {
                    await this.process_job(job)
                } else {
                    await @sleep(1000)  # Wait if no jobs
                }
                
            } catch (error) {
                @console.error("Job processing error:", error)
                await @sleep(5000)  # Backoff on error
            }
        }
    }
    
    async claim_job(queue_name) {
        # Atomic job claiming using Redis
        lua_script: """
            local job = redis.call('LPOP', KEYS[1])
            if job then
                redis.call('HSET', KEYS[2], job, ARGV[1])
                redis.call('EXPIRE', KEYS[2], ARGV[2])
                return job
            end
            return nil
        """
        
        result: await this.redis.eval(lua_script, [
            queue_name,
            "processing:" + queue_name
        ], [
            this.processor_id,
            300  # 5 minute timeout
        ])
        
        return result ? @json_decode(result) : null
    }
    
    async process_job(job) {
        start_time: Date.now()
        
        try {
            # Execute job
            result: await this.execute_job_handler(job)
            
            # Mark as completed
            await this.mark_job_completed(job, result)
            
            @metrics.increment("jobs.completed")
            @metrics.timing("jobs.duration", Date.now() - start_time)
            
        } catch (error) {
            # Handle job failure
            await this.handle_job_failure(job, error)
            
            @metrics.increment("jobs.failed")
        }
    }
}
```

## CDN and Static Asset Scaling

```tusk
# CDN integration
class CDNManager {
    constructor(config) {
        this.cdn_endpoints: config.endpoints
        this.cache_rules: config.cache_rules
        this.optimization: config.optimization
    }
    
    get_asset_url(asset_path, options = {}) {
        # Select optimal CDN endpoint
        endpoint: this.select_endpoint(options.user_location)
        
        # Apply transformations
        if (options.transformations) {
            asset_path: this.apply_transformations(asset_path, options.transformations)
        }
        
        # Add cache busting
        if (options.cache_bust) {
            asset_path += "?v=" + @get_asset_version(asset_path)
        }
        
        return endpoint.url + asset_path
    }
    
    apply_transformations(asset_path, transformations) {
        # Image optimization
        if (asset_path.endsWith(".jpg") || asset_path.endsWith(".png")) {
            if (transformations.resize) {
                asset_path += "?w=" + transformations.resize.width + "&h=" + transformations.resize.height
            }
            
            if (transformations.format) {
                asset_path += "&f=" + transformations.format
            }
            
            if (transformations.quality) {
                asset_path += "&q=" + transformations.quality
            }
        }
        
        return asset_path
    }
    
    async warm_cache(urls) {
        # Pre-load URLs into CDN cache
        promises: urls.map(url => {
            return @http.head(url)  # Trigger cache population
        })
        
        await Promise.all(promises)
    }
    
    async purge_cache(patterns) {
        # Purge cache for specific patterns
        for (endpoint in this.cdn_endpoints) {
            await endpoint.purge(patterns)
        }
    }
}

# Asset optimization
class AssetOptimizer {
    static optimize_images(source_dir, output_dir) {
        images: @glob(source_dir + "/**/*.{jpg,jpeg,png,gif,webp}")
        
        for (image in images) {
            # Generate multiple sizes
            sizes: [320, 640, 1024, 1920]
            
            for (size in sizes) {
                optimized: @image_resize(image, {
                    width: size,
                    quality: 85,
                    format: "webp"
                })
                
                output_path: this.get_output_path(image, output_dir, size)
                @file_put_contents(output_path, optimized)
            }
        }
    }
    
    static optimize_css(files) {
        combined: ""
        
        for (file in files) {
            content: @file_get_contents(file)
            
            # Process CSS
            processed: @css_process(content, {
                minify: true,
                autoprefixer: true,
                remove_unused: true
            })
            
            combined += processed
        }
        
        # Compress
        compressed: @gzip_compress(combined)
        
        return compressed
    }
    
    static optimize_js(files) {
        # Bundle and minify
        bundled: @js_bundle(files, {
            minify: true,
            tree_shaking: true,
            code_splitting: true
        })
        
        return bundled
    }
}
```

## Monitoring and Alerting

```tusk
# Comprehensive monitoring
class ScalingMonitor {
    constructor(config) {
        this.metrics: config.metrics_collector
        this.alerting: config.alerting_system
        this.thresholds: config.thresholds
    }
    
    async monitor_application() {
        while (true) {
            metrics: await this.collect_all_metrics()
            
            # Check thresholds and alert
            this.check_thresholds(metrics)
            
            # Store metrics for historical analysis
            await this.store_metrics(metrics)
            
            await @sleep(60000)  # Monitor every minute
        }
    }
    
    async collect_all_metrics() {
        return {
            # Application metrics
            response_time: await @prometheus.query("avg(http_request_duration_seconds)"),
            error_rate: await @prometheus.query("rate(http_requests_total{status=~'5..'}[5m])"),
            throughput: await @prometheus.query("rate(http_requests_total[5m])"),
            
            # Infrastructure metrics
            cpu_usage: await @prometheus.query("avg(cpu_usage_percent)"),
            memory_usage: await @prometheus.query("avg(memory_usage_percent)"),
            disk_usage: await @prometheus.query("avg(disk_usage_percent)"),
            
            # Database metrics
            db_connections: await @prometheus.query("mysql_global_status_threads_connected"),
            db_queries_per_sec: await @prometheus.query("rate(mysql_global_status_queries[5m])"),
            db_slow_queries: await @prometheus.query("rate(mysql_global_status_slow_queries[5m])"),
            
            # Cache metrics
            cache_hit_rate: await @prometheus.query("rate(redis_keyspace_hits_total[5m]) / (rate(redis_keyspace_hits_total[5m]) + rate(redis_keyspace_misses_total[5m]))"),
            cache_memory_usage: await @prometheus.query("redis_memory_used_bytes"),
            
            # Queue metrics
            queue_size: await @prometheus.query("queue_pending_jobs"),
            queue_processing_time: await @prometheus.query("avg(queue_job_duration_seconds)")
        }
    }
    
    check_thresholds(metrics) {
        # Response time alert
        if (metrics.response_time > this.thresholds.max_response_time) {
            this.alerting.send_alert("High response time", {
                current: metrics.response_time,
                threshold: this.thresholds.max_response_time
            })
        }
        
        # Error rate alert
        if (metrics.error_rate > this.thresholds.max_error_rate) {
            this.alerting.send_alert("High error rate", {
                current: metrics.error_rate,
                threshold: this.thresholds.max_error_rate
            })
        }
        
        # Resource usage alerts
        if (metrics.cpu_usage > this.thresholds.max_cpu_usage) {
            this.alerting.send_alert("High CPU usage", {
                current: metrics.cpu_usage,
                threshold: this.thresholds.max_cpu_usage
            })
        }
        
        if (metrics.memory_usage > this.thresholds.max_memory_usage) {
            this.alerting.send_alert("High memory usage", {
                current: metrics.memory_usage,
                threshold: this.thresholds.max_memory_usage
            })
        }
    }
}
```

## Performance Testing for Scale

```tusk
# Load testing
class LoadTester {
    static async run_load_test(config) {
        test_duration: config.duration || 300  # 5 minutes
        concurrent_users: config.users || 100
        ramp_up_time: config.ramp_up || 60  # 1 minute
        
        results: {
            requests: 0,
            errors: 0,
            response_times: [],
            throughput: []
        }
        
        # Ramp up users gradually
        users_per_second: concurrent_users / ramp_up_time
        active_users: []
        
        start_time: Date.now()
        end_time: start_time + (test_duration * 1000)
        
        # Ramp up phase
        ramp_up_end: start_time + (ramp_up_time * 1000)
        while (Date.now() < ramp_up_end) {
            # Add users gradually
            users_to_add: Math.floor((Date.now() - start_time) / 1000 * users_per_second) - active_users.length
            
            for (i in 0..users_to_add) {
                user: this.create_virtual_user(config, results)
                active_users.push(user)
            }
            
            await @sleep(1000)
        }
        
        # Sustained load phase
        await @sleep((test_duration - ramp_up_time) * 1000)
        
        # Stop all users
        for (user in active_users) {
            user.stop()
        }
        
        # Calculate statistics
        return this.calculate_results(results)
    }
    
    static create_virtual_user(config, results) {
        user: {
            active: true,
            requests_made: 0
        }
        
        # Start user simulation
        user.interval: setInterval(async () => {
            if (!user.active) return
            
            try {
                start: Date.now()
                response: await @http.get(config.target_url, {
                    timeout: config.timeout || 30000
                })
                duration: Date.now() - start
                
                results.requests++
                results.response_times.push(duration)
                user.requests_made++
                
                if (response.status >= 400) {
                    results.errors++
                }
                
            } catch (error) {
                results.errors++
            }
        }, config.request_interval || 1000)
        
        user.stop: () => {
            user.active: false
            clearInterval(user.interval)
        }
        
        return user
    }
}
```

## Best Practices

1. **Plan for scale early** - Design with scalability in mind
2. **Monitor everything** - Track key metrics and set alerts
3. **Use horizontal scaling** - Scale out rather than up when possible
4. **Implement caching** - Multiple levels of caching
5. **Optimize database** - Use read replicas and sharding
6. **Load test regularly** - Test your scaling strategies
7. **Automate scaling** - Use auto-scaling based on metrics
8. **Plan for failures** - Design for resilience

## Related Topics

- `performance-optimization` - Application optimization
- `caching-strategies` - Caching patterns
- `database-optimization` - Database scaling
- `monitoring` - Application monitoring
- `load-balancing` - Traffic distribution
---

