<h1>Control Flow with TuskLang in Rust</h1>

<h2>Conditional Logic and Control Structures</h2>
<p>TuskLang provides sophisticated control flow capabilities that integrate seamlessly with Rust's pattern matching and error handling, enabling intelligent, adaptive configuration behavior.</p>

<h3>Conditional Configuration</h3>
<pre>
# control-flow.tsk
# Environment-based conditional configuration
environment_config {
    current_env: env("ENVIRONMENT", "development")
    
    # Simple conditional assignment
    log_level: if(current_env == "production", "info", "debug")
    debug_mode: if(current_env == "development", true, false)
    
    # Nested conditionals for complex logic
    database_config: if(current_env == "production", {
        host: env("PROD_DB_HOST")
        pool_size: 50
        ssl_required: true
        backup: {
            enabled: true
            schedule: "0 2 * * *"
            retention: "30d"
        }
    }, if(current_env == "staging", {
        host: env("STAGING_DB_HOST", "staging-db.example.com")
        pool_size: 20
        ssl_required: true
        backup: {
            enabled: true
            schedule: "0 3 * * *"
            retention: "7d"
        }
    }, {
        host: "localhost"
        pool_size: 5
        ssl_required: false
        backup: {
            enabled: false
        }
    }))
    
    # Feature flag-based configuration
    features: {
        authentication: env_bool("ENABLE_AUTH", true)
        rate_limiting: env_bool("ENABLE_RATE_LIMIT", false)
        caching: env_bool("ENABLE_CACHE", true)
        monitoring: env_bool("ENABLE_MONITORING", false)
    }
    
    # Conditional service configuration based on features
    services: {
        auth_service: if(features.authentication, {
            enabled: true
            provider: "jwt"
            secret: env("JWT_SECRET")
            expiry: "24h"
            refresh_enabled: true
        }, {
            enabled: false
        })
        
        cache_service: if(features.caching, {
            enabled: true
            provider: if(current_env == "production", "redis", "memory")
            url: if(current_env == "production", env("REDIS_URL"), "")
            ttl: 3600
        }, {
            enabled: false
        })
        
        monitoring_service: if(features.monitoring, {
            enabled: true
            provider: "prometheus"
            endpoint: "/metrics"
            scrape_interval: "15s"
            alerts: if(current_env == "production", true, false)
        }, {
            enabled: false
        })
    }
}

# Performance-based adaptive configuration
performance_config {
    cpu_count: cpu_count()
    available_memory: memory_total()
    
    # Thread pool sizing based on system resources
    worker_threads: if(cpu_count > 8, 
        min(cpu_count * 2, 32), 
        max(cpu_count, 4))
    
    # Memory allocation based on available resources
    heap_size: if(available_memory > 8_000_000_000,  # 8GB
        "4g",
        if(available_memory > 4_000_000_000,  # 4GB
            "2g",
            "1g"))
    
    # Buffer sizes based on workload
    buffer_config: {
        read_buffer: if(env("WORKLOAD_TYPE") == "read_heavy", 
            64 * 1024,
            32 * 1024)
        
        write_buffer: if(env("WORKLOAD_TYPE") == "write_heavy",
            128 * 1024,
            64 * 1024)
        
        network_buffer: if(env("NETWORK_LATENCY") == "high",
            256 * 1024,
            128 * 1024)
    }
}

# Time-based configuration changes
time_based_config {
    current_hour: hour(now())
    current_day: day_of_week(now())
    
    # Different configuration during business hours
    business_hours: and(current_hour >= 9, current_hour <= 17)
    weekend: or(current_day == 6, current_day == 0)  # Saturday or Sunday
    
    # Scale services based on expected load
    scaling_config: {
        web_replicas: if(and(business_hours, not(weekend)),
            10,  # High load during business hours
            if(weekend,
                3,   # Lower load on weekends
                6))  # Medium load outside business hours
        
        worker_replicas: if(business_hours,
            15,  # More workers during business hours
            5)   # Fewer workers outside business hours
        
        # Cache configuration based on time
        cache_ttl: if(business_hours,
            300,   # 5 minutes during high load
            1800)  # 30 minutes during low load
    }
    
    # Maintenance windows
    maintenance_mode: if(and(current_hour >= 2, current_hour <= 4),
        env_bool("ENABLE_MAINTENANCE", false),
        false)
}
</pre>

<h3>Rust Control Flow Implementation</h3>
<pre>
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc, Timelike, Weekday, Datelike};
use anyhow::Result;

// Control flow evaluator for TuskLang
#[derive(Debug)]
pub struct ControlFlowEvaluator {
    variables: HashMap<String, serde_json::Value>,
    functions: HashMap<String, Box<dyn ConditionFunction>>,
}

impl ControlFlowEvaluator {
    pub fn new() -> Self {
        let mut evaluator = ControlFlowEvaluator {
            variables: HashMap::new(),
            functions: HashMap::new(),
        };
        
        // Register built-in conditional functions
        evaluator.register_function("if", Box::new(IfFunction));
        evaluator.register_function("and", Box::new(AndFunction));
        evaluator.register_function("or", Box::new(OrFunction));
        evaluator.register_function("not", Box::new(NotFunction));
        evaluator.register_function("min", Box::new(MinFunction));
        evaluator.register_function("max", Box::new(MaxFunction));
        evaluator.register_function("hour", Box::new(HourFunction));
        evaluator.register_function("day_of_week", Box::new(DayOfWeekFunction));
        
        evaluator
    }
    
    pub fn register_function(&mut self, name: &str, function: Box<dyn ConditionFunction>) {
        self.functions.insert(name.to_string(), function);
    }
    
    pub fn set_variable(&mut self, name: String, value: serde_json::Value) {
        self.variables.insert(name, value);
    }
    
    pub fn evaluate_condition(&self, condition: &str) -> Result<bool> {
        let parsed = self.parse_condition(condition)?;
        self.evaluate_parsed_condition(&parsed)
    }
    
    pub fn evaluate_expression(&self, expression: &str) -> Result<serde_json::Value> {
        let parsed = self.parse_expression(expression)?;
        self.evaluate_parsed_expression(&parsed)
    }
    
    fn parse_condition(&self, condition: &str) -> Result<ParsedCondition> {
        // Simplified parser for demonstration
        // In production, use a proper parser like nom or pest
        
        if condition.contains("==") {
            let parts: Vec<&str> = condition.split("==").collect();
            if parts.len() == 2 {
                let left = self.parse_value(parts[0].trim())?;
                let right = self.parse_value(parts[1].trim())?;
                return Ok(ParsedCondition::Equals(left, right));
            }
        }
        
        if condition.contains(">=") {
            let parts: Vec<&str> = condition.split(">=").collect();
            if parts.len() == 2 {
                let left = self.parse_value(parts[0].trim())?;
                let right = self.parse_value(parts[1].trim())?;
                return Ok(ParsedCondition::GreaterThanOrEqual(left, right));
            }
        }
        
        if condition.contains("<=") {
            let parts: Vec<&str> = condition.split("<=").collect();
            if parts.len() == 2 {
                let left = self.parse_value(parts[0].trim())?;
                let right = self.parse_value(parts[1].trim())?;
                return Ok(ParsedCondition::LessThanOrEqual(left, right));
            }
        }
        
        if condition.contains('>') {
            let parts: Vec<&str> = condition.split('>').collect();
            if parts.len() == 2 {
                let left = self.parse_value(parts[0].trim())?;
                let right = self.parse_value(parts[1].trim())?;
                return Ok(ParsedCondition::GreaterThan(left, right));
            }
        }
        
        if condition.contains('<') {
            let parts: Vec<&str> = condition.split('<').collect();
            if parts.len() == 2 {
                let left = self.parse_value(parts[0].trim())?;
                let right = self.parse_value(parts[1].trim())?;
                return Ok(ParsedCondition::LessThan(left, right));
            }
        }
        
        // Check for function calls
        if let Some(func_call) = self.parse_function_call(condition)? {
            return Ok(ParsedCondition::FunctionCall(func_call));
        }
        
        // Default to variable lookup
        Ok(ParsedCondition::Variable(condition.to_string()))
    }
    
    fn parse_expression(&self, expression: &str) -> Result<ParsedExpression> {
        // Check for function calls first
        if let Some(func_call) = self.parse_function_call(expression)? {
            return Ok(ParsedExpression::FunctionCall(func_call));
        }
        
        // Check for arithmetic operations
        if expression.contains('+') {
            let parts: Vec<&str> = expression.split('+').collect();
            if parts.len() == 2 {
                let left = Box::new(self.parse_expression(parts[0].trim())?);
                let right = Box::new(self.parse_expression(parts[1].trim())?);
                return Ok(ParsedExpression::Add(left, right));
            }
        }
        
        if expression.contains('-') {
            let parts: Vec<&str> = expression.split('-').collect();
            if parts.len() == 2 {
                let left = Box::new(self.parse_expression(parts[0].trim())?);
                let right = Box::new(self.parse_expression(parts[1].trim())?);
                return Ok(ParsedExpression::Subtract(left, right));
            }
        }
        
        if expression.contains('*') {
            let parts: Vec<&str> = expression.split('*').collect();
            if parts.len() == 2 {
                let left = Box::new(self.parse_expression(parts[0].trim())?);
                let right = Box::new(self.parse_expression(parts[1].trim())?);
                return Ok(ParsedExpression::Multiply(left, right));
            }
        }
        
        // Parse as value
        let value = self.parse_value(expression)?;
        Ok(ParsedExpression::Value(value))
    }
    
    fn parse_value(&self, input: &str) -> Result<ParsedValue> {
        let input = input.trim();
        
        // String literal
        if input.starts_with('"') && input.ends_with('"') {
            let content = &input[1..input.len()-1];
            return Ok(ParsedValue::String(content.to_string()));
        }
        
        // Boolean literal
        if input == "true" {
            return Ok(ParsedValue::Bool(true));
        }
        if input == "false" {
            return Ok(ParsedValue::Bool(false));
        }
        
        // Numeric literal
        if let Ok(int_val) = input.parse::<i64>() {
            return Ok(ParsedValue::Number(serde_json::Number::from(int_val)));
        }
        
        if let Ok(float_val) = input.parse::<f64>() {
            return Ok(ParsedValue::Number(
                serde_json::Number::from_f64(float_val)
                    .ok_or_else(|| anyhow::anyhow!("Invalid float value"))?
            ));
        }
        
        // Variable reference
        Ok(ParsedValue::Variable(input.to_string()))
    }
    
    fn parse_function_call(&self, input: &str) -> Result<Option<FunctionCall>> {
        if let Some(paren_pos) = input.find('(') {
            if input.ends_with(')') {
                let func_name = input[..paren_pos].trim();
                let args_str = &input[paren_pos+1..input.len()-1];
                
                let args = if args_str.trim().is_empty() {
                    Vec::new()
                } else {
                    args_str.split(',')
                        .map(|arg| arg.trim().to_string())
                        .collect()
                };
                
                return Ok(Some(FunctionCall {
                    name: func_name.to_string(),
                    args,
                }));
            }
        }
        
        Ok(None)
    }
    
    fn evaluate_parsed_condition(&self, condition: &ParsedCondition) -> Result<bool> {
        match condition {
            ParsedCondition::Equals(left, right) => {
                let left_val = self.evaluate_parsed_value(left)?;
                let right_val = self.evaluate_parsed_value(right)?;
                Ok(left_val == right_val)
            }
            ParsedCondition::GreaterThan(left, right) => {
                let left_val = self.evaluate_parsed_value(left)?;
                let right_val = self.evaluate_parsed_value(right)?;
                Ok(self.compare_values(&left_val, &right_val)? > 0)
            }
            ParsedCondition::GreaterThanOrEqual(left, right) => {
                let left_val = self.evaluate_parsed_value(left)?;
                let right_val = self.evaluate_parsed_value(right)?;
                Ok(self.compare_values(&left_val, &right_val)? >= 0)
            }
            ParsedCondition::LessThan(left, right) => {
                let left_val = self.evaluate_parsed_value(left)?;
                let right_val = self.evaluate_parsed_value(right)?;
                Ok(self.compare_values(&left_val, &right_val)? < 0)
            }
            ParsedCondition::LessThanOrEqual(left, right) => {
                let left_val = self.evaluate_parsed_value(left)?;
                let right_val = self.evaluate_parsed_value(right)?;
                Ok(self.compare_values(&left_val, &right_val)? <= 0)
            }
            ParsedCondition::FunctionCall(func_call) => {
                let result = self.evaluate_function_call(func_call)?;
                match result {
                    serde_json::Value::Bool(b) => Ok(b),
                    _ => anyhow::bail!("Function call did not return boolean"),
                }
            }
            ParsedCondition::Variable(var_name) => {
                if let Some(value) = self.variables.get(var_name) {
                    match value {
                        serde_json::Value::Bool(b) => Ok(*b),
                        _ => anyhow::bail!("Variable {} is not boolean", var_name),
                    }
                } else {
                    anyhow::bail!("Variable {} not found", var_name);
                }
            }
        }
    }
    
    fn evaluate_parsed_expression(&self, expression: &ParsedExpression) -> Result<serde_json::Value> {
        match expression {
            ParsedExpression::Value(value) => self.evaluate_parsed_value(value),
            ParsedExpression::FunctionCall(func_call) => self.evaluate_function_call(func_call),
            ParsedExpression::Add(left, right) => {
                let left_val = self.evaluate_parsed_expression(left)?;
                let right_val = self.evaluate_parsed_expression(right)?;
                self.add_values(&left_val, &right_val)
            }
            ParsedExpression::Subtract(left, right) => {
                let left_val = self.evaluate_parsed_expression(left)?;
                let right_val = self.evaluate_parsed_expression(right)?;
                self.subtract_values(&left_val, &right_val)
            }
            ParsedExpression::Multiply(left, right) => {
                let left_val = self.evaluate_parsed_expression(left)?;
                let right_val = self.evaluate_parsed_expression(right)?;
                self.multiply_values(&left_val, &right_val)
            }
        }
    }
    
    fn evaluate_parsed_value(&self, value: &ParsedValue) -> Result<serde_json::Value> {
        match value {
            ParsedValue::String(s) => Ok(serde_json::Value::String(s.clone())),
            ParsedValue::Number(n) => Ok(serde_json::Value::Number(n.clone())),
            ParsedValue::Bool(b) => Ok(serde_json::Value::Bool(*b)),
            ParsedValue::Variable(var_name) => {
                if let Some(value) = self.variables.get(var_name) {
                    Ok(value.clone())
                } else {
                    anyhow::bail!("Variable {} not found", var_name);
                }
            }
        }
    }
    
    fn evaluate_function_call(&self, func_call: &FunctionCall) -> Result<serde_json::Value> {
        if let Some(function) = self.functions.get(&func_call.name) {
            function.call(&func_call.args, self)
        } else {
            anyhow::bail!("Unknown function: {}", func_call.name);
        }
    }
    
    fn compare_values(&self, left: &serde_json::Value, right: &serde_json::Value) -> Result<i32> {
        use serde_json::Value;
        
        match (left, right) {
            (Value::Number(l), Value::Number(r)) => {
                let l_f64 = l.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let r_f64 = r.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                Ok(l_f64.partial_cmp(&r_f64).unwrap_or(std::cmp::Ordering::Equal) as i32)
            }
            (Value::String(l), Value::String(r)) => {
                Ok(l.cmp(r) as i32)
            }
            _ => anyhow::bail!("Cannot compare different types"),
        }
    }
    
    fn add_values(&self, left: &serde_json::Value, right: &serde_json::Value) -> Result<serde_json::Value> {
        use serde_json::Value;
        
        match (left, right) {
            (Value::Number(l), Value::Number(r)) => {
                let l_f64 = l.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let r_f64 = r.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let result = l_f64 + r_f64;
                Ok(Value::Number(
                    serde_json::Number::from_f64(result)
                        .ok_or_else(|| anyhow::anyhow!("Invalid result"))?
                ))
            }
            (Value::String(l), Value::String(r)) => {
                Ok(Value::String(format!("{}{}", l, r)))
            }
            _ => anyhow::bail!("Cannot add different types"),
        }
    }
    
    fn subtract_values(&self, left: &serde_json::Value, right: &serde_json::Value) -> Result<serde_json::Value> {
        use serde_json::Value;
        
        match (left, right) {
            (Value::Number(l), Value::Number(r)) => {
                let l_f64 = l.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let r_f64 = r.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let result = l_f64 - r_f64;
                Ok(Value::Number(
                    serde_json::Number::from_f64(result)
                        .ok_or_else(|| anyhow::anyhow!("Invalid result"))?
                ))
            }
            _ => anyhow::bail!("Cannot subtract non-numeric values"),
        }
    }
    
    fn multiply_values(&self, left: &serde_json::Value, right: &serde_json::Value) -> Result<serde_json::Value> {
        use serde_json::Value;
        
        match (left, right) {
            (Value::Number(l), Value::Number(r)) => {
                let l_f64 = l.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let r_f64 = r.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let result = l_f64 * r_f64;
                Ok(Value::Number(
                    serde_json::Number::from_f64(result)
                        .ok_or_else(|| anyhow::anyhow!("Invalid result"))?
                ))
            }
            _ => anyhow::bail!("Cannot multiply non-numeric values"),
        }
    }
}

// Parsed AST structures
#[derive(Debug, Clone)]
enum ParsedCondition {
    Equals(ParsedValue, ParsedValue),
    GreaterThan(ParsedValue, ParsedValue),
    GreaterThanOrEqual(ParsedValue, ParsedValue),
    LessThan(ParsedValue, ParsedValue),
    LessThanOrEqual(ParsedValue, ParsedValue),
    FunctionCall(FunctionCall),
    Variable(String),
}

#[derive(Debug, Clone)]
enum ParsedExpression {
    Value(ParsedValue),
    FunctionCall(FunctionCall),
    Add(Box<ParsedExpression>, Box<ParsedExpression>),
    Subtract(Box<ParsedExpression>, Box<ParsedExpression>),
    Multiply(Box<ParsedExpression>, Box<ParsedExpression>),
}

#[derive(Debug, Clone)]
enum ParsedValue {
    String(String),
    Number(serde_json::Number),
    Bool(bool),
    Variable(String),
}

#[derive(Debug, Clone)]
struct FunctionCall {
    name: String,
    args: Vec<String>,
}

// Trait for conditional functions
trait ConditionFunction: Send + Sync {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value>;
}

// Built-in conditional functions
#[derive(Debug)]
struct IfFunction;

impl ConditionFunction for IfFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 3 {
            anyhow::bail!("if() requires exactly 3 arguments: condition, true_value, false_value");
        }
        
        let condition_result = evaluator.evaluate_condition(&args[0])?;
        
        if condition_result {
            evaluator.evaluate_expression(&args[1])
        } else {
            evaluator.evaluate_expression(&args[2])
        }
    }
}

#[derive(Debug)]
struct AndFunction;

impl ConditionFunction for AndFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 2 {
            anyhow::bail!("and() requires exactly 2 arguments");
        }
        
        let left = evaluator.evaluate_condition(&args[0])?;
        let right = evaluator.evaluate_condition(&args[1])?;
        
        Ok(serde_json::Value::Bool(left && right))
    }
}

#[derive(Debug)]
struct OrFunction;

impl ConditionFunction for OrFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 2 {
            anyhow::bail!("or() requires exactly 2 arguments");
        }
        
        let left = evaluator.evaluate_condition(&args[0])?;
        let right = evaluator.evaluate_condition(&args[1])?;
        
        Ok(serde_json::Value::Bool(left || right))
    }
}

#[derive(Debug)]
struct NotFunction;

impl ConditionFunction for NotFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 1 {
            anyhow::bail!("not() requires exactly 1 argument");
        }
        
        let condition = evaluator.evaluate_condition(&args[0])?;
        Ok(serde_json::Value::Bool(!condition))
    }
}

#[derive(Debug)]
struct MinFunction;

impl ConditionFunction for MinFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 2 {
            anyhow::bail!("min() requires exactly 2 arguments");
        }
        
        let left = evaluator.evaluate_expression(&args[0])?;
        let right = evaluator.evaluate_expression(&args[1])?;
        
        match (&left, &right) {
            (serde_json::Value::Number(l), serde_json::Value::Number(r)) => {
                let l_f64 = l.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let r_f64 = r.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let result = l_f64.min(r_f64);
                Ok(serde_json::Value::Number(
                    serde_json::Number::from_f64(result)
                        .ok_or_else(|| anyhow::anyhow!("Invalid result"))?
                ))
            }
            _ => anyhow::bail!("min() requires numeric arguments"),
        }
    }
}

#[derive(Debug)]
struct MaxFunction;

impl ConditionFunction for MaxFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 2 {
            anyhow::bail!("max() requires exactly 2 arguments");
        }
        
        let left = evaluator.evaluate_expression(&args[0])?;
        let right = evaluator.evaluate_expression(&args[1])?;
        
        match (&left, &right) {
            (serde_json::Value::Number(l), serde_json::Value::Number(r)) => {
                let l_f64 = l.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let r_f64 = r.as_f64().ok_or_else(|| anyhow::anyhow!("Invalid number"))?;
                let result = l_f64.max(r_f64);
                Ok(serde_json::Value::Number(
                    serde_json::Number::from_f64(result)
                        .ok_or_else(|| anyhow::anyhow!("Invalid result"))?
                ))
            }
            _ => anyhow::bail!("max() requires numeric arguments"),
        }
    }
}

#[derive(Debug)]
struct HourFunction;

impl ConditionFunction for HourFunction {
    fn call(&self, args: &[String], _evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 1 {
            anyhow::bail!("hour() requires exactly 1 argument (timestamp)");
        }
        
        // Parse timestamp and extract hour
        let timestamp_str = args[0].trim_matches('"');
        let datetime: DateTime<Utc> = timestamp_str.parse()?;
        let hour = datetime.hour();
        
        Ok(serde_json::Value::Number(serde_json::Number::from(hour)))
    }
}

#[derive(Debug)]
struct DayOfWeekFunction;

impl ConditionFunction for DayOfWeekFunction {
    fn call(&self, args: &[String], _evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 1 {
            anyhow::bail!("day_of_week() requires exactly 1 argument (timestamp)");
        }
        
        // Parse timestamp and extract day of week
        let timestamp_str = args[0].trim_matches('"');
        let datetime: DateTime<Utc> = timestamp_str.parse()?;
        let weekday = datetime.weekday();
        
        // Convert to number (0 = Sunday, 6 = Saturday)
        let day_num = match weekday {
            Weekday::Sun => 0,
            Weekday::Mon => 1,
            Weekday::Tue => 2,
            Weekday::Wed => 3,
            Weekday::Thu => 4,
            Weekday::Fri => 5,
            Weekday::Sat => 6,
        };
        
        Ok(serde_json::Value::Number(serde_json::Number::from(day_num)))
    }
}
</pre>

<h3>Advanced Control Flow Patterns</h3>
<pre>
# advanced-control-flow.tsk
# State machine-based configuration
state_machine_config {
    current_state: env("APP_STATE", "initializing")
    
    # Configuration changes based on application state
    state_based_config: switch(current_state, {
        initializing: {
            log_level: "debug"
            metrics_enabled: false
            external_services: false
            maintenance_mode: true
        }
        
        running: {
            log_level: if(env("ENVIRONMENT") == "production", "info", "debug")
            metrics_enabled: true
            external_services: true
            maintenance_mode: false
            
            # Performance optimizations when running
            performance: {
                thread_pool_size: @optimize("thread_pool", 8)
                connection_pool_size: @optimize("conn_pool", 20)
                cache_size: @optimize("cache_size", 1000)
            }
        }
        
        degraded: {
            log_level: "warn"
            metrics_enabled: true
            external_services: false
            maintenance_mode: false
            
            # Reduced performance settings
            performance: {
                thread_pool_size: 4
                connection_pool_size: 10
                cache_size: 500
            }
        }
        
        shutdown: {
            log_level: "info"
            metrics_enabled: false
            external_services: false
            maintenance_mode: true
            
            # Graceful shutdown configuration
            shutdown: {
                grace_period: parse_duration("30s")
                force_timeout: parse_duration("60s")
                save_state: true
            }
        }
    })
}

# Load-based adaptive configuration
load_config {
    current_cpu: cpu_usage()
    current_memory: memory_usage()
    request_rate: @metrics("requests_per_second", 0)
    
    # Classify system load
    load_level: if(or(current_cpu > 80, current_memory > 85),
        "high",
        if(or(current_cpu > 60, current_memory > 70),
            "medium",
            "low"))
    
    # Adaptive configuration based on load
    adaptive_config: switch(load_level, {
        high: {
            # Aggressive optimization under high load
            cache_strategy: "aggressive"
            compression_enabled: false  # Trade CPU for I/O
            batch_size: 200
            worker_threads: max(cpu_count() - 2, 2)
            
            # Circuit breaker settings
            circuit_breaker: {
                failure_threshold: 3
                timeout: parse_duration("5s")
                half_open_max_calls: 2
            }
            
            # Rate limiting
            rate_limiting: {
                enabled: true
                requests_per_minute: 1000
                burst_size: 50
            }
        }
        
        medium: {
            # Balanced configuration
            cache_strategy: "balanced"
            compression_enabled: true
            batch_size: 100
            worker_threads: cpu_count()
            
            circuit_breaker: {
                failure_threshold: 5
                timeout: parse_duration("10s")
                half_open_max_calls: 5
            }
            
            rate_limiting: {
                enabled: false
            }
        }
        
        low: {
            # Relaxed configuration for low load
            cache_strategy: "lazy"
            compression_enabled: true
            batch_size: 50
            worker_threads: max(cpu_count() / 2, 2)
            
            circuit_breaker: {
                failure_threshold: 10
                timeout: parse_duration("30s")
                half_open_max_calls: 10
            }
            
            rate_limiting: {
                enabled: false
            }
            
            # Background tasks can run during low load
            background_tasks: {
                cleanup_enabled: true
                optimization_enabled: true
                analytics_processing: true
            }
        }
    })
}

# Feature rollout configuration with gradual deployment
feature_rollout {
    user_id: env("USER_ID", "")
    user_tier: env("USER_TIER", "free")
    deployment_group: hash(user_id) % 100
    
    # Gradual feature rollout based on deployment groups
    features: {
        new_ui: {
            enabled: if(user_tier == "premium",
                true,  # All premium users get new UI
                if(user_tier == "pro",
                    deployment_group < 50,  # 50% of pro users
                    deployment_group < 10)) # 10% of free users
        }
        
        advanced_analytics: {
            enabled: if(user_tier == "enterprise",
                true,  # All enterprise users
                if(user_tier == "premium",
                    deployment_group < 25,  # 25% of premium users
                    false)) # Not available for other tiers
        }
        
        beta_api: {
            enabled: if(env("BETA_PARTICIPANT") == "true",
                true,  # Beta participants always get access
                deployment_group < 5) # 5% general rollout
        }
    }
    
    # Configuration specific to enabled features
    feature_config: {
        new_ui: if(features.new_ui.enabled, {
            theme: "modern"
            animations: true
            performance_mode: if(user_tier == "free", "lite", "full")
        }, {
            theme: "classic"
            animations: false
            performance_mode: "lite"
        })
        
        analytics: if(features.advanced_analytics.enabled, {
            real_time: true
            retention_days: if(user_tier == "enterprise", 365, 90)
            custom_dashboards: true
        }, {
            real_time: false
            retention_days: 30
            custom_dashboards: false
        })
    }
}

# Error handling and retry configuration
error_handling {
    error_rate: @metrics("error_rate", 0.0)
    consecutive_errors: @metrics("consecutive_errors", 0)
    
    # Adaptive retry configuration based on error patterns
    retry_config: if(error_rate > 0.1,
        {
            # High error rate - be more conservative
            max_retries: 2
            initial_delay: parse_duration("1s")
            max_delay: parse_duration("10s")
            backoff_multiplier: 3.0
            jitter: true
        },
        if(error_rate > 0.05,
            {
                # Medium error rate - balanced approach
                max_retries: 3
                initial_delay: parse_duration("500ms")
                max_delay: parse_duration("5s")
                backoff_multiplier: 2.0
                jitter: true
            },
            {
                # Low error rate - more aggressive retries
                max_retries: 5
                initial_delay: parse_duration("100ms")
                max_delay: parse_duration("2s")
                backoff_multiplier: 1.5
                jitter: false
            }))
    
    # Circuit breaker configuration
    circuit_breaker: {
        enabled: error_rate > 0.05
        failure_threshold: if(error_rate > 0.2, 3, 
                             if(error_rate > 0.1, 5, 10))
        
        recovery_timeout: if(consecutive_errors > 10,
            parse_duration("60s"),
            if(consecutive_errors > 5,
                parse_duration("30s"),
                parse_duration("10s")))
        
        half_open_max_calls: 3
    }
    
    # Fallback strategies
    fallback_strategies: {
        cache_fallback: error_rate > 0.1
        default_response: error_rate > 0.2
        service_degradation: consecutive_errors > 5
    }
}

// Advanced control flow implementation with state machines
use std::collections::HashMap;
use std::hash::{Hash, Hasher};

#[derive(Debug)]
pub struct StateMachineEvaluator {
    evaluator: ControlFlowEvaluator,
    state_machines: HashMap<String, StateMachine>,
}

impl StateMachineEvaluator {
    pub fn new() -> Self {
        let mut evaluator = ControlFlowEvaluator::new();
        
        // Register state machine functions
        evaluator.register_function("switch", Box::new(SwitchFunction));
        evaluator.register_function("hash", Box::new(HashFunction));
        evaluator.register_function("cpu_usage", Box::new(CpuUsageFunction));
        evaluator.register_function("memory_usage", Box::new(MemoryUsageFunction));
        
        StateMachineEvaluator {
            evaluator,
            state_machines: HashMap::new(),
        }
    }
    
    pub fn register_state_machine(&mut self, name: String, state_machine: StateMachine) {
        self.state_machines.insert(name, state_machine);
    }
    
    pub fn evaluate_state_based_config(&self, config_expr: &str) -> Result<serde_json::Value> {
        self.evaluator.evaluate_expression(config_expr)
    }
    
    pub fn transition_state(&mut self, machine_name: &str, event: &str) -> Result<String> {
        if let Some(machine) = self.state_machines.get_mut(machine_name) {
            machine.handle_event(event)
        } else {
            anyhow::bail!("State machine {} not found", machine_name);
        }
    }
}

#[derive(Debug)]
pub struct StateMachine {
    pub current_state: String,
    pub states: HashMap<String, State>,
    pub transitions: HashMap<(String, String), String>, // (from_state, event) -> to_state
}

#[derive(Debug, Clone)]
pub struct State {
    pub name: String,
    pub config: serde_json::Value,
    pub entry_actions: Vec<String>,
    pub exit_actions: Vec<String>,
}

impl StateMachine {
    pub fn new(initial_state: String) -> Self {
        StateMachine {
            current_state: initial_state,
            states: HashMap::new(),
            transitions: HashMap::new(),
        }
    }
    
    pub fn add_state(&mut self, state: State) {
        self.states.insert(state.name.clone(), state);
    }
    
    pub fn add_transition(&mut self, from_state: String, event: String, to_state: String) {
        self.transitions.insert((from_state, event), to_state);
    }
    
    pub fn handle_event(&mut self, event: &str) -> Result<String> {
        let key = (self.current_state.clone(), event.to_string());
        
        if let Some(next_state) = self.transitions.get(&key) {
            // Execute exit actions for current state
            if let Some(current_state_obj) = self.states.get(&self.current_state) {
                for action in &current_state_obj.exit_actions {
                    self.execute_action(action)?;
                }
            }
            
            // Transition to next state
            let previous_state = self.current_state.clone();
            self.current_state = next_state.clone();
            
            // Execute entry actions for new state
            if let Some(next_state_obj) = self.states.get(&self.current_state) {
                for action in &next_state_obj.entry_actions {
                    self.execute_action(action)?;
                }
            }
            
            Ok(previous_state)
        } else {
            anyhow::bail!("No transition from {} on event {}", self.current_state, event);
        }
    }
    
    fn execute_action(&self, action: &str) -> Result<()> {
        // Execute state machine actions (log, metrics, etc.)
        println!("Executing action: {}", action);
        Ok(())
    }
    
    pub fn get_current_config(&self) -> Option<&serde_json::Value> {
        self.states.get(&self.current_state).map(|state| &state.config)
    }
}

// Additional control flow functions
#[derive(Debug)]
struct SwitchFunction;

impl ConditionFunction for SwitchFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 2 {
            anyhow::bail!("switch() requires exactly 2 arguments: value, cases");
        }
        
        let switch_value = evaluator.evaluate_expression(&args[0])?;
        let cases_expr = &args[1];
        
        // Parse cases object (simplified - would need proper JSON parsing)
        let cases: serde_json::Value = serde_json::from_str(cases_expr)?;
        
        if let serde_json::Value::Object(cases_map) = cases {
            let switch_key = match &switch_value {
                serde_json::Value::String(s) => s.clone(),
                serde_json::Value::Number(n) => n.to_string(),
                serde_json::Value::Bool(b) => b.to_string(),
                _ => return Err(anyhow::anyhow!("Invalid switch value type")),
            };
            
            if let Some(case_value) = cases_map.get(&switch_key) {
                Ok(case_value.clone())
            } else {
                anyhow::bail!("No case found for value: {}", switch_key);
            }
        } else {
            anyhow::bail!("Cases must be an object");
        }
    }
}

#[derive(Debug)]
struct HashFunction;

impl ConditionFunction for HashFunction {
    fn call(&self, args: &[String], evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        if args.len() != 1 {
            anyhow::bail!("hash() requires exactly 1 argument");
        }
        
        let value = evaluator.evaluate_expression(&args[0])?;
        let value_str = match value {
            serde_json::Value::String(s) => s,
            _ => value.to_string(),
        };
        
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        value_str.hash(&mut hasher);
        let hash_result = hasher.finish();
        
        Ok(serde_json::Value::Number(serde_json::Number::from(hash_result)))
    }
}

#[derive(Debug)]
struct CpuUsageFunction;

impl ConditionFunction for CpuUsageFunction {
    fn call(&self, _args: &[String], _evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        // Get current CPU usage (simplified - would use system monitoring)
        let cpu_usage = 45.0; // Mock value
        Ok(serde_json::Value::Number(
            serde_json::Number::from_f64(cpu_usage)
                .ok_or_else(|| anyhow::anyhow!("Invalid CPU usage value"))?
        ))
    }
}

#[derive(Debug)]
struct MemoryUsageFunction;

impl ConditionFunction for MemoryUsageFunction {
    fn call(&self, _args: &[String], _evaluator: &ControlFlowEvaluator) -> Result<serde_json::Value> {
        // Get current memory usage (simplified - would use system monitoring)
        let memory_usage = 62.0; // Mock value
        Ok(serde_json::Value::Number(
            serde_json::Number::from_f64(memory_usage)
                .ok_or_else(|| anyhow::anyhow!("Invalid memory usage value"))?
        ))
    }
}
</pre>

<p>TuskLang's control flow capabilities in Rust provide sophisticated conditional logic, state machine support, adaptive configuration, and intelligent decision-making that integrates seamlessly with Rust's pattern matching and error handling systems.</p>