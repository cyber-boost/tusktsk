<h1>Ecosystem Integration</h1>

<h2>TuskLang Ecosystem Integration in C#</h2>
<p>Integrate TuskLang with the .NET ecosystem, package managers, build systems, IDEs, and deployment platforms for comprehensive development workflows.</p>

<h3>ecosystem.tsk</h3>
<pre>
# .NET Ecosystem Integration Configuration
ecosystem {
    # .NET Platform Configuration
    dotnet {
        version: "8.0"
        framework: "net8.0"
        
        # Runtime configuration
        runtime {
            identifier: env("RUNTIME_ID", "linux-x64")
            framework_dependent: env("FRAMEWORK_DEPENDENT", true)
            
            # Self-contained deployment
            self_contained: {
                enabled: env("SELF_CONTAINED", false)
                single_file: env("SINGLE_FILE", true)
                trim_unused_assemblies: env("TRIM_ASSEMBLIES", true)
                ready_to_run: env("READY_TO_RUN", true)
            }
        }
        
        # Language features
        language {
            version: "12.0"
            nullable_reference_types: "enable"
            implicit_usings: "enable"
            file_scoped_namespaces: true
            global_using_directives: [
                "System",
                "System.Collections.Generic",
                "System.Linq",
                "System.Threading.Tasks"
            ]
        }
    }
    
    # Package Management
    package_management {
        # NuGet configuration
        nuget {
            # Package sources
            sources: [
                {
                    name: "nuget.org"
                    url: "https://api.nuget.org/v3/index.json"
                    protocol_version: 3
                },
                {
                    name: "tusklang-packages"
                    url: "https://nuget.tusklang.org/v3/index.json"
                    api_key: env("TUSKLANG_NUGET_KEY")
                },
                {
                    name: "company-internal"
                    url: env("INTERNAL_NUGET_SOURCE")
                    username: env("INTERNAL_NUGET_USER")
                    password: env("INTERNAL_NUGET_PASS")
                }
            ]
            
            # Global package management
            global_packages_folder: env("NUGET_PACKAGES", "~/.nuget/packages")
            
            # Package restore settings
            restore: {
                lock_file_path: "packages.lock.json"
                use_lock_file: env("USE_PACKAGE_LOCK", true)
                locked_mode: env("LOCKED_MODE", false)
                
                # Dependency validation
                audit_level: "moderate"  # low, moderate, high, critical
                audit_mode: "direct"     # direct, all
            }
            
            # Package security
            security: {
                allow_unsigned_packages: env("ALLOW_UNSIGNED", false)
                trusted_signers: [
                    "Microsoft",
                    "NuGet",
                    "TuskLang"
                ]
                
                # Vulnerability scanning
                vulnerability_scanning: {
                    enabled: env("VULNERABILITY_SCAN", true)
                    fail_on_vulnerability: env("FAIL_ON_VULN", true)
                    severity_threshold: "moderate"
                }
            }
        }
        
        # Package dependencies
        dependencies {
            # Core TuskLang packages
            tusklang: {
                core: "TuskLang.Core@1.0.0"
                extensions: "TuskLang.Extensions@1.0.0"
                aspnetcore: "TuskLang.AspNetCore@1.0.0"
                entityframework: "TuskLang.EntityFramework@1.0.0"
                configuration: "TuskLang.Configuration@1.0.0"
            }
            
            # Microsoft packages
            microsoft: {
                aspnetcore: "Microsoft.AspNetCore.App@8.0.0"
                entityframework: "Microsoft.EntityFrameworkCore@8.0.0"
                extensions_hosting: "Microsoft.Extensions.Hosting@8.0.0"
                extensions_configuration: "Microsoft.Extensions.Configuration@8.0.0"
                extensions_logging: "Microsoft.Extensions.Logging@8.0.0"
                extensions_dependencyinjection: "Microsoft.Extensions.DependencyInjection@8.0.0"
            }
            
            # Third-party integrations
            third_party: {
                # Serialization
                newtonsoft_json: "Newtonsoft.Json@13.0.3"
                system_text_json: "System.Text.Json@8.0.0"
                
                # Logging
                serilog: "Serilog.AspNetCore@8.0.0"
                serilog_sinks_console: "Serilog.Sinks.Console@5.0.0"
                serilog_sinks_file: "Serilog.Sinks.File@5.0.0"
                serilog_sinks_elasticsearch: "Serilog.Sinks.Elasticsearch@9.0.0"
                
                # Testing
                xunit: "xunit@2.4.2"
                xunit_runner: "xunit.runner.visualstudio@2.4.5"
                moq: "Moq@4.20.69"
                fluent_assertions: "FluentAssertions@6.12.0"
                
                # Code quality
                stylecop_analyzers: "StyleCop.Analyzers@1.1.118"
                microsoft_code_analysis_analyzers: "Microsoft.CodeAnalysis.Analyzers@3.3.4"
                
                # Performance
                benchmarkdotnet: "BenchmarkDotNet@0.13.10"
                
                # Documentation
                docfx: "docfx.console@2.70.3"
                
                # Security
                security_code_scan: "SecurityCodeScan.VS2019@5.6.7"
            }
        }
    }
    
    # Build System Integration
    build_systems {
        # MSBuild configuration
        msbuild {
            # Project file settings
            project_settings: {
                target_framework: @ecosystem.dotnet.framework
                output_type: env("OUTPUT_TYPE", "Exe")
                
                # Assembly information
                assembly_title: @project.name
                assembly_description: @project.description
                assembly_version: @project.version
                assembly_file_version: @project.version
                assembly_informational_version: @project.version + "+" + env("BUILD_NUMBER", "local")
                
                # Compilation settings
                lang_version: @ecosystem.dotnet.language.version
                nullable: @ecosystem.dotnet.language.nullable_reference_types
                implicit_usings: @ecosystem.dotnet.language.implicit_usings
                
                # Code analysis
                enable_net_analyzers: true
                enforce_code_style_in_build: true
                treat_warnings_as_errors: env("TREAT_WARNINGS_AS_ERRORS", false)
                warnings_as_errors: ""
                warnings_not_as_errors: ""
                
                # Documentation
                generate_documentation_file: env("GENERATE_DOCS", true)
                no_warn: "1591"  # Missing XML comment warnings
            }
            
            # Build targets
            custom_targets: [
                {
                    name: "ValidateTuskLangFiles"
                    before_targets: ["Build"]
                    commands: [
                        "tusklang validate config/**/*.tsk",
                        "tusklang validate appsettings/**/*.tsk"
                    ]
                },
                {
                    name: "GenerateTuskLangConstants"
                    before_targets: ["CoreCompile"]
                    commands: [
                        "tusklang generate constants --input config/ --output Generated/Constants.cs --namespace $(RootNamespace).Configuration"
                    ]
                },
                {
                    name: "PackageApplication"
                    after_targets: ["Publish"]
                    condition: "$(Configuration) == 'Release'"
                    commands: [
                        "docker build -t $(AssemblyName):$(Version) .",
                        "helm package charts/$(AssemblyName)"
                    ]
                }
            ]
        }
        
        # .NET CLI integration
        dotnet_cli: {
            # Global tools
            global_tools: [
                {
                    name: "tusklang"
                    package: "TuskLang.Cli"
                    version: "1.0.0"
                },
                {
                    name: "dotnet-ef"
                    package: "dotnet-ef"
                    version: "8.0.0"
                },
                {
                    name: "dotnet-outdated"
                    package: "dotnet-outdated-tool"
                    version: "4.6.0"
                },
                {
                    name: "dotnet-format"
                    package: "dotnet-format"
                    version: "5.1.250801"
                },
                {
                    name: "dotnet-reportgenerator-globaltool"
                    package: "dotnet-reportgenerator-globaltool"
                    version: "5.2.0"
                }
            ]
            
            # Project templates
            project_templates: [
                {
                    name: "tusklang-webapi"
                    package: "TuskLang.Templates.WebApi"
                    short_name: "tusklang-api"
                },
                {
                    name: "tusklang-console"
                    package: "TuskLang.Templates.Console"
                    short_name: "tusklang-console"
                },
                {
                    name: "tusklang-library"
                    package: "TuskLang.Templates.Library"
                    short_name: "tusklang-lib"
                }
            ]
        }
    }
    
    # IDE Integration
    ide_integration {
        # Visual Studio
        visual_studio {
            version: "2022"
            
            # Extensions
            extensions: [
                "TuskLang.VisualStudio",
                "SonarLint.VisualStudio.2022",
                "ResharperUltimate",
                "GitExtensions.VisualStudio",
                "SpecFlow.VisualStudio"
            ]
            
            # Project settings
            project_settings: {
                # Debugging
                debug_type: env("DEBUG_TYPE", "portable")
                debug_symbols: true
                
                # Code style
                editor_config: ".editorconfig"
                code_analysis_rule_set: "ruleset.xml"
                
                # IntelliSense
                xml_documentation: true
                include_source_revisions: true
            }
            
            # Solution structure
            solution_structure: {
                # Solution folders
                folders: [
                    "src",
                    "tests", 
                    "tools",
                    "docs",
                    "samples"
                ]
                
                # Project organization
                project_organization: {
                    group_by_solution_folder: true
                    nested_projects: true
                }
            }
        }
        
        # Visual Studio Code
        vscode {
            # Extensions
            extensions: [
                "tusklang.vscode-tusklang",
                "ms-dotnettools.csharp",
                "ms-dotnettools.vscode-dotnet-runtime",
                "formulahendry.dotnet-test-explorer",
                "jongrant.csharpsortusings",
                "k--kato.docomment",
                "patcx.vscode-nuget-gallery"
            ]
            
            # Workspace settings
            workspace_settings: {
                "files.associations": {
                    "*.tsk": "tusklang"
                }
                
                "dotnet.completion.showCompletionItemsFromUnimportedNamespaces": true
                "dotnet.inlayHints.enableInlayHintsForParameters": true
                "dotnet.inlayHints.enableInlayHintsForLiteralParameters": true
                "dotnet.inlayHints.enableInlayHintsForIndexerParameters": true
                "dotnet.inlayHints.enableInlayHintsForObjectCreationParameters": true
                "dotnet.inlayHints.enableInlayHintsForOtherParameters": true
                "dotnet.inlayHints.enableInlayHintsForTypes": true
                "dotnet.inlayHints.enableInlayHintsForImplicitVariableTypes": true
                "dotnet.inlayHints.enableInlayHintsForImplicitObjectCreation": true
                
                "tusklang.validation.enabled": true
                "tusklang.formatting.enabled": true
                "tusklang.completion.enabled": true
                
                "editor.formatOnSave": true
                "editor.codeActionsOnSave": {
                    "source.organizeImports": true,
                    "source.fixAll": true
                }
            }
            
            # Tasks
            tasks: [
                {
                    label: "build"
                    command: "dotnet"
                    type: "process"
                    args: ["build"]
                    group: { kind: "build", isDefault: true }
                    presentation: {
                        echo: true
                        reveal: "silent"
                        focus: false
                        panel: "shared"
                        showReuseMessage: true
                        clear: false
                    }
                    problemMatcher: "$msCompile"
                },
                {
                    label: "test"
                    command: "dotnet"
                    type: "process"
                    args: ["test"]
                    group: "test"
                    presentation: {
                        echo: true
                        reveal: "always"
                        focus: false
                        panel: "shared"
                    }
                },
                {
                    label: "validate-tusklang"
                    command: "tusklang"
                    type: "process"
                    args: ["validate", "config/**/*.tsk"]
                    group: "build"
                }
            ]
            
            # Launch configurations
            launch_configurations: [
                {
                    name: ".NET Core Launch (console)"
                    type: "coreclr"
                    request: "launch"
                    program: "${workspaceFolder}/bin/Debug/net8.0/${workspaceFolderBasename}.dll"
                    args: []
                    cwd: "${workspaceFolder}"
                    console: "internalConsole"
                    stopAtEntry: false
                },
                {
                    name: ".NET Core Launch (web)"
                    type: "coreclr"
                    request: "launch"
                    program: "${workspaceFolder}/bin/Debug/net8.0/${workspaceFolderBasename}.dll"
                    args: []
                    cwd: "${workspaceFolder}"
                    stopAtEntry: false
                    serverReadyAction: {
                        action: "openExternally"
                        pattern: "\\bNow listening on:\\s+(https?://\\S+)"
                    }
                    env: {
                        ASPNETCORE_ENVIRONMENT: "Development"
                    }
                }
            ]
        }
        
        # JetBrains Rider
        rider {
            # Plugins
            plugins: [
                "TuskLang.Rider",
                "IdeaVim",
                "GitToolBox",
                "SonarLint",
                "String Manipulation"
            ]
            
            # Project settings
            project_settings: {
                # Code style
                code_style_scheme: "Microsoft Visual Studio"
                inspection_profile: "Solution Wide Analysis"
                
                # Build and run
                build_configuration: "Debug"
                runtime_framework: @ecosystem.dotnet.framework
                
                # Testing
                test_runner: "MSTest, NUnit, xUnit"
                code_coverage_tool: "dotCover"
            }
        }
    }
    
    # Version Control Integration
    version_control {
        # Git configuration
        git {
            # Repository settings
            repository: {
                default_branch: "main"
                
                # Git hooks
                hooks: {
                    pre_commit: {
                        enabled: true
                        scripts: [
                            "dotnet format --verify-no-changes",
                            "tusklang validate config/**/*.tsk",
                            "dotnet test --no-build --configuration Debug"
                        ]
                    }
                    
                    pre_push: {
                        enabled: true
                        scripts: [
                            "dotnet build --configuration Release",
                            "dotnet test --configuration Release"
                        ]
                    }
                    
                    commit_msg: {
                        enabled: true
                        format: "conventional_commits"
                        scopes: ["feat", "fix", "docs", "style", "refactor", "test", "chore"]
                    }
                }
            }
            
            # Git ignore patterns
            gitignore: [
                # Build results
                "[Dd]ebug/",
                "[Dd]ebugPublic/",
                "[Rr]elease/",
                "[Rr]eleases/",
                "x64/",
                "x86/",
                "[Aa][Rr][Mm]/",
                "[Aa][Rr][Mm]64/",
                "bld/",
                "[Bb]in/",
                "[Oo]bj/",
                "[Ll]og/",
                "[Ll]ogs/",
                
                # Visual Studio
                ".vs/",
                "*.user",
                "*.userosscache",
                "*.sln.docstates",
                
                # TuskLang artifacts
                "*.tsk.cache",
                ".tusk/",
                "tusk-lock.json",
                
                # Package managers
                "**/packages/*",
                "!**/packages/build/",
                "*.nuget.props",
                "*.nuget.targets",
                
                # Others
                "*.log",
                "appsettings.Development.json",
                "appsettings.Local.json"
            ]
            
            # Git attributes
            gitattributes: [
                "* text=auto eol=lf",
                "*.{cmd,[cC][mM][dD]} text eol=crlf",
                "*.{bat,[bB][aA][tT]} text eol=crlf",
                "*.tsk linguist-language=TuskLang text",
                "*.cs text diff=csharp",
                "*.sln text eol=crlf",
                "*.csproj text",
                "*.vbproj text",
                "*.vcxproj text",
                "*.vcproj text",
                "*.dbproj text",
                "*.fsproj text",
                "*.lsproj text",
                "*.wixproj text",
                "*.modelproj text",
                "*.sqlproj text",
                "*.wwaproj text"
            ]
        }
        
        # GitHub integration
        github: {
            # Repository settings
            repository_settings: {
                # Branch protection
                branch_protection: {
                    main: {
                        required_status_checks: [
                            "build",
                            "test",
                            "code-quality"
                        ]
                        require_pull_request_reviews: true
                        required_approving_review_count: 2
                        dismiss_stale_reviews: true
                        require_code_owner_reviews: true
                        enforce_admins: false
                    }
                }
                
                # Issue templates
                issue_templates: [
                    {
                        name: "Bug Report"
                        about: "Create a report to help us improve"
                        labels: ["bug"]
                    },
                    {
                        name: "Feature Request"
                        about: "Suggest an idea for this project"
                        labels: ["enhancement"]
                    }
                ]
                
                # Pull request template
                pull_request_template: {
                    content: """
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] TuskLang configurations validated
"""
                }
            }
        }
    }
    
    # CI/CD Integration
    cicd {
        # GitHub Actions
        github_actions: {
            workflows: [
                {
                    name: "CI"
                    trigger: {
                        push: { branches: ["main", "develop"] }
                        pull_request: { branches: ["main"] }
                    }
                    
                    jobs: [
                        {
                            name: "build-and-test"
                            runs_on: "ubuntu-latest"
                            
                            strategy: {
                                matrix: {
                                    dotnet_version: ["6.0.x", "7.0.x", "8.0.x"]
                                    os: ["ubuntu-latest", "windows-latest", "macos-latest"]
                                }
                            }
                            
                            steps: [
                                "actions/checkout@v4",
                                {
                                    name: "Setup .NET"
                                    uses: "actions/setup-dotnet@v3"
                                    with: { dotnet_version: "${{ matrix.dotnet-version }}" }
                                },
                                {
                                    name: "Install TuskLang CLI"
                                    run: "dotnet tool install -g TuskLang.Cli"
                                },
                                {
                                    name: "Validate TuskLang files"
                                    run: "tusklang validate config/**/*.tsk"
                                },
                                {
                                    name: "Restore dependencies"
                                    run: "dotnet restore"
                                },
                                {
                                    name: "Build"
                                    run: "dotnet build --no-restore --configuration Release"
                                },
                                {
                                    name: "Test"
                                    run: "dotnet test --no-build --configuration Release --verbosity normal --collect:\"XPlat Code Coverage\" --results-directory coverage"
                                },
                                {
                                    name: "Upload coverage to Codecov"
                                    uses: "codecov/codecov-action@v3"
                                    with: {
                                        directory: "coverage"
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    name: "Release"
                    trigger: {
                        push: { tags: ["v*"] }
                    }
                    
                    jobs: [
                        {
                            name: "release"
                            runs_on: "ubuntu-latest"
                            
                            steps: [
                                "actions/checkout@v4",
                                {
                                    name: "Setup .NET"
                                    uses: "actions/setup-dotnet@v3"
                                    with: { dotnet_version: "8.0.x" }
                                },
                                {
                                    name: "Build and pack"
                                    run: "dotnet pack --configuration Release --output nupkgs"
                                },
                                {
                                    name: "Publish to NuGet"
                                    run: "dotnet nuget push nupkgs/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json"
                                },
                                {
                                    name: "Create GitHub Release"
                                    uses: "actions/create-release@v1"
                                    env: { GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}" }
                                    with: {
                                        tag_name: "${{ github.ref }}"
                                        release_name: "Release ${{ github.ref }}"
                                        draft: false
                                        prerelease: false
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        # Azure DevOps
        azure_devops: {
            enabled: env("AZURE_DEVOPS_ENABLED", false)
            
            pipelines: [
                {
                    name: "ci-pipeline"
                    trigger: ["main", "develop"]
                    
                    variables: {
                        buildConfiguration: "Release"
                        dotnetVersion: "8.0.x"
                    }
                    
                    stages: [
                        {
                            name: "Build"
                            jobs: [
                                {
                                    name: "BuildJob"
                                    pool: { vmImage: "ubuntu-latest" }
                                    
                                    steps: [
                                        {
                                            task: "UseDotNet@2"
                                            inputs: {
                                                version: "$(dotnetVersion)"
                                                includePreviewVersions: false
                                            }
                                        },
                                        {
                                            task: "DotNetCoreCLI@2"
                                            displayName: "Install TuskLang CLI"
                                            inputs: {
                                                command: "custom"
                                                custom: "tool"
                                                arguments: "install -g TuskLang.Cli"
                                            }
                                        },
                                        {
                                            script: "tusklang validate config/**/*.tsk"
                                            displayName: "Validate TuskLang files"
                                        },
                                        {
                                            task: "DotNetCoreCLI@2"
                                            displayName: "Restore"
                                            inputs: {
                                                command: "restore"
                                                projects: "**/*.csproj"
                                            }
                                        },
                                        {
                                            task: "DotNetCoreCLI@2"
                                            displayName: "Build"
                                            inputs: {
                                                command: "build"
                                                projects: "**/*.csproj"
                                                arguments: "--configuration $(buildConfiguration) --no-restore"
                                            }
                                        },
                                        {
                                            task: "DotNetCoreCLI@2"
                                            displayName: "Test"
                                            inputs: {
                                                command: "test"
                                                projects: "**/*Tests/*.csproj"
                                                arguments: "--configuration $(buildConfiguration) --no-build --collect:\"XPlat Code Coverage\""
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    }
    
    # Deployment Platforms
    deployment {
        # Docker
        docker: {
            enabled: env("DOCKER_ENABLED", true)
            
            # Dockerfile configuration
            dockerfile: {
                base_image: "mcr.microsoft.com/dotnet/aspnet:8.0"
                build_image: "mcr.microsoft.com/dotnet/sdk:8.0"
                
                # Multi-stage build
                stages: [
                    {
                        name: "build"
                        base: @deployment.docker.dockerfile.build_image
                        workdir: "/src"
                        
                        steps: [
                            "COPY [\"*.csproj\", \"./\"]",
                            "RUN dotnet restore",
                            "COPY . .",
                            "RUN dotnet tool install -g TuskLang.Cli",
                            "RUN tusklang validate config/**/*.tsk",
                            "RUN dotnet publish -c Release -o /app/publish"
                        ]
                    },
                    {
                        name: "final"
                        base: @deployment.docker.dockerfile.base_image
                        workdir: "/app"
                        
                        steps: [
                            "COPY --from=build /app/publish .",
                            "ENTRYPOINT [\"dotnet\", \"YourApp.dll\"]"
                        ]
                    }
                ]
            }
            
            # Docker Compose
            compose: {
                version: "3.8"
                
                services: {
                    app: {
                        build: {
                            context: "."
                            dockerfile: "Dockerfile"
                        }
                        ports: ["8080:80"]
                        environment: {
                            ASPNETCORE_ENVIRONMENT: "Production"
                            ConnectionStrings__DefaultConnection: "${DATABASE_URL}"
                        }
                        depends_on: ["database"]
                    }
                    
                    database: {
                        image: "postgres:15"
                        environment: {
                            POSTGRES_DB: "${DB_NAME}"
                            POSTGRES_USER: "${DB_USER}"
                            POSTGRES_PASSWORD: "${DB_PASSWORD}"
                        }
                        volumes: ["postgres_data:/var/lib/postgresql/data"]
                        ports: ["5432:5432"]
                    }
                }
                
                volumes: {
                    postgres_data: {}
                }
            }
        }
        
        # Kubernetes
        kubernetes: {
            enabled: env("KUBERNETES_ENABLED", false)
            
            # Helm chart
            helm: {
                chart_name: @project.name
                chart_version: @project.version
                
                values: {
                    replicaCount: env("REPLICA_COUNT", 3)
                    
                    image: {
                        repository: @project.docker_image
                        tag: @project.version
                        pullPolicy: "IfNotPresent"
                    }
                    
                    service: {
                        type: "ClusterIP"
                        port: 80
                        targetPort: 8080
                    }
                    
                    ingress: {
                        enabled: env("INGRESS_ENABLED", true)
                        className: "nginx"
                        annotations: {
                            "nginx.ingress.kubernetes.io/rewrite-target": "/"
                        }
                        hosts: [
                            {
                                host: env("APP_HOST", "myapp.example.com")
                                paths: [
                                    {
                                        path: "/"
                                        pathType: "Prefix"
                                    }
                                ]
                            }
                        ]
                    }
                    
                    resources: {
                        limits: {
                            cpu: "500m"
                            memory: "512Mi"
                        }
                        requests: {
                            cpu: "250m"
                            memory: "256Mi"
                        }
                    }
                    
                    # ConfigMap for TuskLang files
                    configMap: {
                        name: @project.name + "-config"
                        data: {
                            "app.tsk": @file("config/app.tsk")
                            "database.tsk": @file("config/database.tsk")
                        }
                    }
                }
            }
        }
        
        # Azure App Service
        azure_app_service: {
            enabled: env("AZURE_ENABLED", false)
            
            configuration: {
                sku: env("AZURE_SKU", "S1")
                runtime_stack: "DOTNETCORE|8.0"
                
                app_settings: {
                    ASPNETCORE_ENVIRONMENT: env("ASPNETCORE_ENVIRONMENT", "Production")
                    WEBSITE_RUN_FROM_PACKAGE: "1"
                    TUSKLANG_CONFIG_PATH: env("TUSKLANG_CONFIG_PATH", "/home/site/wwwroot/config")
                }
                
                connection_strings: {
                    DefaultConnection: {
                        value: env("DATABASE_CONNECTION_STRING")
                        type: "SQLServer"
                    }
                }
            }
        }
    }
    
    # Monitoring and Observability
    observability {
        # Application Performance Monitoring
        apm: {
            # Application Insights
            application_insights: {
                enabled: env("APPLICATION_INSIGHTS_ENABLED", true)
                instrumentation_key: env("APPINSIGHTS_INSTRUMENTATIONKEY")
                connection_string: env("APPLICATIONINSIGHTS_CONNECTION_STRING")
                
                # Telemetry configuration
                telemetry: {
                    sampling_percentage: env("AI_SAMPLING_PERCENTAGE", 100)
                    adaptive_sampling: env("AI_ADAPTIVE_SAMPLING", true)
                    
                    # Custom telemetry
                    track_dependencies: true
                    track_requests: true
                    track_exceptions: true
                    track_traces: true
                    track_events: true
                    track_page_views: false
                }
            }
            
            # OpenTelemetry
            opentelemetry: {
                enabled: env("OTEL_ENABLED", false)
                
                tracing: {
                    service_name: @project.name
                    service_version: @project.version
                    
                    exporters: [
                        {
                            type: "jaeger"
                            endpoint: env("JAEGER_ENDPOINT", "http://localhost:14268/api/traces")
                        },
                        {
                            type: "zipkin"
                            endpoint: env("ZIPKIN_ENDPOINT", "http://localhost:9411/api/v2/spans")
                        }
                    ]
                }
                
                metrics: {
                    enabled: true
                    
                    exporters: [
                        {
                            type: "prometheus"
                            endpoint: "/metrics"
                        }
                    ]
                }
            }
        }
        
        # Health checks
        health_checks: {
            enabled: env("HEALTH_CHECKS_ENABLED", true)
            endpoint: "/health"
            
            checks: [
                {
                    name: "database"
                    type: "DbContext"
                    timeout: "00:00:10"
                },
                {
                    name: "memory"
                    type: "MemoryHealthCheck"
                    threshold: 1024
                },
                {
                    name: "disk_space"
                    type: "DiskStorageHealthCheck"
                    path: "C:\\"
                    minimum_free_space: 1024
                }
            ]
        }
    }
}
</pre>

<h3>C# Ecosystem Integration Implementation</h3>
<pre>
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace TuskLang.Ecosystem
{
    // Ecosystem configuration models
    public class EcosystemConfig
    {
        public DotNetConfig DotNet { get; set; } = new();
        public PackageManagementConfig PackageManagement { get; set; } = new();
        public BuildSystemsConfig BuildSystems { get; set; } = new();
        public IdeIntegrationConfig IdeIntegration { get; set; } = new();
        public VersionControlConfig VersionControl { get; set; } = new();
        public CiCdConfig CiCd { get; set; } = new();
        public DeploymentConfig Deployment { get; set; } = new();
        public ObservabilityConfig Observability { get; set; } = new();
    }

    public class DotNetConfig
    {
        public string Version { get; set; } = "8.0";
        public string Framework { get; set; } = "net8.0";
        public RuntimeConfig Runtime { get; set; } = new();
        public LanguageConfig Language { get; set; } = new();
    }

    public class RuntimeConfig
    {
        public string Identifier { get; set; } = "linux-x64";
        public bool FrameworkDependent { get; set; } = true;
        public SelfContainedConfig SelfContained { get; set; } = new();
    }

    public class SelfContainedConfig
    {
        public bool Enabled { get; set; } = false;
        public bool SingleFile { get; set; } = true;
        public bool TrimUnusedAssemblies { get; set; } = true;
        public bool ReadyToRun { get; set; } = true;
    }

    public class PackageManagementConfig
    {
        public NuGetConfig NuGet { get; set; } = new();
        public DependenciesConfig Dependencies { get; set; } = new();
    }

    // Ecosystem integration service
    public class TuskLangEcosystemService
    {
        private readonly EcosystemConfig _config;
        private readonly ILogger<TuskLangEcosystemService> _logger;

        public TuskLangEcosystemService(EcosystemConfig config, ILogger<TuskLangEcosystemService> logger)
        {
            _config = config;
            _logger = logger;
        }

        public async Task InitializeEcosystemAsync()
        {
            _logger.LogInformation("Initializing TuskLang ecosystem integration");

            try
            {
                // Initialize package management
                await InitializePackageManagementAsync();

                // Setup build system integration
                await SetupBuildSystemAsync();

                // Configure IDE integration
                await ConfigureIdeIntegrationAsync();

                // Setup version control
                await SetupVersionControlAsync();

                // Initialize observability
                await InitializeObservabilityAsync();

                _logger.LogInformation("TuskLang ecosystem integration initialized successfully");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize TuskLang ecosystem integration");
                throw;
            }
        }

        private async Task InitializePackageManagementAsync()
        {
            _logger.LogDebug("Initializing package management");

            // Create NuGet.config
            await CreateNuGetConfigAsync();

            // Install global tools
            await InstallGlobalToolsAsync();

            // Validate package sources
            await ValidatePackageSourcesAsync();
        }

        private async Task CreateNuGetConfigAsync()
        {
            var nugetConfig = new XDocument(
                new XElement("configuration",
                    new XElement("packageSources",
                        _config.PackageManagement.NuGet.Sources.Select(source =>
                            new XElement("add",
                                new XAttribute("key", source.Name),
                                new XAttribute("value", source.Url)
                            )
                        )
                    ),
                    new XElement("packageSourceCredentials",
                        _config.PackageManagement.NuGet.Sources
                            .Where(s => !string.IsNullOrEmpty(s.ApiKey))
                            .Select(source =>
                                new XElement(source.Name,
                                    new XElement("add",
                                        new XAttribute("key", "Username"),
                                        new XAttribute("value", source.Username ?? "api")
                                    ),
                                    new XElement("add",
                                        new XAttribute("key", "ClearTextPassword"),
                                        new XAttribute("value", source.ApiKey)
                                    )
                                )
                            )
                    )
                )
            );

            await File.WriteAllTextAsync("nuget.config", nugetConfig.ToString());
            _logger.LogDebug("Created NuGet.config file");
        }

        private async Task InstallGlobalToolsAsync()
        {
            foreach (var tool in _config.BuildSystems.DotNetCli.GlobalTools)
            {
                try
                {
                    var process = new Process
                    {
                        StartInfo = new ProcessStartInfo
                        {
                            FileName = "dotnet",
                            Arguments = $"tool install -g {tool.Package} --version {tool.Version}",
                            UseShellExecute = false,
                            RedirectStandardOutput = true,
                            RedirectStandardError = true
                        }
                    };

                    process.Start();
                    await process.WaitForExitAsync();

                    if (process.ExitCode == 0)
                    {
                        _logger.LogDebug("Installed global tool: {Tool}", tool.Name);
                    }
                    else
                    {
                        _logger.LogWarning("Tool {Tool} may already be installed", tool.Name);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to install global tool: {Tool}", tool.Name);
                }
            }
        }

        private async Task ValidatePackageSourcesAsync()
        {
            foreach (var source in _config.PackageManagement.NuGet.Sources)
            {
                try
                {
                    using var httpClient = new HttpClient();
                    httpClient.Timeout = TimeSpan.FromSeconds(10);
                    
                    var response = await httpClient.GetAsync(source.Url);
                    if (response.IsSuccessStatusCode)
                    {
                        _logger.LogDebug("Package source {SourceName} is accessible", source.Name);
                    }
                    else
                    {
                        _logger.LogWarning("Package source {SourceName} returned status {StatusCode}", 
                            source.Name, response.StatusCode);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to validate package source: {SourceName}", source.Name);
                }
            }
        }

        private async Task SetupBuildSystemAsync()
        {
            _logger.LogDebug("Setting up build system integration");

            // Create Directory.Build.props
            await CreateDirectoryBuildPropsAsync();

            // Create Directory.Build.targets
            await CreateDirectoryBuildTargetsAsync();

            // Setup EditorConfig
            await CreateEditorConfigAsync();
        }

        private async Task CreateDirectoryBuildPropsAsync()
        {
            var props = new XDocument(
                new XElement("Project",
                    new XElement("PropertyGroup",
                        new XElement("TargetFramework", _config.DotNet.Framework),
                        new XElement("LangVersion", _config.DotNet.Language.Version),
                        new XElement("Nullable", _config.DotNet.Language.NullableReferenceTypes),
                        new XElement("ImplicitUsings", _config.DotNet.Language.ImplicitUsings),
                        new XElement("TreatWarningsAsErrors", _config.BuildSystems.MSBuild.ProjectSettings.TreatWarningsAsErrors),
                        new XElement("EnableNETAnalyzers", "true"),
                        new XElement("EnforceCodeStyleInBuild", "true")
                    ),
                    new XElement("ItemGroup",
                        _config.DotNet.Language.GlobalUsingDirectives?.Select(usingDirective =>
                            new XElement("Using",
                                new XAttribute("Include", usingDirective)
                            )
                        )
                    )
                )
            );

            await File.WriteAllTextAsync("Directory.Build.props", props.ToString());
            _logger.LogDebug("Created Directory.Build.props");
        }

        private async Task CreateDirectoryBuildTargetsAsync()
        {
            var targets = new XDocument(
                new XElement("Project",
                    _config.BuildSystems.MSBuild.CustomTargets?.Select(target =>
                        new XElement("Target",
                            new XAttribute("Name", target.Name),
                            new XAttribute("BeforeTargets", target.BeforeTargets ?? ""),
                            new XAttribute("AfterTargets", target.AfterTargets ?? ""),
                            target.Commands?.Select(command =>
                                new XElement("Exec",
                                    new XAttribute("Command", command)
                                )
                            )
                        )
                    )
                )
            );

            await File.WriteAllTextAsync("Directory.Build.targets", targets.ToString());
            _logger.LogDebug("Created Directory.Build.targets");
        }

        private async Task CreateEditorConfigAsync()
        {
            var editorConfig = @"
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.cs]
indent_style = space
indent_size = 4

[*.tsk]
indent_style = space
indent_size = 4

[*.{yml,yaml}]
indent_style = space
indent_size = 2

[*.{json,js,ts}]
indent_style = space
indent_size = 2

# .NET Code style rules
[*.cs]
dotnet_sort_system_directives_first = true
dotnet_separate_import_directive_groups = false

# C# formatting rules
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
csharp_new_line_before_catch = true
csharp_new_line_before_finally = true
csharp_indent_case_contents = true
csharp_indent_switch_labels = true
";

            await File.WriteAllTextAsync(".editorconfig", editorConfig);
            _logger.LogDebug("Created .editorconfig");
        }

        private async Task ConfigureIdeIntegrationAsync()
        {
            _logger.LogDebug("Configuring IDE integration");

            // Create VS Code settings
            await CreateVSCodeSettingsAsync();

            // Create launch configurations
            await CreateLaunchConfigurationsAsync();

            // Create tasks
            await CreateTasksAsync();
        }

        private async Task CreateVSCodeSettingsAsync()
        {
            Directory.CreateDirectory(".vscode");

            var settings = _config.IdeIntegration.VSCode.WorkspaceSettings;
            var settingsJson = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });

            await File.WriteAllTextAsync(".vscode/settings.json", settingsJson);
            _logger.LogDebug("Created VS Code settings");
        }

        private async Task CreateLaunchConfigurationsAsync()
        {
            var launch = new
            {
                version = "0.2.0",
                configurations = _config.IdeIntegration.VSCode.LaunchConfigurations
            };

            var launchJson = JsonSerializer.Serialize(launch, new JsonSerializerOptions { WriteIndented = true });
            await File.WriteAllTextAsync(".vscode/launch.json", launchJson);
            _logger.LogDebug("Created VS Code launch configurations");
        }

        private async Task CreateTasksAsync()
        {
            var tasks = new
            {
                version = "2.0.0",
                tasks = _config.IdeIntegration.VSCode.Tasks
            };

            var tasksJson = JsonSerializer.Serialize(tasks, new JsonSerializerOptions { WriteIndented = true });
            await File.WriteAllTextAsync(".vscode/tasks.json", tasksJson);
            _logger.LogDebug("Created VS Code tasks");
        }

        private async Task SetupVersionControlAsync()
        {
            _logger.LogDebug("Setting up version control integration");

            // Create .gitignore
            await CreateGitIgnoreAsync();

            // Create .gitattributes
            await CreateGitAttributesAsync();

            // Setup Git hooks
            await SetupGitHooksAsync();
        }

        private async Task CreateGitIgnoreAsync()
        {
            var gitignoreContent = string.Join(Environment.NewLine, _config.VersionControl.Git.GitIgnore);
            await File.WriteAllTextAsync(".gitignore", gitignoreContent);
            _logger.LogDebug("Created .gitignore");
        }

        private async Task CreateGitAttributesAsync()
        {
            var gitattributesContent = string.Join(Environment.NewLine, _config.VersionControl.Git.GitAttributes);
            await File.WriteAllTextAsync(".gitattributes", gitattributesContent);
            _logger.LogDebug("Created .gitattributes");
        }

        private async Task SetupGitHooksAsync()
        {
            Directory.CreateDirectory(".git/hooks");

            if (_config.VersionControl.Git.Repository.Hooks.PreCommit.Enabled)
            {
                var preCommitHook = $@"#!/bin/sh
# TuskLang pre-commit hook

echo ""Running pre-commit checks...""

{string.Join(Environment.NewLine, _config.VersionControl.Git.Repository.Hooks.PreCommit.Scripts)}

echo ""Pre-commit checks completed successfully""
";

                await File.WriteAllTextAsync(".git/hooks/pre-commit", preCommitHook);
                
                // Make executable on Unix systems
                if (Environment.OSVersion.Platform == PlatformID.Unix)
                {
                    Process.Start("chmod", "+x .git/hooks/pre-commit");
                }
                
                _logger.LogDebug("Created pre-commit Git hook");
            }
        }

        private async Task InitializeObservabilityAsync()
        {
            _logger.LogDebug("Initializing observability integration");

            // Configure Application Insights if enabled
            if (_config.Observability.Apm.ApplicationInsights.Enabled)
            {
                await ConfigureApplicationInsightsAsync();
            }

            // Configure OpenTelemetry if enabled
            if (_config.Observability.Apm.OpenTelemetry.Enabled)
            {
                await ConfigureOpenTelemetryAsync();
            }

            // Setup health checks
            if (_config.Observability.HealthChecks.Enabled)
            {
                await ConfigureHealthChecksAsync();
            }
        }

        private async Task ConfigureApplicationInsightsAsync()
        {
            _logger.LogDebug("Configuring Application Insights");
            
            // Application Insights configuration would be done through
            // dependency injection and configuration in Startup/Program.cs
            // This is a placeholder for the actual implementation
            
            await Task.CompletedTask;
        }

        private async Task ConfigureOpenTelemetryAsync()
        {
            _logger.LogDebug("Configuring OpenTelemetry");
            
            // OpenTelemetry configuration would be done through
            // dependency injection and configuration in Startup/Program.cs
            
            await Task.CompletedTask;
        }

        private async Task ConfigureHealthChecksAsync()
        {
            _logger.LogDebug("Configuring health checks");
            
            // Health checks configuration would be done through
            // dependency injection in Startup/Program.cs
            
            await Task.CompletedTask;
        }

        public async Task<EcosystemStatus> GetEcosystemStatusAsync()
        {
            var status = new EcosystemStatus();

            try
            {
                // Check .NET version
                status.DotNetVersion = await GetDotNetVersionAsync();
                status.IsDotNetInstalled = !string.IsNullOrEmpty(status.DotNetVersion);

                // Check global tools
                status.GlobalTools = await GetInstalledGlobalToolsAsync();

                // Check package sources
                status.PackageSources = await GetPackageSourceStatusAsync();

                // Check Git status
                status.GitStatus = await GetGitStatusAsync();

                status.IsHealthy = status.IsDotNetInstalled && 
                                 status.GlobalTools.Any(t => t.Name == "tusklang") &&
                                 status.PackageSources.All(s => s.IsAccessible);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get ecosystem status");
                status.IsHealthy = false;
                status.ErrorMessage = ex.Message;
            }

            return status;
        }

        private async Task<string> GetDotNetVersionAsync()
        {
            try
            {
                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = "dotnet",
                        Arguments = "--version",
                        UseShellExecute = false,
                        RedirectStandardOutput = true
                    }
                };

                process.Start();
                var output = await process.StandardOutput.ReadToEndAsync();
                await process.WaitForExitAsync();

                return process.ExitCode == 0 ? output.Trim() : "";
            }
            catch
            {
                return "";
            }
        }

        private async Task<List<GlobalToolStatus>> GetInstalledGlobalToolsAsync()
        {
            var tools = new List<GlobalToolStatus>();

            foreach (var tool in _config.BuildSystems.DotNetCli.GlobalTools)
            {
                var isInstalled = await CheckGlobalToolInstalledAsync(tool.Name);
                tools.Add(new GlobalToolStatus
                {
                    Name = tool.Name,
                    Package = tool.Package,
                    ExpectedVersion = tool.Version,
                    IsInstalled = isInstalled
                });
            }

            return tools;
        }

        private async Task<bool> CheckGlobalToolInstalledAsync(string toolName)
        {
            try
            {
                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = toolName,
                        Arguments = "--version",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true
                    }
                };

                process.Start();
                await process.WaitForExitAsync();

                return process.ExitCode == 0;
            }
            catch
            {
                return false;
            }
        }

        private async Task<List<PackageSourceStatus>> GetPackageSourceStatusAsync()
        {
            var sources = new List<PackageSourceStatus>();

            foreach (var source in _config.PackageManagement.NuGet.Sources)
            {
                var isAccessible = await CheckPackageSourceAccessibleAsync(source.Url);
                sources.Add(new PackageSourceStatus
                {
                    Name = source.Name,
                    Url = source.Url,
                    IsAccessible = isAccessible
                });
            }

            return sources;
        }

        private async Task<bool> CheckPackageSourceAccessibleAsync(string url)
        {
            try
            {
                using var httpClient = new HttpClient();
                httpClient.Timeout = TimeSpan.FromSeconds(5);
                
                var response = await httpClient.GetAsync(url);
                return response.IsSuccessStatusCode;
            }
            catch
            {
                return false;
            }
        }

        private async Task<GitStatus> GetGitStatusAsync()
        {
            var gitStatus = new GitStatus();

            try
            {
                // Check if git repository
                gitStatus.IsGitRepository = Directory.Exists(".git");

                if (gitStatus.IsGitRepository)
                {
                    // Get current branch
                    gitStatus.CurrentBranch = await GetGitCurrentBranchAsync();

                    // Check if there are uncommitted changes
                    gitStatus.HasUncommittedChanges = await CheckGitUncommittedChangesAsync();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get Git status");
            }

            return gitStatus;
        }

        private async Task<string> GetGitCurrentBranchAsync()
        {
            try
            {
                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = "git",
                        Arguments = "rev-parse --abbrev-ref HEAD",
                        UseShellExecute = false,
                        RedirectStandardOutput = true
                    }
                };

                process.Start();
                var output = await process.StandardOutput.ReadToEndAsync();
                await process.WaitForExitAsync();

                return process.ExitCode == 0 ? output.Trim() : "";
            }
            catch
            {
                return "";
            }
        }

        private async Task<bool> CheckGitUncommittedChangesAsync()
        {
            try
            {
                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = "git",
                        Arguments = "status --porcelain",
                        UseShellExecute = false,
                        RedirectStandardOutput = true
                    }
                };

                process.Start();
                var output = await process.StandardOutput.ReadToEndAsync();
                await process.WaitForExitAsync();

                return process.ExitCode == 0 && !string.IsNullOrWhiteSpace(output);
            }
            catch
            {
                return false;
            }
        }
    }

    // Status classes
    public class EcosystemStatus
    {
        public bool IsHealthy { get; set; }
        public string ErrorMessage { get; set; } = "";
        public string DotNetVersion { get; set; } = "";
        public bool IsDotNetInstalled { get; set; }
        public List<GlobalToolStatus> GlobalTools { get; set; } = new();
        public List<PackageSourceStatus> PackageSources { get; set; } = new();
        public GitStatus GitStatus { get; set; } = new();
    }

    public class GlobalToolStatus
    {
        public string Name { get; set; } = "";
        public string Package { get; set; } = "";
        public string ExpectedVersion { get; set; } = "";
        public bool IsInstalled { get; set; }
    }

    public class PackageSourceStatus
    {
        public string Name { get; set; } = "";
        public string Url { get; set; } = "";
        public bool IsAccessible { get; set; }
    }

    public class GitStatus
    {
        public bool IsGitRepository { get; set; }
        public string CurrentBranch { get; set; } = "";
        public bool HasUncommittedChanges { get; set; }
    }

    // Extension methods for dependency injection
    public static class EcosystemServiceCollectionExtensions
    {
        public static IServiceCollection AddTuskLangEcosystem(this IServiceCollection services, EcosystemConfig config)
        {
            services.AddSingleton(config);
            services.AddSingleton<TuskLangEcosystemService>();
            return services;
        }
    }

    // Configuration helper classes (partial definitions)
    public class LanguageConfig
    {
        public string Version { get; set; } = "12.0";
        public string NullableReferenceTypes { get; set; } = "enable";
        public string ImplicitUsings { get; set; } = "enable";
        public bool FileScopedNamespaces { get; set; } = true;
        public List<string> GlobalUsingDirectives { get; set; } = new();
    }

    public class NuGetConfig
    {
        public List<PackageSource> Sources { get; set; } = new();
    }

    public class PackageSource
    {
        public string Name { get; set; } = "";
        public string Url { get; set; } = "";
        public string ApiKey { get; set; } = "";
        public string Username { get; set; } = "";
        public string Password { get; set; } = "";
    }

    public class DependenciesConfig
    {
        // Dependency configuration properties
    }

    public class BuildSystemsConfig
    {
        public MSBuildConfig MSBuild { get; set; } = new();
        public DotNetCliConfig DotNetCli { get; set; } = new();
    }

    public class MSBuildConfig
    {
        public ProjectSettingsConfig ProjectSettings { get; set; } = new();
        public List<CustomTarget> CustomTargets { get; set; } = new();
    }

    public class ProjectSettingsConfig
    {
        public bool TreatWarningsAsErrors { get; set; } = false;
    }

    public class CustomTarget
    {
        public string Name { get; set; } = "";
        public string BeforeTargets { get; set; } = "";
        public string AfterTargets { get; set; } = "";
        public List<string> Commands { get; set; } = new();
    }

    public class DotNetCliConfig
    {
        public List<GlobalTool> GlobalTools { get; set; } = new();
    }

    public class GlobalTool
    {
        public string Name { get; set; } = "";
        public string Package { get; set; } = "";
        public string Version { get; set; } = "";
    }

    public class IdeIntegrationConfig
    {
        public VSCodeConfig VSCode { get; set; } = new();
    }

    public class VSCodeConfig
    {
        public Dictionary<string, object> WorkspaceSettings { get; set; } = new();
        public List<object> LaunchConfigurations { get; set; } = new();
        public List<object> Tasks { get; set; } = new();
    }

    public class VersionControlConfig
    {
        public GitConfig Git { get; set; } = new();
    }

    public class GitConfig
    {
        public RepositoryConfig Repository { get; set; } = new();
        public List<string> GitIgnore { get; set; } = new();
        public List<string> GitAttributes { get; set; } = new();
    }

    public class RepositoryConfig
    {
        public HooksConfig Hooks { get; set; } = new();
    }

    public class HooksConfig
    {
        public HookConfig PreCommit { get; set; } = new();
    }

    public class HookConfig
    {
        public bool Enabled { get; set; } = false;
        public List<string> Scripts { get; set; } = new();
    }

    public class CiCdConfig
    {
        // CI/CD configuration properties
    }

    public class DeploymentConfig
    {
        // Deployment configuration properties
    }

    public class ObservabilityConfig
    {
        public ApmConfig Apm { get; set; } = new();
        public HealthChecksConfig HealthChecks { get; set; } = new();
    }

    public class ApmConfig
    {
        public ApplicationInsightsConfig ApplicationInsights { get; set; } = new();
        public OpenTelemetryConfig OpenTelemetry { get; set; } = new();
    }

    public class ApplicationInsightsConfig
    {
        public bool Enabled { get; set; } = false;
    }

    public class OpenTelemetryConfig
    {
        public bool Enabled { get; set; } = false;
    }

    public class HealthChecksConfig
    {
        public bool Enabled { get; set; } = false;
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Threading.Tasks;
using TuskLang.Ecosystem;

class Program
{
    static async Task Main(string[] args)
    {
        Console.WriteLine("=== TuskLang Ecosystem Integration Demo ===");

        // 1. Setup ecosystem configuration
        var ecosystemConfig = CreateEcosystemConfig();

        // 2. Build service container
        var services = new ServiceCollection();
        services.AddLogging(builder => builder.AddConsole());
        services.AddTuskLangEcosystem(ecosystemConfig);
        
        var serviceProvider = services.BuildServiceProvider();

        // 3. Initialize ecosystem
        var ecosystemService = serviceProvider.GetRequiredService<TuskLangEcosystemService>();
        
        Console.WriteLine("\n1. Initializing Ecosystem Integration:");
        await ecosystemService.InitializeEcosystemAsync();

        // 4. Check ecosystem status
        Console.WriteLine("\n2. Ecosystem Status Check:");
        await CheckEcosystemStatusAsync(ecosystemService);

        // 5. Demonstrate integration features
        Console.WriteLine("\n3. Integration Features:");
        await DemonstrateIntegrationFeaturesAsync();

        Console.WriteLine("\n=== Demo Complete ===");
    }

    static EcosystemConfig CreateEcosystemConfig()
    {
        return new EcosystemConfig
        {
            DotNet = new DotNetConfig
            {
                Version = "8.0",
                Framework = "net8.0",
                Language = new LanguageConfig
                {
                    Version = "12.0",
                    NullableReferenceTypes = "enable",
                    ImplicitUsings = "enable",
                    GlobalUsingDirectives = new List<string>
                    {
                        "System",
                        "System.Collections.Generic",
                        "System.Linq",
                        "System.Threading.Tasks"
                    }
                }
            },
            PackageManagement = new PackageManagementConfig
            {
                NuGet = new NuGetConfig
                {
                    Sources = new List<PackageSource>
                    {
                        new PackageSource
                        {
                            Name = "nuget.org",
                            Url = "https://api.nuget.org/v3/index.json"
                        },
                        new PackageSource
                        {
                            Name = "tusklang-packages",
                            Url = "https://nuget.tusklang.org/v3/index.json"
                        }
                    }
                }
            },
            BuildSystems = new BuildSystemsConfig
            {
                DotNetCli = new DotNetCliConfig
                {
                    GlobalTools = new List<GlobalTool>
                    {
                        new GlobalTool { Name = "tusklang", Package = "TuskLang.Cli", Version = "1.0.0" },
                        new GlobalTool { Name = "dotnet-ef", Package = "dotnet-ef", Version = "8.0.0" },
                        new GlobalTool { Name = "dotnet-format", Package = "dotnet-format", Version = "5.1.250801" }
                    }
                }
            },
            IdeIntegration = new IdeIntegrationConfig
            {
                VSCode = new VSCodeConfig
                {
                    WorkspaceSettings = new Dictionary<string, object>
                    {
                        ["files.associations"] = new Dictionary<string, string> { ["*.tsk"] = "tusklang" },
                        ["tusklang.validation.enabled"] = true,
                        ["tusklang.formatting.enabled"] = true,
                        ["editor.formatOnSave"] = true
                    }
                }
            },
            VersionControl = new VersionControlConfig
            {
                Git = new GitConfig
                {
                    GitIgnore = new List<string>
                    {
                        "[Dd]ebug/",
                        "[Rr]elease/",
                        "[Bb]in/",
                        "[Oo]bj/",
                        "*.user",
                        "*.tsk.cache",
                        ".tusk/",
                        ".vs/"
                    },
                    Repository = new RepositoryConfig
                    {
                        Hooks = new HooksConfig
                        {
                            PreCommit = new HookConfig
                            {
                                Enabled = true,
                                Scripts = new List<string>
                                {
                                    "dotnet format --verify-no-changes",
                                    "tusklang validate config/**/*.tsk"
                                }
                            }
                        }
                    }
                }
            },
            Observability = new ObservabilityConfig
            {
                HealthChecks = new HealthChecksConfig { Enabled = true }
            }
        };
    }

    static async Task CheckEcosystemStatusAsync(TuskLangEcosystemService ecosystemService)
    {
        var status = await ecosystemService.GetEcosystemStatusAsync();

        Console.WriteLine($"  Overall Health: {(status.IsHealthy ? " Healthy" : " Unhealthy")}");
        Console.WriteLine($"  .NET Version: {status.DotNetVersion}");
        Console.WriteLine($"  .NET Installed: {(status.IsDotNetInstalled ? "" : "")}");

        Console.WriteLine("  Global Tools:");
        foreach (var tool in status.GlobalTools)
        {
            Console.WriteLine($"    {tool.Name}: {(tool.IsInstalled ? "" : "")} (Expected: {tool.ExpectedVersion})");
        }

        Console.WriteLine("  Package Sources:");
        foreach (var source in status.PackageSources)
        {
            Console.WriteLine($"    {source.Name}: {(source.IsAccessible ? "" : "")} ({source.Url})");
        }

        Console.WriteLine("  Git Status:");
        Console.WriteLine($"    Repository: {(status.GitStatus.IsGitRepository ? "" : "")}");
        if (status.GitStatus.IsGitRepository)
        {
            Console.WriteLine($"    Current Branch: {status.GitStatus.CurrentBranch}");
            Console.WriteLine($"    Uncommitted Changes: {(status.GitStatus.HasUncommittedChanges ? "Yes" : "No")}");
        }

        if (!status.IsHealthy)
        {
            Console.WriteLine($"  Error: {status.ErrorMessage}");
        }
    }

    static async Task DemonstrateIntegrationFeaturesAsync()
    {
        Console.WriteLine("  Generated Files:");

        // Check for generated ecosystem files
        var files = new[]
        {
            "nuget.config",
            "Directory.Build.props",
            "Directory.Build.targets",
            ".editorconfig",
            ".vscode/settings.json",
            ".vscode/tasks.json",
            ".vscode/launch.json",
            ".gitignore",
            ".gitattributes"
        };

        foreach (var file in files)
        {
            var exists = File.Exists(file) || Directory.Exists(Path.GetDirectoryName(file));
            Console.WriteLine($"    {file}: {(exists ? "" : "")}");
        }

        Console.WriteLine("\n  IDE Integration:");
        Console.WriteLine("     VS Code settings configured");
        Console.WriteLine("     Tasks and launch configurations created");
        Console.WriteLine("     Extension recommendations specified");

        Console.WriteLine("\n  Build System:");
        Console.WriteLine("     MSBuild properties configured");
        Console.WriteLine("     Custom build targets defined");
        Console.WriteLine("     Code analysis rules enabled");

        Console.WriteLine("\n  Version Control:");
        Console.WriteLine("     Git ignore patterns configured");
        Console.WriteLine("     Git attributes for TuskLang files");
        Console.WriteLine("     Pre-commit hooks ready");

        Console.WriteLine("\n  Package Management:");
        Console.WriteLine("     NuGet sources configured");
        Console.WriteLine("     Global tools installation");
        Console.WriteLine("     Security and vulnerability scanning");

        await Task.CompletedTask;
    }
}
</pre>

<p>TuskLang ecosystem integration in C# provides comprehensive tooling integration with .NET, Visual Studio, VS Code, package management, build systems, version control, CI/CD, and deployment platforms for a complete development experience.</p>