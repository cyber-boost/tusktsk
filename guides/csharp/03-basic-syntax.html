<h1>Basic Syntax</h1>

<h2>TuskLang Basic Syntax in C#</h2>
<p>Learn the fundamental syntax elements of TuskLang and how to parse and work with them in C# applications.</p>

<h3>syntax.tsk</h3>
<pre>
# TuskLang Basic Syntax Examples

# 1. Comments
# Single-line comment
/* Multi-line comment
   can span multiple lines */

# 2. Key-Value Pairs (both syntaxes supported)
name: "TuskLang"
version = "1.0.0"
description: "A modern configuration language"

# 3. Numbers
port: 8080
timeout = 30.5
count: -10
scientific: 1.23e-4
binary: 0b1010
hex: 0xFF
octal: 0o755

# 4. Booleans
enabled: true
disabled: false
debug = true

# 5. Strings
single_quoted: 'Hello World'
double_quoted: "Hello World"
multiline: """
This is a multiline string
that can span multiple lines
and preserves formatting
"""

# String interpolation
greeting: "Hello, #{@user.name}!"
path: "#{@app.root}/data/#{@file.name}"

# 6. Arrays
numbers: [1, 2, 3, 4, 5]
strings: ["apple", "banana", "cherry"]
mixed: [1, "two", true, null]

# Multiline arrays
technologies: [
    "C#",
    "JavaScript", 
    "Python",
    "Go"
]

# 7. Objects (nested structures)
database {
    host: "localhost"
    port: 5432
    credentials {
        username: "admin"
        password: "secret"
    }
    
    # Alternative object syntax with colons
    settings: {
        timeout: 30,
        retries: 3,
        pool_size: 10
    }
}

# 8. Null values
empty_value: null
optional_setting: null

# 9. Environment variable references
api_key: env("API_KEY")
database_url: env("DATABASE_URL", "postgresql://localhost/myapp")
debug_mode: env("DEBUG", false)

# 10. Variable references and paths
app_name: "MyApp"
log_file: "#{@app_name}.log"
config_path: "config/#{@app_name.toLowerCase()}.json"

# 11. Conditional expressions
cache_enabled: @env.NODE_ENV == "production"
ssl_config: @if(@cache_enabled, {
    certificate: "/path/to/cert.pem"
    key: "/path/to/key.pem"
})

# 12. Mathematical expressions
memory_limit: @system.total_memory * 0.8
cpu_threads: @system.cpu_count / 2
calculation: @(10 + 5) * 2

# 13. String operations
full_name: @user.first_name + " " + @user.last_name
upper_name: @app_name.toUpperCase()
slug: @title.toLowerCase().replace(" ", "-")

# 14. Array operations
first_item: @technologies[0]
last_item: @technologies[-1]
subset: @technologies[1:3]

# 15. Object property access
db_host: @database.host
username: @database.credentials.username

# 16. Function calls
current_time: @now()
uuid: @uuid()
hash: @sha256("password123")

# 17. Conditional logic
environment: env("NODE_ENV", "development")

development_config: @if(@environment == "development", {
    log_level: "debug"
    hot_reload: true
})

production_config: @if(@environment == "production", {
    log_level: "warn"
    optimize: true
})

# 18. Switch/match expressions
server_config: @match(@environment, {
    "development": { port: 3000, debug: true },
    "staging": { port: 4000, debug: false },
    "production": { port: 80, debug: false },
    default: { port: 8080, debug: false }
})

# 19. Loops and iterations
ports: @range(3000, 3010)
replicated_services: @repeat({
    name: "service-#{@index}"
    port: @(3000 + @index)
}, 3)

# 20. Include and imports
base_config: @file("./base.tsk")
secrets: @file("./secrets.tsk")

# 21. Advanced syntax features
computed_property: @{
    let total = @items.length;
    return total > 0 ? total : 1;
}

template_string: @template(`
Server: #{host}:#{port}
Environment: #{env}
Debug: #{debug ? 'enabled' : 'disabled'}
`)

# 22. Type annotations (optional)
name: "TuskLang" :: string
port: 8080 :: number
enabled: true :: boolean
items: [1, 2, 3] :: number[]

# 23. Constraints and validation
email: "user@example.com" @validate.email
password: "secret123" @validate.length(8, 100)
port: 8080 @validate.range(1024, 65535)

# 24. Metadata and annotations
@deprecated
old_setting: "legacy value"

@description("Database connection settings")
@version("2.0")
database_v2 {
    @required
    connection_string: env("DB_CONNECTION")
    
    @default(30)
    timeout: env("DB_TIMEOUT", 30)
}

# 25. Complex nested structures
application {
    metadata {
        name: @app_name
        version: @app.version
        created: @now()
        
        authors: [
            {
                name: "John Doe"
                email: "john@example.com"
                role: "lead"
            },
            {
                name: "Jane Smith" 
                email: "jane@example.com"
                role: "developer"
            }
        ]
    }
    
    services {
        web {
            enabled: true
            instances: @if(@environment == "production", 3, 1)
            
            configuration {
                host: env("WEB_HOST", "0.0.0.0")
                port: env("WEB_PORT", 8080)
                
                features {
                    rate_limiting: @environment == "production"
                    cors: @environment != "production"
                    compression: true
                }
            }
        }
        
        api {
            enabled: @app.services.web.enabled
            prefix: "/api/v1"
            
            endpoints: [
                { path: "/health", method: "GET", auth: false },
                { path: "/users", method: "GET", auth: true },
                { path: "/users", method: "POST", auth: true }
            ]
        }
    }
}
</pre>

<h3>C# Basic Syntax Implementation</h3>
<pre>
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace TuskLang.Syntax
{
    // Token types for lexical analysis
    public enum TokenType
    {
        // Literals
        String,
        Number,
        Boolean,
        Null,
        
        // Identifiers and keywords
        Identifier,
        EnvironmentVariable,
        Reference,
        
        // Operators
        Colon,
        Equals,
        Plus,
        Minus,
        Multiply,
        Divide,
        
        // Delimiters
        LeftBrace,
        RightBrace,
        LeftBracket,
        RightBracket,
        LeftParen,
        RightParen,
        Comma,
        
        // Special
        Comment,
        Newline,
        EOF,
        
        // Functions and expressions
        Function,
        ConditionalExpression,
        MatchExpression
    }

    // Token representation
    public class Token
    {
        public TokenType Type { get; set; }
        public string Value { get; set; } = "";
        public int Line { get; set; }
        public int Column { get; set; }
        
        public override string ToString() => $"{Type}: {Value} ({Line}:{Column})";
    }

    // Lexical analyzer for TuskLang
    public class TuskLangLexer
    {
        private readonly string _input;
        private int _position;
        private int _line = 1;
        private int _column = 1;

        public TuskLangLexer(string input)
        {
            _input = input ?? throw new ArgumentNullException(nameof(input));
        }

        public List<Token> Tokenize()
        {
            var tokens = new List<Token>();
            
            while (_position < _input.Length)
            {
                var token = NextToken();
                if (token.Type != TokenType.Comment) // Skip comments
                {
                    tokens.Add(token);
                }
            }
            
            tokens.Add(new Token { Type = TokenType.EOF, Line = _line, Column = _column });
            return tokens;
        }

        private Token NextToken()
        {
            SkipWhitespace();
            
            if (_position >= _input.Length)
            {
                return new Token { Type = TokenType.EOF, Line = _line, Column = _column };
            }

            var startLine = _line;
            var startColumn = _column;
            var c = _input[_position];

            // Single character tokens
            switch (c)
            {
                case ':':
                    Advance();
                    return new Token { Type = TokenType.Colon, Value = ":", Line = startLine, Column = startColumn };
                case '=':
                    Advance();
                    return new Token { Type = TokenType.Equals, Value = "=", Line = startLine, Column = startColumn };
                case '+':
                    Advance();
                    return new Token { Type = TokenType.Plus, Value = "+", Line = startLine, Column = startColumn };
                case '-':
                    // Check if it's a negative number or minus operator
                    if (char.IsDigit(Peek(1)))
                    {
                        return ReadNumber();
                    }
                    Advance();
                    return new Token { Type = TokenType.Minus, Value = "-", Line = startLine, Column = startColumn };
                case '*':
                    Advance();
                    return new Token { Type = TokenType.Multiply, Value = "*", Line = startLine, Column = startColumn };
                case '/':
                    // Check for comments
                    if (Peek(1) == '*')
                    {
                        return ReadMultiLineComment();
                    }
                    Advance();
                    return new Token { Type = TokenType.Divide, Value = "/", Line = startLine, Column = startColumn };
                case '{':
                    Advance();
                    return new Token { Type = TokenType.LeftBrace, Value = "{", Line = startLine, Column = startColumn };
                case '}':
                    Advance();
                    return new Token { Type = TokenType.RightBrace, Value = "}", Line = startLine, Column = startColumn };
                case '[':
                    Advance();
                    return new Token { Type = TokenType.LeftBracket, Value = "[", Line = startLine, Column = startColumn };
                case ']':
                    Advance();
                    return new Token { Type = TokenType.RightBracket, Value = "]", Line = startLine, Column = startColumn };
                case '(':
                    Advance();
                    return new Token { Type = TokenType.LeftParen, Value = "(", Line = startLine, Column = startColumn };
                case ')':
                    Advance();
                    return new Token { Type = TokenType.RightParen, Value = ")", Line = startLine, Column = startColumn };
                case ',':
                    Advance();
                    return new Token { Type = TokenType.Comma, Value = ",", Line = startLine, Column = startColumn };
                case '\n':
                    Advance();
                    return new Token { Type = TokenType.Newline, Value = "\n", Line = startLine, Column = startColumn };
            }

            // Comments
            if (c == '#')
            {
                return ReadSingleLineComment();
            }

            // Strings
            if (c == '"' || c == '\'')
            {
                return ReadString();
            }

            // Multi-line strings
            if (c == '"' && Peek(1) == '"' && Peek(2) == '"')
            {
                return ReadMultiLineString();
            }

            // Numbers
            if (char.IsDigit(c) || (c == '-' && char.IsDigit(Peek(1))))
            {
                return ReadNumber();
            }

            // Environment variables
            if (c == 'e' && MatchKeyword("env"))
            {
                return ReadEnvironmentVariable();
            }

            // References
            if (c == '@')
            {
                return ReadReference();
            }

            // Identifiers and keywords
            if (char.IsLetter(c) || c == '_')
            {
                return ReadIdentifier();
            }

            throw new InvalidOperationException($"Unexpected character '{c}' at line {_line}, column {_column}");
        }

        private Token ReadSingleLineComment()
        {
            var startLine = _line;
            var startColumn = _column;
            var sb = new StringBuilder();

            while (_position < _input.Length && _input[_position] != '\n')
            {
                sb.Append(_input[_position]);
                Advance();
            }

            return new Token
            {
                Type = TokenType.Comment,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadMultiLineComment()
        {
            var startLine = _line;
            var startColumn = _column;
            var sb = new StringBuilder();

            Advance(); // Skip '/'
            Advance(); // Skip '*'

            while (_position < _input.Length - 1)
            {
                if (_input[_position] == '*' && _input[_position + 1] == '/')
                {
                    Advance(); // Skip '*'
                    Advance(); // Skip '/'
                    break;
                }

                sb.Append(_input[_position]);
                Advance();
            }

            return new Token
            {
                Type = TokenType.Comment,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadString()
        {
            var startLine = _line;
            var startColumn = _column;
            var quote = _input[_position];
            var sb = new StringBuilder();

            Advance(); // Skip opening quote

            while (_position < _input.Length && _input[_position] != quote)
            {
                if (_input[_position] == '\\')
                {
                    Advance();
                    if (_position < _input.Length)
                    {
                        var escaped = _input[_position] switch
                        {
                            'n' => '\n',
                            'r' => '\r',
                            't' => '\t',
                            '\\' => '\\',
                            '"' => '"',
                            '\'' => '\'',
                            _ => _input[_position]
                        };
                        sb.Append(escaped);
                    }
                }
                else
                {
                    sb.Append(_input[_position]);
                }
                Advance();
            }

            if (_position < _input.Length)
            {
                Advance(); // Skip closing quote
            }

            return new Token
            {
                Type = TokenType.String,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadMultiLineString()
        {
            var startLine = _line;
            var startColumn = _column;
            var sb = new StringBuilder();

            // Skip opening """
            Advance();
            Advance();
            Advance();

            while (_position < _input.Length - 2)
            {
                if (_input[_position] == '"' && _input[_position + 1] == '"' && _input[_position + 2] == '"')
                {
                    Advance();
                    Advance();
                    Advance();
                    break;
                }

                sb.Append(_input[_position]);
                Advance();
            }

            return new Token
            {
                Type = TokenType.String,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadNumber()
        {
            var startLine = _line;
            var startColumn = _column;
            var sb = new StringBuilder();

            // Handle negative sign
            if (_input[_position] == '-')
            {
                sb.Append(_input[_position]);
                Advance();
            }

            // Handle different number formats
            if (_position < _input.Length - 1 && _input[_position] == '0')
            {
                var next = _input[_position + 1];
                if (next == 'x' || next == 'X') // Hexadecimal
                {
                    sb.Append(_input[_position]); // '0'
                    Advance();
                    sb.Append(_input[_position]); // 'x'
                    Advance();

                    while (_position < _input.Length && 
                           (char.IsDigit(_input[_position]) || 
                            "ABCDEFabcdef".Contains(_input[_position])))
                    {
                        sb.Append(_input[_position]);
                        Advance();
                    }
                }
                else if (next == 'b' || next == 'B') // Binary
                {
                    sb.Append(_input[_position]); // '0'
                    Advance();
                    sb.Append(_input[_position]); // 'b'
                    Advance();

                    while (_position < _input.Length && (_input[_position] == '0' || _input[_position] == '1'))
                    {
                        sb.Append(_input[_position]);
                        Advance();
                    }
                }
                else if (next == 'o' || next == 'O') // Octal
                {
                    sb.Append(_input[_position]); // '0'
                    Advance();
                    sb.Append(_input[_position]); // 'o'
                    Advance();

                    while (_position < _input.Length && _input[_position] >= '0' && _input[_position] <= '7')
                    {
                        sb.Append(_input[_position]);
                        Advance();
                    }
                }
                else
                {
                    // Regular decimal number starting with 0
                    ReadDecimalNumber(sb);
                }
            }
            else
            {
                // Regular decimal number
                ReadDecimalNumber(sb);
            }

            return new Token
            {
                Type = TokenType.Number,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private void ReadDecimalNumber(StringBuilder sb)
        {
            // Read integer part
            while (_position < _input.Length && char.IsDigit(_input[_position]))
            {
                sb.Append(_input[_position]);
                Advance();
            }

            // Read decimal part
            if (_position < _input.Length && _input[_position] == '.')
            {
                sb.Append(_input[_position]);
                Advance();

                while (_position < _input.Length && char.IsDigit(_input[_position]))
                {
                    sb.Append(_input[_position]);
                    Advance();
                }
            }

            // Read scientific notation
            if (_position < _input.Length && (_input[_position] == 'e' || _input[_position] == 'E'))
            {
                sb.Append(_input[_position]);
                Advance();

                if (_position < _input.Length && (_input[_position] == '+' || _input[_position] == '-'))
                {
                    sb.Append(_input[_position]);
                    Advance();
                }

                while (_position < _input.Length && char.IsDigit(_input[_position]))
                {
                    sb.Append(_input[_position]);
                    Advance();
                }
            }
        }

        private Token ReadEnvironmentVariable()
        {
            var startLine = _line;
            var startColumn = _column;

            // Skip "env"
            Advance();
            Advance();
            Advance();

            SkipWhitespace();

            if (_position < _input.Length && _input[_position] == '(')
            {
                var sb = new StringBuilder("env");
                
                while (_position < _input.Length && _input[_position] != ')')
                {
                    sb.Append(_input[_position]);
                    Advance();
                }

                if (_position < _input.Length)
                {
                    sb.Append(_input[_position]); // Include closing ')'
                    Advance();
                }

                return new Token
                {
                    Type = TokenType.EnvironmentVariable,
                    Value = sb.ToString(),
                    Line = startLine,
                    Column = startColumn
                };
            }

            return new Token
            {
                Type = TokenType.Identifier,
                Value = "env",
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadReference()
        {
            var startLine = _line;
            var startColumn = _column;
            var sb = new StringBuilder();

            Advance(); // Skip '@'

            // Handle different reference types
            if (_position < _input.Length)
            {
                if (_input[_position] == 'i' && MatchKeyword("if"))
                {
                    return ReadConditionalExpression(startLine, startColumn);
                }
                else if (_input[_position] == 'm' && MatchKeyword("match"))
                {
                    return ReadMatchExpression(startLine, startColumn);
                }
                else
                {
                    // Regular reference
                    while (_position < _input.Length && 
                           (char.IsLetterOrDigit(_input[_position]) || _input[_position] == '_' || _input[_position] == '.'))
                    {
                        sb.Append(_input[_position]);
                        Advance();
                    }
                }
            }

            return new Token
            {
                Type = TokenType.Reference,
                Value = "@" + sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadConditionalExpression(int startLine, int startColumn)
        {
            var sb = new StringBuilder("@if");
            
            // Skip "if"
            Advance();
            Advance();

            // Read the entire conditional expression
            var parenCount = 0;
            while (_position < _input.Length)
            {
                var c = _input[_position];
                sb.Append(c);

                if (c == '(') parenCount++;
                else if (c == ')') parenCount--;

                Advance();

                if (parenCount == 0) break;
            }

            return new Token
            {
                Type = TokenType.ConditionalExpression,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadMatchExpression(int startLine, int startColumn)
        {
            var sb = new StringBuilder("@match");
            
            // Skip "match"
            Advance();
            Advance();
            Advance();
            Advance();
            Advance();

            // Read the entire match expression
            var parenCount = 0;
            while (_position < _input.Length)
            {
                var c = _input[_position];
                sb.Append(c);

                if (c == '(') parenCount++;
                else if (c == ')') parenCount--;

                Advance();

                if (parenCount == 0) break;
            }

            return new Token
            {
                Type = TokenType.MatchExpression,
                Value = sb.ToString(),
                Line = startLine,
                Column = startColumn
            };
        }

        private Token ReadIdentifier()
        {
            var startLine = _line;
            var startColumn = _column;
            var sb = new StringBuilder();

            while (_position < _input.Length && 
                   (char.IsLetterOrDigit(_input[_position]) || _input[_position] == '_'))
            {
                sb.Append(_input[_position]);
                Advance();
            }

            var value = sb.ToString();

            // Check for boolean literals
            var tokenType = value switch
            {
                "true" or "false" => TokenType.Boolean,
                "null" => TokenType.Null,
                _ => TokenType.Identifier
            };

            return new Token
            {
                Type = tokenType,
                Value = value,
                Line = startLine,
                Column = startColumn
            };
        }

        private void SkipWhitespace()
        {
            while (_position < _input.Length && 
                   char.IsWhiteSpace(_input[_position]) && 
                   _input[_position] != '\n')
            {
                Advance();
            }
        }

        private void Advance()
        {
            if (_position < _input.Length)
            {
                if (_input[_position] == '\n')
                {
                    _line++;
                    _column = 1;
                }
                else
                {
                    _column++;
                }
                _position++;
            }
        }

        private char Peek(int offset = 0)
        {
            var pos = _position + offset;
            return pos < _input.Length ? _input[pos] : '\0';
        }

        private bool MatchKeyword(string keyword)
        {
            if (_position + keyword.Length > _input.Length)
                return false;

            for (int i = 0; i < keyword.Length; i++)
            {
                if (_input[_position + i] != keyword[i])
                    return false;
            }

            // Ensure it's not part of a larger identifier
            var nextPos = _position + keyword.Length;
            if (nextPos < _input.Length && 
                (char.IsLetterOrDigit(_input[nextPos]) || _input[nextPos] == '_'))
            {
                return false;
            }

            return true;
        }
    }

    // Value types for parsed TuskLang values
    public abstract class TuskValue
    {
        public abstract object ToObject();
        public abstract T As<T>();
    }

    public class TuskString : TuskValue
    {
        public string Value { get; }
        
        public TuskString(string value) => Value = value;
        
        public override object ToObject() => Value;
        public override T As<T>() => (T)(object)Value;
        public override string ToString() => Value;
    }

    public class TuskNumber : TuskValue
    {
        public decimal Value { get; }
        
        public TuskNumber(decimal value) => Value = value;
        
        public override object ToObject() => Value;
        public override T As<T>() => (T)Convert.ChangeType(Value, typeof(T));
        public override string ToString() => Value.ToString(CultureInfo.InvariantCulture);
    }

    public class TuskBoolean : TuskValue
    {
        public bool Value { get; }
        
        public TuskBoolean(bool value) => Value = value;
        
        public override object ToObject() => Value;
        public override T As<T>() => (T)(object)Value;
        public override string ToString() => Value.ToString().ToLowerInvariant();
    }

    public class TuskNull : TuskValue
    {
        public static readonly TuskNull Instance = new();
        
        private TuskNull() { }
        
        public override object ToObject() => null;
        public override T As<T>() => default;
        public override string ToString() => "null";
    }

    public class TuskArray : TuskValue
    {
        public List<TuskValue> Values { get; }
        
        public TuskArray(IEnumerable<TuskValue> values) => Values = values.ToList();
        
        public override object ToObject() => Values.Select(v => v.ToObject()).ToList();
        public override T As<T>() => (T)ToObject();
        public override string ToString() => $"[{string.Join(", ", Values)}]";
    }

    public class TuskObject : TuskValue
    {
        public Dictionary<string, TuskValue> Properties { get; }
        
        public TuskObject(Dictionary<string, TuskValue> properties) => Properties = properties;
        
        public override object ToObject()
        {
            return Properties.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToObject());
        }
        
        public override T As<T>() => (T)ToObject();
        
        public override string ToString()
        {
            var props = Properties.Select(kvp => $"{kvp.Key}: {kvp.Value}");
            return $"{{{string.Join(", ", props)}}}";
        }
    }

    // Syntax validation and analysis
    public class TuskLangSyntaxAnalyzer
    {
        public SyntaxAnalysisResult Analyze(string input)
        {
            var result = new SyntaxAnalysisResult();
            
            try
            {
                var lexer = new TuskLangLexer(input);
                var tokens = lexer.Tokenize();
                
                result.Tokens = tokens;
                result.IsValid = ValidateTokenSequence(tokens, result);
                
                if (result.IsValid)
                {
                    result.Structure = AnalyzeStructure(tokens);
                }
            }
            catch (Exception ex)
            {
                result.IsValid = false;
                result.Errors.Add($"Lexical analysis failed: {ex.Message}");
            }
            
            return result;
        }

        private bool ValidateTokenSequence(List<Token> tokens, SyntaxAnalysisResult result)
        {
            var isValid = true;
            var braceStack = new Stack<Token>();
            var bracketStack = new Stack<Token>();
            var parenStack = new Stack<Token>();

            foreach (var token in tokens)
            {
                switch (token.Type)
                {
                    case TokenType.LeftBrace:
                        braceStack.Push(token);
                        break;
                    case TokenType.RightBrace:
                        if (braceStack.Count == 0)
                        {
                            result.Errors.Add($"Unmatched closing brace at line {token.Line}");
                            isValid = false;
                        }
                        else
                        {
                            braceStack.Pop();
                        }
                        break;
                    case TokenType.LeftBracket:
                        bracketStack.Push(token);
                        break;
                    case TokenType.RightBracket:
                        if (bracketStack.Count == 0)
                        {
                            result.Errors.Add($"Unmatched closing bracket at line {token.Line}");
                            isValid = false;
                        }
                        else
                        {
                            bracketStack.Pop();
                        }
                        break;
                    case TokenType.LeftParen:
                        parenStack.Push(token);
                        break;
                    case TokenType.RightParen:
                        if (parenStack.Count == 0)
                        {
                            result.Errors.Add($"Unmatched closing parenthesis at line {token.Line}");
                            isValid = false;
                        }
                        else
                        {
                            parenStack.Pop();
                        }
                        break;
                }
            }

            // Check for unclosed delimiters
            if (braceStack.Count > 0)
            {
                result.Errors.Add($"Unclosed braces detected");
                isValid = false;
            }
            
            if (bracketStack.Count > 0)
            {
                result.Errors.Add($"Unclosed brackets detected");
                isValid = false;
            }
            
            if (parenStack.Count > 0)
            {
                result.Errors.Add($"Unclosed parentheses detected");
                isValid = false;
            }

            return isValid;
        }

        private StructureInfo AnalyzeStructure(List<Token> tokens)
        {
            var structure = new StructureInfo();
            var depth = 0;
            var maxDepth = 0;

            foreach (var token in tokens)
            {
                switch (token.Type)
                {
                    case TokenType.LeftBrace:
                        depth++;
                        maxDepth = Math.Max(maxDepth, depth);
                        structure.ObjectCount++;
                        break;
                    case TokenType.RightBrace:
                        depth--;
                        break;
                    case TokenType.LeftBracket:
                        structure.ArrayCount++;
                        break;
                    case TokenType.String:
                        structure.StringCount++;
                        break;
                    case TokenType.Number:
                        structure.NumberCount++;
                        break;
                    case TokenType.Boolean:
                        structure.BooleanCount++;
                        break;
                    case TokenType.Null:
                        structure.NullCount++;
                        break;
                    case TokenType.EnvironmentVariable:
                        structure.EnvironmentVariableCount++;
                        break;
                    case TokenType.Reference:
                        structure.ReferenceCount++;
                        break;
                    case TokenType.ConditionalExpression:
                        structure.ConditionalCount++;
                        break;
                    case TokenType.MatchExpression:
                        structure.MatchExpressionCount++;
                        break;
                }
            }

            structure.MaxNestingDepth = maxDepth;
            return structure;
        }
    }

    // Analysis result classes
    public class SyntaxAnalysisResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
        public List<Token> Tokens { get; set; } = new();
        public StructureInfo Structure { get; set; } = new();
    }

    public class StructureInfo
    {
        public int ObjectCount { get; set; }
        public int ArrayCount { get; set; }
        public int StringCount { get; set; }
        public int NumberCount { get; set; }
        public int BooleanCount { get; set; }
        public int NullCount { get; set; }
        public int EnvironmentVariableCount { get; set; }
        public int ReferenceCount { get; set; }
        public int ConditionalCount { get; set; }
        public int MatchExpressionCount { get; set; }
        public int MaxNestingDepth { get; set; }
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using System;
using System.Linq;
using TuskLang.Syntax;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== TuskLang Basic Syntax Demo ===");

        // 1. Lexical analysis demonstration
        Console.WriteLine("\n1. Lexical Analysis:");
        DemonstrateTokenization();

        // 2. Syntax validation
        Console.WriteLine("\n2. Syntax Validation:");
        DemonstrateSyntaxValidation();

        // 3. Value parsing
        Console.WriteLine("\n3. Value Parsing:");
        DemonstrateValueParsing();

        // 4. Complex structure analysis
        Console.WriteLine("\n4. Structure Analysis:");
        DemonstrateStructureAnalysis();

        Console.WriteLine("\n=== Demo Complete ===");
    }

    static void DemonstrateTokenization()
    {
        var input = @"
# Sample configuration
name: ""TuskLang""
version = 1.0
enabled: true
items: [1, 2, 3]
config {
    host: ""localhost""
    port: env(""PORT"", 8080)
}
";

        var lexer = new TuskLangLexer(input);
        var tokens = lexer.Tokenize();

        Console.WriteLine($"  Tokenized {tokens.Count} tokens:");
        
        foreach (var token in tokens.Take(15)) // Show first 15 tokens
        {
            Console.WriteLine($"    {token}");
        }
        
        if (tokens.Count > 15)
        {
            Console.WriteLine($"    ... and {tokens.Count - 15} more tokens");
        }
    }

    static void DemonstrateSyntaxValidation()
    {
        var validInputs = new[]
        {
            "name: \"valid\"",
            "config { port: 8080 }",
            "items: [1, 2, 3]",
            "enabled: true",
            "value: env(\"VAR\", \"default\")"
        };

        var invalidInputs = new[]
        {
            "name: \"unclosed string",
            "config { port: 8080 # missing closing brace",
            "items: [1, 2, 3 # missing closing bracket",
            "value: env(\"VAR\" # missing closing paren"
        };

        Console.WriteLine("  Valid syntax examples:");
        foreach (var input in validInputs)
        {
            var analyzer = new TuskLangSyntaxAnalyzer();
            var result = analyzer.Analyze(input);
            
            Console.WriteLine($"    ✓ {input} - {(result.IsValid ? "Valid" : "Invalid")}");
        }

        Console.WriteLine("\n  Invalid syntax examples:");
        foreach (var input in invalidInputs)
        {
            var analyzer = new TuskLangSyntaxAnalyzer();
            var result = analyzer.Analyze(input);
            
            Console.WriteLine($"    ✗ {input} - {(result.IsValid ? "Valid" : "Invalid")}");
            if (!result.IsValid && result.Errors.Any())
            {
                Console.WriteLine($"      Error: {result.Errors.First()}");
            }
        }
    }

    static void DemonstrateValueParsing()
    {
        var values = new (string input, string expected)[]
        {
            ("\"Hello World\"", "String: Hello World"),
            ("42", "Number: 42"),
            ("3.14", "Number: 3.14"),
            ("true", "Boolean: true"),
            ("false", "Boolean: false"),
            ("null", "Null: null"),
            ("[1, 2, 3]", "Array: [1, 2, 3]"),
            ("0xFF", "Number: 255 (hex)"),
            ("0b1010", "Number: 10 (binary)"),
            ("1.23e-4", "Number: 0.000123 (scientific)")
        };

        Console.WriteLine("  Value parsing examples:");
        
        foreach (var (input, expected) in values)
        {
            try
            {
                var lexer = new TuskLangLexer(input);
                var tokens = lexer.Tokenize();
                var mainToken = tokens.FirstOrDefault(t => t.Type != TokenType.EOF);
                
                if (mainToken != null)
                {
                    var parsedValue = ParseTokenValue(mainToken);
                    Console.WriteLine($"    {input,-15} → {parsedValue}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"    {input,-15} → Error: {ex.Message}");
            }
        }
    }

    static void DemonstrateStructureAnalysis()
    {
        var complexInput = @"
# Complex configuration example
application {
    name: ""MyApp""
    version: ""1.0.0""
    
    features {
        authentication: true
        caching: env(""ENABLE_CACHE"", false)
        
        database {
            provider: ""PostgreSQL""
            settings {
                timeout: 30
                pool_size: 10
            }
        }
    }
    
    servers: [
        { name: ""web"", port: 8080 },
        { name: ""api"", port: 8081 }
    ]
    
    environment: @if(env(""NODE_ENV"") == ""production"", ""prod"", ""dev"")
}
";

        var analyzer = new TuskLangSyntaxAnalyzer();
        var result = analyzer.Analyze(complexInput);

        Console.WriteLine($"  Analysis of complex structure:");
        Console.WriteLine($"    Valid: {result.IsValid}");
        Console.WriteLine($"    Objects: {result.Structure.ObjectCount}");
        Console.WriteLine($"    Arrays: {result.Structure.ArrayCount}");
        Console.WriteLine($"    Strings: {result.Structure.StringCount}");
        Console.WriteLine($"    Numbers: {result.Structure.NumberCount}");
        Console.WriteLine($"    Booleans: {result.Structure.BooleanCount}");
        Console.WriteLine($"    Environment Variables: {result.Structure.EnvironmentVariableCount}");
        Console.WriteLine($"    References: {result.Structure.ReferenceCount}");
        Console.WriteLine($"    Conditionals: {result.Structure.ConditionalCount}");
        Console.WriteLine($"    Max Nesting Depth: {result.Structure.MaxNestingDepth}");

        if (result.Errors.Any())
        {
            Console.WriteLine("    Errors:");
            foreach (var error in result.Errors)
            {
                Console.WriteLine($"      - {error}");
            }
        }

        if (result.Warnings.Any())
        {
            Console.WriteLine("    Warnings:");
            foreach (var warning in result.Warnings)
            {
                Console.WriteLine($"      - {warning}");
            }
        }
    }

    static string ParseTokenValue(Token token)
    {
        return token.Type switch
        {
            TokenType.String => $"String: {token.Value}",
            TokenType.Number => ParseNumberValue(token.Value),
            TokenType.Boolean => $"Boolean: {token.Value}",
            TokenType.Null => "Null: null",
            TokenType.EnvironmentVariable => $"Environment Variable: {token.Value}",
            TokenType.Reference => $"Reference: {token.Value}",
            _ => $"{token.Type}: {token.Value}"
        };
    }

    static string ParseNumberValue(string value)
    {
        if (value.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
        {
            var hexValue = Convert.ToInt32(value, 16);
            return $"Number: {hexValue} (hex)";
        }
        else if (value.StartsWith("0b", StringComparison.OrdinalIgnoreCase))
        {
            var binaryValue = Convert.ToInt32(value.Substring(2), 2);
            return $"Number: {binaryValue} (binary)";
        }
        else if (value.StartsWith("0o", StringComparison.OrdinalIgnoreCase))
        {
            var octalValue = Convert.ToInt32(value.Substring(2), 8);
            return $"Number: {octalValue} (octal)";
        }
        else if (value.Contains('e') || value.Contains('E'))
        {
            var scientificValue = decimal.Parse(value);
            return $"Number: {scientificValue} (scientific)";
        }
        else
        {
            return $"Number: {value}";
        }
    }
}
</pre>

<p>TuskLang basic syntax in C# provides comprehensive lexical analysis, token parsing, syntax validation, and structure analysis for robust configuration processing.</p>