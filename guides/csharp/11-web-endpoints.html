<h1>Web Endpoints</h1>

<h2>Web Endpoints with TuskLang in C#</h2>
<p>Create dynamic web endpoints and API controllers using TuskLang configuration with ASP.NET Core in C# applications.</p>

<h3>endpoints.tsk</h3>
<pre>
# TuskLang Web Endpoints Configuration

# 1. API Endpoint Definitions
#!api
api_endpoints {
    # Basic REST endpoints
    users_api: {
        base_path: "/api/users"
        
        # GET /api/users - List users
        list: {
            method: "GET"
            path: ""
            handler: @query("Users").where("active", true).find()
            
            # Query parameters
            parameters: {
                page: { type: "integer", default: 1, min: 1 }
                limit: { type: "integer", default: 10, min: 1, max: 100 }
                search: { type: "string", optional: true }
                sort: { type: "string", default: "created_at", enum: ["name", "email", "created_at"] }
                order: { type: "string", default: "desc", enum: ["asc", "desc"] }
            }
            
            # Response format
            response: {
                type: "json"
                schema: {
                    users: "array",
                    total: "integer",
                    page: "integer",
                    pages: "integer"
                }
                
                # Pagination and filtering
                data: @paginate(
                    @filter_and_sort(@users, @request.query),
                    @request.query.page,
                    @request.query.limit
                )
            }
            
            # Caching
            cache: {
                enabled: true
                ttl: "5m"
                key: "users_list_#{@request.query_hash}"
                vary_by: ["page", "limit", "search", "sort", "order"]
            }
            
            # Rate limiting
            rate_limit: {
                requests: 100
                window: "1m"
                key: @request.ip
            }
        }
        
        # GET /api/users/{id} - Get user by ID
        get_by_id: {
            method: "GET"
            path: "/{id}"
            handler: @query("Users").where("id", @request.params.id).findOne()
            
            # Path parameters
            parameters: {
                id: { type: "string", required: true, pattern: "^[a-fA-F0-9]{24}$" }
            }
            
            # Response format
            response: {
                type: "json"
                schema: @schema.user
                data: @user_data
                
                # Include related data
                include: {
                    profile: @query("UserProfiles").where("user_id", @user_data.id).findOne(),
                    recent_activities: @query("Activities").where("user_id", @user_data.id).orderBy("created_at", "desc").limit(10).find()
                }
            }
            
            # Error handling
            errors: {
                404: { message: "User not found", when: @user_data == null }
                403: { message: "Access denied", when: !@can_access_user(@request.user, @user_data) }
            }
            
            # Caching
            cache: {
                enabled: true
                ttl: "10m"
                key: "user_#{@request.params.id}"
                invalidate_on: ["user_updated_#{@request.params.id}"]
            }
        }
        
        # POST /api/users - Create new user
        create: {
            method: "POST"
            path: ""
            handler: @create_user(@request.body)
            
            # Request validation
            validation: {
                schema: @schema.user_create
                required: ["name", "email", "password"]
                
                custom_validators: [
                    @validate_unique_email(@request.body.email),
                    @validate_password_strength(@request.body.password),
                    @validate_name_format(@request.body.name)
                ]
            }
            
            # Response format
            response: {
                type: "json"
                status: 201
                schema: @schema.user
                data: @created_user
                
                # Additional response data
                meta: {
                    created_at: @now,
                    created_by: @request.user.id,
                    welcome_email_sent: @send_welcome_email(@created_user)
                }
            }
            
            # Side effects
            side_effects: [
                @invalidate_cache("users_list_*"),
                @log_user_creation(@created_user),
                @trigger_webhook("user_created", @created_user),
                @metrics.counter("users_created", 1)
            ]
            
            # Rate limiting
            rate_limit: {
                requests: 10
                window: "1h"
                key: @request.ip
            }
        }
        
        # PUT /api/users/{id} - Update user
        update: {
            method: "PUT"
            path: "/{id}"
            handler: @update_user(@request.params.id, @request.body)
            
            # Authorization
            authorization: {
                required: true
                conditions: [
                    @request.user.id == @request.params.id,  # Own profile
                    @request.user.role == "admin",          # Admin user
                    @has_permission(@request.user, "users:update")  # Specific permission
                ]
                operator: "OR"  # Any condition must be true
            }
            
            # Request validation
            validation: {
                schema: @schema.user_update
                optional: ["name", "email", "profile"]
                
                conditional_validation: {
                    email: @validate_unique_email_excluding(@request.body.email, @request.params.id),
                    password: @validate_password_strength(@request.body.password)
                }
            }
            
            # Response format
            response: {
                type: "json"
                schema: @schema.user
                data: @updated_user
                
                # Change tracking
                meta: {
                    updated_at: @now,
                    updated_by: @request.user.id,
                    changes: @track_changes(@original_user, @updated_user)
                }
            }
            
            # Side effects
            side_effects: [
                @invalidate_cache("user_#{@request.params.id}"),
                @invalidate_cache("users_list_*"),
                @log_user_update(@updated_user, @changes),
                @notify_user_updated(@updated_user),
                @trigger_webhook("user_updated", @updated_user)
            ]
        }
        
        # DELETE /api/users/{id} - Delete user
        delete: {
            method: "DELETE"
            path: "/{id}"
            handler: @delete_user(@request.params.id)
            
            # Authorization
            authorization: {
                required: true
                conditions: [
                    @request.user.role == "admin",
                    @has_permission(@request.user, "users:delete")
                ]
                operator: "OR"
            }
            
            # Soft delete configuration
            soft_delete: {
                enabled: true
                field: "deleted_at"
                cascade: ["user_profiles", "user_sessions", "user_preferences"]
            }
            
            # Response format
            response: {
                type: "json"
                status: 204
                data: null
                
                meta: {
                    deleted_at: @now,
                    deleted_by: @request.user.id,
                    soft_delete: @soft_delete.enabled
                }
            }
            
            # Side effects
            side_effects: [
                @invalidate_cache("user_#{@request.params.id}"),
                @invalidate_cache("users_list_*"),
                @cleanup_user_data(@request.params.id),
                @log_user_deletion(@request.params.id),
                @trigger_webhook("user_deleted", { id: @request.params.id })
            ]
        }
    }
    
    # Health check endpoints
    health: {
        base_path: "/health"
        
        # GET /health - Basic health check
        basic: {
            method: "GET"
            path: ""
            handler: @health_check()
            
            response: {
                type: "json"
                data: {
                    status: @system_status,
                    timestamp: @now,
                    version: env("APP_VERSION", "1.0.0"),
                    uptime: @uptime_seconds,
                    
                    # Component health
                    components: {
                        database: @check_database_health(),
                        cache: @check_cache_health(),
                        external_services: @check_external_services()
                    }
                }
            }
            
            # No authentication required
            authentication: false
            
            # Always enabled
            cache: { enabled: false }
        }
        
        # GET /health/detailed - Detailed health information
        detailed: {
            method: "GET"
            path: "/detailed"
            handler: @detailed_health_check()
            
            # Require admin access
            authorization: {
                required: true
                conditions: [@request.user.role == "admin"]
            }
            
            response: {
                type: "json"
                data: {
                    status: @system_status,
                    timestamp: @now,
                    
                    # System metrics
                    metrics: {
                        cpu_usage: @system.cpu_percent,
                        memory_usage: @system.memory_percent,
                        disk_usage: @system.disk_percent,
                        active_connections: @database.active_connections,
                        cache_hit_rate: @cache.hit_rate
                    },
                    
                    # Service dependencies
                    dependencies: {
                        database: @detailed_db_health(),
                        cache: @detailed_cache_health(),
                        message_queue: @detailed_queue_health(),
                        external_apis: @check_external_apis()
                    },
                    
                    # Performance data
                    performance: {
                        average_response_time: @metrics.avg_response_time,
                        requests_per_second: @metrics.requests_per_second,
                        error_rate: @metrics.error_rate
                    }
                }
            }
        }
    }
    
    # File upload endpoints
    uploads: {
        base_path: "/api/uploads"
        
        # POST /api/uploads - Upload file
        upload_file: {
            method: "POST"
            path: ""
            handler: @handle_file_upload(@request.files.file)
            
            # File validation
            validation: {
                max_size: "10MB"
                allowed_types: ["image/jpeg", "image/png", "image/gif", "application/pdf", "text/plain"]
                virus_scan: true
                
                custom_validators: [
                    @validate_file_content(@request.files.file),
                    @check_file_permissions(@request.user, @request.files.file)
                ]
            }
            
            # File processing
            processing: {
                # Image optimization
                images: {
                    resize: { width: 1920, height: 1080, maintain_aspect: true }
                    compress: { quality: 85 }
                    formats: ["webp", "jpg"]
                }
                
                # Generate thumbnails
                thumbnails: [
                    { size: "small", width: 150, height: 150 },
                    { size: "medium", width: 300, height: 300 },
                    { size: "large", width: 600, height: 600 }
                ]
                
                # Metadata extraction
                extract_metadata: true
            }
            
            # Storage configuration
            storage: {
                provider: env("STORAGE_PROVIDER", "local")  # local, s3, azure, gcp
                path: "uploads/#{@now.year}/#{@now.month}/#{@now.day}"
                filename: "#{@uuid()}.#{@file_extension}"
                
                # Cloud storage settings
                cloud: {
                    bucket: env("STORAGE_BUCKET")
                    region: env("STORAGE_REGION", "us-east-1")
                    access_control: "private"
                    encryption: true
                }
            }
            
            # Response format
            response: {
                type: "json"
                status: 201
                data: {
                    id: @uploaded_file.id,
                    filename: @uploaded_file.filename,
                    original_name: @uploaded_file.original_name,
                    size: @uploaded_file.size,
                    mime_type: @uploaded_file.mime_type,
                    url: @uploaded_file.url,
                    
                    # Processing results
                    thumbnails: @uploaded_file.thumbnails,
                    metadata: @uploaded_file.metadata,
                    
                    # Upload details
                    uploaded_at: @now,
                    uploaded_by: @request.user.id
                }
            }
            
            # Rate limiting
            rate_limit: {
                requests: 20
                window: "1h"
                key: @request.user.id
            }
        }
        
        # GET /api/uploads/{id} - Get file info
        get_file_info: {
            method: "GET"
            path: "/{id}"
            handler: @get_file_info(@request.params.id)
            
            # Authorization
            authorization: {
                required: true
                conditions: [
                    @file_owner(@request.params.id) == @request.user.id,
                    @has_file_access(@request.user, @request.params.id),
                    @request.user.role == "admin"
                ]
                operator: "OR"
            }
            
            response: {
                type: "json"
                data: @file_info
            }
        }
    }
}

# 2. Middleware Configuration
middleware {
    # Global middleware pipeline
    global: [
        # Request logging
        {
            name: "request_logging"
            order: 1
            config: {
                include_headers: env("LOG_HEADERS", false)
                include_body: env("LOG_BODY", false)
                exclude_paths: ["/health", "/metrics"]
                log_level: env("LOG_LEVEL", "info")
            }
        },
        
        # CORS handling
        {
            name: "cors"
            order: 2
            config: {
                origins: env_list("CORS_ORIGINS", ",", ["http://localhost:3000"])
                methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
                headers: ["Content-Type", "Authorization", "X-API-Key"]
                credentials: true
                max_age: 86400  # 24 hours
            }
        },
        
        # Rate limiting
        {
            name: "rate_limiting"
            order: 3
            config: {
                global_limit: {
                    requests: 1000
                    window: "1h"
                    key: @request.ip
                }
                
                # Per-endpoint limits defined in endpoint config
                respect_endpoint_limits: true
                
                # Rate limit headers
                include_headers: true
                header_prefix: "X-RateLimit"
                
                # Storage for rate limit data
                storage: {
                    provider: "redis"
                    connection: env("REDIS_CONNECTION")
                    key_prefix: "rate_limit:"
                }
            }
        },
        
        # Authentication
        {
            name: "authentication"
            order: 4
            config: {
                # JWT configuration
                jwt: {
                    secret: env("JWT_SECRET")
                    issuer: env("JWT_ISSUER", "myapp")
                    audience: env("JWT_AUDIENCE", "myapp")
                    expiry: env("JWT_EXPIRY", "1h")
                    
                    # Token sources
                    sources: [
                        { type: "header", name: "Authorization", prefix: "Bearer " },
                        { type: "cookie", name: "auth_token" },
                        { type: "query", name: "token" }
                    ]
                }
                
                # API key authentication
                api_key: {
                    enabled: true
                    header: "X-API-Key"
                    query_param: "api_key"
                    
                    # API key validation
                    validator: @validate_api_key
                }
                
                # Session-based authentication
                session: {
                    enabled: true
                    cookie_name: "session_id"
                    store: "redis"
                    ttl: 3600  # 1 hour
                }
                
                # Skip authentication for certain paths
                skip_paths: ["/health", "/public/*", "/auth/login", "/auth/register"]
            }
        },
        
        # Authorization
        {
            name: "authorization"
            order: 5
            config: {
                # Role-based access control
                rbac: {
                    enabled: true
                    
                    # Default roles
                    roles: {
                        admin: { permissions: ["*"] }
                        user: { permissions: ["users:read", "users:update_own"] }
                        guest: { permissions: ["public:read"] }
                    }
                    
                    # Permission inheritance
                    inheritance: {
                        admin: ["user", "guest"]
                        user: ["guest"]
                    }
                }
                
                # Attribute-based access control
                abac: {
                    enabled: false
                    policy_store: "database"
                    
                    # Policy evaluation
                    policies: [
                        {
                            name: "user_data_access"
                            condition: "@request.user.id == @resource.user_id OR @request.user.role == 'admin'"
                            actions: ["read", "update"]
                            resources: ["user_profile", "user_settings"]
                        }
                    ]
                }
            }
        },
        
        # Response compression
        {
            name: "compression"
            order: 6
            config: {
                algorithms: ["gzip", "deflate", "br"]
                min_size: 1024  # 1KB
                
                # MIME types to compress
                types: [
                    "application/json",
                    "application/xml",
                    "text/html",
                    "text/css",
                    "text/javascript",
                    "text/plain"
                ]
                
                # Compression levels
                levels: {
                    gzip: 6
                    deflate: 6
                    br: 4
                }
            }
        }
    ]
    
    # Route-specific middleware
    route_specific: {
        "/api/admin/*": [
            {
                name: "admin_logging"
                config: {
                    include_request_body: true
                    include_response_body: true
                    log_file: "logs/admin-actions.log"
                }
            },
            {
                name: "admin_authorization"
                config: {
                    required_role: "admin"
                    log_access_attempts: true
                }
            }
        ],
        
        "/api/uploads/*": [
            {
                name: "file_validation"
                config: {
                    max_file_size: "50MB"
                    scan_for_malware: true
                    quarantine_suspicious: true
                }
            }
        ]
    }
}

# 3. Response Formatting
response_formatting {
    # Default response format
    default: {
        format: "json"
        
        # Envelope structure
        envelope: {
            success: @response.success
            data: @response.data
            meta: {
                timestamp: @now
                request_id: @request.id
                execution_time: @response.execution_time
                version: env("API_VERSION", "1.0")
            }
            
            # Include errors if any
            errors: @response.errors
            
            # Include pagination for lists
            pagination: @response.pagination
        }
        
        # Status code mapping
        status_codes: {
            success: 200
            created: 201
            no_content: 204
            bad_request: 400
            unauthorized: 401
            forbidden: 403
            not_found: 404
            conflict: 409
            validation_error: 422
            internal_error: 500
        }
    }
    
    # XML response format
    xml: {
        format: "xml"
        root_element: "response"
        
        # Namespace configuration
        namespaces: {
            default: "http://api.myapp.com/v1"
            meta: "http://api.myapp.com/meta"
        }
        
        # Attribute mapping
        attributes: {
            success: "@success"
            timestamp: "@timestamp"
            version: "@version"
        }
    }
    
    # CSV response format for data exports
    csv: {
        format: "csv"
        delimiter: ","
        
        # Headers
        include_headers: true
        header_case: "snake_case"  # snake_case, camelCase, PascalCase
        
        # Data formatting
        date_format: "yyyy-MM-dd HH:mm:ss"
        null_value: ""
        boolean_format: { true: "true", false: "false" }
    }
}

# 4. Error Handling
error_handling {
    # Global error handlers
    global: {
        # Validation errors
        validation_error: {
            status: 422
            message: "Validation failed"
            
            format: {
                type: "validation_error"
                message: @error.message
                details: @error.validation_details
                
                # Field-level errors
                field_errors: @map(@error.field_errors, error => ({
                    field: error.field,
                    message: error.message,
                    code: error.code,
                    value: error.invalid_value
                }))
            }
        }
        
        # Authentication errors
        authentication_error: {
            status: 401
            message: "Authentication required"
            
            format: {
                type: "authentication_error"
                message: @error.message
                
                # Help information
                help: {
                    login_url: "/auth/login"
                    supported_methods: ["jwt", "api_key", "session"]
                }
            }
        }
        
        # Authorization errors
        authorization_error: {
            status: 403
            message: "Access denied"
            
            format: {
                type: "authorization_error"
                message: @error.message
                required_permissions: @error.required_permissions
                user_permissions: @request.user.permissions
            }
        }
        
        # Not found errors
        not_found_error: {
            status: 404
            message: "Resource not found"
            
            format: {
                type: "not_found_error"
                message: @error.message
                resource_type: @error.resource_type
                resource_id: @error.resource_id
            }
        }
        
        # Rate limit errors
        rate_limit_error: {
            status: 429
            message: "Rate limit exceeded"
            
            format: {
                type: "rate_limit_error"
                message: @error.message
                
                # Rate limit details
                rate_limit: {
                    limit: @error.limit
                    remaining: @error.remaining
                    reset_time: @error.reset_time
                    retry_after: @error.retry_after
                }
            }
            
            # Include rate limit headers
            headers: {
                "X-RateLimit-Limit": @error.limit
                "X-RateLimit-Remaining": @error.remaining
                "X-RateLimit-Reset": @error.reset_time
                "Retry-After": @error.retry_after
            }
        }
        
        # Internal server errors
        internal_error: {
            status: 500
            message: "Internal server error"
            
            format: {
                type: "internal_error"
                message: @env.NODE_ENV == "development" ? @error.message : "An unexpected error occurred"
                
                # Include stack trace in development
                stack_trace: @env.NODE_ENV == "development" ? @error.stack_trace : null
                
                # Error tracking
                error_id: @error.tracking_id
                timestamp: @now
            }
            
            # Log the error
            logging: {
                level: "error"
                include_request: true
                include_user: true
                include_stack_trace: true
            }
        }
    }
    
    # Custom error pages
    error_pages: {
        404: {
            template: "errors/404.html"
            data: {
                title: "Page Not Found"
                message: "The page you're looking for doesn't exist."
                suggestions: [
                    "Check the URL for typos",
                    "Go back to the home page",
                    "Contact support if you believe this is an error"
                ]
            }
        }
        
        500: {
            template: "errors/500.html"
            data: {
                title: "Internal Server Error"
                message: "Something went wrong on our end."
                contact: "Please contact support if the problem persists."
            }
        }
    }
}
</pre>

<h3>TuskWebEndpointEngine.cs</h3>
<pre>
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;

namespace TuskLang.WebEndpoints
{
    // Main engine for processing TuskLang web endpoints
    public class TuskWebEndpointEngine
    {
        private readonly Dictionary&lt;string, EndpointDefinition&gt; _endpoints;
        private readonly Dictionary&lt;string, MiddlewareDefinition&gt; _middleware;
        private readonly ErrorHandlingConfig _errorHandling;
        private readonly ResponseFormattingConfig _responseFormatting;
        
        public TuskWebEndpointEngine()
        {
            _endpoints = new Dictionary&lt;string, EndpointDefinition&gt;();
            _middleware = new Dictionary&lt;string, MiddlewareDefinition&gt;();
            _errorHandling = new ErrorHandlingConfig();
            _responseFormatting = new ResponseFormattingConfig();
        }
        
        // Configure endpoints from TuskLang configuration
        public void ConfigureEndpoints(WebApplication app, Dictionary&lt;string, object&gt; config)
        {
            if (config.TryGetValue("api_endpoints", out var endpointsConfig))
            {
                ConfigureApiEndpoints(app, (Dictionary&lt;string, object&gt;)endpointsConfig);
            }
            
            if (config.TryGetValue("middleware", out var middlewareConfig))
            {
                ConfigureMiddleware(app, (Dictionary&lt;string, object&gt;)middlewareConfig);
            }
            
            if (config.TryGetValue("error_handling", out var errorConfig))
            {
                ConfigureErrorHandling(app, (Dictionary&lt;string, object&gt;)errorConfig);
            }
        }
        
        // Configure API endpoints
        private void ConfigureApiEndpoints(WebApplication app, Dictionary&lt;string, object&gt; endpointsConfig)
        {
            foreach (var endpointGroup in endpointsConfig)
            {
                var groupName = endpointGroup.Key;
                var groupConfig = (Dictionary&lt;string, object&gt;)endpointGroup.Value;
                
                if (!groupConfig.TryGetValue("base_path", out var basePath))
                    continue;
                
                var basePathStr = basePath.ToString();
                
                foreach (var endpoint in groupConfig)
                {
                    if (endpoint.Key == "base_path") continue;
                    
                    var endpointName = endpoint.Key;
                    var endpointConfig = (Dictionary&lt;string, object&gt;)endpoint.Value;
                    
                    RegisterEndpoint(app, groupName, endpointName, basePathStr, endpointConfig);
                }
            }
        }
        
        // Register a single endpoint
        private void RegisterEndpoint(WebApplication app, string groupName, string endpointName, 
            string basePath, Dictionary&lt;string, object&gt; config)
        {
            var method = config.GetValueOrDefault("method", "GET").ToString();
            var path = config.GetValueOrDefault("path", "").ToString();
            var fullPath = basePath + path;
            
            var endpointDefinition = new EndpointDefinition
            {
                GroupName = groupName,
                EndpointName = endpointName,
                Method = method,
                Path = fullPath,
                Config = config
            };
            
            _endpoints[$"{groupName}_{endpointName}"] = endpointDefinition;
            
            // Register the endpoint with ASP.NET Core
            switch (method.ToUpper())
            {
                case "GET":
                    app.MapGet(fullPath, async (HttpContext context) =&gt; await HandleRequest(context, endpointDefinition));
                    break;
                case "POST":
                    app.MapPost(fullPath, async (HttpContext context) =&gt; await HandleRequest(context, endpointDefinition));
                    break;
                case "PUT":
                    app.MapPut(fullPath, async (HttpContext context) =&gt; await HandleRequest(context, endpointDefinition));
                    break;
                case "DELETE":
                    app.MapDelete(fullPath, async (HttpContext context) =&gt; await HandleRequest(context, endpointDefinition));
                    break;
                case "PATCH":
                    app.MapPatch(fullPath, async (HttpContext context) =&gt; await HandleRequest(context, endpointDefinition));
                    break;
            }
        }
        
        // Handle HTTP request
        private async Task&lt;IResult&gt; HandleRequest(HttpContext context, EndpointDefinition endpoint)
        {
            var requestContext = new RequestContext(context, endpoint);
            
            try
            {
                // 1. Validate request parameters
                await ValidateRequest(requestContext);
                
                // 2. Check authentication
                await AuthenticateRequest(requestContext);
                
                // 3. Check authorization
                await AuthorizeRequest(requestContext);
                
                // 4. Check rate limits
                await CheckRateLimit(requestContext);
                
                // 5. Check cache
                var cachedResult = await CheckCache(requestContext);
                if (cachedResult != null)
                {
                    return FormatResponse(requestContext, cachedResult, fromCache: true);
                }
                
                // 6. Execute handler
                var result = await ExecuteHandler(requestContext);
                
                // 7. Execute side effects
                await ExecuteSideEffects(requestContext, result);
                
                // 8. Cache result if applicable
                await CacheResult(requestContext, result);
                
                // 9. Format and return response
                return FormatResponse(requestContext, result);
            }
            catch (Exception ex)
            {
                return await HandleError(requestContext, ex);
            }
        }
        
        // Validate request parameters
        private async Task ValidateRequest(RequestContext context)
        {
            if (!context.Endpoint.Config.TryGetValue("parameters", out var parametersConfig))
                return;
            
            var parameters = (Dictionary&lt;string, object&gt;)parametersConfig;
            var errors = new List&lt;ValidationError&gt;();
            
            foreach (var param in parameters)
            {
                var paramName = param.Key;
                var paramConfig = (Dictionary&lt;string, object&gt;)param.Value;
                
                var value = GetParameterValue(context, paramName);
                var validationResult = ValidateParameter(paramName, value, paramConfig);
                
                if (!validationResult.IsValid)
                {
                    errors.AddRange(validationResult.Errors);
                }
            }
            
            if (errors.Any())
            {
                throw new ValidationException("Request validation failed", errors);
            }
        }
        
        // Authenticate request
        private async Task AuthenticateRequest(RequestContext context)
        {
            if (context.Endpoint.Config.TryGetValue("authentication", out var authConfig) &&
                authConfig is bool authRequired && !authRequired)
            {
                return; // Authentication not required
            }
            
            // JWT authentication
            var token = ExtractToken(context.HttpContext);
            if (!string.IsNullOrEmpty(token))
            {
                var user = await ValidateJwtToken(token);
                if (user != null)
                {
                    context.User = user;
                    return;
                }
            }
            
            // API key authentication
            var apiKey = ExtractApiKey(context.HttpContext);
            if (!string.IsNullOrEmpty(apiKey))
            {
                var user = await ValidateApiKey(apiKey);
                if (user != null)
                {
                    context.User = user;
                    return;
                }
            }
            
            throw new AuthenticationException("Authentication required");
        }
        
        // Authorize request
        private async Task AuthorizeRequest(RequestContext context)
        {
            if (!context.Endpoint.Config.TryGetValue("authorization", out var authzConfig))
                return; // No authorization required
            
            var authzDict = (Dictionary&lt;string, object&gt;)authzConfig;
            
            if (authzDict.TryGetValue("required", out var required) && !(bool)required)
                return;
            
            if (context.User == null)
                throw new AuthorizationException("User must be authenticated for authorization");
            
            if (authzDict.TryGetValue("conditions", out var conditions))
            {
                var conditionsList = (List&lt;object&gt;)conditions;
                var operatorType = authzDict.GetValueOrDefault("operator", "AND").ToString();
                
                var results = new List&lt;bool&gt;();
                foreach (var condition in conditionsList)
                {
                    var result = await EvaluateAuthorizationCondition(context, condition.ToString());
                    results.Add(result);
                }
                
                var authorized = operatorType.ToUpper() == "OR" 
                    ? results.Any(r =&gt; r) 
                    : results.All(r =&gt; r);
                
                if (!authorized)
                    throw new AuthorizationException("Access denied");
            }
        }
        
        // Check rate limit
        private async Task CheckRateLimit(RequestContext context)
        {
            if (!context.Endpoint.Config.TryGetValue("rate_limit", out var rateLimitConfig))
                return;
            
            var rateLimit = (Dictionary&lt;string, object&gt;)rateLimitConfig;
            var requests = (int)rateLimit["requests"];
            var window = rateLimit["window"].ToString();
            var key = EvaluateRateLimitKey(context, rateLimit["key"].ToString());
            
            var isAllowed = await CheckRateLimitAllowed(key, requests, window);
            if (!isAllowed)
            {
                throw new RateLimitException($"Rate limit exceeded: {requests} requests per {window}");
            }
        }
        
        // Check cache
        private async Task&lt;object&gt; CheckCache(RequestContext context)
        {
            if (!context.Endpoint.Config.TryGetValue("cache", out var cacheConfig))
                return null;
            
            var cache = (Dictionary&lt;string, object&gt;)cacheConfig;
            if (!(bool)cache.GetValueOrDefault("enabled", false))
                return null;
            
            var cacheKey = EvaluateCacheKey(context, cache["key"].ToString());
            return await GetFromCache(cacheKey);
        }
        
        // Execute handler
        private async Task&lt;object&gt; ExecuteHandler(RequestContext context)
        {
            if (!context.Endpoint.Config.TryGetValue("handler", out var handlerConfig))
                throw new InvalidOperationException("No handler defined for endpoint");
            
            var handlerExpression = handlerConfig.ToString();
            
            // This would integrate with the TuskLang expression evaluator
            // For now, return a simple result
            return await EvaluateHandlerExpression(context, handlerExpression);
        }
        
        // Execute side effects
        private async Task ExecuteSideEffects(RequestContext context, object result)
        {
            if (!context.Endpoint.Config.TryGetValue("side_effects", out var sideEffectsConfig))
                return;
            
            var sideEffects = (List&lt;object&gt;)sideEffectsConfig;
            
            foreach (var sideEffect in sideEffects)
            {
                await ExecuteSideEffect(context, result, sideEffect.ToString());
            }
        }
        
        // Cache result
        private async Task CacheResult(RequestContext context, object result)
        {
            if (!context.Endpoint.Config.TryGetValue("cache", out var cacheConfig))
                return;
            
            var cache = (Dictionary&lt;string, object&gt;)cacheConfig;
            if (!(bool)cache.GetValueOrDefault("enabled", false))
                return;
            
            var cacheKey = EvaluateCacheKey(context, cache["key"].ToString());
            var ttl = cache["ttl"].ToString();
            
            await StoreInCache(cacheKey, result, ttl);
        }
        
        // Format response
        private IResult FormatResponse(RequestContext context, object data, bool fromCache = false)
        {
            if (!context.Endpoint.Config.TryGetValue("response", out var responseConfig))
            {
                return Results.Json(data);
            }
            
            var response = (Dictionary&lt;string, object&gt;)responseConfig;
            var responseType = response.GetValueOrDefault("type", "json").ToString();
            var status = (int)response.GetValueOrDefault("status", 200);
            
            var responseData = new Dictionary&lt;string, object&gt;
            {
                ["success"] = true,
                ["data"] = data,
                ["meta"] = new Dictionary&lt;string, object&gt;
                {
                    ["timestamp"] = DateTime.UtcNow,
                    ["from_cache"] = fromCache,
                    ["execution_time"] = context.ExecutionTime
                }
            };
            
            return responseType.ToLower() switch
            {
                "json" =&gt; Results.Json(responseData, statusCode: status),
                "xml" =&gt; Results.Text(ConvertToXml(responseData), "application/xml", statusCode: status),
                "csv" =&gt; Results.Text(ConvertToCsv(data), "text/csv", statusCode: status),
                _ =&gt; Results.Json(responseData, statusCode: status)
            };
        }
        
        // Handle errors
        private async Task&lt;IResult&gt; HandleError(RequestContext context, Exception exception)
        {
            var errorType = exception.GetType().Name;
            var status = GetErrorStatusCode(exception);
            
            var errorResponse = new Dictionary&lt;string, object&gt;
            {
                ["success"] = false,
                ["error"] = new Dictionary&lt;string, object&gt;
                {
                    ["type"] = errorType,
                    ["message"] = exception.Message,
                    ["timestamp"] = DateTime.UtcNow
                }
            };
            
            // Log the error
            await LogError(context, exception);
            
            return Results.Json(errorResponse, statusCode: status);
        }
        
        // Helper methods (simplified implementations)
        private object GetParameterValue(RequestContext context, string paramName)
        {
            // Get parameter from query string, route values, or request body
            return context.HttpContext.Request.Query[paramName].FirstOrDefault();
        }
        
        private ValidationResult ValidateParameter(string name, object value, Dictionary&lt;string, object&gt; config)
        {
            // Parameter validation logic
            return new ValidationResult { IsValid = true };
        }
        
        private string ExtractToken(HttpContext context)
        {
            var authHeader = context.Request.Headers["Authorization"].FirstOrDefault();
            return authHeader?.StartsWith("Bearer ") == true ? authHeader.Substring(7) : null;
        }
        
        private string ExtractApiKey(HttpContext context)
        {
            return context.Request.Headers["X-API-Key"].FirstOrDefault();
        }
        
        private async Task&lt;User&gt; ValidateJwtToken(string token)
        {
            // JWT validation logic
            return new User { Id = "user123", Role = "user" };
        }
        
        private async Task&lt;User&gt; ValidateApiKey(string apiKey)
        {
            // API key validation logic
            return new User { Id = "api_user", Role = "api" };
        }
        
        private async Task&lt;bool&gt; EvaluateAuthorizationCondition(RequestContext context, string condition)
        {
            // Authorization condition evaluation
            return true;
        }
        
        private string EvaluateRateLimitKey(RequestContext context, string keyExpression)
        {
            // Rate limit key evaluation
            return context.HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        }
        
        private async Task&lt;bool&gt; CheckRateLimitAllowed(string key, int requests, string window)
        {
            // Rate limit checking logic
            return true;
        }
        
        private string EvaluateCacheKey(RequestContext context, string keyExpression)
        {
            // Cache key evaluation
            return $"endpoint_{context.Endpoint.GroupName}_{context.Endpoint.EndpointName}";
        }
        
        private async Task&lt;object&gt; GetFromCache(string key)
        {
            // Cache retrieval logic
            return null;
        }
        
        private async Task&lt;object&gt; EvaluateHandlerExpression(RequestContext context, string expression)
        {
            // Handler expression evaluation
            return new { message = "Hello from TuskLang endpoint!" };
        }
        
        private async Task ExecuteSideEffect(RequestContext context, object result, string sideEffect)
        {
            // Side effect execution
            await Task.CompletedTask;
        }
        
        private async Task StoreInCache(string key, object value, string ttl)
        {
            // Cache storage logic
            await Task.CompletedTask;
        }
        
        private string ConvertToXml(object data)
        {
            // XML conversion logic
            return "&lt;response&gt;&lt;/response&gt;";
        }
        
        private string ConvertToCsv(object data)
        {
            // CSV conversion logic
            return "header1,header2\nvalue1,value2";
        }
        
        private int GetErrorStatusCode(Exception exception)
        {
            return exception switch
            {
                ValidationException =&gt; 422,
                AuthenticationException =&gt; 401,
                AuthorizationException =&gt; 403,
                NotFoundException =&gt; 404,
                RateLimitException =&gt; 429,
                _ =&gt; 500
            };
        }
        
        private async Task LogError(RequestContext context, Exception exception)
        {
            // Error logging logic
            Console.WriteLine($"Error in {context.Endpoint.Path}: {exception.Message}");
            await Task.CompletedTask;
        }
        
        private void ConfigureMiddleware(WebApplication app, Dictionary&lt;string, object&gt; middlewareConfig)
        {
            // Middleware configuration logic
        }
        
        private void ConfigureErrorHandling(WebApplication app, Dictionary&lt;string, object&gt; errorConfig)
        {
            // Error handling configuration logic
        }
    }
    
    // Supporting classes
    public class EndpointDefinition
    {
        public string GroupName { get; set; }
        public string EndpointName { get; set; }
        public string Method { get; set; }
        public string Path { get; set; }
        public Dictionary&lt;string, object&gt; Config { get; set; }
    }
    
    public class RequestContext
    {
        public HttpContext HttpContext { get; set; }
        public EndpointDefinition Endpoint { get; set; }
        public User User { get; set; }
        public DateTime StartTime { get; set; } = DateTime.UtcNow;
        public TimeSpan ExecutionTime =&gt; DateTime.UtcNow - StartTime;
        
        public RequestContext(HttpContext httpContext, EndpointDefinition endpoint)
        {
            HttpContext = httpContext;
            Endpoint = endpoint;
        }
    }
    
    public class User
    {
        public string Id { get; set; }
        public string Role { get; set; }
        public List&lt;string&gt; Permissions { get; set; } = new();
    }
    
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List&lt;ValidationError&gt; Errors { get; set; } = new();
    }
    
    public class ValidationError
    {
        public string Field { get; set; }
        public string Message { get; set; }
        public string Code { get; set; }
        public object InvalidValue { get; set; }
    }
    
    public class MiddlewareDefinition
    {
        public string Name { get; set; }
        public int Order { get; set; }
        public Dictionary&lt;string, object&gt; Config { get; set; }
    }
    
    public class ErrorHandlingConfig
    {
        public Dictionary&lt;string, object&gt; Global { get; set; } = new();
        public Dictionary&lt;string, object&gt; ErrorPages { get; set; } = new();
    }
    
    public class ResponseFormattingConfig
    {
        public Dictionary&lt;string, object&gt; Default { get; set; } = new();
        public Dictionary&lt;string, object&gt; Formats { get; set; } = new();
    }
    
    // Custom exceptions
    public class ValidationException : Exception
    {
        public List&lt;ValidationError&gt; ValidationErrors { get; }
        
        public ValidationException(string message, List&lt;ValidationError&gt; errors) : base(message)
        {
            ValidationErrors = errors;
        }
    }
    
    public class AuthenticationException : Exception
    {
        public AuthenticationException(string message) : base(message) { }
    }
    
    public class AuthorizationException : Exception
    {
        public AuthorizationException(string message) : base(message) { }
    }
    
    public class NotFoundException : Exception
    {
        public NotFoundException(string message) : base(message) { }
    }
    
    public class RateLimitException : Exception
    {
        public RateLimitException(string message) : base(message) { }
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using TuskLang.WebEndpoints;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddSingleton&lt;TuskWebEndpointEngine&gt;();

var app = builder.Build();

// Load TuskLang configuration
var parser = new TuskLangParser();
var configContent = await File.ReadAllTextAsync("endpoints.tsk");
var config = parser.Parse(configContent);

// Configure endpoints from TuskLang
var endpointEngine = app.Services.GetRequiredService&lt;TuskWebEndpointEngine&gt;();
endpointEngine.ConfigureEndpoints(app, config);

// Start the application
app.Run();
</pre>