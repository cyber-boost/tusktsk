<h1>Security & Validation</h1>

<h2>Security & Validation with TuskLang in C#</h2>
<p>Implement comprehensive security measures, input validation, authentication, authorization, and security monitoring using TuskLang configuration in C# applications.</p>

<h3>security.tsk</h3>
<pre>
# TuskLang Security & Validation Configuration

# 1. Authentication Configuration
authentication {
    # JWT Authentication
    jwt: {
        enabled: true
        
        # Token configuration
        token: {
            issuer: env("JWT_ISSUER", "myapp")
            audience: env("JWT_AUDIENCE", "myapp-api")
            secret: env("JWT_SECRET")  # Required
            algorithm: "HS256"         # HS256, RS256, ES256
            
            # Token lifetime
            access_token_lifetime: env("JWT_ACCESS_LIFETIME", "15m")
            refresh_token_lifetime: env("JWT_REFRESH_LIFETIME", "7d")
            
            # Token validation
            validate_issuer: true
            validate_audience: true
            validate_lifetime: true
            validate_signature: true
            clock_skew: "5m"  # Allow 5 minutes clock skew
        }
        
        # Key management
        keys: {
            # For RS256/ES256 algorithms
            public_key_path: env("JWT_PUBLIC_KEY_PATH")
            private_key_path: env("JWT_PRIVATE_KEY_PATH")
            
            # Key rotation
            rotation: {
                enabled: env("JWT_KEY_ROTATION", false)
                rotation_interval: "30d"
                overlap_period: "24h"  # Keep old key for 24h during rotation
            }
        }
        
        # Token sources
        sources: [
            {
                type: "header"
                name: "Authorization"
                prefix: "Bearer "
                required: true
            },
            {
                type: "cookie"
                name: "auth_token"
                required: false
                secure: true
                http_only: true
            },
            {
                type: "query"
                name: "token"
                required: false
            }
        ]
        
        # Claims configuration
        claims: {
            # Standard claims
            subject_claim: "sub"
            role_claim: "role"
            permission_claim: "permissions"
            
            # Custom claims
            custom_claims: [
                {
                    name: "tenant_id"
                    required: true
                    type: "string"
                },
                {
                    name: "user_type"
                    required: false
                    type: "string"
                    default: "regular"
                }
            ]
        }
    }
    
    # API Key Authentication
    api_key: {
        enabled: true
        
        # API key sources
        sources: [
            {
                type: "header"
                name: "X-API-Key"
                required: true
            },
            {
                type: "query"
                name: "api_key"
                required: false
            }
        ]
        
        # Key validation
        validation: {
            hash_algorithm: "SHA256"
            key_format: "uuid"  # uuid, base64, hex
            min_length: 32
            max_length: 128
            
            # Rate limiting per API key
            rate_limiting: {
                enabled: true
                requests_per_minute: 1000
                burst_limit: 100
            }
        }
        
        # Key management
        management: {
            auto_rotation: {
                enabled: false
                rotation_interval: "90d"
                notification_before: "7d"
            }
            
            # Key scoping
            scopes: [
                "read",
                "write", 
                "admin",
                "analytics"
            ]
        }
    }
    
    # OAuth 2.0 / OpenID Connect
    oauth: {
        enabled: env("OAUTH_ENABLED", false)
        
        # Provider configuration
        providers: [
            {
                name: "google"
                enabled: true
                
                # OAuth settings
                client_id: env("GOOGLE_CLIENT_ID")
                client_secret: env("GOOGLE_CLIENT_SECRET")
                
                # Endpoints
                authorization_endpoint: "https://accounts.google.com/o/oauth2/v2/auth"
                token_endpoint: "https://www.googleapis.com/oauth2/v4/token"
                user_info_endpoint: "https://www.googleapis.com/oauth2/v2/userinfo"
                
                # Scopes
                scopes: ["openid", "profile", "email"]
                
                # Claims mapping
                claims_mapping: {
                    sub: "id"
                    email: "email"
                    name: "name"
                    picture: "avatar_url"
                }
            },
            
            {
                name: "microsoft"
                enabled: true
                
                client_id: env("MICROSOFT_CLIENT_ID")
                client_secret: env("MICROSOFT_CLIENT_SECRET")
                
                # Azure AD endpoints
                authority: "https://login.microsoftonline.com/common/v2.0"
                scopes: ["openid", "profile", "email"]
            }
        ]
        
        # Callback configuration
        callback: {
            path: "/auth/callback"
            success_redirect: env("AUTH_SUCCESS_REDIRECT", "/dashboard")
            error_redirect: env("AUTH_ERROR_REDIRECT", "/login?error=auth_failed")
        }
    }
    
    # Multi-Factor Authentication
    mfa: {
        enabled: env("MFA_ENABLED", false)
        
        # TOTP (Time-based One-Time Password)
        totp: {
            enabled: true
            issuer: env("APP_NAME", "MyApp")
            
            # TOTP settings
            period: 30          # 30 seconds
            digits: 6           # 6 digit codes
            algorithm: "SHA1"   # SHA1, SHA256, SHA512
            
            # QR code generation
            qr_code: {
                size: 200       # 200x200 pixels
                error_correction: "M"  # L, M, Q, H
            }
        }
        
        # SMS-based authentication
        sms: {
            enabled: env("SMS_MFA_ENABLED", false)
            provider: env("SMS_PROVIDER", "twilio")  # twilio, aws_sns
            
            # SMS settings
            code_length: 6
            code_lifetime: "5m"
            max_attempts: 3
            
            # Provider configuration
            twilio: {
                account_sid: env("TWILIO_ACCOUNT_SID")
                auth_token: env("TWILIO_AUTH_TOKEN")
                from_number: env("TWILIO_FROM_NUMBER")
            }
        }
        
        # Email-based authentication
        email: {
            enabled: true
            
            # Email settings
            code_length: 8
            code_lifetime: "10m"
            max_attempts: 3
            
            # Email template
            template: {
                subject: "#{env('APP_NAME')} - Verification Code"
                body: """
                Your verification code is: {{code}}
                
                This code will expire in 10 minutes.
                
                If you didn't request this code, please ignore this email.
                """
            }
        }
        
        # Backup codes
        backup_codes: {
            enabled: true
            count: 10
            length: 8
            one_time_use: true
        }
    }
}

# 2. Authorization Configuration
authorization {
    # Role-Based Access Control (RBAC)
    rbac: {
        enabled: true
        
        # Role definitions
        roles: {
            admin: {
                description: "Full system access"
                permissions: ["*"]
                inherits: []
            }
            
            moderator: {
                description: "Content moderation access"
                permissions: [
                    "users:read",
                    "users:update",
                    "users:suspend",
                    "content:read",
                    "content:update",
                    "content:delete",
                    "reports:read",
                    "reports:update"
                ]
                inherits: ["user"]
            }
            
            user: {
                description: "Regular user access"
                permissions: [
                    "profile:read",
                    "profile:update",
                    "content:create",
                    "content:read_own",
                    "content:update_own",
                    "content:delete_own"
                ]
                inherits: ["guest"]
            }
            
            guest: {
                description: "Anonymous access"
                permissions: [
                    "content:read_public",
                    "auth:login",
                    "auth:register"
                ]
                inherits: []
            }
        }
        
        # Permission definitions
        permissions: {
            # User management
            "users:create": { description: "Create new users" }
            "users:read": { description: "Read user information" }
            "users:update": { description: "Update user information" }
            "users:delete": { description: "Delete users" }
            "users:suspend": { description: "Suspend/unsuspend users" }
            
            # Content management
            "content:create": { description: "Create content" }
            "content:read": { description: "Read all content" }
            "content:read_public": { description: "Read public content" }
            "content:read_own": { description: "Read own content" }
            "content:update": { description: "Update any content" }
            "content:update_own": { description: "Update own content" }
            "content:delete": { description: "Delete any content" }
            "content:delete_own": { description: "Delete own content" }
            
            # System administration
            "system:config": { description: "Modify system configuration" }
            "system:logs": { description: "Access system logs" }
            "system:metrics": { description: "Access system metrics" }
        }
        
        # Dynamic role assignment
        dynamic_roles: {
            enabled: true
            
            # Role assignment rules
            rules: [
                {
                    condition: @user.email.endsWith("@company.com")
                    role: "employee"
                    priority: 10
                },
                {
                    condition: @user.created_at < @now - @duration("30d") && @user.activity_score > 1000
                    role: "trusted_user"
                    priority: 5
                }
            ]
        }
    }
    
    # Attribute-Based Access Control (ABAC)
    abac: {
        enabled: env("ABAC_ENABLED", false)
        
        # Policy engine
        policy_engine: "opa"  # opa (Open Policy Agent), custom
        
        # Policy definitions
        policies: [
            {
                name: "user_data_access"
                description: "Users can only access their own data"
                
                policy: """
                allow {
                    input.user.id == input.resource.owner_id
                }
                
                allow {
                    input.user.role == "admin"
                }
                
                allow {
                    input.user.permissions[_] == "users:read"
                    input.action == "read"
                }
                """
                
                # Policy metadata
                version: "1.0"
                author: "security-team"
                tags: ["user-data", "privacy"]
            },
            
            {
                name: "content_modification"
                description: "Content modification rules"
                
                policy: """
                allow {
                    input.resource.type == "content"
                    input.action == "update"
                    input.user.id == input.resource.author_id
                    input.resource.status != "published"
                }
                
                allow {
                    input.resource.type == "content"
                    input.action == "update"
                    input.user.permissions[_] == "content:update"
                }
                """
            }
        ]
        
        # Context providers
        context_providers: [
            {
                name: "time_context"
                attributes: ["current_time", "business_hours", "timezone"]
            },
            {
                name: "location_context"
                attributes: ["ip_country", "geo_location", "office_location"]
            },
            {
                name: "device_context"
                attributes: ["device_type", "browser", "trusted_device"]
            }
        ]
    }
    
    # Resource-based authorization
    resource_authorization: {
        enabled: true
        
        # Resource ownership
        ownership: {
            enabled: true
            owner_field: "owner_id"
            
            # Ownership rules
            rules: [
                {
                    resource_type: "user_profile"
                    owner_field: "user_id"
                    allow_self_access: true
                },
                {
                    resource_type: "document"
                    owner_field: "author_id"
                    allow_self_access: true
                    allow_shared_access: true
                    shared_field: "shared_with"
                }
            ]
        }
        
        # Access Control Lists (ACLs)
        acls: {
            enabled: true
            
            # ACL structure
            structure: {
                read: ["user", "group", "public"]
                write: ["user", "group"]
                delete: ["user"]
                admin: ["user"]
            }
            
            # Default ACLs
            defaults: {
                user_profile: {
                    read: ["self", "admin"]
                    write: ["self", "admin"]
                    delete: ["admin"]
                }
                
                document: {
                    read: ["author", "admin"]
                    write: ["author", "admin"]
                    delete: ["author", "admin"]
                }
            }
        }
    }
}

# 3. Input Validation
input_validation {
    # Global validation settings
    global: {
        enabled: true
        
        # Default validation behavior
        strict_mode: env("VALIDATION_STRICT", true)
        sanitize_input: true
        trim_strings: true
        
        # Error handling
        error_handling: {
            return_first_error: false
            include_field_path: true
            include_validation_rules: env("INCLUDE_VALIDATION_RULES", false)
            
            # Custom error messages
            messages: {
                required: "This field is required"
                email: "Please enter a valid email address"
                min_length: "Must be at least {min} characters long"
                max_length: "Must be no more than {max} characters long"
                pattern: "Please enter a valid format"
                range: "Must be between {min} and {max}"
            }
        }
    }
    
    # Data type validation
    data_types: {
        # String validation
        string: {
            min_length: 0
            max_length: 1000
            trim: true
            
            # Common patterns
            patterns: {
                email: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
                phone: "^\\+?[1-9]\\d{1,14}$"
                url: "^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$"
                uuid: "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
                slug: "^[a-z0-9]+(?:-[a-z0-9]+)*$"
                username: "^[a-zA-Z0-9_]{3,20}$"
                password: "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$"
            }
            
            # Sanitization rules
            sanitization: {
                html_escape: true
                sql_escape: true
                remove_control_chars: true
                normalize_unicode: true
                
                # Blacklisted patterns
                blacklist: [
                    "<script",
                    "javascript:",
                    "data:text/html",
                    "vbscript:",
                    "onload=",
                    "onerror="
                ]
            }
        }
        
        # Numeric validation
        numeric: {
            integer: {
                min: @integer.min_value
                max: @integer.max_value
                allow_negative: true
            }
            
            decimal: {
                min: @decimal.min_value
                max: @decimal.max_value
                precision: 18
                scale: 2
                allow_negative: true
            }
            
            # Range validation
            ranges: {
                age: { min: 0, max: 150 }
                percentage: { min: 0, max: 100 }
                score: { min: 0, max: 1000 }
                rating: { min: 1, max: 5 }
            }
        }
        
        # Date/Time validation
        datetime: {
            # Date formats
            formats: [
                "yyyy-MM-dd",
                "dd/MM/yyyy",
                "MM/dd/yyyy",
                "yyyy-MM-ddTHH:mm:ss",
                "yyyy-MM-ddTHH:mm:ssZ"
            ]
            
            # Date ranges
            ranges: {
                birth_date: { 
                    min: "1900-01-01", 
                    max: @today 
                }
                
                future_date: { 
                    min: @today,
                    max: @today + @years(10)
                }
                
                business_hours: {
                    time_min: "09:00",
                    time_max: "17:00",
                    weekdays_only: true
                }
            }
        }
        
        # File validation
        file: {
            # Size limits
            max_size: "10MB"
            min_size: "1KB"
            
            # Allowed file types
            allowed_types: [
                "image/jpeg",
                "image/png", 
                "image/gif",
                "image/webp",
                "application/pdf",
                "text/plain",
                "application/msword",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            ]
            
            # File content validation
            content_validation: {
                enabled: true
                virus_scan: env("VIRUS_SCAN_ENABLED", false)
                
                # Magic number validation
                magic_numbers: {
                    "image/jpeg": ["FFD8FF"]
                    "image/png": ["89504E47"]
                    "application/pdf": ["255044462D"]
                }
            }
            
            # File name validation
            filename: {
                max_length: 255
                allowed_chars: "a-zA-Z0-9._-"
                blocked_names: ["CON", "PRN", "AUX", "NUL"]
            }
        }
    }
    
    # Schema validation
    schema_validation: {
        enabled: true
        
        # JSON Schema validation
        json_schema: {
            enabled: true
            version: "draft-07"
            
            # Common schemas
            schemas: {
                user_registration: {
                    type: "object"
                    required: ["email", "password", "firstName", "lastName"]
                    properties: {
                        email: {
                            type: "string"
                            format: "email"
                        }
                        password: {
                            type: "string"
                            minLength: 8
                            pattern: @patterns.password
                        }
                        firstName: {
                            type: "string"
                            minLength: 1
                            maxLength: 50
                        }
                        lastName: {
                            type: "string"
                            minLength: 1
                            maxLength: 50
                        }
                        age: {
                            type: "integer"
                            minimum: 13
                            maximum: 120
                        }
                    }
                }
                
                user_profile_update: {
                    type: "object"
                    properties: {
                        firstName: {
                            type: "string"
                            minLength: 1
                            maxLength: 50
                        }
                        lastName: {
                            type: "string"
                            minLength: 1
                            maxLength: 50
                        }
                        bio: {
                            type: "string"
                            maxLength: 500
                        }
                        website: {
                            type: "string"
                            format: "uri"
                        }
                    }
                }
            }
        }
        
        # Custom validation rules
        custom_rules: [
            {
                name: "unique_email"
                description: "Email must be unique"
                validator: @check_email_uniqueness
                async: true
            },
            
            {
                name: "strong_password"
                description: "Password must meet strength requirements"
                validator: @validate_password_strength
                parameters: {
                    min_length: 8
                    require_uppercase: true
                    require_lowercase: true
                    require_digit: true
                    require_special: true
                    max_repeated_chars: 2
                }
            },
            
            {
                name: "valid_timezone"
                description: "Must be a valid timezone identifier"
                validator: @validate_timezone
            }
        ]
    }
}

# 4. Security Monitoring
security_monitoring {
    # Threat detection
    threat_detection: {
        enabled: true
        
        # Failed authentication tracking
        failed_auth: {
            enabled: true
            threshold: 5              # Failed attempts
            window: "5m"              # Time window
            
            # Actions
            actions: [
                {
                    trigger: "threshold_exceeded"
                    action: "lock_account"
                    duration: "15m"
                },
                {
                    trigger: "threshold_exceeded"
                    action: "log_security_event"
                    severity: "warning"
                },
                {
                    trigger: "multiple_ips"
                    action: "flag_suspicious_activity"
                    notify_security_team: true
                }
            ]
            
            # Account lockout
            lockout: {
                enabled: true
                duration: "15m"
                max_lockout_duration: "24h"
                progressive_lockout: true  # Increase duration with repeated violations
            }
        }
        
        # Brute force detection
        brute_force: {
            enabled: true
            
            # Detection parameters
            thresholds: {
                requests_per_minute: 60
                failed_logins_per_hour: 20
                unique_usernames_per_ip: 10
            }
            
            # Response actions
            response: {
                rate_limit: {
                    enabled: true
                    limit: 10              # Requests per minute
                    duration: "10m"
                }
                
                ip_blocking: {
                    enabled: true
                    duration: "1h"
                    progressive_blocking: true
                }
                
                captcha: {
                    enabled: true
                    trigger_threshold: 3   # Failed attempts before CAPTCHA
                    provider: "recaptcha"
                }
            }
        }
        
        # Anomaly detection
        anomaly_detection: {
            enabled: true
            
            # User behavior analysis
            user_behavior: {
                track_login_patterns: true
                track_access_patterns: true
                track_geographic_patterns: true
                
                # Anomaly thresholds
                thresholds: {
                    unusual_login_time: 0.8      # Probability threshold
                    unusual_location: 0.9        # Probability threshold
                    unusual_device: 0.7          # Probability threshold
                    unusual_access_pattern: 0.8  # Probability threshold
                }
                
                # Machine learning model
                ml_model: {
                    algorithm: "isolation_forest"
                    training_window: "30d"
                    retrain_interval: "7d"
                    
                    # Features
                    features: [
                        "login_time_of_day",
                        "login_day_of_week",
                        "ip_geolocation",
                        "user_agent",
                        "session_duration",
                        "pages_accessed",
                        "api_endpoints_used"
                    ]
                }
            }
            
            # Network anomaly detection
            network_anomalies: {
                enabled: true
                
                # Traffic analysis
                traffic_analysis: {
                    monitor_request_volume: true
                    monitor_response_sizes: true
                    monitor_error_rates: true
                    
                    # Anomaly detection
                    volume_threshold: 2.0    # Standard deviations from normal
                    error_rate_threshold: 3.0
                    response_time_threshold: 2.5
                }
                
                # DDoS detection
                ddos_detection: {
                    enabled: true
                    
                    # Detection criteria
                    criteria: {
                        requests_per_second: 1000
                        unique_ips_threshold: 100
                        suspicious_user_agents: true
                        geographic_distribution: 0.3  # Requests from too few countries
                    }
                    
                    # Mitigation
                    mitigation: {
                        auto_enable_rate_limiting: true
                        auto_block_suspicious_ips: true
                        notify_infrastructure_team: true
                    }
                }
            }
        }
        
        # Security event correlation
        event_correlation: {
            enabled: true
            
            # Correlation rules
            rules: [
                {
                    name: "coordinated_attack"
                    description: "Multiple IPs attacking same user"
                    
                    conditions: [
                        "failed_login_attempts > 3",
                        "unique_source_ips > 5",
                        "time_window < 10m"
                    ]
                    
                    actions: [
                        "escalate_to_security_team",
                        "enable_enhanced_monitoring",
                        "auto_block_attacking_ips"
                    ]
                },
                
                {
                    name: "privilege_escalation_attempt"
                    description: "User attempting to access restricted resources"
                    
                    conditions: [
                        "authorization_failures > 5",
                        "access_pattern_unusual == true",
                        "role_elevation_requests > 0"
                    ]
                    
                    actions: [
                        "flag_user_for_review",
                        "require_mfa_for_session",
                        "log_detailed_audit_trail"
                    ]
                }
            ]
        }
    }
    
    # Security logging and auditing
    security_logging: {
        enabled: true
        
        # Audit trail
        audit_trail: {
            enabled: true
            
            # Events to log
            events: [
                "user_login",
                "user_logout", 
                "failed_login",
                "password_change",
                "role_change",
                "permission_grant",
                "permission_revoke",
                "data_access",
                "data_modification",
                "admin_action",
                "security_event"
            ]
            
            # Log format
            format: {
                timestamp: @now.iso8601
                event_type: @event.type
                user_id: @user.id
                session_id: @session.id
                ip_address: @request.ip
                user_agent: @request.user_agent
                resource: @resource.identifier
                action: @action.name
                result: @action.result
                details: @event.details
                risk_score: @security.risk_score
            }
            
            # Storage configuration
            storage: {
                type: "database"  # database, file, siem
                retention: "7y"   # 7 years retention
                compression: true
                encryption: true
                
                # Integrity protection
                integrity: {
                    enabled: true
                    hash_algorithm: "SHA256"
                    digital_signatures: true
                }
            }
        }
        
        # SIEM integration
        siem_integration: {
            enabled: env("SIEM_INTEGRATION", false)
            
            # SIEM providers
            providers: [
                {
                    name: "splunk"
                    enabled: env("SPLUNK_ENABLED", false)
                    endpoint: env("SPLUNK_ENDPOINT")
                    token: env("SPLUNK_TOKEN")
                    index: env("SPLUNK_INDEX", "security")
                },
                
                {
                    name: "elastic"
                    enabled: env("ELASTIC_ENABLED", false)
                    endpoint: env("ELASTIC_ENDPOINT")
                    username: env("ELASTIC_USERNAME")
                    password: env("ELASTIC_PASSWORD")
                    index: env("ELASTIC_INDEX", "security-logs")
                }
            ]
            
            # Event filtering
            filtering: {
                # Include only high-value security events
                include_events: [
                    "failed_login",
                    "privilege_escalation",
                    "data_breach_attempt",
                    "admin_action",
                    "security_violation"
                ]
                
                # Exclude noisy events
                exclude_patterns: [
                    "health_check",
                    "metrics_collection",
                    "debug_logs"
                ]
            }
        }
    }
    
    # Compliance and reporting
    compliance: {
        enabled: true
        
        # Compliance frameworks
        frameworks: [
            {
                name: "gdpr"
                enabled: env("GDPR_COMPLIANCE", true)
                
                requirements: [
                    "data_protection_by_design",
                    "consent_management",
                    "right_to_be_forgotten",
                    "data_portability",
                    "breach_notification"
                ]
                
                # GDPR-specific controls
                controls: {
                    data_retention: {
                        max_retention: "6y"
                        auto_deletion: true
                        deletion_schedule: "monthly"
                    }
                    
                    consent_tracking: {
                        enabled: true
                        granular_consent: true
                        consent_history: true
                        withdrawal_tracking: true
                    }
                    
                    data_subject_rights: {
                        access_request_sla: "30d"
                        deletion_request_sla: "30d"
                        portability_format: "json"
                    }
                }
            },
            
            {
                name: "sox"
                enabled: env("SOX_COMPLIANCE", false)
                
                requirements: [
                    "financial_data_protection",
                    "audit_trail_integrity", 
                    "segregation_of_duties",
                    "change_management"
                ]
                
                controls: {
                    financial_controls: {
                        approval_workflows: true
                        dual_authorization: true
                        periodic_reviews: "quarterly"
                    }
                }
            }
        ]
        
        # Automated reporting
        reporting: {
            enabled: true
            
            # Report types
            reports: [
                {
                    name: "security_dashboard"
                    frequency: "daily"
                    recipients: ["security-team@company.com"]
                    
                    metrics: [
                        "failed_login_attempts",
                        "security_violations",
                        "anomaly_detections",
                        "threat_incidents"
                    ]
                },
                
                {
                    name: "compliance_summary"
                    frequency: "monthly"
                    recipients: ["compliance@company.com", "management@company.com"]
                    
                    content: [
                        "compliance_status",
                        "policy_violations",
                        "audit_findings",
                        "remediation_progress"
                    ]
                }
            ]
        }
    }
}
</pre>

<h3>TuskSecurityValidator.cs</h3>
<pre>
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace TuskLang.Security
{
    // Main security and validation engine
    public class TuskSecurityValidator
    {
        private readonly ILogger&lt;TuskSecurityValidator&gt; _logger;
        private readonly SecurityConfig _config;
        private readonly ConcurrentDictionary&lt;string, ValidationRule&gt; _validationRules;
        private readonly ConcurrentDictionary&lt;string, SecurityEvent&gt; _securityEvents;
        private readonly ConcurrentDictionary&lt;string, ThreatDetectionState&gt; _threatStates;
        
        public TuskSecurityValidator(ILogger&lt;TuskSecurityValidator&gt; logger, SecurityConfig config)
        {
            _logger = logger;
            _config = config;
            _validationRules = new ConcurrentDictionary&lt;string, ValidationRule&gt;();
            _securityEvents = new ConcurrentDictionary&lt;string, SecurityEvent&gt;();
            _threatStates = new ConcurrentDictionary&lt;string, ThreatDetectionState&gt;();
            
            InitializeValidationRules();
        }
        
        // Validate input data
        public async Task&lt;ValidationResult&gt; ValidateInputAsync(object input, string schemaName, ValidationContext context = null)
        {
            context ??= new ValidationContext();
            var result = new ValidationResult();
            
            try
            {
                // Schema validation
                if (_config.SchemaValidation.TryGetValue(schemaName, out var schema))
                {
                    var schemaResult = await ValidateAgainstSchema(input, schema);
                    result.AddErrors(schemaResult.Errors);
                }
                
                // Custom validation rules
                var customResult = await ApplyCustomValidationRules(input, schemaName, context);
                result.AddErrors(customResult.Errors);
                
                // Sanitization
                if (_config.SanitizeInput)
                {
                    result.SanitizedInput = await SanitizeInput(input);
                }
                
                result.IsValid = !result.Errors.Any();
                
                // Log validation attempt
                await LogValidationAttempt(input, schemaName, result, context);
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during input validation for schema {SchemaName}", schemaName);
                result.AddError("validation_error", "An error occurred during validation");
                return result;
            }
        }
        
        // Authenticate user
        public async Task&lt;AuthenticationResult&gt; AuthenticateAsync(AuthenticationRequest request)
        {
            var result = new AuthenticationResult();
            
            try
            {
                // Check for brute force attacks
                if (await IsBruteForceAttack(request))
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "brute_force_detected";
                    result.ErrorMessage = "Too many failed attempts. Please try again later.";
                    
                    await LogSecurityEvent("brute_force_attempt", request);
                    return result;
                }
                
                // Validate credentials based on authentication type
                switch (request.AuthenticationType)
                {
                    case AuthenticationType.JWT:
                        result = await AuthenticateJwt(request);
                        break;
                        
                    case AuthenticationType.ApiKey:
                        result = await AuthenticateApiKey(request);
                        break;
                        
                    case AuthenticationType.UsernamePassword:
                        result = await AuthenticateUsernamePassword(request);
                        break;
                        
                    default:
                        result.IsSuccess = false;
                        result.ErrorCode = "unsupported_auth_type";
                        result.ErrorMessage = "Unsupported authentication type";
                        break;
                }
                
                // Track authentication attempt
                await TrackAuthenticationAttempt(request, result);
                
                // Check for anomalies
                if (result.IsSuccess)
                {
                    await CheckAuthenticationAnomalies(request, result);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during authentication");
                result.IsSuccess = false;
                result.ErrorCode = "authentication_error";
                result.ErrorMessage = "An error occurred during authentication";
                return result;
            }
        }
        
        // Authorize user action
        public async Task&lt;AuthorizationResult&gt; AuthorizeAsync(AuthorizationRequest request)
        {
            var result = new AuthorizationResult();
            
            try
            {
                // RBAC authorization
                if (_config.RbacEnabled)
                {
                    var rbacResult = await AuthorizeWithRbac(request);
                    if (!rbacResult.IsAuthorized)
                    {
                        result.IsAuthorized = false;
                        result.DenialReason = rbacResult.DenialReason;
                        return result;
                    }
                }
                
                // ABAC authorization
                if (_config.AbacEnabled)
                {
                    var abacResult = await AuthorizeWithAbac(request);
                    if (!abacResult.IsAuthorized)
                    {
                        result.IsAuthorized = false;
                        result.DenialReason = abacResult.DenialReason;
                        return result;
                    }
                }
                
                // Resource-based authorization
                if (request.Resource != null)
                {
                    var resourceResult = await AuthorizeResourceAccess(request);
                    if (!resourceResult.IsAuthorized)
                    {
                        result.IsAuthorized = false;
                        result.DenialReason = resourceResult.DenialReason;
                        return result;
                    }
                }
                
                result.IsAuthorized = true;
                
                // Log successful authorization
                await LogSecurityEvent("authorization_success", request);
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during authorization");
                result.IsAuthorized = false;
                result.DenialReason = "Authorization error occurred";
                
                await LogSecurityEvent("authorization_error", request, ex);
                return result;
            }
        }
        
        // Detect security threats
        public async Task&lt;ThreatDetectionResult&gt; DetectThreatsAsync(SecurityContext context)
        {
            var result = new ThreatDetectionResult();
            
            try
            {
                // Failed authentication detection
                var failedAuthThreats = await DetectFailedAuthenticationThreats(context);
                result.Threats.AddRange(failedAuthThreats);
                
                // Anomaly detection
                var anomalies = await DetectAnomalies(context);
                result.Threats.AddRange(anomalies);
                
                // Brute force detection
                var bruteForceThreats = await DetectBruteForceAttacks(context);
                result.Threats.AddRange(bruteForceThreats);
                
                // DDoS detection
                var ddosThreats = await DetectDdosAttacks(context);
                result.Threats.AddRange(ddosThreats);
                
                // Calculate overall risk score
                result.RiskScore = CalculateRiskScore(result.Threats);
                
                // Take automated actions if necessary
                if (result.RiskScore &gt; _config.AutoActionThreshold)
                {
                    await TakeAutomatedSecurityActions(result, context);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during threat detection");
                result.Threats.Add(new SecurityThreat
                {
                    Type = "system_error",
                    Severity = ThreatSeverity.High,
                    Description = "Error occurred during threat detection",
                    Context = context
                });
                return result;
            }
        }
        
        // Initialize validation rules
        private void InitializeValidationRules()
        {
            // Email validation
            _validationRules["email"] = new ValidationRule
            {
                Name = "email",
                Pattern = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
                ErrorMessage = "Please enter a valid email address"
            };
            
            // Password validation
            _validationRules["strong_password"] = new ValidationRule
            {
                Name = "strong_password",
                Pattern = @"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$",
                ErrorMessage = "Password must be at least 8 characters with uppercase, lowercase, digit, and special character"
            };
            
            // Phone validation
            _validationRules["phone"] = new ValidationRule
            {
                Name = "phone",
                Pattern = @"^\+?[1-9]\d{1,14}$",
                ErrorMessage = "Please enter a valid phone number"
            };
            
            // URL validation
            _validationRules["url"] = new ValidationRule
            {
                Name = "url",
                Pattern = @"^https?://(?:[-\w.])+(?:\:[0-9]+)?(?:/(?:[\w/_.])*(?:\?(?:[\w&=%.])*)?(?:#(?:[\w.])*)?)?$",
                ErrorMessage = "Please enter a valid URL"
            };
        }
        
        // Validate against JSON schema
        private async Task&lt;ValidationResult&gt; ValidateAgainstSchema(object input, JsonSchema schema)
        {
            var result = new ValidationResult();
            
            // Simplified schema validation - would use a library like Newtonsoft.Json.Schema
            var json = JsonSerializer.Serialize(input);
            
            // Validate required fields
            if (schema.Required != null)
            {
                var inputDict = JsonSerializer.Deserialize&lt;Dictionary&lt;string, object&gt;&gt;(json);
                foreach (var requiredField in schema.Required)
                {
                    if (!inputDict.ContainsKey(requiredField))
                    {
                        result.AddError(requiredField, $"Field '{requiredField}' is required");
                    }
                }
            }
            
            return await Task.FromResult(result);
        }
        
        // Apply custom validation rules
        private async Task&lt;ValidationResult&gt; ApplyCustomValidationRules(object input, string schemaName, ValidationContext context)
        {
            var result = new ValidationResult();
            
            // Apply pattern-based validations
            var properties = input.GetType().GetProperties();
            foreach (var property in properties)
            {
                var value = property.GetValue(input)?.ToString();
                if (string.IsNullOrEmpty(value)) continue;
                
                // Check for validation attributes or rules
                var validationAttributes = property.GetCustomAttributes(typeof(ValidationAttribute), true);
                foreach (ValidationAttribute attr in validationAttributes)
                {
                    if (!attr.IsValid(value))
                    {
                        result.AddError(property.Name, attr.ErrorMessage ?? $"Validation failed for {property.Name}");
                    }
                }
            }
            
            return await Task.FromResult(result);
        }
        
        // Sanitize input data
        private async Task&lt;object&gt; SanitizeInput(object input)
        {
            // HTML encoding, SQL injection prevention, etc.
            var json = JsonSerializer.Serialize(input);
            var sanitized = json
                .Replace("&lt;script", "&amp;lt;script", StringComparison.OrdinalIgnoreCase)
                .Replace("javascript:", "javascript_", StringComparison.OrdinalIgnoreCase)
                .Replace("&lt;img", "&amp;lt;img", StringComparison.OrdinalIgnoreCase);
            
            return await Task.FromResult(JsonSerializer.Deserialize&lt;object&gt;(sanitized));
        }
        
        // Check for brute force attacks
        private async Task&lt;bool&gt; IsBruteForceAttack(AuthenticationRequest request)
        {
            var key = $"auth_attempts_{request.IpAddress}_{request.Username}";
            
            if (_threatStates.TryGetValue(key, out var state))
            {
                var timeWindow = TimeSpan.FromMinutes(5);
                var recentAttempts = state.Attempts.Count(a =&gt; DateTime.UtcNow - a &lt; timeWindow);
                
                return recentAttempts &gt;= _config.BruteForceThreshold;
            }
            
            return await Task.FromResult(false);
        }
        
        // Authenticate JWT token
        private async Task&lt;AuthenticationResult&gt; AuthenticateJwt(AuthenticationRequest request)
        {
            var result = new AuthenticationResult();
            
            try
            {
                // JWT validation logic would go here
                // For now, simplified validation
                if (string.IsNullOrEmpty(request.Token))
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "missing_token";
                    result.ErrorMessage = "JWT token is required";
                    return result;
                }
                
                // Validate token format, signature, expiration, etc.
                var isValid = await ValidateJwtToken(request.Token);
                if (isValid)
                {
                    result.IsSuccess = true;
                    result.User = await ExtractUserFromToken(request.Token);
                }
                else
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "invalid_token";
                    result.ErrorMessage = "Invalid or expired token";
                }
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error validating JWT token");
                result.IsSuccess = false;
                result.ErrorCode = "token_validation_error";
                result.ErrorMessage = "Error validating token";
                return result;
            }
        }
        
        // Authenticate API key
        private async Task&lt;AuthenticationResult&gt; AuthenticateApiKey(AuthenticationRequest request)
        {
            var result = new AuthenticationResult();
            
            try
            {
                if (string.IsNullOrEmpty(request.ApiKey))
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "missing_api_key";
                    result.ErrorMessage = "API key is required";
                    return result;
                }
                
                // Validate API key
                var isValid = await ValidateApiKey(request.ApiKey);
                if (isValid)
                {
                    result.IsSuccess = true;
                    result.User = await GetUserByApiKey(request.ApiKey);
                }
                else
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "invalid_api_key";
                    result.ErrorMessage = "Invalid API key";
                }
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error validating API key");
                result.IsSuccess = false;
                result.ErrorCode = "api_key_validation_error";
                result.ErrorMessage = "Error validating API key";
                return result;
            }
        }
        
        // Authenticate username/password
        private async Task&lt;AuthenticationResult&gt; AuthenticateUsernamePassword(AuthenticationRequest request)
        {
            var result = new AuthenticationResult();
            
            try
            {
                if (string.IsNullOrEmpty(request.Username) || string.IsNullOrEmpty(request.Password))
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "missing_credentials";
                    result.ErrorMessage = "Username and password are required";
                    return result;
                }
                
                // Validate credentials
                var user = await GetUserByUsername(request.Username);
                if (user != null && await VerifyPassword(request.Password, user.PasswordHash))
                {
                    result.IsSuccess = true;
                    result.User = user;
                }
                else
                {
                    result.IsSuccess = false;
                    result.ErrorCode = "invalid_credentials";
                    result.ErrorMessage = "Invalid username or password";
                }
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error validating username/password");
                result.IsSuccess = false;
                result.ErrorCode = "credential_validation_error";
                result.ErrorMessage = "Error validating credentials";
                return result;
            }
        }
        
        // Authorize with RBAC
        private async Task&lt;AuthorizationResult&gt; AuthorizeWithRbac(AuthorizationRequest request)
        {
            var result = new AuthorizationResult();
            
            // Check if user has required role
            if (request.RequiredRole != null)
            {
                if (!request.User.Roles.Contains(request.RequiredRole))
                {
                    result.IsAuthorized = false;
                    result.DenialReason = $"User does not have required role: {request.RequiredRole}";
                    return result;
                }
            }
            
            // Check if user has required permission
            if (request.RequiredPermission != null)
            {
                var hasPermission = await UserHasPermission(request.User, request.RequiredPermission);
                if (!hasPermission)
                {
                    result.IsAuthorized = false;
                    result.DenialReason = $"User does not have required permission: {request.RequiredPermission}";
                    return result;
                }
            }
            
            result.IsAuthorized = true;
            return result;
        }
        
        // Authorize with ABAC
        private async Task&lt;AuthorizationResult&gt; AuthorizeWithAbac(AuthorizationRequest request)
        {
            var result = new AuthorizationResult();
            
            // ABAC policy evaluation would go here
            // For now, simplified implementation
            result.IsAuthorized = true;
            
            return await Task.FromResult(result);
        }
        
        // Authorize resource access
        private async Task&lt;AuthorizationResult&gt; AuthorizeResourceAccess(AuthorizationRequest request)
        {
            var result = new AuthorizationResult();
            
            // Check resource ownership
            if (request.Resource.OwnerId != null && request.Resource.OwnerId == request.User.Id)
            {
                result.IsAuthorized = true;
                return result;
            }
            
            // Check ACLs
            if (request.Resource.AccessControlList != null)
            {
                var hasAccess = request.Resource.AccessControlList.Any(acl =&gt; 
                    acl.PrincipalId == request.User.Id && acl.Permission == request.Action);
                
                if (hasAccess)
                {
                    result.IsAuthorized = true;
                    return result;
                }
            }
            
            result.IsAuthorized = false;
            result.DenialReason = "No access to resource";
            return result;
        }
        
        // Helper methods (simplified implementations)
        private async Task&lt;bool&gt; ValidateJwtToken(string token)
        {
            // JWT validation logic
            return await Task.FromResult(!string.IsNullOrEmpty(token) && token.Length &gt; 20);
        }
        
        private async Task&lt;User&gt; ExtractUserFromToken(string token)
        {
            // Extract user from JWT claims
            return await Task.FromResult(new User { Id = "user123", Username = "testuser" });
        }
        
        private async Task&lt;bool&gt; ValidateApiKey(string apiKey)
        {
            // API key validation logic
            return await Task.FromResult(!string.IsNullOrEmpty(apiKey) && apiKey.Length == 32);
        }
        
        private async Task&lt;User&gt; GetUserByApiKey(string apiKey)
        {
            // Get user by API key
            return await Task.FromResult(new User { Id = "api_user", Username = "api_user" });
        }
        
        private async Task&lt;User&gt; GetUserByUsername(string username)
        {
            // Get user from database
            return await Task.FromResult(new User { Id = "user123", Username = username, PasswordHash = "hashed_password" });
        }
        
        private async Task&lt;bool&gt; VerifyPassword(string password, string hash)
        {
            // Password verification logic
            return await Task.FromResult(password == "password123"); // Simplified
        }
        
        private async Task&lt;bool&gt; UserHasPermission(User user, string permission)
        {
            // Check user permissions
            return await Task.FromResult(user.Permissions.Contains(permission));
        }
        
        private async Task LogValidationAttempt(object input, string schema, ValidationResult result, ValidationContext context)
        {
            // Log validation attempt
            await Task.CompletedTask;
        }
        
        private async Task LogSecurityEvent(string eventType, object context, Exception ex = null)
        {
            // Log security event
            await Task.CompletedTask;
        }
        
        private async Task TrackAuthenticationAttempt(AuthenticationRequest request, AuthenticationResult result)
        {
            // Track authentication attempt for threat detection
            await Task.CompletedTask;
        }
        
        private async Task CheckAuthenticationAnomalies(AuthenticationRequest request, AuthenticationResult result)
        {
            // Check for authentication anomalies
            await Task.CompletedTask;
        }
        
        private async Task&lt;List&lt;SecurityThreat&gt;&gt; DetectFailedAuthenticationThreats(SecurityContext context)
        {
            // Detect failed authentication threats
            return await Task.FromResult(new List&lt;SecurityThreat&gt;());
        }
        
        private async Task&lt;List&lt;SecurityThreat&gt;&gt; DetectAnomalies(SecurityContext context)
        {
            // Detect behavioral anomalies
            return await Task.FromResult(new List&lt;SecurityThreat&gt;());
        }
        
        private async Task&lt;List&lt;SecurityThreat&gt;&gt; DetectBruteForceAttacks(SecurityContext context)
        {
            // Detect brute force attacks
            return await Task.FromResult(new List&lt;SecurityThreat&gt;());
        }
        
        private async Task&lt;List&lt;SecurityThreat&gt;&gt; DetectDdosAttacks(SecurityContext context)
        {
            // Detect DDoS attacks
            return await Task.FromResult(new List&lt;SecurityThreat&gt;());
        }
        
        private double CalculateRiskScore(List&lt;SecurityThreat&gt; threats)
        {
            // Calculate overall risk score
            return threats.Sum(t =&gt; (int)t.Severity) / 10.0;
        }
        
        private async Task TakeAutomatedSecurityActions(ThreatDetectionResult result, SecurityContext context)
        {
            // Take automated security actions
            await Task.CompletedTask;
        }
    }
}
</pre>

<h3>Supporting Classes</h3>
<pre>
namespace TuskLang.Security
{
    // Configuration
    public class SecurityConfig
    {
        public bool RbacEnabled { get; set; } = true;
        public bool AbacEnabled { get; set; } = false;
        public bool SanitizeInput { get; set; } = true;
        public int BruteForceThreshold { get; set; } = 5;
        public double AutoActionThreshold { get; set; } = 8.0;
        public Dictionary&lt;string, JsonSchema&gt; SchemaValidation { get; set; } = new();
    }
    
    // Validation
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List&lt;ValidationError&gt; Errors { get; set; } = new();
        public object SanitizedInput { get; set; }
        
        public void AddError(string field, string message)
        {
            Errors.Add(new ValidationError { Field = field, Message = message });
        }
        
        public void AddErrors(IEnumerable&lt;ValidationError&gt; errors)
        {
            Errors.AddRange(errors);
        }
    }
    
    public class ValidationError
    {
        public string Field { get; set; }
        public string Message { get; set; }
        public string Code { get; set; }
        public object InvalidValue { get; set; }
    }
    
    public class ValidationRule
    {
        public string Name { get; set; }
        public string Pattern { get; set; }
        public string ErrorMessage { get; set; }
        public Func&lt;object, ValidationContext, Task&lt;bool&gt;&gt; CustomValidator { get; set; }
    }
    
    public class ValidationContext
    {
        public string UserId { get; set; }
        public string SessionId { get; set; }
        public string IpAddress { get; set; }
        public Dictionary&lt;string, object&gt; AdditionalContext { get; set; } = new();
    }
    
    // Authentication
    public class AuthenticationRequest
    {
        public AuthenticationType AuthenticationType { get; set; }
        public string Username { get; set; }
        public string Password { get; set; }
        public string Token { get; set; }
        public string ApiKey { get; set; }
        public string IpAddress { get; set; }
        public string UserAgent { get; set; }
        public Dictionary&lt;string, object&gt; AdditionalContext { get; set; } = new();
    }
    
    public class AuthenticationResult
    {
        public bool IsSuccess { get; set; }
        public User User { get; set; }
        public string ErrorCode { get; set; }
        public string ErrorMessage { get; set; }
        public DateTime AuthenticatedAt { get; set; } = DateTime.UtcNow;
        public TimeSpan ExpiresIn { get; set; }
        public Dictionary&lt;string, object&gt; AdditionalData { get; set; } = new();
    }
    
    public enum AuthenticationType
    {
        JWT,
        ApiKey,
        UsernamePassword,
        OAuth,
        Certificate
    }
    
    // Authorization
    public class AuthorizationRequest
    {
        public User User { get; set; }
        public string Action { get; set; }
        public Resource Resource { get; set; }
        public string RequiredRole { get; set; }
        public string RequiredPermission { get; set; }
        public SecurityContext Context { get; set; }
    }
    
    public class AuthorizationResult
    {
        public bool IsAuthorized { get; set; }
        public string DenialReason { get; set; }
        public List&lt;string&gt; RequiredRoles { get; set; } = new();
        public List&lt;string&gt; RequiredPermissions { get; set; } = new();
        public Dictionary&lt;string, object&gt; AdditionalData { get; set; } = new();
    }
    
    // User and Resource
    public class User
    {
        public string Id { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public List&lt;string&gt; Roles { get; set; } = new();
        public List&lt;string&gt; Permissions { get; set; } = new();
        public string PasswordHash { get; set; }
        public DateTime LastLogin { get; set; }
        public Dictionary&lt;string, object&gt; Profile { get; set; } = new();
    }
    
    public class Resource
    {
        public string Id { get; set; }
        public string Type { get; set; }
        public string OwnerId { get; set; }
        public List&lt;AccessControlEntry&gt; AccessControlList { get; set; } = new();
        public Dictionary&lt;string, object&gt; Attributes { get; set; } = new();
    }
    
    public class AccessControlEntry
    {
        public string PrincipalId { get; set; }
        public string PrincipalType { get; set; } // user, group, role
        public string Permission { get; set; }
        public DateTime GrantedAt { get; set; }
        public string GrantedBy { get; set; }
    }
    
    // Security monitoring
    public class SecurityContext
    {
        public string SessionId { get; set; }
        public string IpAddress { get; set; }
        public string UserAgent { get; set; }
        public string GeoLocation { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public Dictionary&lt;string, object&gt; AdditionalContext { get; set; } = new();
    }
    
    public class ThreatDetectionResult
    {
        public List&lt;SecurityThreat&gt; Threats { get; set; } = new();
        public double RiskScore { get; set; }
        public List&lt;string&gt; RecommendedActions { get; set; } = new();
        public DateTime DetectedAt { get; set; } = DateTime.UtcNow;
    }
    
    public class SecurityThreat
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public string Type { get; set; }
        public ThreatSeverity Severity { get; set; }
        public string Description { get; set; }
        public SecurityContext Context { get; set; }
        public DateTime DetectedAt { get; set; } = DateTime.UtcNow;
        public Dictionary&lt;string, object&gt; Evidence { get; set; } = new();
    }
    
    public enum ThreatSeverity
    {
        Low = 1,
        Medium = 3,
        High = 7,
        Critical = 10
    }
    
    public class ThreatDetectionState
    {
        public List&lt;DateTime&gt; Attempts { get; set; } = new();
        public DateTime LastAttempt { get; set; }
        public int ConsecutiveFailures { get; set; }
        public bool IsBlocked { get; set; }
        public DateTime? BlockedUntil { get; set; }
    }
    
    public class SecurityEvent
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public string Type { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public string UserId { get; set; }
        public string SessionId { get; set; }
        public string IpAddress { get; set; }
        public string UserAgent { get; set; }
        public Dictionary&lt;string, object&gt; Details { get; set; } = new();
    }
    
    // Schema validation
    public class JsonSchema
    {
        public string Type { get; set; }
        public List&lt;string&gt; Required { get; set; }
        public Dictionary&lt;string, JsonSchemaProperty&gt; Properties { get; set; } = new();
    }
    
    public class JsonSchemaProperty
    {
        public string Type { get; set; }
        public string Format { get; set; }
        public int? MinLength { get; set; }
        public int? MaxLength { get; set; }
        public string Pattern { get; set; }
        public object Default { get; set; }
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using TuskLang.Security;

class Program
{
    static async Task Main(string[] args)
    {
        // Setup dependency injection
        var serviceProvider = new ServiceCollection()
            .AddLogging(builder =&gt; builder.AddConsole())
            .AddSingleton&lt;SecurityConfig&gt;(provider =&gt;
            {
                var config = new SecurityConfig
                {
                    RbacEnabled = true,
                    SanitizeInput = true,
                    BruteForceThreshold = 5
                };
                
                // Configure validation schemas
                config.SchemaValidation["user_registration"] = new JsonSchema
                {
                    Type = "object",
                    Required = new List&lt;string&gt; { "email", "password" },
                    Properties = new Dictionary&lt;string, JsonSchemaProperty&gt;
                    {
                        ["email"] = new JsonSchemaProperty { Type = "string", Format = "email" },
                        ["password"] = new JsonSchemaProperty { Type = "string", MinLength = 8 }
                    }
                };
                
                return config;
            })
            .AddSingleton&lt;TuskSecurityValidator&gt;()
            .BuildServiceProvider();
        
        var validator = serviceProvider.GetRequiredService&lt;TuskSecurityValidator&gt;();
        
        // Test input validation
        var registrationData = new
        {
            email = "user@example.com",
            password = "SecurePass123!",
            firstName = "John",
            lastName = "Doe"
        };
        
        var validationResult = await validator.ValidateInputAsync(registrationData, "user_registration");
        
        if (validationResult.IsValid)
        {
            Console.WriteLine("Input validation successful");
        }
        else
        {
            Console.WriteLine("Validation errors:");
            foreach (var error in validationResult.Errors)
            {
                Console.WriteLine($"  {error.Field}: {error.Message}");
            }
        }
        
        // Test authentication
        var authRequest = new AuthenticationRequest
        {
            AuthenticationType = AuthenticationType.UsernamePassword,
            Username = "testuser",
            Password = "password123",
            IpAddress = "192.168.1.100"
        };
        
        var authResult = await validator.AuthenticateAsync(authRequest);
        
        if (authResult.IsSuccess)
        {
            Console.WriteLine($"Authentication successful for user: {authResult.User.Username}");
            
            // Test authorization
            var authzRequest = new AuthorizationRequest
            {
                User = authResult.User,
                Action = "read",
                RequiredPermission = "users:read"
            };
            
            var authzResult = await validator.AuthorizeAsync(authzRequest);
            
            if (authzResult.IsAuthorized)
            {
                Console.WriteLine("Authorization successful");
            }
            else
            {
                Console.WriteLine($"Authorization denied: {authzResult.DenialReason}");
            }
        }
        else
        {
            Console.WriteLine($"Authentication failed: {authResult.ErrorMessage}");
        }
        
        // Test threat detection
        var securityContext = new SecurityContext
        {
            IpAddress = "192.168.1.100",
            UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            SessionId = "session123"
        };
        
        var threatResult = await validator.DetectThreatsAsync(securityContext);
        
        Console.WriteLine($"Threat detection completed. Risk score: {threatResult.RiskScore}");
        if (threatResult.Threats.Any())
        {
            Console.WriteLine("Detected threats:");
            foreach (var threat in threatResult.Threats)
            {
                Console.WriteLine($"  {threat.Type}: {threat.Description} (Severity: {threat.Severity})");
            }
        }
        else
        {
            Console.WriteLine("No threats detected");
        }
    }
}
</pre>