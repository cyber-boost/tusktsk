<h1>Error Handling</h1>

<h2>Error Handling with TuskLang in C#</h2>
<p>Implement comprehensive error handling, exception management, and error recovery strategies using TuskLang configuration in C# applications.</p>

<h3>error-handling.tsk</h3>
<pre>
# TuskLang Error Handling Configuration

# 1. Global Error Handling
global_error_handling {
    # Error logging configuration
    logging: {
        enabled: true
        level: env("ERROR_LOG_LEVEL", "error")
        
        # Log destinations
        destinations: [
            {
                type: "file"
                path: "logs/errors/#{@date.format('yyyy-MM-dd')}.log"
                format: "json"
                rotation: {
                    max_size: "100MB"
                    max_files: 30
                    compress: true
                }
            },
            {
                type: "console"
                format: "structured"
                enabled: @env.NODE_ENV == "development"
            },
            {
                type: "database"
                table: "error_logs"
                enabled: @env.ERROR_DB_LOGGING == "true"
                batch_size: 100
                flush_interval: 5000
            },
            {
                type: "external"
                provider: "sentry"
                dsn: env("SENTRY_DSN")
                environment: @env.NODE_ENV
                release: env("APP_VERSION")
                enabled: @env.SENTRY_ENABLED == "true"
            }
        ]
        
        # Log format configuration
        format: {
            timestamp: @now.iso8601
            level: @error.level
            message: @error.message
            stack_trace: @error.stack
            context: {
                request_id: @request.id
                user_id: @request.user.id
                session_id: @request.session.id
                ip_address: @request.ip
                user_agent: @request.headers.user_agent
                endpoint: @request.path
                method: @request.method
            }
            
            # Application context
            application: {
                name: env("APP_NAME")
                version: env("APP_VERSION")
                environment: @env.NODE_ENV
                instance_id: env("INSTANCE_ID")
                hostname: @system.hostname
            }
            
            # Error details
            error: {
                type: @error.type
                code: @error.code
                severity: @error.severity
                category: @error.category
                fingerprint: @error.fingerprint
                correlation_id: @error.correlation_id
            }
            
            # Additional metadata
            metadata: @error.metadata
        }
        
        # Filtering and sampling
        filters: [
            {
                condition: @error.type == "ValidationException"
                action: "sample"
                rate: 0.1  # Sample 10% of validation errors
            },
            {
                condition: @error.message.contains("404")
                action: "suppress"  # Don't log 404 errors
            },
            {
                condition: @error.severity == "critical"
                action: "always"  # Always log critical errors
            }
        ]
    }
    
    # Error notifications
    notifications: {
        enabled: true
        
        # Notification rules
        rules: [
            {
                name: "critical_errors"
                condition: @error.severity == "critical"
                
                channels: [
                    {
                        type: "email"
                        recipients: env_list("CRITICAL_ERROR_EMAILS", ",")
                        template: "critical_error_alert"
                        subject: "CRITICAL: #{@error.message}"
                    },
                    {
                        type: "slack"
                        webhook: env("SLACK_CRITICAL_WEBHOOK")
                        channel: "#alerts-critical"
                        template: "slack_critical_error"
                    },
                    {
                        type: "sms"
                        recipients: env_list("CRITICAL_ERROR_PHONES", ",")
                        message: "CRITICAL ERROR: #{@error.message} in #{env('APP_NAME')}"
                        enabled: @env.NODE_ENV == "production"
                    }
                ]
                
                # Rate limiting for notifications
                rate_limit: {
                    max_notifications: 5
                    time_window: "5m"
                    key: @error.fingerprint
                }
            },
            
            {
                name: "high_error_rate"
                condition: @metrics.error_rate_5m > 10  # More than 10% error rate
                
                channels: [
                    {
                        type: "email"
                        recipients: env_list("HIGH_ERROR_RATE_EMAILS", ",")
                        template: "high_error_rate_alert"
                    }
                ]
                
                # Cooldown period
                cooldown: "15m"
            },
            
            {
                name: "new_error_types"
                condition: @error.is_new_type
                
                channels: [
                    {
                        type: "slack"
                        webhook: env("SLACK_DEV_WEBHOOK")
                        channel: "#development"
                        template: "new_error_type"
                    }
                ]
            }
        ]
        
        # Notification templates
        templates: {
            critical_error_alert: {
                subject: "CRITICAL ERROR: #{@error.message}"
                body: """
                A critical error has occurred in #{env('APP_NAME')}:
                
                Error: #{@error.message}
                Type: #{@error.type}
                Time: #{@error.timestamp}
                Environment: #{@env.NODE_ENV}
                
                Request Details:
                - Endpoint: #{@request.method} #{@request.path}
                - User: #{@request.user.id}
                - IP: #{@request.ip}
                
                Stack Trace:
                #{@error.stack}
                """
            }
        }
    }
    
    # Error recovery strategies
    recovery: {
        # Automatic retry configuration
        retry: {
            enabled: true
            
            # Retry policies by error type
            policies: [
                {
                    error_types: ["TimeoutException", "HttpRequestException"]
                    max_attempts: 3
                    delay: "exponential"  # linear, exponential, fixed
                    base_delay: 1000  # 1 second
                    max_delay: 30000  # 30 seconds
                    jitter: true
                    
                    # Conditions for retry
                    retry_conditions: [
                        @error.is_transient,
                        @response.status >= 500,
                        @response.status == 429  # Rate limit
                    ]
                },
                
                {
                    error_types: ["DatabaseException"]
                    max_attempts: 2
                    delay: "fixed"
                    base_delay: 5000  # 5 seconds
                    
                    # Custom retry logic
                    retry_condition: @database.is_available && @error.is_connection_error
                }
            ]
            
            # Circuit breaker configuration
            circuit_breaker: {
                enabled: true
                failure_threshold: 5  # Open after 5 failures
                timeout: 60000  # 1 minute
                half_open_max_calls: 3
                
                # Per-service configuration
                services: {
                    database: {
                        failure_threshold: 3
                        timeout: 30000
                    },
                    external_api: {
                        failure_threshold: 10
                        timeout: 120000
                    }
                }
            }
        }
        
        # Fallback strategies
        fallback: {
            enabled: true
            
            # Default fallback values
            defaults: {
                user_preferences: @load_default_preferences(),
                configuration: @load_backup_config(),
                external_data: @load_cached_data()
            }
            
            # Fallback strategies by operation
            strategies: [
                {
                    operation: "user_authentication"
                    fallback: "anonymous_access"
                    conditions: [@auth_service.unavailable]
                },
                
                {
                    operation: "data_retrieval"
                    fallback: "cached_data"
                    conditions: [@database.unavailable, @external_api.timeout]
                },
                
                {
                    operation: "email_sending"
                    fallback: "queue_for_later"
                    conditions: [@email_service.rate_limited, @email_service.unavailable]
                }
            ]
        }
        
        # Graceful degradation
        degradation: {
            enabled: true
            
            # Feature toggles for degradation
            features: {
                analytics: {
                    disable_on: ["high_error_rate", "database_issues"]
                    fallback: "basic_logging"
                },
                
                real_time_updates: {
                    disable_on: ["websocket_failures", "high_load"]
                    fallback: "polling_updates"
                },
                
                advanced_search: {
                    disable_on: ["search_service_down"]
                    fallback: "basic_search"
                }
            }
        }
    }
}

# 2. Exception Handling Strategies
exception_handling {
    # Exception categorization
    categories: {
        business_logic: {
            exceptions: ["ValidationException", "BusinessRuleException", "InsufficientFundsException"]
            severity: "warning"
            auto_recover: false
            notify_user: true
            log_level: "warn"
        }
        
        infrastructure: {
            exceptions: ["DatabaseException", "NetworkException", "ServiceUnavailableException"]
            severity: "error"
            auto_recover: true
            notify_user: false
            log_level: "error"
        }
        
        security: {
            exceptions: ["UnauthorizedException", "ForbiddenException", "SecurityException"]
            severity: "high"
            auto_recover: false
            notify_user: true
            log_level: "error"
            
            # Additional security handling
            additional_actions: [
                @log_security_event,
                @increment_security_counter,
                @check_rate_limiting
            ]
        }
        
        system: {
            exceptions: ["OutOfMemoryException", "StackOverflowException", "SystemException"]
            severity: "critical"
            auto_recover: false
            notify_user: false
            log_level: "fatal"
            
            # Emergency actions
            emergency_actions: [
                @trigger_health_check,
                @scale_resources,
                @notify_operations_team
            ]
        }
    }
    
    # Exception mapping
    mapping: {
        # HTTP status code mapping
        http_status: {
            "ValidationException": 400
            "UnauthorizedException": 401
            "ForbiddenException": 403
            "NotFoundException": 404
            "ConflictException": 409
            "BusinessRuleException": 422
            "RateLimitException": 429
            "InternalException": 500
            "ServiceUnavailableException": 503
        }
        
        # User-friendly messages
        user_messages: {
            "ValidationException": "The provided information is invalid. Please check your input and try again."
            "UnauthorizedException": "Please log in to access this resource."
            "ForbiddenException": "You don't have permission to perform this action."
            "NotFoundException": "The requested resource could not be found."
            "RateLimitException": "Too many requests. Please try again later."
            "ServiceUnavailableException": "The service is temporarily unavailable. Please try again later."
        }
        
        # Error codes for API responses
        error_codes: {
            "ValidationException": "VALIDATION_ERROR"
            "UnauthorizedException": "UNAUTHORIZED"
            "ForbiddenException": "FORBIDDEN"
            "NotFoundException": "NOT_FOUND"
            "ConflictException": "CONFLICT"
            "RateLimitException": "RATE_LIMIT_EXCEEDED"
            "InternalException": "INTERNAL_ERROR"
        }
    }
    
    # Exception enrichment
    enrichment: {
        enabled: true
        
        # Additional context to add
        context_providers: [
            @add_request_context,
            @add_user_context,
            @add_system_context,
            @add_business_context
        ]
        
        # Error fingerprinting
        fingerprinting: {
            enabled: true
            algorithm: "sha256"
            
            # Include in fingerprint
            include: [
                @error.type,
                @error.message_template,
                @error.stack_trace_signature,
                @request.endpoint
            ]
            
            # Exclude from fingerprint
            exclude: [
                @request.timestamp,
                @request.id,
                @user.session_id
            ]
        }
        
        # Error correlation
        correlation: {
            enabled: true
            
            # Correlation strategies
            strategies: [
                {
                    name: "request_trace"
                    correlate_by: @request.trace_id
                    time_window: "5m"
                },
                {
                    name: "user_session"
                    correlate_by: @user.session_id
                    time_window: "1h"
                },
                {
                    name: "error_cascade"
                    correlate_by: @error.root_cause_id
                    time_window: "10m"
                }
            ]
        }
    }
}

# 3. Health Monitoring
health_monitoring {
    # Health checks
    checks: {
        # Application health
        application: {
            enabled: true
            interval: 30000  # 30 seconds
            timeout: 5000    # 5 seconds
            
            checks: [
                {
                    name: "memory_usage"
                    threshold: 80  # 80% memory usage
                    action: @scale_if_needed
                },
                {
                    name: "cpu_usage"
                    threshold: 90  # 90% CPU usage
                    action: @alert_high_cpu
                },
                {
                    name: "disk_space"
                    threshold: 85  # 85% disk usage
                    action: @cleanup_old_logs
                },
                {
                    name: "error_rate"
                    threshold: 5   # 5% error rate
                    window: "5m"
                    action: @investigate_errors
                }
            ]
        }
        
        # Database health
        database: {
            enabled: true
            interval: 10000  # 10 seconds
            timeout: 3000    # 3 seconds
            
            checks: [
                {
                    name: "connection_pool"
                    query: "SELECT 1"
                    threshold: 80  # 80% pool utilization
                },
                {
                    name: "query_performance"
                    threshold: 1000  # 1 second average query time
                    window: "1m"
                },
                {
                    name: "deadlocks"
                    threshold: 1  # More than 1 deadlock per minute
                    window: "1m"
                }
            ]
        }
        
        # External dependencies
        external_services: {
            enabled: true
            interval: 60000  # 1 minute
            
            services: [
                {
                    name: "payment_api"
                    url: env("PAYMENT_API_HEALTH_URL")
                    timeout: 5000
                    expected_status: 200
                    critical: true
                },
                {
                    name: "email_service"
                    url: env("EMAIL_SERVICE_HEALTH_URL")
                    timeout: 3000
                    expected_status: 200
                    critical: false
                },
                {
                    name: "analytics_service"
                    url: env("ANALYTICS_SERVICE_HEALTH_URL")
                    timeout: 5000
                    expected_status: 200
                    critical: false
                }
            ]
        }
    }
    
    # Health status aggregation
    aggregation: {
        # Overall health calculation
        overall_health: {
            algorithm: "weighted_average"
            
            weights: {
                application: 40
                database: 35
                external_services: 25
            }
            
            # Health status thresholds
            thresholds: {
                healthy: 90
                degraded: 70
                unhealthy: 50
            }
        }
        
        # Health history
        history: {
            enabled: true
            retention: "7d"
            granularity: "1m"
            
            # Metrics to track
            metrics: [
                "overall_health_score",
                "error_rate",
                "response_time",
                "availability"
            ]
        }
    }
}

# 4. Error Recovery Workflows
recovery_workflows {
    # Automatic recovery workflows
    automatic: [
        {
            name: "database_connection_recovery"
            trigger: @error.type == "DatabaseConnectionException"
            
            steps: [
                {
                    action: "wait"
                    duration: 5000
                },
                {
                    action: "test_connection"
                    max_attempts: 3
                },
                {
                    action: "recreate_connection_pool"
                    condition: @connection_test_failed
                },
                {
                    action: "fallback_to_readonly_database"
                    condition: @primary_database_unavailable
                },
                {
                    action: "notify_administrators"
                    condition: @all_recovery_failed
                }
            ]
        },
        
        {
            name: "memory_pressure_recovery"
            trigger: @system.memory_usage > 90
            
            steps: [
                {
                    action: "trigger_garbage_collection"
                },
                {
                    action: "clear_caches"
                    types: ["memory_cache", "object_cache"]
                },
                {
                    action: "reduce_worker_threads"
                    percentage: 50
                },
                {
                    action: "enable_emergency_mode"
                    condition: @memory_usage_still_high
                }
            ]
        },
        
        {
            name: "service_degradation_recovery"
            trigger: @health_score < 70
            
            steps: [
                {
                    action: "identify_failing_components"
                },
                {
                    action: "disable_non_critical_features"
                    features: ["analytics", "real_time_updates", "advanced_search"]
                },
                {
                    action: "enable_fallback_modes"
                },
                {
                    action: "scale_healthy_services"
                    factor: 1.5
                },
                {
                    action: "monitor_recovery"
                    duration: 300000  # 5 minutes
                }
            ]
        }
    ]
    
    # Manual recovery procedures
    manual: [
        {
            name: "critical_system_recovery"
            description: "Manual recovery for critical system failures"
            
            steps: [
                {
                    step: 1
                    description: "Assess system state"
                    actions: ["check_logs", "review_metrics", "verify_dependencies"]
                },
                {
                    step: 2
                    description: "Isolate the problem"
                    actions: ["identify_root_cause", "stop_affected_services", "preserve_evidence"]
                },
                {
                    step: 3
                    description: "Implement temporary fix"
                    actions: ["apply_hotfix", "enable_workaround", "reroute_traffic"]
                },
                {
                    step: 4
                    description: "Verify recovery"
                    actions: ["run_health_checks", "test_critical_paths", "monitor_stability"]
                },
                {
                    step: 5
                    description: "Post-incident tasks"
                    actions: ["update_documentation", "schedule_permanent_fix", "conduct_postmortem"]
                }
            ]
        }
    ]
    
    # Recovery testing
    testing: {
        # Chaos engineering
        chaos_engineering: {
            enabled: env("CHAOS_TESTING_ENABLED", false)
            
            scenarios: [
                {
                    name: "database_failure"
                    frequency: "weekly"
                    environment: "staging"
                    impact: "simulate_database_downtime"
                    duration: "5m"
                },
                {
                    name: "high_latency"
                    frequency: "daily"
                    environment: "staging"
                    impact: "add_network_latency"
                    duration: "10m"
                    latency: "2s"
                },
                {
                    name: "memory_pressure"
                    frequency: "monthly"
                    environment: "staging"
                    impact: "consume_memory"
                    duration: "15m"
                    percentage: 80
                }
            ]
        }
        
        # Recovery validation
        validation: {
            enabled: true
            
            tests: [
                {
                    name: "failover_time"
                    metric: "time_to_recovery"
                    threshold: 30000  # 30 seconds
                },
                {
                    name: "data_consistency"
                    metric: "data_integrity_check"
                    threshold: 100  # 100% consistency
                },
                {
                    name: "service_availability"
                    metric: "availability_during_recovery"
                    threshold: 99   # 99% availability
                }
            ]
        }
    }
}
</pre>

<h3>TuskErrorHandler.cs</h3>
<pre>
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace TuskLang.ErrorHandling
{
    // Main error handling engine for TuskLang applications
    public class TuskErrorHandler : IDisposable
    {
        private readonly ILogger&lt;TuskErrorHandler&gt; _logger;
        private readonly ErrorHandlingConfig _config;
        private readonly ConcurrentDictionary&lt;string, ErrorStats&gt; _errorStats;
        private readonly ConcurrentDictionary&lt;string, CircuitBreakerState&gt; _circuitBreakers;
        private readonly Timer _healthCheckTimer;
        private readonly SemaphoreSlim _notificationSemaphore;
        
        public TuskErrorHandler(ILogger&lt;TuskErrorHandler&gt; logger, ErrorHandlingConfig config)
        {
            _logger = logger;
            _config = config;
            _errorStats = new ConcurrentDictionary&lt;string, ErrorStats&gt;();
            _circuitBreakers = new ConcurrentDictionary&lt;string, CircuitBreakerState&gt;();
            _notificationSemaphore = new SemaphoreSlim(5, 5); // Max 5 concurrent notifications
            
            // Start health monitoring
            _healthCheckTimer = new Timer(RunHealthChecks, null, TimeSpan.Zero, TimeSpan.FromSeconds(30));
        }
        
        // Handle an exception with full error processing
        public async Task&lt;ErrorHandlingResult&gt; HandleExceptionAsync(Exception exception, ErrorContext context = null)
        {
            context ??= new ErrorContext();
            var enrichedException = await EnrichException(exception, context);
            
            // Create error information
            var errorInfo = new ErrorInfo
            {
                Id = Guid.NewGuid().ToString(),
                Exception = enrichedException,
                Context = context,
                Timestamp = DateTime.UtcNow,
                Severity = DetermineSeverity(enrichedException),
                Category = CategorizeException(enrichedException),
                Fingerprint = GenerateFingerprint(enrichedException, context)
            };
            
            // Update error statistics
            UpdateErrorStats(errorInfo);
            
            // Log the error
            await LogError(errorInfo);
            
            // Check for notifications
            await CheckAndSendNotifications(errorInfo);
            
            // Attempt recovery
            var recoveryResult = await AttemptRecovery(errorInfo);
            
            // Check circuit breaker
            UpdateCircuitBreaker(errorInfo, recoveryResult.Success);
            
            return new ErrorHandlingResult
            {
                ErrorInfo = errorInfo,
                RecoveryResult = recoveryResult,
                ShouldRetry = ShouldRetry(errorInfo, recoveryResult),
                UserMessage = GetUserMessage(errorInfo),
                HttpStatusCode = GetHttpStatusCode(errorInfo)
            };
        }
        
        // Enrich exception with additional context
        private async Task&lt;Exception&gt; EnrichException(Exception exception, ErrorContext context)
        {
            var enriched = new EnrichedException(exception)
            {
                CorrelationId = context.CorrelationId ?? Guid.NewGuid().ToString(),
                RequestId = context.RequestId,
                UserId = context.UserId,
                SessionId = context.SessionId,
                Endpoint = context.Endpoint,
                UserAgent = context.UserAgent,
                IpAddress = context.IpAddress,
                
                // System context
                MachineName = Environment.MachineName,
                ProcessId = Environment.ProcessId,
                ThreadId = Thread.CurrentThread.ManagedThreadId,
                
                // Application context
                ApplicationName = _config.ApplicationName,
                ApplicationVersion = _config.ApplicationVersion,
                Environment = _config.Environment,
                
                // Additional metadata
                Metadata = new Dictionary&lt;string, object&gt;()
            };
            
            // Add custom context providers
            foreach (var provider in _config.ContextProviders)
            {
                await provider.AddContextAsync(enriched, context);
            }
            
            return enriched;
        }
        
        // Determine error severity
        private ErrorSeverity DetermineSeverity(Exception exception)
        {
            var exceptionType = exception.GetType().Name;
            
            if (_config.SeverityMapping.TryGetValue(exceptionType, out var mappedSeverity))
                return mappedSeverity;
            
            // Default severity logic
            return exception switch
            {
                ArgumentException or FormatException or InvalidOperationException =&gt; ErrorSeverity.Low,
                UnauthorizedAccessException or SecurityException =&gt; ErrorSeverity.High,
                OutOfMemoryException or StackOverflowException =&gt; ErrorSeverity.Critical,
                _ =&gt; ErrorSeverity.Medium
            };
        }
        
        // Categorize exception
        private ErrorCategory CategorizeException(Exception exception)
        {
            var exceptionType = exception.GetType().Name;
            
            foreach (var category in _config.Categories)
            {
                if (category.Value.ExceptionTypes.Contains(exceptionType))
                    return category.Key;
            }
            
            return ErrorCategory.Unknown;
        }
        
        // Generate error fingerprint for deduplication
        private string GenerateFingerprint(Exception exception, ErrorContext context)
        {
            var fingerprintData = new
            {
                ExceptionType = exception.GetType().Name,
                MessageTemplate = ExtractMessageTemplate(exception.Message),
                StackTraceSignature = ExtractStackSignature(exception.StackTrace),
                Endpoint = context.Endpoint
            };
            
            var json = JsonSerializer.Serialize(fingerprintData);
            return ComputeHash(json);
        }
        
        // Update error statistics
        private void UpdateErrorStats(ErrorInfo errorInfo)
        {
            var key = $"{errorInfo.Category}_{errorInfo.Exception.GetType().Name}";
            
            _errorStats.AddOrUpdate(key, 
                new ErrorStats { Count = 1, LastOccurrence = errorInfo.Timestamp, FirstOccurrence = errorInfo.Timestamp },
                (k, existing) =&gt; new ErrorStats 
                { 
                    Count = existing.Count + 1, 
                    LastOccurrence = errorInfo.Timestamp,
                    FirstOccurrence = existing.FirstOccurrence
                });
        }
        
        // Log error with configured destinations
        private async Task LogError(ErrorInfo errorInfo)
        {
            var logEntry = new
            {
                ErrorId = errorInfo.Id,
                Timestamp = errorInfo.Timestamp,
                Level = errorInfo.Severity.ToString().ToLower(),
                Message = errorInfo.Exception.Message,
                ExceptionType = errorInfo.Exception.GetType().Name,
                Category = errorInfo.Category.ToString(),
                Fingerprint = errorInfo.Fingerprint,
                
                Context = new
                {
                    CorrelationId = errorInfo.Context.CorrelationId,
                    RequestId = errorInfo.Context.RequestId,
                    UserId = errorInfo.Context.UserId,
                    Endpoint = errorInfo.Context.Endpoint,
                    UserAgent = errorInfo.Context.UserAgent,
                    IpAddress = errorInfo.Context.IpAddress
                },
                
                Exception = new
                {
                    Type = errorInfo.Exception.GetType().FullName,
                    Message = errorInfo.Exception.Message,
                    StackTrace = errorInfo.Exception.StackTrace,
                    Data = errorInfo.Exception.Data,
                    InnerException = errorInfo.Exception.InnerException?.Message
                },
                
                Application = new
                {
                    Name = _config.ApplicationName,
                    Version = _config.ApplicationVersion,
                    Environment = _config.Environment,
                    MachineName = Environment.MachineName,
                    ProcessId = Environment.ProcessId
                }
            };
            
            // Log to configured destinations
            foreach (var destination in _config.LogDestinations)
            {
                try
                {
                    await destination.LogAsync(logEntry);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to log to destination {DestinationType}", destination.Type);
                }
            }
        }
        
        // Check and send notifications
        private async Task CheckAndSendNotifications(ErrorInfo errorInfo)
        {
            foreach (var rule in _config.NotificationRules)
            {
                if (await ShouldNotify(errorInfo, rule))
                {
                    await _notificationSemaphore.WaitAsync();
                    try
                    {
                        await SendNotification(errorInfo, rule);
                    }
                    finally
                    {
                        _notificationSemaphore.Release();
                    }
                }
            }
        }
        
        // Determine if notification should be sent
        private async Task&lt;bool&gt; ShouldNotify(ErrorInfo errorInfo, NotificationRule rule)
        {
            // Check condition
            if (!await rule.Condition(errorInfo))
                return false;
            
            // Check rate limiting
            if (rule.RateLimit != null)
            {
                var rateLimitKey = $"notification_{rule.Name}_{errorInfo.Fingerprint}";
                var rateLimitCount = await GetRateLimitCount(rateLimitKey, rule.RateLimit.TimeWindow);
                
                if (rateLimitCount >= rule.RateLimit.MaxNotifications)
                    return false;
                
                await IncrementRateLimitCount(rateLimitKey, rule.RateLimit.TimeWindow);
            }
            
            // Check cooldown
            if (rule.Cooldown.HasValue)
            {
                var cooldownKey = $"cooldown_{rule.Name}";
                var lastNotification = await GetLastNotificationTime(cooldownKey);
                
                if (lastNotification.HasValue && 
                    DateTime.UtcNow - lastNotification.Value &lt; rule.Cooldown.Value)
                    return false;
                
                await SetLastNotificationTime(cooldownKey, DateTime.UtcNow);
            }
            
            return true;
        }
        
        // Send notification
        private async Task SendNotification(ErrorInfo errorInfo, NotificationRule rule)
        {
            foreach (var channel in rule.Channels)
            {
                try
                {
                    await channel.SendAsync(errorInfo, rule);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to send notification via {ChannelType}", channel.Type);
                }
            }
        }
        
        // Attempt error recovery
        private async Task&lt;RecoveryResult&gt; AttemptRecovery(ErrorInfo errorInfo)
        {
            var recoveryStrategy = GetRecoveryStrategy(errorInfo);
            if (recoveryStrategy == null)
            {
                return new RecoveryResult { Success = false, Message = "No recovery strategy available" };
            }
            
            try
            {
                var result = await recoveryStrategy.RecoverAsync(errorInfo);
                
                if (result.Success)
                {
                    _logger.LogInformation("Successfully recovered from error {ErrorId} using strategy {StrategyName}", 
                        errorInfo.Id, recoveryStrategy.Name);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Recovery strategy {StrategyName} failed for error {ErrorId}", 
                    recoveryStrategy.Name, errorInfo.Id);
                
                return new RecoveryResult { Success = false, Message = $"Recovery failed: {ex.Message}" };
            }
        }
        
        // Get recovery strategy for error
        private IRecoveryStrategy GetRecoveryStrategy(ErrorInfo errorInfo)
        {
            return _config.RecoveryStrategies
                .FirstOrDefault(strategy =&gt; strategy.CanHandle(errorInfo));
        }
        
        // Update circuit breaker state
        private void UpdateCircuitBreaker(ErrorInfo errorInfo, bool success)
        {
            var service = GetServiceName(errorInfo);
            if (string.IsNullOrEmpty(service))
                return;
            
            _circuitBreakers.AddOrUpdate(service,
                new CircuitBreakerState { FailureCount = success ? 0 : 1, LastFailure = DateTime.UtcNow },
                (key, existing) =&gt;
                {
                    if (success)
                    {
                        existing.FailureCount = 0;
                        existing.State = CircuitBreakerStateEnum.Closed;
                    }
                    else
                    {
                        existing.FailureCount++;
                        existing.LastFailure = DateTime.UtcNow;
                        
                        if (existing.FailureCount &gt;= _config.CircuitBreakerThreshold)
                        {
                            existing.State = CircuitBreakerStateEnum.Open;
                            existing.OpenedAt = DateTime.UtcNow;
                        }
                    }
                    
                    return existing;
                });
        }
        
        // Determine if operation should be retried
        private bool ShouldRetry(ErrorInfo errorInfo, RecoveryResult recoveryResult)
        {
            if (recoveryResult.Success)
                return false;
            
            var retryPolicy = GetRetryPolicy(errorInfo);
            return retryPolicy?.ShouldRetry(errorInfo) == true;
        }
        
        // Get user-friendly error message
        private string GetUserMessage(ErrorInfo errorInfo)
        {
            var exceptionType = errorInfo.Exception.GetType().Name;
            
            if (_config.UserMessages.TryGetValue(exceptionType, out var userMessage))
                return userMessage;
            
            return _config.DefaultUserMessage;
        }
        
        // Get HTTP status code for error
        private int GetHttpStatusCode(ErrorInfo errorInfo)
        {
            var exceptionType = errorInfo.Exception.GetType().Name;
            
            if (_config.HttpStatusMapping.TryGetValue(exceptionType, out var statusCode))
                return statusCode;
            
            return 500; // Internal Server Error
        }
        
        // Health checks
        private async void RunHealthChecks(object state)
        {
            try
            {
                await RunApplicationHealthChecks();
                await RunDatabaseHealthChecks();
                await RunExternalServiceHealthChecks();
                
                // Update overall health score
                var healthScore = CalculateOverallHealthScore();
                await UpdateHealthMetrics(healthScore);
                
                // Check for degradation
                if (healthScore &lt; _config.DegradationThreshold)
                {
                    await TriggerDegradation(healthScore);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Health check failed");
            }
        }
        
        // Helper methods (simplified implementations)
        private string ExtractMessageTemplate(string message)
        {
            // Extract template from error message (remove dynamic parts)
            return System.Text.RegularExpressions.Regex.Replace(message, @"\d+", "{number}");
        }
        
        private string ExtractStackSignature(string stackTrace)
        {
            // Extract meaningful signature from stack trace
            return stackTrace?.Split('\n').Take(3).FirstOrDefault()?.Trim() ?? "";
        }
        
        private string ComputeHash(string input)
        {
            using var sha256 = System.Security.Cryptography.SHA256.Create();
            var hash = sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(input));
            return Convert.ToBase64String(hash);
        }
        
        private string GetServiceName(ErrorInfo errorInfo)
        {
            // Extract service name from context
            return errorInfo.Context.ServiceName ?? "default";
        }
        
        private IRetryPolicy GetRetryPolicy(ErrorInfo errorInfo)
        {
            return _config.RetryPolicies
                .FirstOrDefault(policy =&gt; policy.CanHandle(errorInfo));
        }
        
        private async Task&lt;int&gt; GetRateLimitCount(string key, TimeSpan window)
        {
            // Rate limit counting implementation
            return 0; // Placeholder
        }
        
        private async Task IncrementRateLimitCount(string key, TimeSpan window)
        {
            // Rate limit increment implementation
            await Task.CompletedTask; // Placeholder
        }
        
        private async Task&lt;DateTime?&gt; GetLastNotificationTime(string key)
        {
            // Get last notification time implementation
            return await Task.FromResult&lt;DateTime?&gt;(null); // Placeholder
        }
        
        private async Task SetLastNotificationTime(string key, DateTime time)
        {
            // Set last notification time implementation
            await Task.CompletedTask; // Placeholder
        }
        
        private async Task RunApplicationHealthChecks()
        {
            // Application health check implementation
            await Task.CompletedTask; // Placeholder
        }
        
        private async Task RunDatabaseHealthChecks()
        {
            // Database health check implementation
            await Task.CompletedTask; // Placeholder
        }
        
        private async Task RunExternalServiceHealthChecks()
        {
            // External service health check implementation
            await Task.CompletedTask; // Placeholder
        }
        
        private double CalculateOverallHealthScore()
        {
            // Health score calculation
            return 95.0; // Placeholder
        }
        
        private async Task UpdateHealthMetrics(double healthScore)
        {
            // Health metrics update implementation
            await Task.CompletedTask; // Placeholder
        }
        
        private async Task TriggerDegradation(double healthScore)
        {
            // Degradation triggering implementation
            await Task.CompletedTask; // Placeholder
        }
        
        public void Dispose()
        {
            _healthCheckTimer?.Dispose();
            _notificationSemaphore?.Dispose();
        }
    }
}
</pre>

<h3>Supporting Classes</h3>
<pre>
namespace TuskLang.ErrorHandling
{
    // Error handling configuration
    public class ErrorHandlingConfig
    {
        public string ApplicationName { get; set; }
        public string ApplicationVersion { get; set; }
        public string Environment { get; set; }
        public Dictionary&lt;string, ErrorSeverity&gt; SeverityMapping { get; set; } = new();
        public Dictionary&lt;ErrorCategory, CategoryConfig&gt; Categories { get; set; } = new();
        public Dictionary&lt;string, string&gt; UserMessages { get; set; } = new();
        public Dictionary&lt;string, int&gt; HttpStatusMapping { get; set; } = new();
        public string DefaultUserMessage { get; set; } = "An error occurred. Please try again.";
        public List&lt;ILogDestination&gt; LogDestinations { get; set; } = new();
        public List&lt;NotificationRule&gt; NotificationRules { get; set; } = new();
        public List&lt;IRecoveryStrategy&gt; RecoveryStrategies { get; set; } = new();
        public List&lt;IRetryPolicy&gt; RetryPolicies { get; set; } = new();
        public List&lt;IContextProvider&gt; ContextProviders { get; set; } = new();
        public int CircuitBreakerThreshold { get; set; } = 5;
        public double DegradationThreshold { get; set; } = 70.0;
    }
    
    // Error information
    public class ErrorInfo
    {
        public string Id { get; set; }
        public Exception Exception { get; set; }
        public ErrorContext Context { get; set; }
        public DateTime Timestamp { get; set; }
        public ErrorSeverity Severity { get; set; }
        public ErrorCategory Category { get; set; }
        public string Fingerprint { get; set; }
    }
    
    // Error context
    public class ErrorContext
    {
        public string CorrelationId { get; set; }
        public string RequestId { get; set; }
        public string UserId { get; set; }
        public string SessionId { get; set; }
        public string Endpoint { get; set; }
        public string UserAgent { get; set; }
        public string IpAddress { get; set; }
        public string ServiceName { get; set; }
        public Dictionary&lt;string, object&gt; AdditionalContext { get; set; } = new();
    }
    
    // Enriched exception
    public class EnrichedException : Exception
    {
        public Exception OriginalException { get; }
        public string CorrelationId { get; set; }
        public string RequestId { get; set; }
        public string UserId { get; set; }
        public string SessionId { get; set; }
        public string Endpoint { get; set; }
        public string UserAgent { get; set; }
        public string IpAddress { get; set; }
        public string MachineName { get; set; }
        public int ProcessId { get; set; }
        public int ThreadId { get; set; }
        public string ApplicationName { get; set; }
        public string ApplicationVersion { get; set; }
        public string Environment { get; set; }
        public Dictionary&lt;string, object&gt; Metadata { get; set; } = new();
        
        public EnrichedException(Exception originalException) : base(originalException.Message, originalException)
        {
            OriginalException = originalException;
        }
    }
    
    // Error handling result
    public class ErrorHandlingResult
    {
        public ErrorInfo ErrorInfo { get; set; }
        public RecoveryResult RecoveryResult { get; set; }
        public bool ShouldRetry { get; set; }
        public string UserMessage { get; set; }
        public int HttpStatusCode { get; set; }
    }
    
    // Recovery result
    public class RecoveryResult
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public Dictionary&lt;string, object&gt; Data { get; set; } = new();
    }
    
    // Error statistics
    public class ErrorStats
    {
        public int Count { get; set; }
        public DateTime FirstOccurrence { get; set; }
        public DateTime LastOccurrence { get; set; }
    }
    
    // Circuit breaker state
    public class CircuitBreakerState
    {
        public int FailureCount { get; set; }
        public DateTime LastFailure { get; set; }
        public CircuitBreakerStateEnum State { get; set; } = CircuitBreakerStateEnum.Closed;
        public DateTime? OpenedAt { get; set; }
    }
    
    // Notification rule
    public class NotificationRule
    {
        public string Name { get; set; }
        public Func&lt;ErrorInfo, Task&lt;bool&gt;&gt; Condition { get; set; }
        public List&lt;INotificationChannel&gt; Channels { get; set; } = new();
        public RateLimit RateLimit { get; set; }
        public TimeSpan? Cooldown { get; set; }
    }
    
    // Rate limit
    public class RateLimit
    {
        public int MaxNotifications { get; set; }
        public TimeSpan TimeWindow { get; set; }
    }
    
    // Category configuration
    public class CategoryConfig
    {
        public List&lt;string&gt; ExceptionTypes { get; set; } = new();
        public ErrorSeverity Severity { get; set; }
        public bool AutoRecover { get; set; }
        public bool NotifyUser { get; set; }
        public string LogLevel { get; set; }
    }
    
    // Enums
    public enum ErrorSeverity
    {
        Low,
        Medium,
        High,
        Critical
    }
    
    public enum ErrorCategory
    {
        BusinessLogic,
        Infrastructure,
        Security,
        System,
        Unknown
    }
    
    public enum CircuitBreakerStateEnum
    {
        Closed,
        Open,
        HalfOpen
    }
    
    // Interfaces
    public interface ILogDestination
    {
        string Type { get; }
        Task LogAsync(object logEntry);
    }
    
    public interface INotificationChannel
    {
        string Type { get; }
        Task SendAsync(ErrorInfo errorInfo, NotificationRule rule);
    }
    
    public interface IRecoveryStrategy
    {
        string Name { get; }
        bool CanHandle(ErrorInfo errorInfo);
        Task&lt;RecoveryResult&gt; RecoverAsync(ErrorInfo errorInfo);
    }
    
    public interface IRetryPolicy
    {
        bool CanHandle(ErrorInfo errorInfo);
        bool ShouldRetry(ErrorInfo errorInfo);
    }
    
    public interface IContextProvider
    {
        Task AddContextAsync(EnrichedException exception, ErrorContext context);
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using TuskLang.ErrorHandling;

class Program
{
    static async Task Main(string[] args)
    {
        // Setup dependency injection
        var serviceProvider = new ServiceCollection()
            .AddLogging(builder =&gt; builder.AddConsole())
            .AddSingleton&lt;ErrorHandlingConfig&gt;(provider =&gt;
            {
                var config = new ErrorHandlingConfig
                {
                    ApplicationName = "MyApp",
                    ApplicationVersion = "1.0.0",
                    Environment = "Development"
                };
                
                // Configure error categories
                config.Categories[ErrorCategory.BusinessLogic] = new CategoryConfig
                {
                    ExceptionTypes = new List&lt;string&gt; { "ValidationException", "BusinessRuleException" },
                    Severity = ErrorSeverity.Low,
                    AutoRecover = false,
                    NotifyUser = true
                };
                
                // Configure user messages
                config.UserMessages["ValidationException"] = "Please check your input and try again.";
                config.UserMessages["UnauthorizedException"] = "Please log in to continue.";
                
                return config;
            })
            .AddSingleton&lt;TuskErrorHandler&gt;()
            .BuildServiceProvider();
        
        var errorHandler = serviceProvider.GetRequiredService&lt;TuskErrorHandler&gt;();
        
        try
        {
            // Simulate an error
            throw new InvalidOperationException("Something went wrong!");
        }
        catch (Exception ex)
        {
            var context = new ErrorContext
            {
                CorrelationId = Guid.NewGuid().ToString(),
                UserId = "user123",
                Endpoint = "/api/test"
            };
            
            var result = await errorHandler.HandleExceptionAsync(ex, context);
            
            Console.WriteLine($"Error handled: {result.ErrorInfo.Id}");
            Console.WriteLine($"User message: {result.UserMessage}");
            Console.WriteLine($"HTTP status: {result.HttpStatusCode}");
            Console.WriteLine($"Should retry: {result.ShouldRetry}");
            
            if (result.RecoveryResult.Success)
            {
                Console.WriteLine($"Recovery successful: {result.RecoveryResult.Message}");
            }
        }
    }
}
</pre>