<h1>Data Types</h1>

<h2>TuskLang Data Types in C#</h2>
<p>Comprehensive guide to working with TuskLang data types in C# applications, including type mapping, validation, and conversion.</p>

<h3>types.tsk</h3>
<pre>
# TuskLang Data Types Example Configuration

# 1. Primitive Types
primitives {
    # String types
    simple_string: "Hello World"
    single_quoted: 'Single quotes work too'
    empty_string: ""
    
    # String with escape sequences
    escaped_string: "Line 1\nLine 2\tTabbed"
    unicode_string: "Unicode: \u2603 \u2764"
    
    # Multi-line strings
    multiline_string: """
    This is a multiline string
    that preserves formatting
    and line breaks
    """
    
    # String interpolation
    interpolated: "Hello, #{@user.name}!"
    path_string: "#{@app.root}/data/#{@file.name}"
    
    # Numeric types
    integer: 42
    negative_integer: -123
    zero: 0
    
    # Floating point
    decimal_number: 3.14159
    negative_decimal: -2.718
    scientific_notation: 1.23e-4
    large_scientific: 6.022e23
    
    # Special numeric formats
    hexadecimal: 0xFF        # 255 in decimal
    binary: 0b1010          # 10 in decimal
    octal: 0o755            # 493 in decimal
    
    # Boolean types
    is_enabled: true
    is_disabled: false
    
    # Null type
    optional_value: null
    unset_value: null
}

# 2. Collection Types
collections {
    # Arrays
    simple_array: [1, 2, 3, 4, 5]
    string_array: ["apple", "banana", "cherry"]
    boolean_array: [true, false, true]
    mixed_array: [1, "text", true, null]
    
    # Empty array
    empty_array: []
    
    # Nested arrays
    matrix: [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    
    # Array of objects
    users: [
        { name: "John", age: 30, active: true },
        { name: "Jane", age: 25, active: false },
        { name: "Bob", age: 35, active: true }
    ]
    
    # Multiline array formatting
    technologies: [
        "C#",
        "JavaScript",
        "Python",
        "Go",
        "Rust"
    ]
}

# 3. Object Types
objects {
    # Simple object
    simple_object: {
        key1: "value1",
        key2: "value2"
    }
    
    # Nested objects
    nested_object {
        level1 {
            level2 {
                level3 {
                    deep_value: "Found at depth 3"
                }
            }
        }
    }
    
    # Mixed object with different value types
    mixed_object {
        string_prop: "text"
        number_prop: 42
        boolean_prop: true
        null_prop: null
        array_prop: [1, 2, 3]
        nested_prop: {
            inner_value: "nested"
        }
    }
    
    # Object with computed properties
    computed_object {
        base_value: 10
        doubled: @(base_value * 2)
        is_positive: @(base_value > 0)
        description: "Value is #{@base_value}"
    }
}

# 4. Special Types and Functions
special_types {
    # Environment variables
    env_string: env("APP_NAME", "DefaultApp")
    env_number: env("PORT", 8080)
    env_boolean: env("DEBUG", false)
    
    # File references
    config_file: file("./config.json")
    template_file: file("./template.html")
    
    # Dynamic values
    current_time: now()
    random_id: uuid()
    hash_value: sha256("password123")
    
    # Type annotations (optional metadata)
    typed_string: "Hello" :: string
    typed_number: 42 :: integer
    typed_decimal: 3.14 :: float
    typed_boolean: true :: boolean
    typed_array: [1, 2, 3] :: integer[]
    
    # Constraints and validation
    email: "user@example.com" @validate.email
    phone: "+1-555-123-4567" @validate.phone
    url: "https://example.com" @validate.url
    password: "SecurePass123!" @validate.password
    
    # Range constraints
    port: 8080 @validate.range(1024, 65535)
    percentage: 85.5 @validate.range(0.0, 100.0)
    
    # Length constraints
    username: "johndoe" @validate.length(3, 20)
    description: "Short desc" @validate.max_length(255)
    
    # Pattern constraints
    product_code: "ABC-123" @validate.pattern("[A-Z]{3}-[0-9]{3}")
    slug: "my-product-name" @validate.pattern("[a-z0-9-]+")
}

# 5. Advanced Data Structures
advanced {
    # Maps/Dictionaries
    status_codes: {
        200: "OK",
        404: "Not Found",
        500: "Internal Server Error"
    }
    
    # Configuration variants
    environments: {
        development: {
            debug: true,
            log_level: "debug",
            database_url: "sqlite:///dev.db"
        },
        
        production: {
            debug: false,
            log_level: "error",
            database_url: env("DATABASE_URL")
        },
        
        testing: {
            debug: true,
            log_level: "info",
            database_url: ":memory:"
        }
    }
    
    # Tuples (ordered collections)
    coordinates: [40.7128, -74.0060]  # [latitude, longitude]
    rgb_color: [255, 128, 0]          # [red, green, blue]
    version_info: [1, 2, 3]           # [major, minor, patch]
    
    # Records (structured data)
    person_record: {
        id: 1,
        first_name: "John",
        last_name: "Doe",
        birth_date: "1990-01-15",
        address: {
            street: "123 Main St",
            city: "New York",
            state: "NY",
            zip_code: "10001"
        },
        contact: {
            email: "john.doe@example.com",
            phone: "+1-555-123-4567"
        }
    }
    
    # Sets (unique collections)
    unique_tags: ["web", "api", "database", "cache"]
    permissions: ["read", "write", "delete", "admin"]
    
    # Enums (predefined values)
    log_level: "INFO"  # one of: DEBUG, INFO, WARN, ERROR, FATAL
    status: "active"   # one of: active, inactive, pending, suspended
    
    # Union types (multiple possible types)
    mixed_id: 12345          # could be number or string
    flexible_config: {       # object with variable structure
        type: "database",
        connection: "postgresql://..."
    }
}

# 6. Type Conversions and Coercion
conversions {
    # Automatic type conversion examples
    string_to_number: "123"     # "123" -> 123
    number_to_string: 456       # 456 -> "456"
    string_to_boolean: "true"   # "true" -> true
    
    # Explicit type conversion
    parsed_int: parseInt("789")
    parsed_float: parseFloat("3.14")
    to_string: toString(42)
    to_boolean: toBoolean("yes")
    
    # JSON parsing
    json_data: parseJSON('{"key": "value"}')
    json_array: parseJSON('[1, 2, 3]')
    
    # Date/time parsing
    date_string: "2023-12-25"
    parsed_date: parseDate("2023-12-25T10:30:00Z")
    timestamp: parseTimestamp("1640995200")
    
    # Base64 encoding/decoding
    encoded_data: base64Encode("Hello World")
    decoded_data: base64Decode("SGVsbG8gV29ybGQ=")
    
    # URL encoding/decoding
    encoded_url: urlEncode("hello world")
    decoded_url: urlDecode("hello%20world")
}

# 7. Conditional Types
conditional_types {
    # Type based on environment
    database_config: @if(env("NODE_ENV") == "production", {
        host: env("DB_HOST"),
        port: env("DB_PORT", 5432),
        ssl: true
    }, {
        host: "localhost",
        port: 5432,
        ssl: false
    })
    
    # Type based on feature flags
    cache_settings: @if(env("ENABLE_REDIS", false), {
        type: "redis",
        url: env("REDIS_URL"),
        ttl: 3600
    }, {
        type: "memory",
        max_size: 1000,
        ttl: 1800
    })
    
    # Default values with type preservation
    timeout: env("TIMEOUT") ?? 30        # number or default
    name: env("APP_NAME") ?? "MyApp"     # string or default
    enabled: env("ENABLED") ?? true      # boolean or default
    
    # Optional chaining
    deep_value: @config?.database?.settings?.timeout ?? 30
    array_item: @items?.[0]?.name ?? "Unknown"
}

# 8. Generic and Template Types
generics {
    # Generic configuration template
    service_template: {
        name: @template.name,
        port: @template.port,
        replicas: @template.replicas ?? 1,
        resources: {
            memory: @template.memory ?? "512Mi",
            cpu: @template.cpu ?? "100m"
        }
    }
    
    # Instantiate templates
    web_service: @extend(service_template, {
        name: "web-service",
        port: 8080,
        replicas: 3
    })
    
    api_service: @extend(service_template, {
        name: "api-service", 
        port: 8081,
        replicas: 2,
        memory: "1Gi"
    })
    
    # Collection generics
    string_list: [] :: string[]
    number_map: {} :: map[string, number]
    user_records: [] :: User[]
    
    # Function type signatures
    validator: @function(input: string) -> boolean
    transformer: @function(data: any) -> any
    callback: @function(error: Error?, result: any) -> void
}

# 9. Schema Definitions
schemas {
    # Define custom types
    User: @schema({
        id: number @required,
        username: string @required @min_length(3),
        email: string @required @email,
        age: number @min(13) @max(120),
        active: boolean @default(true),
        created_at: string @iso_date,
        profile: {
            first_name: string,
            last_name: string,
            bio: string @max_length(500)
        } @optional
    })
    
    Product: @schema({
        sku: string @required @pattern("[A-Z]{3}-[0-9]{4}"),
        name: string @required @max_length(100),
        price: number @required @min(0),
        category: string @enum(["electronics", "clothing", "books"]),
        tags: string[] @default([]),
        availability: {
            in_stock: boolean @default(true),
            quantity: number @min(0) @default(0)
        }
    })
    
    # Use schemas for validation
    sample_user: {
        id: 1,
        username: "johndoe",
        email: "john@example.com",
        age: 25,
        active: true,
        created_at: "2023-01-15T10:30:00Z"
    } :: User
    
    sample_product: {
        sku: "ELE-1234",
        name: "Wireless Headphones",
        price: 99.99,
        category: "electronics",
        tags: ["wireless", "bluetooth", "audio"],
        availability: {
            in_stock: true,
            quantity: 50
        }
    } :: Product
}
</pre>

<h3>C# Data Types Implementation</h3>
<pre>
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace TuskLang.DataTypes
{
    // Base class for all TuskLang data types
    public abstract class TuskDataType
    {
        public abstract Type CLRType { get; }
        public abstract object DefaultValue { get; }
        public abstract bool IsValid(object value);
        public abstract object Convert(object value);
        public abstract string TypeName { get; }
    }

    // String data type
    public class TuskString : TuskDataType
    {
        public override Type CLRType => typeof(string);
        public override object DefaultValue => string.Empty;
        public override string TypeName => "string";

        public int? MinLength { get; set; }
        public int? MaxLength { get; set; }
        public string Pattern { get; set; }
        public List<string> AllowedValues { get; set; }

        public override bool IsValid(object value)
        {
            if (value == null) return true;
            if (value is not string str) return false;

            if (MinLength.HasValue && str.Length < MinLength.Value) return false;
            if (MaxLength.HasValue && str.Length > MaxLength.Value) return false;
            
            if (!string.IsNullOrEmpty(Pattern))
            {
                if (!Regex.IsMatch(str, Pattern)) return false;
            }

            if (AllowedValues?.Any() == true)
            {
                if (!AllowedValues.Contains(str)) return false;
            }

            return true;
        }

        public override object Convert(object value)
        {
            return value switch
            {
                null => null,
                string s => s,
                bool b => b.ToString().ToLowerInvariant(),
                _ => value.ToString()
            };
        }
    }

    // Number data type
    public class TuskNumber : TuskDataType
    {
        public override Type CLRType => typeof(decimal);
        public override object DefaultValue => 0m;
        public override string TypeName => "number";

        public decimal? Min { get; set; }
        public decimal? Max { get; set; }
        public bool IsInteger { get; set; }

        public override bool IsValid(object value)
        {
            if (value == null) return true;
            
            decimal numValue;
            if (value is decimal d)
            {
                numValue = d;
            }
            else if (decimal.TryParse(value.ToString(), out numValue))
            {
                // Valid conversion
            }
            else
            {
                return false;
            }

            if (IsInteger && numValue % 1 != 0) return false;
            if (Min.HasValue && numValue < Min.Value) return false;
            if (Max.HasValue && numValue > Max.Value) return false;

            return true;
        }

        public override object Convert(object value)
        {
            return value switch
            {
                null => null,
                decimal d => d,
                int i => (decimal)i,
                long l => (decimal)l,
                float f => (decimal)f,
                double db => (decimal)db,
                string s when decimal.TryParse(s, out var result) => result,
                string s when s.StartsWith("0x", StringComparison.OrdinalIgnoreCase) 
                    => (decimal)System.Convert.ToInt64(s, 16),
                string s when s.StartsWith("0b", StringComparison.OrdinalIgnoreCase) 
                    => (decimal)System.Convert.ToInt64(s.Substring(2), 2),
                string s when s.StartsWith("0o", StringComparison.OrdinalIgnoreCase) 
                    => (decimal)System.Convert.ToInt64(s.Substring(2), 8),
                _ => throw new InvalidCastException($"Cannot convert {value?.GetType().Name} to number")
            };
        }
    }

    // Boolean data type
    public class TuskBoolean : TuskDataType
    {
        public override Type CLRType => typeof(bool);
        public override object DefaultValue => false;
        public override string TypeName => "boolean";

        public override bool IsValid(object value)
        {
            if (value == null) return true;
            
            return value switch
            {
                bool => true,
                string s => s.ToLowerInvariant() is "true" or "false" or "yes" or "no" or "1" or "0",
                int i => i is 0 or 1,
                _ => false
            };
        }

        public override object Convert(object value)
        {
            return value switch
            {
                null => null,
                bool b => b,
                string s => s.ToLowerInvariant() switch
                {
                    "true" or "yes" or "1" => true,
                    "false" or "no" or "0" => false,
                    _ => throw new InvalidCastException($"Cannot convert '{s}' to boolean")
                },
                int i => i switch
                {
                    1 => true,
                    0 => false,
                    _ => throw new InvalidCastException($"Cannot convert {i} to boolean")
                },
                _ => throw new InvalidCastException($"Cannot convert {value?.GetType().Name} to boolean")
            };
        }
    }

    // Array data type
    public class TuskArray : TuskDataType
    {
        public override Type CLRType => typeof(List<object>);
        public override object DefaultValue => new List<object>();
        public override string TypeName => "array";

        public TuskDataType ElementType { get; set; }
        public int? MinLength { get; set; }
        public int? MaxLength { get; set; }

        public override bool IsValid(object value)
        {
            if (value == null) return true;
            if (value is not IEnumerable<object> enumerable) return false;

            var list = enumerable.ToList();
            
            if (MinLength.HasValue && list.Count < MinLength.Value) return false;
            if (MaxLength.HasValue && list.Count > MaxLength.Value) return false;

            if (ElementType != null)
            {
                return list.All(item => ElementType.IsValid(item));
            }

            return true;
        }

        public override object Convert(object value)
        {
            return value switch
            {
                null => null,
                IEnumerable<object> enumerable => enumerable.ToList(),
                string s when s.StartsWith('[') && s.EndsWith(']') => 
                    JsonSerializer.Deserialize<List<object>>(s),
                _ => new List<object> { value }
            };
        }
    }

    // Object data type
    public class TuskObject : TuskDataType
    {
        public override Type CLRType => typeof(Dictionary<string, object>);
        public override object DefaultValue => new Dictionary<string, object>();
        public override string TypeName => "object";

        public Dictionary<string, TuskDataType> Properties { get; set; } = new();
        public List<string> RequiredProperties { get; set; } = new();
        public bool AllowAdditionalProperties { get; set; } = true;

        public override bool IsValid(object value)
        {
            if (value == null) return true;
            if (value is not Dictionary<string, object> dict) return false;

            // Check required properties
            foreach (var required in RequiredProperties)
            {
                if (!dict.ContainsKey(required)) return false;
            }

            // Check property types
            foreach (var (key, propValue) in dict)
            {
                if (Properties.TryGetValue(key, out var propType))
                {
                    if (!propType.IsValid(propValue)) return false;
                }
                else if (!AllowAdditionalProperties)
                {
                    return false;
                }
            }

            return true;
        }

        public override object Convert(object value)
        {
            return value switch
            {
                null => null,
                Dictionary<string, object> dict => dict,
                string s when s.StartsWith('{') && s.EndsWith('}') => 
                    JsonSerializer.Deserialize<Dictionary<string, object>>(s),
                _ => throw new InvalidCastException($"Cannot convert {value?.GetType().Name} to object")
            };
        }
    }

    // Type system manager
    public class TuskTypeSystem
    {
        private readonly Dictionary<string, TuskDataType> _types = new();
        private readonly Dictionary<string, Func<string, object>> _validators = new();

        public TuskTypeSystem()
        {
            RegisterBuiltInTypes();
            RegisterBuiltInValidators();
        }

        private void RegisterBuiltInTypes()
        {
            RegisterType("string", new TuskString());
            RegisterType("number", new TuskNumber());
            RegisterType("integer", new TuskNumber { IsInteger = true });
            RegisterType("float", new TuskNumber { IsInteger = false });
            RegisterType("boolean", new TuskBoolean());
            RegisterType("array", new TuskArray());
            RegisterType("object", new TuskObject());
        }

        private void RegisterBuiltInValidators()
        {
            _validators["email"] = ValidateEmail;
            _validators["phone"] = ValidatePhone;
            _validators["url"] = ValidateUrl;
            _validators["password"] = ValidatePassword;
            _validators["iso_date"] = ValidateIsoDate;
        }

        public void RegisterType(string name, TuskDataType type)
        {
            _types[name] = type;
        }

        public TuskDataType GetType(string name)
        {
            return _types.TryGetValue(name, out var type) ? type : null;
        }

        public ValidationResult ValidateValue(object value, string typeName, Dictionary<string, object> constraints = null)
        {
            var result = new ValidationResult();
            var type = GetType(typeName);

            if (type == null)
            {
                result.IsValid = false;
                result.Errors.Add($"Unknown type: {typeName}");
                return result;
            }

            // Basic type validation
            if (!type.IsValid(value))
            {
                result.IsValid = false;
                result.Errors.Add($"Value is not a valid {typeName}");
                return result;
            }

            // Apply constraints
            if (constraints != null)
            {
                foreach (var (constraint, constraintValue) in constraints)
                {
                    if (!ApplyConstraint(value, constraint, constraintValue, result))
                    {
                        result.IsValid = false;
                    }
                }
            }

            return result;
        }

        private bool ApplyConstraint(object value, string constraint, object constraintValue, ValidationResult result)
        {
            switch (constraint.ToLowerInvariant())
            {
                case "required":
                    if (value == null)
                    {
                        result.Errors.Add("Value is required");
                        return false;
                    }
                    break;

                case "min_length":
                    if (value is string str && str.Length < (int)constraintValue)
                    {
                        result.Errors.Add($"String length must be at least {constraintValue}");
                        return false;
                    }
                    break;

                case "max_length":
                    if (value is string str2 && str2.Length > (int)constraintValue)
                    {
                        result.Errors.Add($"String length must be at most {constraintValue}");
                        return false;
                    }
                    break;

                case "min":
                    if (value is decimal num && num < (decimal)constraintValue)
                    {
                        result.Errors.Add($"Value must be at least {constraintValue}");
                        return false;
                    }
                    break;

                case "max":
                    if (value is decimal num2 && num2 > (decimal)constraintValue)
                    {
                        result.Errors.Add($"Value must be at most {constraintValue}");
                        return false;
                    }
                    break;

                case "pattern":
                    if (value is string str3 && !Regex.IsMatch(str3, (string)constraintValue))
                    {
                        result.Errors.Add($"Value does not match required pattern");
                        return false;
                    }
                    break;

                case "email":
                    if (value is string email && ValidateEmail(email) == null)
                    {
                        result.Errors.Add("Invalid email format");
                        return false;
                    }
                    break;

                case "url":
                    if (value is string url && ValidateUrl(url) == null)
                    {
                        result.Errors.Add("Invalid URL format");
                        return false;
                    }
                    break;

                case "enum":
                    if (constraintValue is string[] allowedValues && 
                        value is string enumValue && 
                        !allowedValues.Contains(enumValue))
                    {
                        result.Errors.Add($"Value must be one of: {string.Join(", ", allowedValues)}");
                        return false;
                    }
                    break;
            }

            return true;
        }

        // Built-in validators
        private static object ValidateEmail(string value)
        {
            var emailRegex = new Regex(@"^[^\s@]+@[^\s@]+\.[^\s@]+$");
            return emailRegex.IsMatch(value) ? value : null;
        }

        private static object ValidatePhone(string value)
        {
            var phoneRegex = new Regex(@"^[\+]?[1-9][\d]{0,15}$");
            return phoneRegex.IsMatch(value.Replace("-", "").Replace(" ", "")) ? value : null;
        }

        private static object ValidateUrl(string value)
        {
            return Uri.TryCreate(value, UriKind.Absolute, out _) ? value : null;
        }

        private static object ValidatePassword(string value)
        {
            // Basic password validation: at least 8 characters, contains letter and number
            if (value.Length < 8) return null;
            if (!value.Any(char.IsLetter)) return null;
            if (!value.Any(char.IsDigit)) return null;
            return value;
        }

        private static object ValidateIsoDate(string value)
        {
            return DateTime.TryParse(value, null, DateTimeStyles.RoundtripKind, out _) ? value : null;
        }

        public object ConvertValue(object value, string targetType)
        {
            var type = GetType(targetType);
            return type?.Convert(value) ?? value;
        }

        public T ConvertValue<T>(object value)
        {
            if (value is T directCast)
                return directCast;

            try
            {
                return (T)System.Convert.ChangeType(value, typeof(T));
            }
            catch
            {
                return default(T);
            }
        }
    }

    // Validation result
    public class ValidationResult
    {
        public bool IsValid { get; set; } = true;
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    // Type metadata
    public class TypeMetadata
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string Version { get; set; }
        public bool Deprecated { get; set; }
        public object DefaultValue { get; set; }
        public Dictionary<string, object> Constraints { get; set; } = new();
        public List<string> Examples { get; set; } = new();
    }

    // Schema definition
    public class TuskSchema
    {
        public string Name { get; set; }
        public string Version { get; set; }
        public Dictionary<string, PropertySchema> Properties { get; set; } = new();
        public List<string> Required { get; set; } = new();
        public bool AdditionalProperties { get; set; } = true;

        public ValidationResult Validate(Dictionary<string, object> data)
        {
            var result = new ValidationResult();
            var typeSystem = new TuskTypeSystem();

            // Check required properties
            foreach (var requiredProp in Required)
            {
                if (!data.ContainsKey(requiredProp))
                {
                    result.IsValid = false;
                    result.Errors.Add($"Required property '{requiredProp}' is missing");
                }
            }

            // Validate each property
            foreach (var (propName, propValue) in data)
            {
                if (Properties.TryGetValue(propName, out var propSchema))
                {
                    var propResult = typeSystem.ValidateValue(propValue, propSchema.Type, propSchema.Constraints);
                    if (!propResult.IsValid)
                    {
                        result.IsValid = false;
                        result.Errors.AddRange(propResult.Errors.Select(e => $"{propName}: {e}"));
                    }
                }
                else if (!AdditionalProperties)
                {
                    result.IsValid = false;
                    result.Errors.Add($"Additional property '{propName}' is not allowed");
                }
            }

            return result;
        }
    }

    public class PropertySchema
    {
        public string Type { get; set; }
        public object DefaultValue { get; set; }
        public Dictionary<string, object> Constraints { get; set; } = new();
        public string Description { get; set; }
        public List<string> Examples { get; set; } = new();
    }

    // Type converter utility
    public static class TuskTypeConverter
    {
        public static T ConvertTo<T>(object value)
        {
            if (value == null)
                return default(T);

            if (value is T direct)
                return direct;

            var targetType = typeof(T);
            var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

            if (underlyingType == typeof(string))
                return (T)(object)value.ToString();

            if (underlyingType == typeof(bool))
            {
                var boolValue = value.ToString().ToLowerInvariant() switch
                {
                    "true" or "yes" or "1" => true,
                    "false" or "no" or "0" => false,
                    _ => bool.Parse(value.ToString())
                };
                return (T)(object)boolValue;
            }

            if (underlyingType.IsEnum)
            {
                return (T)Enum.Parse(underlyingType, value.ToString(), true);
            }

            return (T)System.Convert.ChangeType(value, underlyingType);
        }

        public static bool TryConvertTo<T>(object value, out T result)
        {
            try
            {
                result = ConvertTo<T>(value);
                return true;
            }
            catch
            {
                result = default(T);
                return false;
            }
        }
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using System;
using System.Collections.Generic;
using TuskLang.DataTypes;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== TuskLang Data Types Demo ===");

        // 1. Basic type system
        Console.WriteLine("\n1. Type System Basics:");
        DemonstrateBasicTypes();

        // 2. Type validation
        Console.WriteLine("\n2. Type Validation:");
        DemonstrateTypeValidation();

        // 3. Type conversion
        Console.WriteLine("\n3. Type Conversion:");
        DemonstrateTypeConversion();

        // 4. Schema validation
        Console.WriteLine("\n4. Schema Validation:");
        DemonstrateSchemaValidation();

        // 5. Advanced types
        Console.WriteLine("\n5. Advanced Types:");
        DemonstrateAdvancedTypes();

        Console.WriteLine("\n=== Demo Complete ===");
    }

    static void DemonstrateBasicTypes()
    {
        var typeSystem = new TuskTypeSystem();

        // Test string type
        var stringType = typeSystem.GetType("string");
        Console.WriteLine($"  String type validation:");
        Console.WriteLine($"    'Hello' is valid: {stringType.IsValid("Hello")}");
        Console.WriteLine($"    123 is valid: {stringType.IsValid(123)}");
        Console.WriteLine($"    null is valid: {stringType.IsValid(null)}");

        // Test number type
        var numberType = typeSystem.GetType("number");
        Console.WriteLine($"  Number type validation:");
        Console.WriteLine($"    42 is valid: {numberType.IsValid(42)}");
        Console.WriteLine($"    3.14 is valid: {numberType.IsValid(3.14m)}");
        Console.WriteLine($"    'text' is valid: {numberType.IsValid("text")}");

        // Test boolean type
        var boolType = typeSystem.GetType("boolean");
        Console.WriteLine($"  Boolean type validation:");
        Console.WriteLine($"    true is valid: {boolType.IsValid(true)}");
        Console.WriteLine($"    'true' is valid: {boolType.IsValid("true")}");
        Console.WriteLine($"    'maybe' is valid: {boolType.IsValid("maybe")}");
    }

    static void DemonstrateTypeValidation()
    {
        var typeSystem = new TuskTypeSystem();

        // String with constraints
        var stringConstraints = new Dictionary<string, object>
        {
            ["min_length"] = 3,
            ["max_length"] = 20,
            ["pattern"] = @"^[a-zA-Z0-9_]+$"
        };

        var testStrings = new[] { "abc", "a", "valid_name123", "invalid-name!", "very_long_string_that_exceeds_limit" };

        Console.WriteLine("  String validation with constraints:");
        foreach (var testString in testStrings)
        {
            var result = typeSystem.ValidateValue(testString, "string", stringConstraints);
            Console.WriteLine($"    '{testString}': {(result.IsValid ? "✓" : "✗")}");
            if (!result.IsValid)
            {
                Console.WriteLine($"      Errors: {string.Join(", ", result.Errors)}");
            }
        }

        // Number with range constraints
        var numberConstraints = new Dictionary<string, object>
        {
            ["min"] = 0,
            ["max"] = 100
        };

        var testNumbers = new object[] { 50, -10, 150, 0, 100 };

        Console.WriteLine("\n  Number validation with range:");
        foreach (var testNumber in testNumbers)
        {
            var result = typeSystem.ValidateValue(testNumber, "number", numberConstraints);
            Console.WriteLine($"    {testNumber}: {(result.IsValid ? "✓" : "✗")}");
            if (!result.IsValid)
            {
                Console.WriteLine($"      Errors: {string.Join(", ", result.Errors)}");
            }
        }

        // Email validation
        var emailConstraints = new Dictionary<string, object> { ["email"] = true };
        var testEmails = new[] { "valid@example.com", "invalid-email", "test@domain.co.uk", "@invalid.com" };

        Console.WriteLine("\n  Email validation:");
        foreach (var email in testEmails)
        {
            var result = typeSystem.ValidateValue(email, "string", emailConstraints);
            Console.WriteLine($"    '{email}': {(result.IsValid ? "✓" : "✗")}");
        }
    }

    static void DemonstrateTypeConversion()
    {
        var typeSystem = new TuskTypeSystem();

        Console.WriteLine("  Type conversions:");

        // String conversions
        var stringType = typeSystem.GetType("string");
        Console.WriteLine($"    Convert 123 to string: '{stringType.Convert(123)}'");
        Console.WriteLine($"    Convert true to string: '{stringType.Convert(true)}'");

        // Number conversions
        var numberType = typeSystem.GetType("number");
        Console.WriteLine($"    Convert '42' to number: {numberType.Convert("42")}");
        Console.WriteLine($"    Convert '0xFF' to number: {numberType.Convert("0xFF")}");
        Console.WriteLine($"    Convert '0b1010' to number: {numberType.Convert("0b1010")}");

        // Boolean conversions
        var boolType = typeSystem.GetType("boolean");
        Console.WriteLine($"    Convert 'true' to boolean: {boolType.Convert("true")}");
        Console.WriteLine($"    Convert 'yes' to boolean: {boolType.Convert("yes")}");
        Console.WriteLine($"    Convert 1 to boolean: {boolType.Convert(1)}");

        // Using utility converter
        Console.WriteLine("\n  Utility converter:");
        Console.WriteLine($"    Convert '42' to int: {TuskTypeConverter.ConvertTo<int>("42")}");
        Console.WriteLine($"    Convert 'true' to bool: {TuskTypeConverter.ConvertTo<bool>("true")}");
        Console.WriteLine($"    Convert 3.14 to string: '{TuskTypeConverter.ConvertTo<string>(3.14)}'");
    }

    static void DemonstrateSchemaValidation()
    {
        // Define a user schema
        var userSchema = new TuskSchema
        {
            Name = "User",
            Version = "1.0",
            Required = new List<string> { "id", "username", "email" },
            Properties = new Dictionary<string, PropertySchema>
            {
                ["id"] = new PropertySchema
                {
                    Type = "integer",
                    Constraints = new Dictionary<string, object> { ["min"] = 1 }
                },
                ["username"] = new PropertySchema
                {
                    Type = "string",
                    Constraints = new Dictionary<string, object>
                    {
                        ["min_length"] = 3,
                        ["max_length"] = 20,
                        ["pattern"] = @"^[a-zA-Z0-9_]+$"
                    }
                },
                ["email"] = new PropertySchema
                {
                    Type = "string",
                    Constraints = new Dictionary<string, object> { ["email"] = true }
                },
                ["age"] = new PropertySchema
                {
                    Type = "integer",
                    Constraints = new Dictionary<string, object> { ["min"] = 13, ["max"] = 120 }
                },
                ["active"] = new PropertySchema
                {
                    Type = "boolean",
                    DefaultValue = true
                }
            }
        };

        // Test valid user
        var validUser = new Dictionary<string, object>
        {
            ["id"] = 1,
            ["username"] = "johndoe",
            ["email"] = "john@example.com",
            ["age"] = 25,
            ["active"] = true
        };

        Console.WriteLine("  Valid user schema validation:");
        var result = userSchema.Validate(validUser);
        Console.WriteLine($"    Is valid: {result.IsValid}");

        // Test invalid user
        var invalidUser = new Dictionary<string, object>
        {
            ["id"] = -1,  // Invalid: negative ID
            ["username"] = "jd",  // Invalid: too short
            ["email"] = "invalid-email",  // Invalid: bad format
            ["age"] = 10  // Invalid: too young
            // Missing required email field
        };

        Console.WriteLine("\n  Invalid user schema validation:");
        result = userSchema.Validate(invalidUser);
        Console.WriteLine($"    Is valid: {result.IsValid}");
        if (!result.IsValid)
        {
            Console.WriteLine("    Errors:");
            foreach (var error in result.Errors)
            {
                Console.WriteLine($"      - {error}");
            }
        }
    }

    static void DemonstrateAdvancedTypes()
    {
        // Generic array type
        var stringArrayType = new TuskArray
        {
            ElementType = new TuskString
            {
                MinLength = 1,
                MaxLength = 50
            },
            MinLength = 1,
            MaxLength = 10
        };

        var testArrays = new object[]
        {
            new List<object> { "apple", "banana", "cherry" },
            new List<object> { "" },  // Invalid: empty string
            new List<object>(),  // Invalid: empty array
            new List<object> { "valid", "also_valid", "still_valid" }
        };

        Console.WriteLine("  String array validation:");
        foreach (var testArray in testArrays)
        {
            var isValid = stringArrayType.IsValid(testArray);
            Console.WriteLine($"    {JsonSerializer.Serialize(testArray)}: {(isValid ? "✓" : "✗")}");
        }

        // Complex object type
        var addressType = new TuskObject
        {
            RequiredProperties = new List<string> { "street", "city", "zip" },
            Properties = new Dictionary<string, TuskDataType>
            {
                ["street"] = new TuskString { MinLength = 1, MaxLength = 100 },
                ["city"] = new TuskString { MinLength = 1, MaxLength = 50 },
                ["state"] = new TuskString { MinLength = 2, MaxLength = 2 },
                ["zip"] = new TuskString { Pattern = @"^\d{5}(-\d{4})?$" },
                ["country"] = new TuskString { AllowedValues = new List<string> { "US", "CA", "MX" } }
            }
        };

        var testAddresses = new object[]
        {
            new Dictionary<string, object>
            {
                ["street"] = "123 Main St",
                ["city"] = "New York",
                ["state"] = "NY",
                ["zip"] = "10001",
                ["country"] = "US"
            },
            new Dictionary<string, object>
            {
                ["street"] = "456 Oak Ave",
                ["city"] = "Los Angeles"
                // Missing required zip
            }
        };

        Console.WriteLine("\n  Address object validation:");
        foreach (var address in testAddresses)
        {
            var isValid = addressType.IsValid(address);
            Console.WriteLine($"    Address: {(isValid ? "✓" : "✗")}");
        }
    }
}
</pre>

<p>TuskLang data types in C# provide comprehensive type validation, conversion, and schema enforcement for robust configuration processing with strong typing and constraint validation.</p>