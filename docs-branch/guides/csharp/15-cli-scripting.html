<h1>CLI & Scripting</h1>

<h2>CLI & Scripting with TuskLang in C#</h2>
<p>Create command-line interfaces, scripting tools, and automation utilities using TuskLang configuration in C# applications.</p>

<h3>cli.tsk</h3>
<pre>
# TuskLang CLI & Scripting Configuration

# 1. CLI Application Configuration
cli_application {
    # Application metadata
    metadata: {
        name: env("CLI_APP_NAME", "tuskcli")
        version: env("CLI_APP_VERSION", "1.0.0")
        description: "TuskLang CLI and scripting tool"
        author: "TuskLang Team"
        
        # Usage information
        usage: "#{@metadata.name} [command] [options]"
        examples: [
            "#{@metadata.name} convert -i file.json -o file.tsk",
            "#{@metadata.name} validate -f config.tsk",
            "#{@metadata.name} migrate --dry-run",
            "#{@metadata.name} script run deployment.tsk"
        ]
    }
    
    # Global options
    global_options: {
        # Help option
        help: {
            short: "h"
            long: "help"
            description: "Show help information"
            action: "show_help"
        }
        
        # Version option
        version: {
            short: "v"
            long: "version"
            description: "Show version information"
            action: "show_version"
        }
        
        # Verbose output
        verbose: {
            short: "V"
            long: "verbose"
            description: "Enable verbose output"
            type: "flag"
            default: false
        }
        
        # Quiet mode
        quiet: {
            short: "q"
            long: "quiet"
            description: "Suppress output"
            type: "flag"
            default: false
        }
        
        # Configuration file
        config: {
            short: "c"
            long: "config"
            description: "Configuration file path"
            type: "string"
            default: "tusklang.config.tsk"
        }
        
        # Output format
        format: {
            short: "f"
            long: "format"
            description: "Output format"
            type: "choice"
            choices: ["json", "yaml", "tsk", "table", "csv"]
            default: "tsk"
        }
        
        # Log level
        log_level: {
            long: "log-level"
            description: "Set log level"
            type: "choice"
            choices: ["trace", "debug", "info", "warn", "error", "fatal"]
            default: "info"
        }
        
        # Working directory
        directory: {
            short: "d"
            long: "directory"
            description: "Working directory"
            type: "directory"
            default: @pwd
        }
        
        # Parallel processing
        parallel: {
            short: "j"
            long: "jobs"
            description: "Number of parallel jobs"
            type: "integer"
            default: @system.cpu_count
            min: 1
            max: 32
        }
        
        # Force operations
        force: {
            long: "force"
            description: "Force operation without confirmation"
            type: "flag"
            default: false
        }
        
        # Dry run mode
        dry_run: {
            long: "dry-run"
            description: "Show what would be done without executing"
            type: "flag"
            default: false
        }
    }
}

# 2. CLI Commands
cli_commands {
    # Convert command
    convert: {
        description: "Convert between different configuration formats"
        usage: "convert [options]"
        
        # Command options
        options: {
            input: {
                short: "i"
                long: "input"
                description: "Input file path"
                type: "file"
                required: true
                validate: @file_exists
            }
            
            output: {
                short: "o"
                long: "output"
                description: "Output file path"
                type: "string"
                required: true
            }
            
            input_format: {
                long: "input-format"
                description: "Input format (auto-detected if not specified)"
                type: "choice"
                choices: ["json", "yaml", "tsk", "xml", "toml"]
            }
            
            output_format: {
                long: "output-format"
                description: "Output format (inferred from extension if not specified)"
                type: "choice"
                choices: ["json", "yaml", "tsk", "xml", "toml"]
            }
            
            pretty: {
                short: "p"
                long: "pretty"
                description: "Pretty-print output"
                type: "flag"
                default: true
            }
            
            validate: {
                long: "validate"
                description: "Validate input before conversion"
                type: "flag"
                default: true
            }
            
            schema: {
                short: "s"
                long: "schema"
                description: "Schema file for validation"
                type: "file"
            }
        }
        
        # Command execution
        execution: {
            handler: @convert_files
            pre_hooks: [@validate_input_file, @check_output_permissions]
            post_hooks: [@validate_output_file, @log_conversion_stats]
            
            # Error handling
            error_handling: {
                on_validation_error: "abort"
                on_conversion_error: "abort"
                on_output_error: "abort"
                retry_attempts: 0
            }
        }
        
        # Examples
        examples: [
            "convert -i config.json -o config.tsk",
            "convert -i settings.yaml -o settings.json --pretty",
            "convert -i data.tsk -o data.xml --validate --schema schema.json"
        ]
    }
    
    # Validate command
    validate: {
        description: "Validate TuskLang configuration files"
        usage: "validate [options]"
        
        # Command options
        options: {
            file: {
                short: "f"
                long: "file"
                description: "File or directory to validate"
                type: "path"
                required: true
                multiple: true
            }
            
            schema: {
                short: "s"
                long: "schema"
                description: "Schema file for validation"
                type: "file"
            }
            
            recursive: {
                short: "r"
                long: "recursive"
                description: "Recursively validate directories"
                type: "flag"
                default: false
            }
            
            pattern: {
                short: "p"
                long: "pattern"
                description: "File pattern to match"
                type: "string"
                default: "*.tsk"
            }
            
            strict: {
                long: "strict"
                description: "Enable strict validation mode"
                type: "flag"
                default: false
            }
            
            warnings_as_errors: {
                long: "warnings-as-errors"
                description: "Treat warnings as errors"
                type: "flag"
                default: false
            }
            
            max_errors: {
                long: "max-errors"
                description: "Maximum number of errors to report"
                type: "integer"
                default: 50
                min: 1
            }
        }
        
        # Validation rules
        validation: {
            syntax_check: true
            schema_validation: true
            reference_validation: true
            
            # Custom rules
            custom_rules: [
                @check_deprecated_syntax,
                @check_security_patterns,
                @check_performance_patterns,
                @check_naming_conventions
            ]
            
            # Rule configuration
            rules: {
                deprecated_syntax: {
                    level: "warning"
                    auto_fix: true
                }
                
                security_patterns: {
                    level: "error"
                    auto_fix: false
                    patterns: [
                        "hardcoded_secrets",
                        "sql_injection_risk",
                        "xss_vulnerability"
                    ]
                }
                
                performance_patterns: {
                    level: "warning"
                    auto_fix: false
                    patterns: [
                        "inefficient_queries",
                        "memory_leaks",
                        "blocking_operations"
                    ]
                }
                
                naming_conventions: {
                    level: "info"
                    auto_fix: true
                    conventions: {
                        variables: "snake_case"
                        functions: "camelCase"
                        constants: "UPPER_CASE"
                    }
                }
            }
        }
        
        # Output configuration
        output: {
            show_summary: true
            show_details: true
            show_context: true
            group_by_file: true
            
            # Report formats
            formats: {
                console: {
                    enabled: true
                    color: @supports_color
                    icons: @supports_unicode
                }
                
                json: {
                    enabled: @format == "json"
                    pretty: true
                    include_context: true
                }
                
                junit: {
                    enabled: false
                    output_file: "validation-results.xml"
                }
                
                html: {
                    enabled: false
                    output_file: "validation-report.html"
                    template: "default"
                }
            }
        }
        
        # Examples
        examples: [
            "validate -f config.tsk",
            "validate -f configs/ --recursive --pattern '*.tsk'",
            "validate -f app.tsk --schema app.schema.json --strict",
            "validate -f . -r --format json --max-errors 10"
        ]
    }
    
    # Migrate command
    migrate: {
        description: "Migrate configuration files to newer formats or versions"
        usage: "migrate [subcommand] [options]"
        
        # Subcommands
        subcommands: {
            analyze: {
                description: "Analyze files for migration opportunities"
                
                options: {
                    path: {
                        short: "p"
                        long: "path"
                        description: "Path to analyze"
                        type: "directory"
                        default: @pwd
                    }
                    
                    report: {
                        short: "r"
                        long: "report"
                        description: "Generate migration report"
                        type: "string"
                        default: "migration-report.json"
                    }
                }
            }
            
            migrate: {
                description: "Perform migration"
                
                options: {
                    source_version: {
                        long: "from"
                        description: "Source version"
                        type: "string"
                        required: true
                    }
                    
                    target_version: {
                        long: "to"
                        description: "Target version"
                        type: "string"
                        required: true
                    }
                    
                    backup: {
                        short: "b"
                        long: "backup"
                        description: "Create backup before migration"
                        type: "flag"
                        default: true
                    }
                    
                    backup_suffix: {
                        long: "backup-suffix"
                        description: "Backup file suffix"
                        type: "string"
                        default: ".backup"
                    }
                }
            }
            
            rollback: {
                description: "Rollback migration"
                
                options: {
                    migration_id: {
                        short: "i"
                        long: "id"
                        description: "Migration ID to rollback"
                        type: "string"
                        required: true
                    }
                    
                    confirm: {
                        long: "confirm"
                        description: "Confirm rollback operation"
                        type: "flag"
                        default: false
                    }
                }
            }
        }
        
        # Migration strategies
        strategies: {
            # V1 to V2 migration
            "1.0_to_2.0": {
                description: "Migrate from TuskLang v1.0 to v2.0"
                
                transformations: [
                    {
                        name: "update_syntax"
                        description: "Update deprecated syntax"
                        pattern: "old_syntax_pattern"
                        replacement: "new_syntax_pattern"
                        type: "regex"
                    },
                    
                    {
                        name: "restructure_config"
                        description: "Restructure configuration layout"
                        type: "custom"
                        handler: @restructure_v2_config
                    }
                ]
                
                validations: [
                    @validate_v2_compatibility,
                    @check_breaking_changes
                ]
            }
        }
        
        # Examples
        examples: [
            "migrate analyze --path ./configs",
            "migrate migrate --from 1.0 --to 2.0 --backup",
            "migrate rollback --id migration_20231201_001 --confirm"
        ]
    }
    
    # Script command
    script: {
        description: "Execute TuskLang scripts"
        usage: "script [subcommand] [options]"
        
        # Subcommands
        subcommands: {
            run: {
                description: "Run a TuskLang script"
                
                options: {
                    script_file: {
                        short: "s"
                        long: "script"
                        description: "Script file to execute"
                        type: "file"
                        required: true
                        validate: @file_exists
                    }
                    
                    parameters: {
                        short: "p"
                        long: "params"
                        description: "Script parameters (key=value pairs)"
                        type: "key_value"
                        multiple: true
                    }
                    
                    environment: {
                        short: "e"
                        long: "env"
                        description: "Environment to run in"
                        type: "choice"
                        choices: ["development", "staging", "production"]
                        default: "development"
                    }
                    
                    timeout: {
                        short: "t"
                        long: "timeout"
                        description: "Script execution timeout (seconds)"
                        type: "integer"
                        default: 300
                        min: 1
                    }
                    
                    output_file: {
                        short: "o"
                        long: "output"
                        description: "Save output to file"
                        type: "string"
                    }
                }
            }
            
            validate: {
                description: "Validate a TuskLang script"
                
                options: {
                    script_file: {
                        short: "s"
                        long: "script"
                        description: "Script file to validate"
                        type: "file"
                        required: true
                    }
                    
                    check_dependencies: {
                        long: "check-deps"
                        description: "Check script dependencies"
                        type: "flag"
                        default: true
                    }
                }
            }
            
            debug: {
                description: "Debug a TuskLang script"
                
                options: {
                    script_file: {
                        short: "s"
                        long: "script"
                        description: "Script file to debug"
                        type: "file"
                        required: true
                    }
                    
                    breakpoints: {
                        short: "b"
                        long: "breakpoint"
                        description: "Set breakpoints (line numbers)"
                        type: "integer"
                        multiple: true
                    }
                    
                    step_mode: {
                        long: "step"
                        description: "Enable step-by-step execution"
                        type: "flag"
                        default: false
                    }
                    
                    watch: {
                        short: "w"
                        long: "watch"
                        description: "Watch variables"
                        type: "string"
                        multiple: true
                    }
                }
            }
        }
        
        # Script execution environment
        execution_environment: {
            # Sandbox configuration
            sandbox: {
                enabled: true
                
                # Resource limits
                limits: {
                    memory: "512MB"
                    cpu_time: "300s"
                    file_size: "100MB"
                    network_requests: 100
                }
                
                # Allowed operations
                allowed_operations: [
                    "file_read",
                    "file_write",
                    "http_request",
                    "database_query",
                    "environment_variable_read"
                ]
                
                # Restricted paths
                restricted_paths: [
                    "/etc",
                    "/sys",
                    "/proc",
                    "/root"
                ]
            }
            
            # Built-in functions
            builtins: {
                # File operations
                file: {
                    read: @builtin_file_read
                    write: @builtin_file_write
                    exists: @builtin_file_exists
                    delete: @builtin_file_delete
                    copy: @builtin_file_copy
                    move: @builtin_file_move
                }
                
                # HTTP operations
                http: {
                    get: @builtin_http_get
                    post: @builtin_http_post
                    put: @builtin_http_put
                    delete: @builtin_http_delete
                }
                
                # Database operations
                db: {
                    query: @builtin_db_query
                    execute: @builtin_db_execute
                    transaction: @builtin_db_transaction
                }
                
                # Utility functions
                utils: {
                    log: @builtin_log
                    sleep: @builtin_sleep
                    random: @builtin_random
                    uuid: @builtin_uuid
                    hash: @builtin_hash
                    base64_encode: @builtin_base64_encode
                    base64_decode: @builtin_base64_decode
                }
                
                # String operations
                string: {
                    format: @builtin_string_format
                    regex_match: @builtin_regex_match
                    regex_replace: @builtin_regex_replace
                    split: @builtin_string_split
                    join: @builtin_string_join
                }
                
                # Date/time operations
                datetime: {
                    now: @builtin_datetime_now
                    format: @builtin_datetime_format
                    parse: @builtin_datetime_parse
                    add: @builtin_datetime_add
                    diff: @builtin_datetime_diff
                }
            }
        }
        
        # Examples
        examples: [
            "script run deployment.tsk --env production",
            "script run backup.tsk --params backup_path=/backups/daily",
            "script validate automation.tsk --check-deps",
            "script debug complex.tsk --step --watch variables"
        ]
    }
    
    # Benchmark command
    benchmark: {
        description: "Run performance benchmarks"
        usage: "benchmark [options]"
        
        # Command options
        options: {
            test_file: {
                short: "t"
                long: "test"
                description: "Benchmark test file"
                type: "file"
                default: "benchmark.tsk"
            }
            
            iterations: {
                short: "i"
                long: "iterations"
                description: "Number of iterations"
                type: "integer"
                default: 1000
                min: 1
            }
            
            warmup: {
                short: "w"
                long: "warmup"
                description: "Number of warmup iterations"
                type: "integer"
                default: 100
                min: 0
            }
            
            output: {
                short: "o"
                long: "output"
                description: "Output file for results"
                type: "string"
                default: "benchmark-results.json"
            }
            
            format: {
                short: "f"
                long: "format"
                description: "Output format"
                type: "choice"
                choices: ["json", "csv", "table", "markdown"]
                default: "table"
            }
            
            compare: {
                short: "c"
                long: "compare"
                description: "Compare with baseline results"
                type: "file"
            }
            
            profile: {
                short: "p"
                long: "profile"
                description: "Enable profiling"
                type: "flag"
                default: false
            }
        }
        
        # Benchmark tests
        tests: {
            # Parser performance
            parser_performance: {
                description: "Test TuskLang parser performance"
                
                test_cases: [
                    {
                        name: "small_config"
                        file_size: "1KB"
                        complexity: "low"
                        target_ops_per_second: 10000
                    },
                    
                    {
                        name: "medium_config"
                        file_size: "100KB"
                        complexity: "medium"
                        target_ops_per_second: 1000
                    },
                    
                    {
                        name: "large_config"
                        file_size: "10MB"
                        complexity: "high"
                        target_ops_per_second: 10
                    }
                ]
            }
            
            # Serialization performance
            serialization_performance: {
                description: "Test serialization performance"
                
                formats: ["json", "yaml", "xml", "binary"]
                
                test_cases: [
                    {
                        name: "object_serialization"
                        object_count: 1000
                        complexity: "medium"
                    },
                    
                    {
                        name: "array_serialization"
                        array_size: 10000
                        element_type: "mixed"
                    }
                ]
            }
            
            # Memory usage
            memory_usage: {
                description: "Test memory consumption"
                
                scenarios: [
                    {
                        name: "parsing_large_files"
                        file_sizes: ["1MB", "10MB", "100MB"]
                        max_memory_usage: "500MB"
                    },
                    
                    {
                        name: "concurrent_parsing"
                        thread_count: 10
                        file_size: "1MB"
                        max_memory_per_thread: "50MB"
                    }
                ]
            }
        }
        
        # Examples
        examples: [
            "benchmark --iterations 5000 --warmup 500",
            "benchmark --test parser-bench.tsk --format json",
            "benchmark --compare baseline.json --profile"
        ]
    }
}

# 3. Scripting Features
scripting {
    # Script types
    script_types: {
        # Automation scripts
        automation: {
            description: "Automation and workflow scripts"
            file_extension: ".auto.tsk"
            
            # Built-in automation functions
            functions: [
                "deploy",
                "backup",
                "monitor",
                "cleanup",
                "notify",
                "schedule"
            ]
            
            # Execution context
            context: {
                working_directory: @pwd
                environment_variables: @env
                command_line_args: @args
                
                # Automation-specific context
                automation: {
                    job_id: @uuid()
                    started_at: @now
                    user: @current_user
                    hostname: @hostname
                }
            }
        }
        
        # Data processing scripts
        data_processing: {
            description: "Data transformation and processing scripts"
            file_extension: ".data.tsk"
            
            # Data processing functions
            functions: [
                "transform",
                "filter",
                "aggregate",
                "validate",
                "enrich",
                "export"
            ]
            
            # Processing pipeline
            pipeline: {
                input_sources: ["file", "database", "api", "stream"]
                output_targets: ["file", "database", "api", "stream"]
                transformations: ["map", "filter", "reduce", "sort", "group"]
                
                # Error handling
                error_handling: {
                    strategy: "skip"  # skip, stop, retry
                    max_errors: 100
                    error_log: "data-processing-errors.log"
                }
            }
        }
        
        # Deployment scripts
        deployment: {
            description: "Application deployment scripts"
            file_extension: ".deploy.tsk"
            
            # Deployment functions
            functions: [
                "build",
                "test",
                "package",
                "deploy",
                "verify",
                "rollback"
            ]
            
            # Deployment stages
            stages: [
                {
                    name: "build"
                    description: "Build application"
                    required: true
                    timeout: "10m"
                },
                
                {
                    name: "test"
                    description: "Run tests"
                    required: true
                    timeout: "5m"
                    parallel: true
                },
                
                {
                    name: "package"
                    description: "Package application"
                    required: true
                    timeout: "2m"
                    depends_on: ["build", "test"]
                },
                
                {
                    name: "deploy"
                    description: "Deploy to environment"
                    required: true
                    timeout: "15m"
                    depends_on: ["package"]
                },
                
                {
                    name: "verify"
                    description: "Verify deployment"
                    required: true
                    timeout: "5m"
                    depends_on: ["deploy"]
                }
            ]
        }
        
        # Monitoring scripts
        monitoring: {
            description: "System and application monitoring scripts"
            file_extension: ".monitor.tsk"
            
            # Monitoring functions
            functions: [
                "check_health",
                "collect_metrics",
                "analyze_logs",
                "detect_anomalies",
                "alert",
                "report"
            ]
            
            # Monitoring configuration
            configuration: {
                # Check intervals
                intervals: {
                    health_check: "30s"
                    metrics_collection: "1m"
                    log_analysis: "5m"
                    anomaly_detection: "10m"
                }
                
                # Alert thresholds
                thresholds: {
                    cpu_usage: 90
                    memory_usage: 85
                    disk_usage: 80
                    error_rate: 5
                    response_time: 2000
                }
                
                # Notification channels
                notifications: [
                    {
                        type: "email"
                        recipients: env_list("ALERT_EMAILS", ",")
                        severity: ["critical", "high"]
                    },
                    
                    {
                        type: "slack"
                        webhook: env("SLACK_WEBHOOK")
                        channel: "#alerts"
                        severity: ["critical", "high", "medium"]
                    }
                ]
            }
        }
    }
    
    # Script execution engine
    execution_engine: {
        # Interpreter settings
        interpreter: {
            version: "1.0"
            compatibility_mode: false
            
            # Language features
            features: {
                async_await: true
                generators: true
                destructuring: true
                template_literals: true
                arrow_functions: true
                modules: true
            }
            
            # Runtime limits
            limits: {
                max_execution_time: "1h"
                max_memory_usage: "1GB"
                max_file_operations: 10000
                max_network_requests: 1000
                max_recursion_depth: 1000
            }
        }
        
        # Module system
        modules: {
            # Standard library
            stdlib: {
                path: "stdlib/"
                modules: [
                    "fs",      # File system operations
                    "http",    # HTTP client
                    "crypto",  # Cryptography
                    "json",    # JSON processing
                    "yaml",    # YAML processing
                    "xml",     # XML processing
                    "csv",     # CSV processing
                    "db",      # Database operations
                    "log",     # Logging
                    "test",    # Testing utilities
                    "math",    # Mathematical functions
                    "string",  # String operations
                    "date",    # Date/time operations
                    "regex",   # Regular expressions
                    "process", # Process operations
                    "env",     # Environment operations
                    "path",    # Path operations
                    "url",     # URL operations
                    "email",   # Email operations
                    "template" # Template processing
                ]
            }
            
            # Third-party modules
            third_party: {
                enabled: true
                path: "modules/"
                registry: env("MODULE_REGISTRY", "https://modules.tusklang.org")
                
                # Security settings
                security: {
                    allow_network_access: false
                    allow_file_system_access: false
                    sandbox_execution: true
                    signature_verification: true
                }
            }
            
            # Custom modules
            custom: {
                path: "custom_modules/"
                
                # Module discovery
                discovery: {
                    recursive: true
                    pattern: "*.module.tsk"
                    cache_enabled: true
                    cache_ttl: "1h"
                }
            }
        }
        
        # Error handling
        error_handling: {
            # Global error handler
            global_handler: {
                enabled: true
                log_errors: true
                error_log: "script-errors.log"
                
                # Error recovery
                recovery: {
                    retry_on_failure: true
                    max_retries: 3
                    retry_delay: "5s"
                    
                    # Recovery strategies
                    strategies: [
                        "restart_script",
                        "skip_operation",
                        "use_fallback",
                        "manual_intervention"
                    ]
                }
            }
            
            # Exception types
            exceptions: {
                syntax_error: {
                    recovery: "abort"
                    message: "Script contains syntax errors"
                }
                
                runtime_error: {
                    recovery: "retry"
                    message: "Runtime error occurred"
                }
                
                timeout_error: {
                    recovery: "abort"
                    message: "Script execution timed out"
                }
                
                permission_error: {
                    recovery: "skip"
                    message: "Insufficient permissions"
                }
                
                resource_error: {
                    recovery: "retry"
                    message: "Resource unavailable"
                }
            }
        }
        
        # Debugging support
        debugging: {
            enabled: env("DEBUG_ENABLED", false)
            
            # Debug features
            features: {
                breakpoints: true
                step_execution: true
                variable_inspection: true
                call_stack_trace: true
                memory_profiling: true
                performance_profiling: true
            }
            
            # Debug output
            output: {
                format: "structured"  # structured, plain, json
                include_timestamps: true
                include_line_numbers: true
                include_context: true
                
                # Output destinations
                destinations: [
                    {
                        type: "console"
                        enabled: true
                        color: true
                    },
                    
                    {
                        type: "file"
                        enabled: true
                        path: "debug.log"
                        rotation: true
                    }
                ]
            }
        }
    }
}

# 4. Interactive Mode
interactive_mode {
    # REPL configuration
    repl: {
        enabled: true
        
        # Interface settings
        interface: {
            prompt: "tusk> "
            continuation_prompt: "... "
            
            # History
            history: {
                enabled: true
                file: "~/.tusk_history"
                max_entries: 1000
                search_enabled: true
            }
            
            # Auto-completion
            completion: {
                enabled: true
                
                # Completion sources
                sources: [
                    "keywords",
                    "functions",
                    "variables",
                    "modules",
                    "file_paths"
                ]
                
                # Fuzzy matching
                fuzzy_matching: {
                    enabled: true
                    threshold: 0.7
                    max_suggestions: 10
                }
            }
            
            # Syntax highlighting
            syntax_highlighting: {
                enabled: @supports_color
                theme: "default"
                
                # Color scheme
                colors: {
                    keyword: "blue"
                    string: "green"
                    number: "yellow"
                    comment: "gray"
                    operator: "red"
                    function: "magenta"
                    variable: "cyan"
                }
            }
        }
        
        # Commands
        commands: {
            # Help command
            help: {
                aliases: ["?", "h"]
                description: "Show help information"
                usage: "help [command]"
            }
            
            # Clear command
            clear: {
                aliases: ["cls"]
                description: "Clear the screen"
                usage: "clear"
            }
            
            # Exit command
            exit: {
                aliases: ["quit", "q"]
                description: "Exit the REPL"
                usage: "exit"
            }
            
            # Load command
            load: {
                aliases: ["l"]
                description: "Load and execute a script file"
                usage: "load <file>"
            }
            
            # Save command
            save: {
                aliases: ["s"]
                description: "Save current session to file"
                usage: "save <file>"
            }
            
            # Variables command
            vars: {
                aliases: ["variables"]
                description: "Show defined variables"
                usage: "vars"
            }
            
            # Functions command
            funcs: {
                aliases: ["functions"]
                description: "Show defined functions"
                usage: "funcs"
            }
            
            # Modules command
            modules: {
                aliases: ["mods"]
                description: "Show loaded modules"
                usage: "modules"
            }
            
            # Reset command
            reset: {
                aliases: ["r"]
                description: "Reset the environment"
                usage: "reset"
            }
            
            # Timing command
            time: {
                aliases: ["t"]
                description: "Time expression execution"
                usage: "time <expression>"
            }
            
            # Profile command
            profile: {
                aliases: ["p"]
                description: "Profile expression execution"
                usage: "profile <expression>"
            }
        }
        
        # Session management
        session: {
            # Auto-save
            auto_save: {
                enabled: true
                interval: "5m"
                file: "~/.tusk_session"
            }
            
            # Session restoration
            restore_on_startup: true
            
            # Workspace isolation
            workspace: {
                isolated: false
                shared_variables: true
                shared_functions: true
                shared_modules: true
            }
        }
    }
    
    # Jupyter notebook integration
    jupyter: {
        enabled: env("JUPYTER_ENABLED", false)
        
        # Kernel configuration
        kernel: {
            name: "tusklang"
            display_name: "TuskLang"
            language: "tusklang"
            
            # Kernel capabilities
            capabilities: {
                execute_code: true
                complete_code: true
                inspect_code: true
                history_access: true
                
                # Rich output
                rich_output: {
                    html: true
                    javascript: true
                    svg: true
                    png: true
                    jpeg: true
                    latex: true
                    markdown: true
                }
            }
        }
        
        # Magic commands
        magic_commands: {
            # Line magics
            line_magics: [
                {
                    name: "time"
                    description: "Time the execution of a line"
                    usage: "%time expression"
                },
                
                {
                    name: "load"
                    description: "Load a TuskLang file"
                    usage: "%load file.tsk"
                },
                
                {
                    name: "save"
                    description: "Save cell content to file"
                    usage: "%save file.tsk"
                },
                
                {
                    name: "env"
                    description: "Set environment variable"
                    usage: "%env VAR=value"
                }
            ]
            
            # Cell magics
            cell_magics: [
                {
                    name: "benchmark"
                    description: "Benchmark the entire cell"
                    usage: "%%benchmark"
                },
                
                {
                    name: "profile"
                    description: "Profile the entire cell"
                    usage: "%%profile"
                },
                
                {
                    name: "debug"
                    description: "Debug the entire cell"
                    usage: "%%debug"
                }
            ]
        }
    }
}
</pre>

<h3>TuskCliEngine.cs</h3>
<pre>
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace TuskLang.Cli
{
    // Main CLI engine for TuskLang
    public class TuskCliEngine
    {
        private readonly ILogger&lt;TuskCliEngine&gt; _logger;
        private readonly CliConfig _config;
        private readonly RootCommand _rootCommand;
        private readonly Dictionary&lt;string, ICommandHandler&gt; _commandHandlers;
        private readonly ScriptExecutor _scriptExecutor;
        
        public TuskCliEngine(ILogger&lt;TuskCliEngine&gt; logger, CliConfig config)
        {
            _logger = logger;
            _config = config;
            _commandHandlers = new Dictionary&lt;string, ICommandHandler&gt;();
            _scriptExecutor = new ScriptExecutor(logger);
            
            _rootCommand = CreateRootCommand();
            RegisterCommandHandlers();
        }
        
        // Create the root command with global options
        private RootCommand CreateRootCommand()
        {
            var rootCommand = new RootCommand(_config.Description);
            
            // Add global options
            var verboseOption = new Option&lt;bool&gt;("--verbose", "Enable verbose output");
            verboseOption.AddAlias("-V");
            rootCommand.AddGlobalOption(verboseOption);
            
            var quietOption = new Option&lt;bool&gt;("--quiet", "Suppress output");
            quietOption.AddAlias("-q");
            rootCommand.AddGlobalOption(quietOption);
            
            var configOption = new Option&lt;FileInfo&gt;("--config", "Configuration file path");
            configOption.AddAlias("-c");
            rootCommand.AddGlobalOption(configOption);
            
            var formatOption = new Option&lt;OutputFormat&gt;("--format", "Output format");
            formatOption.AddAlias("-f");
            rootCommand.AddGlobalOption(formatOption);
            
            var logLevelOption = new Option&lt;LogLevel&gt;("--log-level", "Set log level");
            rootCommand.AddGlobalOption(logLevelOption);
            
            var directoryOption = new Option&lt;DirectoryInfo&gt;("--directory", "Working directory");
            directoryOption.AddAlias("-d");
            rootCommand.AddGlobalOption(directoryOption);
            
            var parallelOption = new Option&lt;int&gt;("--jobs", () =&gt; Environment.ProcessorCount, "Number of parallel jobs");
            parallelOption.AddAlias("-j");
            rootCommand.AddGlobalOption(parallelOption);
            
            var forceOption = new Option&lt;bool&gt;("--force", "Force operation without confirmation");
            rootCommand.AddGlobalOption(forceOption);
            
            var dryRunOption = new Option&lt;bool&gt;("--dry-run", "Show what would be done without executing");
            rootCommand.AddGlobalOption(dryRunOption);
            
            // Add version option
            rootCommand.AddOption(new Option&lt;bool&gt;("--version", "Show version information"));
            
            return rootCommand;
        }
        
        // Register command handlers
        private void RegisterCommandHandlers()
        {
            // Convert command
            var convertCommand = CreateConvertCommand();
            _rootCommand.AddCommand(convertCommand);
            _commandHandlers["convert"] = new ConvertCommandHandler(_logger);
            
            // Validate command
            var validateCommand = CreateValidateCommand();
            _rootCommand.AddCommand(validateCommand);
            _commandHandlers["validate"] = new ValidateCommandHandler(_logger);
            
            // Migrate command
            var migrateCommand = CreateMigrateCommand();
            _rootCommand.AddCommand(migrateCommand);
            _commandHandlers["migrate"] = new MigrateCommandHandler(_logger);
            
            // Script command
            var scriptCommand = CreateScriptCommand();
            _rootCommand.AddCommand(scriptCommand);
            _commandHandlers["script"] = new ScriptCommandHandler(_logger, _scriptExecutor);
            
            // Benchmark command
            var benchmarkCommand = CreateBenchmarkCommand();
            _rootCommand.AddCommand(benchmarkCommand);
            _commandHandlers["benchmark"] = new BenchmarkCommandHandler(_logger);
        }
        
        // Create convert command
        private Command CreateConvertCommand()
        {
            var command = new Command("convert", "Convert between different configuration formats");
            
            var inputOption = new Option&lt;FileInfo&gt;("--input", "Input file path") { IsRequired = true };
            inputOption.AddAlias("-i");
            command.AddOption(inputOption);
            
            var outputOption = new Option&lt;string&gt;("--output", "Output file path") { IsRequired = true };
            outputOption.AddAlias("-o");
            command.AddOption(outputOption);
            
            var inputFormatOption = new Option&lt;string&gt;("--input-format", "Input format");
            command.AddOption(inputFormatOption);
            
            var outputFormatOption = new Option&lt;string&gt;("--output-format", "Output format");
            command.AddOption(outputFormatOption);
            
            var prettyOption = new Option&lt;bool&gt;("--pretty", () =&gt; true, "Pretty-print output");
            prettyOption.AddAlias("-p");
            command.AddOption(prettyOption);
            
            var validateOption = new Option&lt;bool&gt;("--validate", () =&gt; true, "Validate input before conversion");
            command.AddOption(validateOption);
            
            var schemaOption = new Option&lt;FileInfo&gt;("--schema", "Schema file for validation");
            schemaOption.AddAlias("-s");
            command.AddOption(schemaOption);
            
            command.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["convert"];
                await handler.HandleAsync(context);
            });
            
            return command;
        }
        
        // Create validate command
        private Command CreateValidateCommand()
        {
            var command = new Command("validate", "Validate TuskLang configuration files");
            
            var fileOption = new Option&lt;string[]&gt;("--file", "File or directory to validate") { IsRequired = true };
            fileOption.AddAlias("-f");
            fileOption.AllowMultipleArgumentsPerToken = true;
            command.AddOption(fileOption);
            
            var schemaOption = new Option&lt;FileInfo&gt;("--schema", "Schema file for validation");
            schemaOption.AddAlias("-s");
            command.AddOption(schemaOption);
            
            var recursiveOption = new Option&lt;bool&gt;("--recursive", "Recursively validate directories");
            recursiveOption.AddAlias("-r");
            command.AddOption(recursiveOption);
            
            var patternOption = new Option&lt;string&gt;("--pattern", () =&gt; "*.tsk", "File pattern to match");
            patternOption.AddAlias("-p");
            command.AddOption(patternOption);
            
            var strictOption = new Option&lt;bool&gt;("--strict", "Enable strict validation mode");
            command.AddOption(strictOption);
            
            var warningsAsErrorsOption = new Option&lt;bool&gt;("--warnings-as-errors", "Treat warnings as errors");
            command.AddOption(warningsAsErrorsOption);
            
            var maxErrorsOption = new Option&lt;int&gt;("--max-errors", () =&gt; 50, "Maximum number of errors to report");
            command.AddOption(maxErrorsOption);
            
            command.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["validate"];
                await handler.HandleAsync(context);
            });
            
            return command;
        }
        
        // Create migrate command
        private Command CreateMigrateCommand()
        {
            var command = new Command("migrate", "Migrate configuration files to newer formats or versions");
            
            // Analyze subcommand
            var analyzeCommand = new Command("analyze", "Analyze files for migration opportunities");
            
            var pathOption = new Option&lt;DirectoryInfo&gt;("--path", () =&gt; new DirectoryInfo("."), "Path to analyze");
            pathOption.AddAlias("-p");
            analyzeCommand.AddOption(pathOption);
            
            var reportOption = new Option&lt;string&gt;("--report", () =&gt; "migration-report.json", "Generate migration report");
            reportOption.AddAlias("-r");
            analyzeCommand.AddOption(reportOption);
            
            analyzeCommand.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["migrate"];
                await handler.HandleAsync(context);
            });
            
            command.AddCommand(analyzeCommand);
            
            // Migrate subcommand
            var migrateSubCommand = new Command("migrate", "Perform migration");
            
            var fromOption = new Option&lt;string&gt;("--from", "Source version") { IsRequired = true };
            migrateSubCommand.AddOption(fromOption);
            
            var toOption = new Option&lt;string&gt;("--to", "Target version") { IsRequired = true };
            migrateSubCommand.AddOption(toOption);
            
            var backupOption = new Option&lt;bool&gt;("--backup", () =&gt; true, "Create backup before migration");
            backupOption.AddAlias("-b");
            migrateSubCommand.AddOption(backupOption);
            
            var backupSuffixOption = new Option&lt;string&gt;("--backup-suffix", () =&gt; ".backup", "Backup file suffix");
            migrateSubCommand.AddOption(backupSuffixOption);
            
            migrateSubCommand.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["migrate"];
                await handler.HandleAsync(context);
            });
            
            command.AddCommand(migrateSubCommand);
            
            // Rollback subcommand
            var rollbackCommand = new Command("rollback", "Rollback migration");
            
            var idOption = new Option&lt;string&gt;("--id", "Migration ID to rollback") { IsRequired = true };
            idOption.AddAlias("-i");
            rollbackCommand.AddOption(idOption);
            
            var confirmOption = new Option&lt;bool&gt;("--confirm", "Confirm rollback operation");
            rollbackCommand.AddOption(confirmOption);
            
            rollbackCommand.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["migrate"];
                await handler.HandleAsync(context);
            });
            
            command.AddCommand(rollbackCommand);
            
            return command;
        }
        
        // Create script command
        private Command CreateScriptCommand()
        {
            var command = new Command("script", "Execute TuskLang scripts");
            
            // Run subcommand
            var runCommand = new Command("run", "Run a TuskLang script");
            
            var scriptOption = new Option&lt;FileInfo&gt;("--script", "Script file to execute") { IsRequired = true };
            scriptOption.AddAlias("-s");
            runCommand.AddOption(scriptOption);
            
            var parametersOption = new Option&lt;string[]&gt;("--params", "Script parameters (key=value pairs)");
            parametersOption.AddAlias("-p");
            parametersOption.AllowMultipleArgumentsPerToken = true;
            runCommand.AddOption(parametersOption);
            
            var environmentOption = new Option&lt;string&gt;("--env", () =&gt; "development", "Environment to run in");
            environmentOption.AddAlias("-e");
            runCommand.AddOption(environmentOption);
            
            var timeoutOption = new Option&lt;int&gt;("--timeout", () =&gt; 300, "Script execution timeout (seconds)");
            timeoutOption.AddAlias("-t");
            runCommand.AddOption(timeoutOption);
            
            var outputFileOption = new Option&lt;string&gt;("--output", "Save output to file");
            outputFileOption.AddAlias("-o");
            runCommand.AddOption(outputFileOption);
            
            runCommand.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["script"];
                await handler.HandleAsync(context);
            });
            
            command.AddCommand(runCommand);
            
            // Validate subcommand
            var validateScriptCommand = new Command("validate", "Validate a TuskLang script");
            
            var scriptValidateOption = new Option&lt;FileInfo&gt;("--script", "Script file to validate") { IsRequired = true };
            scriptValidateOption.AddAlias("-s");
            validateScriptCommand.AddOption(scriptValidateOption);
            
            var checkDepsOption = new Option&lt;bool&gt;("--check-deps", () =&gt; true, "Check script dependencies");
            validateScriptCommand.AddOption(checkDepsOption);
            
            validateScriptCommand.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["script"];
                await handler.HandleAsync(context);
            });
            
            command.AddCommand(validateScriptCommand);
            
            // Debug subcommand
            var debugCommand = new Command("debug", "Debug a TuskLang script");
            
            var debugScriptOption = new Option&lt;FileInfo&gt;("--script", "Script file to debug") { IsRequired = true };
            debugScriptOption.AddAlias("-s");
            debugCommand.AddOption(debugScriptOption);
            
            var breakpointsOption = new Option&lt;int[]&gt;("--breakpoint", "Set breakpoints (line numbers)");
            breakpointsOption.AddAlias("-b");
            breakpointsOption.AllowMultipleArgumentsPerToken = true;
            debugCommand.AddOption(breakpointsOption);
            
            var stepModeOption = new Option&lt;bool&gt;("--step", "Enable step-by-step execution");
            debugCommand.AddOption(stepModeOption);
            
            var watchOption = new Option&lt;string[]&gt;("--watch", "Watch variables");
            watchOption.AddAlias("-w");
            watchOption.AllowMultipleArgumentsPerToken = true;
            debugCommand.AddOption(watchOption);
            
            debugCommand.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["script"];
                await handler.HandleAsync(context);
            });
            
            command.AddCommand(debugCommand);
            
            return command;
        }
        
        // Create benchmark command
        private Command CreateBenchmarkCommand()
        {
            var command = new Command("benchmark", "Run performance benchmarks");
            
            var testFileOption = new Option&lt;FileInfo&gt;("--test", () =&gt; new FileInfo("benchmark.tsk"), "Benchmark test file");
            testFileOption.AddAlias("-t");
            command.AddOption(testFileOption);
            
            var iterationsOption = new Option&lt;int&gt;("--iterations", () =&gt; 1000, "Number of iterations");
            iterationsOption.AddAlias("-i");
            command.AddOption(iterationsOption);
            
            var warmupOption = new Option&lt;int&gt;("--warmup", () =&gt; 100, "Number of warmup iterations");
            warmupOption.AddAlias("-w");
            command.AddOption(warmupOption);
            
            var outputOption = new Option&lt;string&gt;("--output", () =&gt; "benchmark-results.json", "Output file for results");
            outputOption.AddAlias("-o");
            command.AddOption(outputOption);
            
            var benchmarkFormatOption = new Option&lt;string&gt;("--format", () =&gt; "table", "Output format");
            benchmarkFormatOption.AddAlias("-f");
            command.AddOption(benchmarkFormatOption);
            
            var compareOption = new Option&lt;FileInfo&gt;("--compare", "Compare with baseline results");
            compareOption.AddAlias("-c");
            command.AddOption(compareOption);
            
            var profileOption = new Option&lt;bool&gt;("--profile", "Enable profiling");
            profileOption.AddAlias("-p");
            command.AddOption(profileOption);
            
            command.SetHandler(async (context) =&gt;
            {
                var handler = _commandHandlers["benchmark"];
                await handler.HandleAsync(context);
            });
            
            return command;
        }
        
        // Execute CLI with arguments
        public async Task&lt;int&gt; ExecuteAsync(string[] args)
        {
            try
            {
                return await _rootCommand.InvokeAsync(args);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "CLI execution failed");
                Console.Error.WriteLine($"Error: {ex.Message}");
                return 1;
            }
        }
        
        // Start interactive REPL mode
        public async Task StartInteractiveModeAsync(CancellationToken cancellationToken = default)
        {
            var repl = new TuskRepl(_logger, _config);
            await repl.StartAsync(cancellationToken);
        }
    }
    
    // Command handler interface
    public interface ICommandHandler
    {
        Task HandleAsync(InvocationContext context);
    }
    
    // Convert command handler
    public class ConvertCommandHandler : ICommandHandler
    {
        private readonly ILogger _logger;
        
        public ConvertCommandHandler(ILogger logger)
        {
            _logger = logger;
        }
        
        public async Task HandleAsync(InvocationContext context)
        {
            var inputFile = context.ParseResult.GetValueForOption&lt;FileInfo&gt;("--input");
            var outputFile = context.ParseResult.GetValueForOption&lt;string&gt;("--output");
            var pretty = context.ParseResult.GetValueForOption&lt;bool&gt;("--pretty");
            var validate = context.ParseResult.GetValueForOption&lt;bool&gt;("--validate");
            
            _logger.LogInformation("Converting {InputFile} to {OutputFile}", inputFile.FullName, outputFile);
            
            try
            {
                // Read input file
                var content = await File.ReadAllTextAsync(inputFile.FullName);
                
                // Parse input content
                var parser = new TuskLangParser();
                var parsed = parser.Parse(content);
                
                // Validate if requested
                if (validate)
                {
                    var validator = new TuskLangValidator();
                    var validationResult = await validator.ValidateAsync(parsed);
                    
                    if (!validationResult.IsValid)
                    {
                        Console.Error.WriteLine("Validation failed:");
                        foreach (var error in validationResult.Errors)
                        {
                            Console.Error.WriteLine($"  {error}");
                        }
                        context.ExitCode = 1;
                        return;
                    }
                }
                
                // Convert to output format
                var serializer = new TuskLangSerializer();
                var outputFormat = DetermineOutputFormat(outputFile);
                var converted = await serializer.SerializeAsync(parsed, outputFormat, pretty);
                
                // Write output file
                await File.WriteAllTextAsync(outputFile, converted);
                
                Console.WriteLine($"Successfully converted {inputFile.Name} to {outputFile}");
                _logger.LogInformation("Conversion completed successfully");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Conversion failed");
                Console.Error.WriteLine($"Conversion failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private string DetermineOutputFormat(string outputFile)
        {
            var extension = Path.GetExtension(outputFile).ToLower();
            return extension switch
            {
                ".json" =&gt; "json",
                ".yaml" or ".yml" =&gt; "yaml",
                ".xml" =&gt; "xml",
                ".toml" =&gt; "toml",
                ".tsk" =&gt; "tsk",
                _ =&gt; "json"
            };
        }
    }
    
    // Validate command handler
    public class ValidateCommandHandler : ICommandHandler
    {
        private readonly ILogger _logger;
        
        public ValidateCommandHandler(ILogger logger)
        {
            _logger = logger;
        }
        
        public async Task HandleAsync(InvocationContext context)
        {
            var files = context.ParseResult.GetValueForOption&lt;string[]&gt;("--file");
            var recursive = context.ParseResult.GetValueForOption&lt;bool&gt;("--recursive");
            var pattern = context.ParseResult.GetValueForOption&lt;string&gt;("--pattern");
            var strict = context.ParseResult.GetValueForOption&lt;bool&gt;("--strict");
            
            _logger.LogInformation("Validating files with pattern {Pattern}", pattern);
            
            var validator = new TuskLangValidator();
            var totalFiles = 0;
            var validFiles = 0;
            var totalErrors = 0;
            
            foreach (var file in files)
            {
                var filesToValidate = GetFilesToValidate(file, recursive, pattern);
                
                foreach (var fileToValidate in filesToValidate)
                {
                    totalFiles++;
                    
                    try
                    {
                        var content = await File.ReadAllTextAsync(fileToValidate);
                        var parser = new TuskLangParser();
                        var parsed = parser.Parse(content);
                        
                        var validationResult = await validator.ValidateAsync(parsed, strict);
                        
                        if (validationResult.IsValid)
                        {
                            validFiles++;
                            Console.WriteLine($"✓ {fileToValidate}");
                        }
                        else
                        {
                            Console.WriteLine($"✗ {fileToValidate}");
                            foreach (var error in validationResult.Errors)
                            {
                                Console.WriteLine($"    {error}");
                                totalErrors++;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"✗ {fileToValidate}: {ex.Message}");
                        totalErrors++;
                    }
                }
            }
            
            // Summary
            Console.WriteLine();
            Console.WriteLine($"Validation Summary:");
            Console.WriteLine($"  Total files: {totalFiles}");
            Console.WriteLine($"  Valid files: {validFiles}");
            Console.WriteLine($"  Invalid files: {totalFiles - validFiles}");
            Console.WriteLine($"  Total errors: {totalErrors}");
            
            if (totalErrors &gt; 0)
            {
                context.ExitCode = 1;
            }
            
            _logger.LogInformation("Validation completed: {ValidFiles}/{TotalFiles} files valid", validFiles, totalFiles);
        }
        
        private IEnumerable&lt;string&gt; GetFilesToValidate(string path, bool recursive, string pattern)
        {
            if (File.Exists(path))
            {
                return new[] { path };
            }
            
            if (Directory.Exists(path))
            {
                var searchOption = recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
                return Directory.GetFiles(path, pattern, searchOption);
            }
            
            return Enumerable.Empty&lt;string&gt;();
        }
    }
    
    // Script command handler
    public class ScriptCommandHandler : ICommandHandler
    {
        private readonly ILogger _logger;
        private readonly ScriptExecutor _scriptExecutor;
        
        public ScriptCommandHandler(ILogger logger, ScriptExecutor scriptExecutor)
        {
            _logger = logger;
            _scriptExecutor = scriptExecutor;
        }
        
        public async Task HandleAsync(InvocationContext context)
        {
            var command = context.ParseResult.CommandResult.Command.Name;
            
            switch (command)
            {
                case "run":
                    await HandleRunCommand(context);
                    break;
                case "validate":
                    await HandleValidateCommand(context);
                    break;
                case "debug":
                    await HandleDebugCommand(context);
                    break;
            }
        }
        
        private async Task HandleRunCommand(InvocationContext context)
        {
            var scriptFile = context.ParseResult.GetValueForOption&lt;FileInfo&gt;("--script");
            var parameters = context.ParseResult.GetValueForOption&lt;string[]&gt;("--params") ?? Array.Empty&lt;string&gt;();
            var environment = context.ParseResult.GetValueForOption&lt;string&gt;("--env");
            var timeout = context.ParseResult.GetValueForOption&lt;int&gt;("--timeout");
            var outputFile = context.ParseResult.GetValueForOption&lt;string&gt;("--output");
            
            _logger.LogInformation("Executing script {ScriptFile} in {Environment} environment", scriptFile.Name, environment);
            
            try
            {
                var scriptContext = new ScriptContext
                {
                    ScriptFile = scriptFile.FullName,
                    Environment = environment,
                    Parameters = ParseParameters(parameters),
                    Timeout = TimeSpan.FromSeconds(timeout)
                };
                
                var result = await _scriptExecutor.ExecuteAsync(scriptContext);
                
                if (result.Success)
                {
                    Console.WriteLine("Script executed successfully");
                    
                    if (!string.IsNullOrEmpty(outputFile))
                    {
                        await File.WriteAllTextAsync(outputFile, result.Output);
                        Console.WriteLine($"Output saved to {outputFile}");
                    }
                    else if (!string.IsNullOrEmpty(result.Output))
                    {
                        Console.WriteLine("Output:");
                        Console.WriteLine(result.Output);
                    }
                }
                else
                {
                    Console.Error.WriteLine($"Script execution failed: {result.ErrorMessage}");
                    context.ExitCode = 1;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Script execution failed");
                Console.Error.WriteLine($"Script execution failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private async Task HandleValidateCommand(InvocationContext context)
        {
            var scriptFile = context.ParseResult.GetValueForOption&lt;FileInfo&gt;("--script");
            var checkDeps = context.ParseResult.GetValueForOption&lt;bool&gt;("--check-deps");
            
            _logger.LogInformation("Validating script {ScriptFile}", scriptFile.Name);
            
            try
            {
                var result = await _scriptExecutor.ValidateAsync(scriptFile.FullName, checkDeps);
                
                if (result.IsValid)
                {
                    Console.WriteLine($"✓ Script {scriptFile.Name} is valid");
                }
                else
                {
                    Console.WriteLine($"✗ Script {scriptFile.Name} validation failed:");
                    foreach (var error in result.Errors)
                    {
                        Console.WriteLine($"    {error}");
                    }
                    context.ExitCode = 1;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Script validation failed");
                Console.Error.WriteLine($"Script validation failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private async Task HandleDebugCommand(InvocationContext context)
        {
            var scriptFile = context.ParseResult.GetValueForOption&lt;FileInfo&gt;("--script");
            var breakpoints = context.ParseResult.GetValueForOption&lt;int[]&gt;("--breakpoint") ?? Array.Empty&lt;int&gt;();
            var stepMode = context.ParseResult.GetValueForOption&lt;bool&gt;("--step");
            var watchVariables = context.ParseResult.GetValueForOption&lt;string[]&gt;("--watch") ?? Array.Empty&lt;string&gt;();
            
            _logger.LogInformation("Debugging script {ScriptFile}", scriptFile.Name);
            
            try
            {
                var debugContext = new DebugContext
                {
                    ScriptFile = scriptFile.FullName,
                    Breakpoints = breakpoints.ToList(),
                    StepMode = stepMode,
                    WatchVariables = watchVariables.ToList()
                };
                
                await _scriptExecutor.DebugAsync(debugContext);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Script debugging failed");
                Console.Error.WriteLine($"Script debugging failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private Dictionary&lt;string, string&gt; ParseParameters(string[] parameters)
        {
            var result = new Dictionary&lt;string, string&gt;();
            
            foreach (var param in parameters)
            {
                var parts = param.Split('=', 2);
                if (parts.Length == 2)
                {
                    result[parts[0]] = parts[1];
                }
            }
            
            return result;
        }
    }
    
    // Benchmark command handler
    public class BenchmarkCommandHandler : ICommandHandler
    {
        private readonly ILogger _logger;
        
        public BenchmarkCommandHandler(ILogger logger)
        {
            _logger = logger;
        }
        
        public async Task HandleAsync(InvocationContext context)
        {
            var testFile = context.ParseResult.GetValueForOption&lt;FileInfo&gt;("--test");
            var iterations = context.ParseResult.GetValueForOption&lt;int&gt;("--iterations");
            var warmup = context.ParseResult.GetValueForOption&lt;int&gt;("--warmup");
            var outputFile = context.ParseResult.GetValueForOption&lt;string&gt;("--output");
            var format = context.ParseResult.GetValueForOption&lt;string&gt;("--format");
            var compare = context.ParseResult.GetValueForOption&lt;FileInfo&gt;("--compare");
            var profile = context.ParseResult.GetValueForOption&lt;bool&gt;("--profile");
            
            _logger.LogInformation("Running benchmarks with {Iterations} iterations", iterations);
            
            try
            {
                var benchmarkRunner = new BenchmarkRunner();
                
                var config = new BenchmarkConfig
                {
                    TestFile = testFile?.FullName,
                    Iterations = iterations,
                    WarmupIterations = warmup,
                    EnableProfiling = profile
                };
                
                var results = await benchmarkRunner.RunAsync(config);
                
                // Output results
                await OutputBenchmarkResults(results, format, outputFile);
                
                // Compare with baseline if specified
                if (compare != null && compare.Exists)
                {
                    await CompareBenchmarkResults(results, compare.FullName);
                }
                
                Console.WriteLine("Benchmark completed successfully");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Benchmark failed");
                Console.Error.WriteLine($"Benchmark failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private async Task OutputBenchmarkResults(BenchmarkResults results, string format, string outputFile)
        {
            string output = format.ToLower() switch
            {
                "json" =&gt; JsonSerializer.Serialize(results, new JsonSerializerOptions { WriteIndented = true }),
                "csv" =&gt; ConvertToCsv(results),
                "markdown" =&gt; ConvertToMarkdown(results),
                _ =&gt; ConvertToTable(results)
            };
            
            if (!string.IsNullOrEmpty(outputFile))
            {
                await File.WriteAllTextAsync(outputFile, output);
                Console.WriteLine($"Results saved to {outputFile}");
            }
            else
            {
                Console.WriteLine(output);
            }
        }
        
        private async Task CompareBenchmarkResults(BenchmarkResults current, string baselineFile)
        {
            var baselineJson = await File.ReadAllTextAsync(baselineFile);
            var baseline = JsonSerializer.Deserialize&lt;BenchmarkResults&gt;(baselineJson);
            
            Console.WriteLine("\nComparison with baseline:");
            // Implementation would compare results and show differences
        }
        
        private string ConvertToCsv(BenchmarkResults results)
        {
            // CSV conversion implementation
            return "Test,Iterations,Average,Min,Max\n";
        }
        
        private string ConvertToMarkdown(BenchmarkResults results)
        {
            // Markdown conversion implementation
            return "# Benchmark Results\n";
        }
        
        private string ConvertToTable(BenchmarkResults results)
        {
            // Table conversion implementation
            return "Benchmark Results\n================\n";
        }
    }
    
    // Migrate command handler
    public class MigrateCommandHandler : ICommandHandler
    {
        private readonly ILogger _logger;
        
        public MigrateCommandHandler(ILogger logger)
        {
            _logger = logger;
        }
        
        public async Task HandleAsync(InvocationContext context)
        {
            var command = context.ParseResult.CommandResult.Command.Name;
            
            switch (command)
            {
                case "analyze":
                    await HandleAnalyzeCommand(context);
                    break;
                case "migrate":
                    await HandleMigrateCommand(context);
                    break;
                case "rollback":
                    await HandleRollbackCommand(context);
                    break;
            }
        }
        
        private async Task HandleAnalyzeCommand(InvocationContext context)
        {
            var path = context.ParseResult.GetValueForOption&lt;DirectoryInfo&gt;("--path");
            var report = context.ParseResult.GetValueForOption&lt;string&gt;("--report");
            
            _logger.LogInformation("Analyzing migration opportunities in {Path}", path.FullName);
            
            try
            {
                var analyzer = new MigrationAnalyzer();
                var analysis = await analyzer.AnalyzeAsync(path.FullName);
                
                // Save report
                var reportJson = JsonSerializer.Serialize(analysis, new JsonSerializerOptions { WriteIndented = true });
                await File.WriteAllTextAsync(report, reportJson);
                
                Console.WriteLine($"Migration analysis completed. Report saved to {report}");
                Console.WriteLine($"Found {analysis.MigrationOpportunities.Count} migration opportunities");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Migration analysis failed");
                Console.Error.WriteLine($"Migration analysis failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private async Task HandleMigrateCommand(InvocationContext context)
        {
            var from = context.ParseResult.GetValueForOption&lt;string&gt;("--from");
            var to = context.ParseResult.GetValueForOption&lt;string&gt;("--to");
            var backup = context.ParseResult.GetValueForOption&lt;bool&gt;("--backup");
            var backupSuffix = context.ParseResult.GetValueForOption&lt;string&gt;("--backup-suffix");
            
            _logger.LogInformation("Migrating from version {From} to {To}", from, to);
            
            try
            {
                var migrator = new ConfigurationMigrator();
                
                var migrationConfig = new MigrationConfig
                {
                    SourceVersion = from,
                    TargetVersion = to,
                    CreateBackup = backup,
                    BackupSuffix = backupSuffix
                };
                
                var result = await migrator.MigrateAsync(migrationConfig);
                
                if (result.Success)
                {
                    Console.WriteLine($"Migration completed successfully");
                    Console.WriteLine($"Migrated {result.ProcessedFiles} files");
                }
                else
                {
                    Console.Error.WriteLine($"Migration failed: {result.ErrorMessage}");
                    context.ExitCode = 1;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Migration failed");
                Console.Error.WriteLine($"Migration failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
        
        private async Task HandleRollbackCommand(InvocationContext context)
        {
            var id = context.ParseResult.GetValueForOption&lt;string&gt;("--id");
            var confirm = context.ParseResult.GetValueForOption&lt;bool&gt;("--confirm");
            
            _logger.LogInformation("Rolling back migration {Id}", id);
            
            if (!confirm)
            {
                Console.Write($"Are you sure you want to rollback migration {id}? (y/N): ");
                var response = Console.ReadLine();
                if (response?.ToLower() != "y" && response?.ToLower() != "yes")
                {
                    Console.WriteLine("Rollback cancelled");
                    return;
                }
            }
            
            try
            {
                var migrator = new ConfigurationMigrator();
                var result = await migrator.RollbackAsync(id);
                
                if (result.Success)
                {
                    Console.WriteLine("Rollback completed successfully");
                }
                else
                {
                    Console.Error.WriteLine($"Rollback failed: {result.ErrorMessage}");
                    context.ExitCode = 1;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Rollback failed");
                Console.Error.WriteLine($"Rollback failed: {ex.Message}");
                context.ExitCode = 1;
            }
        }
    }
}
</pre>

<h3>Supporting Classes</h3>
<pre>
namespace TuskLang.Cli
{
    // CLI configuration
    public class CliConfig
    {
        public string Name { get; set; } = "tuskcli";
        public string Version { get; set; } = "1.0.0";
        public string Description { get; set; } = "TuskLang CLI and scripting tool";
        public bool InteractiveMode { get; set; } = false;
    }
    
    // Output formats
    public enum OutputFormat
    {
        Json,
        Yaml,
        Tsk,
        Table,
        Csv,
        Xml
    }
    
    // Script execution
    public class ScriptExecutor
    {
        private readonly ILogger _logger;
        
        public ScriptExecutor(ILogger logger)
        {
            _logger = logger;
        }
        
        public async Task&lt;ScriptResult&gt; ExecuteAsync(ScriptContext context)
        {
            // Script execution implementation
            return await Task.FromResult(new ScriptResult { Success = true, Output = "Script executed" });
        }
        
        public async Task&lt;ValidationResult&gt; ValidateAsync(string scriptFile, bool checkDependencies)
        {
            // Script validation implementation
            return await Task.FromResult(new ValidationResult { IsValid = true });
        }
        
        public async Task DebugAsync(DebugContext context)
        {
            // Script debugging implementation
            await Task.CompletedTask;
        }
    }
    
    public class ScriptContext
    {
        public string ScriptFile { get; set; }
        public string Environment { get; set; }
        public Dictionary&lt;string, string&gt; Parameters { get; set; } = new();
        public TimeSpan Timeout { get; set; }
    }
    
    public class ScriptResult
    {
        public bool Success { get; set; }
        public string Output { get; set; }
        public string ErrorMessage { get; set; }
        public TimeSpan ExecutionTime { get; set; }
    }
    
    public class DebugContext
    {
        public string ScriptFile { get; set; }
        public List&lt;int&gt; Breakpoints { get; set; } = new();
        public bool StepMode { get; set; }
        public List&lt;string&gt; WatchVariables { get; set; } = new();
    }
    
    // Validation
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List&lt;string&gt; Errors { get; set; } = new();
    }
    
    // Benchmarking
    public class BenchmarkRunner
    {
        public async Task&lt;BenchmarkResults&gt; RunAsync(BenchmarkConfig config)
        {
            // Benchmark implementation
            return await Task.FromResult(new BenchmarkResults());
        }
    }
    
    public class BenchmarkConfig
    {
        public string TestFile { get; set; }
        public int Iterations { get; set; }
        public int WarmupIterations { get; set; }
        public bool EnableProfiling { get; set; }
    }
    
    public class BenchmarkResults
    {
        public Dictionary&lt;string, BenchmarkResult&gt; Results { get; set; } = new();
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public TimeSpan TotalDuration { get; set; }
    }
    
    public class BenchmarkResult
    {
        public string Name { get; set; }
        public int Iterations { get; set; }
        public TimeSpan AverageTime { get; set; }
        public TimeSpan MinTime { get; set; }
        public TimeSpan MaxTime { get; set; }
        public double OperationsPerSecond { get; set; }
        public long MemoryUsed { get; set; }
    }
    
    // Migration
    public class MigrationAnalyzer
    {
        public async Task&lt;MigrationAnalysis&gt; AnalyzeAsync(string path)
        {
            // Migration analysis implementation
            return await Task.FromResult(new MigrationAnalysis());
        }
    }
    
    public class MigrationAnalysis
    {
        public List&lt;MigrationOpportunity&gt; MigrationOpportunities { get; set; } = new();
        public int TotalFiles { get; set; }
        public int FilesRequiringMigration { get; set; }
        public DateTime AnalysisDate { get; set; } = DateTime.UtcNow;
    }
    
    public class MigrationOpportunity
    {
        public string FilePath { get; set; }
        public string CurrentVersion { get; set; }
        public string RecommendedVersion { get; set; }
        public List&lt;string&gt; RequiredChanges { get; set; } = new();
        public MigrationComplexity Complexity { get; set; }
    }
    
    public enum MigrationComplexity
    {
        Low,
        Medium,
        High
    }
    
    public class ConfigurationMigrator
    {
        public async Task&lt;MigrationResult&gt; MigrateAsync(MigrationConfig config)
        {
            // Migration implementation
            return await Task.FromResult(new MigrationResult { Success = true });
        }
        
        public async Task&lt;MigrationResult&gt; RollbackAsync(string migrationId)
        {
            // Rollback implementation
            return await Task.FromResult(new MigrationResult { Success = true });
        }
    }
    
    public class MigrationConfig
    {
        public string SourceVersion { get; set; }
        public string TargetVersion { get; set; }
        public bool CreateBackup { get; set; }
        public string BackupSuffix { get; set; }
    }
    
    public class MigrationResult
    {
        public bool Success { get; set; }
        public string ErrorMessage { get; set; }
        public int ProcessedFiles { get; set; }
        public List&lt;string&gt; ChangedFiles { get; set; } = new();
    }
    
    // REPL
    public class TuskRepl
    {
        private readonly ILogger _logger;
        private readonly CliConfig _config;
        
        public TuskRepl(ILogger logger, CliConfig config)
        {
            _logger = logger;
            _config = config;
        }
        
        public async Task StartAsync(CancellationToken cancellationToken = default)
        {
            Console.WriteLine($"TuskLang Interactive Shell v{_config.Version}");
            Console.WriteLine("Type 'help' for available commands or 'exit' to quit.");
            
            while (!cancellationToken.IsCancellationRequested)
            {
                Console.Write("tusk> ");
                var input = Console.ReadLine();
                
                if (string.IsNullOrWhiteSpace(input))
                    continue;
                
                if (input.Trim().ToLower() == "exit" || input.Trim().ToLower() == "quit")
                    break;
                
                try
                {
                    await ProcessReplInput(input);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error: {ex.Message}");
                }
            }
            
            Console.WriteLine("Goodbye!");
        }
        
        private async Task ProcessReplInput(string input)
        {
            // REPL command processing
            await Task.CompletedTask;
            Console.WriteLine($"Processed: {input}");
        }
    }
    
    // Dummy implementations for missing classes
    public class TuskLangParser
    {
        public Dictionary&lt;string, object&gt; Parse(string content)
        {
            return JsonSerializer.Deserialize&lt;Dictionary&lt;string, object&gt;&gt;(content) ?? new Dictionary&lt;string, object&gt;();
        }
    }
    
    public class TuskLangValidator
    {
        public async Task&lt;ValidationResult&gt; ValidateAsync(Dictionary&lt;string, object&gt; parsed, bool strict = false)
        {
            return await Task.FromResult(new ValidationResult { IsValid = true });
        }
    }
    
    public class TuskLangSerializer
    {
        public async Task&lt;string&gt; SerializeAsync(Dictionary&lt;string, object&gt; data, string format, bool pretty = false)
        {
            var options = pretty ? new JsonSerializerOptions { WriteIndented = true } : null;
            return await Task.FromResult(JsonSerializer.Serialize(data, options));
        }
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using TuskLang.Cli;

class Program
{
    static async Task Main(string[] args)
    {
        // Setup dependency injection
        var serviceProvider = new ServiceCollection()
            .AddLogging(builder =&gt; builder.AddConsole())
            .AddSingleton&lt;CliConfig&gt;(provider =&gt; new CliConfig
            {
                Name = "tuskcli",
                Version = "1.0.0",
                Description = "TuskLang CLI and scripting tool"
            })
            .AddSingleton&lt;TuskCliEngine&gt;()
            .BuildServiceProvider();
        
        var cliEngine = serviceProvider.GetRequiredService&lt;TuskCliEngine&gt;();
        
        // Check for interactive mode
        if (args.Length == 0 || args.Contains("--interactive"))
        {
            await cliEngine.StartInteractiveModeAsync();
        }
        else
        {
            // Execute CLI command
            var exitCode = await cliEngine.ExecuteAsync(args);
            Environment.Exit(exitCode);
        }
    }
}
</pre>