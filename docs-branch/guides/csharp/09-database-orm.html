<h1>Database & ORM</h1>

<h2>Database Integration and ORM with TuskLang in C#</h2>
<p>Integrate TuskLang with Entity Framework Core and implement database configurations, connection management, and data access patterns.</p>

<h3>database.tsk</h3>
<pre>
# Database configuration with TuskLang
database {
    # Connection settings
    connections {
        # Primary database connection
        primary {
            provider: env("DB_PROVIDER", "SqlServer")
            connection_string: env("CONNECTION_STRING", 
                "Server=localhost;Database=MyApp;Trusted_Connection=true;")
            
            # Connection pool configuration
            pool {
                min_connections: env("DB_POOL_MIN", 5)
                max_connections: env("DB_POOL_MAX", 100)
                connection_timeout: env("DB_TIMEOUT", 30)
                command_timeout: env("DB_COMMAND_TIMEOUT", 60)
                
                # Retry policy
                retry_policy {
                    max_retries: 3
                    delay_between_retries: "00:00:05"
                    max_random_delay: "00:00:02"
                }
            }
            
            # Security settings
            security {
                encrypt: env("DB_ENCRYPT", true)
                trust_server_certificate: env("DB_TRUST_CERT", false)
                integrated_security: env("DB_INTEGRATED_AUTH", true)
                
                # Connection string encryption
                encrypt_connection_string: env("ENCRYPT_CONNECTION_STRING", false)
                encryption_key: env("DB_ENCRYPTION_KEY")
            }
        }
        
        # Read replica connection
        read_replica {
            provider: @database.connections.primary.provider
            connection_string: env("READ_REPLICA_CONNECTION_STRING")
            
            # Read-only specific settings
            read_only: true
            load_balancing: {
                enabled: true
                strategy: "round_robin"  # round_robin, random, least_connections
                health_check_interval: "00:01:00"
            }
        }
        
        # Cache database (Redis)
        cache {
            provider: "Redis"
            connection_string: env("REDIS_CONNECTION_STRING", "localhost:6379")
            
            database_number: env("REDIS_DB", 0)
            prefix: env("REDIS_PREFIX", "myapp:")
            
            settings {
                sync_timeout: "00:00:05"
                async_timeout: "00:00:05"
                connect_timeout: "00:00:05"
                
                # Clustering
                cluster_endpoints: env("REDIS_CLUSTER_ENDPOINTS", "").split(",")
                abort_on_connect_fail: false
                allow_admin: env("REDIS_ALLOW_ADMIN", false)
            }
        }
    }
    
    # Entity Framework configuration
    entity_framework {
        # Global settings
        settings {
            # Tracking behavior
            query_tracking_behavior: env("EF_TRACKING", "TrackAll")  # TrackAll, NoTracking
            auto_detect_changes: env("EF_AUTO_DETECT_CHANGES", true)
            validate_on_save: env("EF_VALIDATE_ON_SAVE", true)
            
            # Performance settings
            enable_service_provider_caching: true
            enable_sensitive_data_logging: @environment == "Development"
            enable_detailed_errors: @environment == "Development"
            
            # Query settings
            default_query_splitting_behavior: "SplitQuery"
            max_batch_size: env("EF_MAX_BATCH_SIZE", 100)
            command_timeout: env("EF_COMMAND_TIMEOUT", 30)
        }
        
        # Migration settings
        migrations {
            assembly: env("MIGRATIONS_ASSEMBLY", "MyApp.Data")
            table_name: env("MIGRATIONS_TABLE", "__EFMigrationsHistory")
            schema: env("MIGRATIONS_SCHEMA", "dbo")
            
            # Auto-migration settings
            auto_migrate: env("AUTO_MIGRATE", false)
            auto_migrate_environments: ["Development", "Testing"]
            
            # Migration strategies
            strategy: env("MIGRATION_STRATEGY", "migrate")  # migrate, recreate, validate
            seed_data: env("SEED_DATA", true)
            
            # Backup settings
            backup_before_migration: env("BACKUP_BEFORE_MIGRATION", true)
            backup_location: env("BACKUP_LOCATION", "./backups")
        }
        
        # Interceptors
        interceptors {
            # Auditing interceptor
            audit {
                enabled: env("ENABLE_AUDIT", true)
                audit_table: "AuditLog"
                
                tracked_entities: ["User", "Order", "Product", "Payment"]
                
                fields {
                    created_by: "CreatedBy"
                    created_at: "CreatedAt"
                    modified_by: "ModifiedBy"
                    modified_at: "ModifiedAt"
                    version: "Version"
                }
            }
            
            # Soft delete interceptor
            soft_delete {
                enabled: env("ENABLE_SOFT_DELETE", true)
                deleted_field: "IsDeleted"
                deleted_at_field: "DeletedAt"
                deleted_by_field: "DeletedBy"
                
                # Entities that support soft delete
                entities: ["User", "Order", "Product"]
            }
            
            # Performance monitoring
            performance {
                enabled: env("ENABLE_DB_MONITORING", true)
                log_slow_queries: true
                slow_query_threshold: "00:00:01"
                
                # Query analysis
                analyze_queries: env("ANALYZE_QUERIES", false)
                log_query_plans: env("LOG_QUERY_PLANS", false)
            }
        }
    }
    
    # Repository patterns
    repositories {
        # Base repository configuration
        base {
            # Caching strategy
            caching {
                enabled: env("ENABLE_REPO_CACHE", true)
                default_expiration: "00:15:00"
                cache_provider: "Memory"  # Memory, Redis, Hybrid
                
                # Cache invalidation
                invalidation_strategy: "time_based"  # time_based, event_based, manual
                tags_enabled: true
            }
            
            # Pagination settings
            pagination {
                default_page_size: env("DEFAULT_PAGE_SIZE", 20)
                max_page_size: env("MAX_PAGE_SIZE", 100)
                
                # Performance optimization
                count_optimization: true
                async_enumeration: true
            }
        }
        
        # Specific repository configurations
        user_repository {
            caching: {
                enabled: true,
                expiration: "00:30:00",
                tags: ["users", "authentication"]
            }
            
            # Specialized queries
            queries {
                active_users: "u => u.IsActive && !u.IsDeleted"
                recent_users: "u => u.CreatedAt >= DateTime.UtcNow.AddDays(-30)"
                admin_users: "u => u.Roles.Any(r => r.Name == \"Admin\")"
            }
        }
        
        order_repository {
            caching: {
                enabled: true,
                expiration: "00:05:00",
                tags: ["orders", "commerce"]
            }
            
            # Include strategies
            includes {
                default: ["Customer", "Items", "Items.Product"]
                detailed: ["Customer", "Items", "Items.Product", "Payments", "Shipments"]
            }
        }
    }
    
    # Data seeding
    seeding {
        enabled: env("ENABLE_SEEDING", true)
        environments: ["Development", "Testing"]
        
        # Seed data sources
        sources {
            # JSON files
            json_files: [
                { file: "SeedData/users.json", entity: "User" },
                { file: "SeedData/products.json", entity: "Product" },
                { file: "SeedData/categories.json", entity: "Category" }
            ]
            
            # CSV files
            csv_files: [
                { file: "SeedData/orders.csv", entity: "Order", delimiter: "," },
                { file: "SeedData/inventory.csv", entity: "Inventory", delimiter: ";" }
            ]
            
            # External APIs
            external_apis: [
                {
                    name: "reference_data",
                    url: env("REFERENCE_DATA_API"),
                    entity: "ReferenceData",
                    auth_header: env("API_AUTH_HEADER")
                }
            ]
        }
        
        # Seeding strategy
        strategy {
            # How to handle existing data
            existing_data: "skip"  # skip, update, replace, error
            
            # Dependency resolution
            resolve_dependencies: true
            dependency_order: ["Category", "Product", "User", "Order"]
            
            # Validation
            validate_before_insert: true
            batch_size: env("SEED_BATCH_SIZE", 100)
        }
    }
    
    # Query optimization
    optimization {
        # Query compilation
        compiled_queries {
            enabled: env("ENABLE_COMPILED_QUERIES", true)
            
            # Pre-compiled query definitions
            definitions: [
                {
                    name: "GetUserById",
                    query: "context.Users.Include(u => u.Profile).FirstOrDefault(u => u.Id == userId)",
                    parameters: ["userId"]
                },
                {
                    name: "GetActiveOrders",
                    query: "context.Orders.Where(o => o.Status == OrderStatus.Active).Include(o => o.Items)",
                    parameters: []
                }
            ]
        }
        
        # Query splitting
        query_splitting {
            enabled: env("ENABLE_QUERY_SPLITTING", true)
            
            # Automatic splitting rules
            auto_split: {
                collection_threshold: 3,
                depth_threshold: 2
            }
            
            # Manual split configurations
            manual_splits: [
                {
                    entity: "Order",
                    includes: ["Items", "Payments"],
                    split_on: ["Items", "Payments"]
                }
            ]
        }
        
        # Index hints
        index_hints {
            enabled: env("ENABLE_INDEX_HINTS", false)
            
            hints: [
                {
                    table: "Users",
                    index: "IX_Users_Email",
                    queries: ["GetUserByEmail", "ValidateUserEmail"]
                },
                {
                    table: "Orders",
                    index: "IX_Orders_CustomerId_Status", 
                    queries: ["GetCustomerOrders"]
                }
            ]
        }
    }
    
    # Health checks
    health_checks {
        enabled: env("ENABLE_DB_HEALTH_CHECKS", true)
        
        # Connection health
        connection_check {
            enabled: true
            timeout: "00:00:10"
            query: "SELECT 1"
            interval: "00:01:00"
        }
        
        # Performance health
        performance_check {
            enabled: true
            max_response_time: "00:00:05"
            sample_queries: [
                "SELECT COUNT(*) FROM Users",
                "SELECT TOP 10 * FROM Orders ORDER BY CreatedAt DESC"
            ]
        }
        
        # Disk space health
        disk_space_check {
            enabled: true
            minimum_free_space_mb: 1000
            warning_threshold_mb: 5000
        }
    }
}

# Environment-specific overrides
@if(@environment == "Development", {
    database: {
        entity_framework: {
            settings: {
                enable_sensitive_data_logging: true,
                enable_detailed_errors: true
            }
        },
        
        seeding: {
            enabled: true
        }
    }
})

@if(@environment == "Production", {
    database: {
        connections: {
            primary: {
                pool: {
                    min_connections: 10,
                    max_connections: 200
                }
            }
        },
        
        entity_framework: {
            settings: {
                enable_sensitive_data_logging: false,
                enable_detailed_errors: false
            }
        },
        
        optimization: {
            compiled_queries: { enabled: true },
            query_splitting: { enabled: true }
        }
    }
})
</pre>

<h3>C# Database Integration Implementation</h3>
<pre>
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;

namespace TuskLang.Database
{
    // Database configuration models
    public class DatabaseConfig
    {
        public ConnectionsConfig Connections { get; set; } = new();
        public EntityFrameworkConfig EntityFramework { get; set; } = new();
        public RepositoriesConfig Repositories { get; set; } = new();
        public SeedingConfig Seeding { get; set; } = new();
        public OptimizationConfig Optimization { get; set; } = new();
        public HealthChecksConfig HealthChecks { get; set; } = new();
    }

    public class ConnectionsConfig
    {
        public ConnectionConfig Primary { get; set; } = new();
        public ConnectionConfig ReadReplica { get; set; } = new();
        public CacheConnectionConfig Cache { get; set; } = new();
    }

    public class ConnectionConfig
    {
        public string Provider { get; set; } = "SqlServer";
        public string ConnectionString { get; set; } = "";
        public PoolConfig Pool { get; set; } = new();
        public SecurityConfig Security { get; set; } = new();
    }

    public class PoolConfig
    {
        public int MinConnections { get; set; } = 5;
        public int MaxConnections { get; set; } = 100;
        public int ConnectionTimeout { get; set; } = 30;
        public int CommandTimeout { get; set; } = 60;
    }

    // Entity base classes
    public abstract class BaseEntity
    {
        public int Id { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime? ModifiedAt { get; set; }
        public bool IsDeleted { get; set; } = false;
        public DateTime? DeletedAt { get; set; }
        
        [Timestamp]
        public byte[] Version { get; set; }
    }

    public abstract class AuditableEntity : BaseEntity
    {
        public string CreatedBy { get; set; } = "";
        public string ModifiedBy { get; set; } = "";
        public string DeletedBy { get; set; } = "";
    }

    // Sample entities
    public class User : AuditableEntity
    {
        public string Username { get; set; } = "";
        public string Email { get; set; } = "";
        public string FirstName { get; set; } = "";
        public string LastName { get; set; } = "";
        public bool IsActive { get; set; } = true;
        
        // Navigation properties
        public UserProfile Profile { get; set; }
        public ICollection<Order> Orders { get; set; } = new List<Order>();
        public ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();
    }

    public class UserProfile : BaseEntity
    {
        public int UserId { get; set; }
        public string Bio { get; set; } = "";
        public string PhoneNumber { get; set; } = "";
        public DateTime? DateOfBirth { get; set; }
        
        // Navigation properties
        public User User { get; set; }
    }

    public class Order : AuditableEntity
    {
        public int UserId { get; set; }
        public string OrderNumber { get; set; } = "";
        public OrderStatus Status { get; set; } = OrderStatus.Pending;
        public decimal TotalAmount { get; set; }
        public DateTime? ShippedAt { get; set; }
        public DateTime? DeliveredAt { get; set; }
        
        // Navigation properties
        public User User { get; set; }
        public ICollection<OrderItem> Items { get; set; } = new List<OrderItem>();
        public ICollection<Payment> Payments { get; set; } = new List<Payment>();
    }

    public class OrderItem : BaseEntity
    {
        public int OrderId { get; set; }
        public int ProductId { get; set; }
        public int Quantity { get; set; }
        public decimal UnitPrice { get; set; }
        public decimal TotalPrice { get; set; }
        
        // Navigation properties
        public Order Order { get; set; }
        public Product Product { get; set; }
    }

    public class Product : AuditableEntity
    {
        public string Name { get; set; } = "";
        public string Description { get; set; } = "";
        public string SKU { get; set; } = "";
        public decimal Price { get; set; }
        public int StockQuantity { get; set; }
        public bool IsActive { get; set; } = true;
        
        // Navigation properties
        public ICollection<OrderItem> OrderItems { get; set; } = new List<OrderItem>();
    }

    public class Payment : BaseEntity
    {
        public int OrderId { get; set; }
        public decimal Amount { get; set; }
        public PaymentMethod Method { get; set; }
        public PaymentStatus Status { get; set; }
        public string TransactionId { get; set; } = "";
        public DateTime? ProcessedAt { get; set; }
        
        // Navigation properties
        public Order Order { get; set; }
    }

    public class UserRole : BaseEntity
    {
        public int UserId { get; set; }
        public string RoleName { get; set; } = "";
        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;
        
        // Navigation properties
        public User User { get; set; }
    }

    // Enums
    public enum OrderStatus
    {
        Pending,
        Processing,
        Shipped,
        Delivered,
        Cancelled,
        Returned
    }

    public enum PaymentMethod
    {
        CreditCard,
        DebitCard,
        PayPal,
        BankTransfer,
        Cash
    }

    public enum PaymentStatus
    {
        Pending,
        Processing,
        Completed,
        Failed,
        Refunded
    }

    // DbContext with TuskLang configuration
    public class AppDbContext : DbContext
    {
        private readonly DatabaseConfig _config;
        private readonly ILogger<AppDbContext> _logger;

        public AppDbContext(DbContextOptions<AppDbContext> options, DatabaseConfig config, ILogger<AppDbContext> logger)
            : base(options)
        {
            _config = config;
            _logger = logger;
        }

        // DbSets
        public DbSet<User> Users { get; set; }
        public DbSet<UserProfile> UserProfiles { get; set; }
        public DbSet<Order> Orders { get; set; }
        public DbSet<OrderItem> OrderItems { get; set; }
        public DbSet<Product> Products { get; set; }
        public DbSet<Payment> Payments { get; set; }
        public DbSet<UserRole> UserRoles { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            // Apply TuskLang configuration
            if (_config.EntityFramework.Settings.EnableSensitiveDataLogging)
            {
                optionsBuilder.EnableSensitiveDataLogging();
            }

            if (_config.EntityFramework.Settings.EnableDetailedErrors)
            {
                optionsBuilder.EnableDetailedErrors();
            }

            // Add interceptors
            if (_config.EntityFramework.Interceptors.Audit.Enabled)
            {
                optionsBuilder.AddInterceptors(new AuditingInterceptor());
            }

            if (_config.EntityFramework.Interceptors.SoftDelete.Enabled)
            {
                optionsBuilder.AddInterceptors(new SoftDeleteInterceptor());
            }

            if (_config.EntityFramework.Interceptors.Performance.Enabled)
            {
                optionsBuilder.AddInterceptors(new PerformanceInterceptor(_logger));
            }
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Configure entities
            ConfigureUser(modelBuilder);
            ConfigureOrder(modelBuilder);
            ConfigureProduct(modelBuilder);
            ConfigurePayment(modelBuilder);

            // Apply global query filters for soft delete
            if (_config.EntityFramework.Interceptors.SoftDelete.Enabled)
            {
                modelBuilder.Entity<User>().HasQueryFilter(u => !u.IsDeleted);
                modelBuilder.Entity<Order>().HasQueryFilter(o => !o.IsDeleted);
                modelBuilder.Entity<Product>().HasQueryFilter(p => !p.IsDeleted);
            }
        }

        private void ConfigureUser(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<User>(entity =>
            {
                entity.HasKey(u => u.Id);
                entity.Property(u => u.Username).IsRequired().HasMaxLength(50);
                entity.Property(u => u.Email).IsRequired().HasMaxLength(255);
                entity.HasIndex(u => u.Email).IsUnique();
                entity.HasIndex(u => u.Username).IsUnique();

                // Configure relationships
                entity.HasOne(u => u.Profile)
                      .WithOne(p => p.User)
                      .HasForeignKey<UserProfile>(p => p.UserId);

                entity.HasMany(u => u.Orders)
                      .WithOne(o => o.User)
                      .HasForeignKey(o => o.UserId);
            });
        }

        private void ConfigureOrder(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Order>(entity =>
            {
                entity.HasKey(o => o.Id);
                entity.Property(o => o.OrderNumber).IsRequired().HasMaxLength(50);
                entity.Property(o => o.TotalAmount).HasColumnType("decimal(18,2)");
                entity.HasIndex(o => o.OrderNumber).IsUnique();

                // Configure relationships
                entity.HasMany(o => o.Items)
                      .WithOne(i => i.Order)
                      .HasForeignKey(i => i.OrderId);

                entity.HasMany(o => o.Payments)
                      .WithOne(p => p.Order)
                      .HasForeignKey(p => p.OrderId);
            });

            modelBuilder.Entity<OrderItem>(entity =>
            {
                entity.HasKey(i => i.Id);
                entity.Property(i => i.UnitPrice).HasColumnType("decimal(18,2)");
                entity.Property(i => i.TotalPrice).HasColumnType("decimal(18,2)");

                entity.HasOne(i => i.Product)
                      .WithMany(p => p.OrderItems)
                      .HasForeignKey(i => i.ProductId);
            });
        }

        private void ConfigureProduct(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Product>(entity =>
            {
                entity.HasKey(p => p.Id);
                entity.Property(p => p.Name).IsRequired().HasMaxLength(100);
                entity.Property(p => p.SKU).IsRequired().HasMaxLength(50);
                entity.Property(p => p.Price).HasColumnType("decimal(18,2)");
                entity.HasIndex(p => p.SKU).IsUnique();
            });
        }

        private void ConfigurePayment(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Payment>(entity =>
            {
                entity.HasKey(p => p.Id);
                entity.Property(p => p.Amount).HasColumnType("decimal(18,2)");
                entity.Property(p => p.TransactionId).HasMaxLength(100);
            });
        }
    }

    // Base repository interface
    public interface IRepository<T> where T : BaseEntity
    {
        Task<T> GetByIdAsync(int id, CancellationToken cancellationToken = default);
        Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default);
        Task<IEnumerable<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);
        Task<T> AddAsync(T entity, CancellationToken cancellationToken = default);
        Task<T> UpdateAsync(T entity, CancellationToken cancellationToken = default);
        Task DeleteAsync(int id, CancellationToken cancellationToken = default);
        Task<bool> ExistsAsync(int id, CancellationToken cancellationToken = default);
        Task<int> CountAsync(Expression<Func<T, bool>> predicate = null, CancellationToken cancellationToken = default);
        Task<PagedResult<T>> GetPagedAsync(int page, int pageSize, CancellationToken cancellationToken = default);
    }

    // Base repository implementation
    public class Repository<T> : IRepository<T> where T : BaseEntity
    {
        protected readonly AppDbContext _context;
        protected readonly DbSet<T> _dbSet;
        protected readonly IMemoryCache _cache;
        protected readonly DatabaseConfig _config;

        public Repository(AppDbContext context, IMemoryCache cache, DatabaseConfig config)
        {
            _context = context;
            _dbSet = context.Set<T>();
            _cache = cache;
            _config = config;
        }

        public virtual async Task<T> GetByIdAsync(int id, CancellationToken cancellationToken = default)
        {
            var cacheKey = $"{typeof(T).Name}_{id}";
            
            if (_config.Repositories.Base.Caching.Enabled && _cache.TryGetValue(cacheKey, out T cached))
            {
                return cached;
            }

            var entity = await _dbSet.FindAsync(new object[] { id }, cancellationToken);
            
            if (entity != null && _config.Repositories.Base.Caching.Enabled)
            {
                var expiration = TimeSpan.Parse(_config.Repositories.Base.Caching.DefaultExpiration);
                _cache.Set(cacheKey, entity, expiration);
            }

            return entity;
        }

        public virtual async Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default)
        {
            return await _dbSet.ToListAsync(cancellationToken);
        }

        public virtual async Task<IEnumerable<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
        {
            return await _dbSet.Where(predicate).ToListAsync(cancellationToken);
        }

        public virtual async Task<T> AddAsync(T entity, CancellationToken cancellationToken = default)
        {
            _dbSet.Add(entity);
            await _context.SaveChangesAsync(cancellationToken);
            
            // Invalidate cache
            if (_config.Repositories.Base.Caching.Enabled)
            {
                InvalidateCache(entity);
            }
            
            return entity;
        }

        public virtual async Task<T> UpdateAsync(T entity, CancellationToken cancellationToken = default)
        {
            entity.ModifiedAt = DateTime.UtcNow;
            _dbSet.Update(entity);
            await _context.SaveChangesAsync(cancellationToken);
            
            // Invalidate cache
            if (_config.Repositories.Base.Caching.Enabled)
            {
                InvalidateCache(entity);
            }
            
            return entity;
        }

        public virtual async Task DeleteAsync(int id, CancellationToken cancellationToken = default)
        {
            var entity = await GetByIdAsync(id, cancellationToken);
            if (entity != null)
            {
                if (_config.EntityFramework.Interceptors.SoftDelete.Enabled)
                {
                    entity.IsDeleted = true;
                    entity.DeletedAt = DateTime.UtcNow;
                    await UpdateAsync(entity, cancellationToken);
                }
                else
                {
                    _dbSet.Remove(entity);
                    await _context.SaveChangesAsync(cancellationToken);
                }
                
                // Invalidate cache
                if (_config.Repositories.Base.Caching.Enabled)
                {
                    InvalidateCache(entity);
                }
            }
        }

        public virtual async Task<bool> ExistsAsync(int id, CancellationToken cancellationToken = default)
        {
            return await _dbSet.AnyAsync(e => e.Id == id, cancellationToken);
        }

        public virtual async Task<int> CountAsync(Expression<Func<T, bool>> predicate = null, CancellationToken cancellationToken = default)
        {
            return predicate == null 
                ? await _dbSet.CountAsync(cancellationToken)
                : await _dbSet.CountAsync(predicate, cancellationToken);
        }

        public virtual async Task<PagedResult<T>> GetPagedAsync(int page, int pageSize, CancellationToken cancellationToken = default)
        {
            var maxPageSize = _config.Repositories.Base.Pagination.MaxPageSize;
            pageSize = Math.Min(pageSize, maxPageSize);
            
            var totalCount = await _dbSet.CountAsync(cancellationToken);
            var items = await _dbSet
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync(cancellationToken);

            return new PagedResult<T>
            {
                Items = items,
                TotalCount = totalCount,
                Page = page,
                PageSize = pageSize,
                TotalPages = (int)Math.Ceiling((double)totalCount / pageSize)
            };
        }

        protected virtual void InvalidateCache(T entity)
        {
            var cacheKey = $"{typeof(T).Name}_{entity.Id}";
            _cache.Remove(cacheKey);
        }
    }

    // Specialized repositories
    public interface IUserRepository : IRepository<User>
    {
        Task<User> GetByEmailAsync(string email, CancellationToken cancellationToken = default);
        Task<User> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);
        Task<IEnumerable<User>> GetActiveUsersAsync(CancellationToken cancellationToken = default);
        Task<IEnumerable<User>> GetRecentUsersAsync(int days = 30, CancellationToken cancellationToken = default);
    }

    public class UserRepository : Repository<User>, IUserRepository
    {
        public UserRepository(AppDbContext context, IMemoryCache cache, DatabaseConfig config)
            : base(context, cache, config)
        {
        }

        public async Task<User> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
        {
            return await _dbSet
                .Include(u => u.Profile)
                .FirstOrDefaultAsync(u => u.Email == email, cancellationToken);
        }

        public async Task<User> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
        {
            return await _dbSet
                .Include(u => u.Profile)
                .FirstOrDefaultAsync(u => u.Username == username, cancellationToken);
        }

        public async Task<IEnumerable<User>> GetActiveUsersAsync(CancellationToken cancellationToken = default)
        {
            return await _dbSet
                .Where(u => u.IsActive)
                .Include(u => u.Profile)
                .ToListAsync(cancellationToken);
        }

        public async Task<IEnumerable<User>> GetRecentUsersAsync(int days = 30, CancellationToken cancellationToken = default)
        {
            var cutoffDate = DateTime.UtcNow.AddDays(-days);
            return await _dbSet
                .Where(u => u.CreatedAt >= cutoffDate)
                .Include(u => u.Profile)
                .OrderByDescending(u => u.CreatedAt)
                .ToListAsync(cancellationToken);
        }
    }

    // EF Core interceptors
    public class AuditingInterceptor : SaveChangesInterceptor
    {
        public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
        {
            UpdateAuditFields(eventData.Context);
            return base.SavingChanges(eventData, result);
        }

        public override ValueTask<InterceptionResult<int>> SavingChangesAsync(DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
        {
            UpdateAuditFields(eventData.Context);
            return base.SavingChangesAsync(eventData, result, cancellationToken);
        }

        private void UpdateAuditFields(DbContext context)
        {
            var entries = context.ChangeTracker.Entries<AuditableEntity>();

            foreach (var entry in entries)
            {
                switch (entry.State)
                {
                    case EntityState.Added:
                        entry.Entity.CreatedAt = DateTime.UtcNow;
                        entry.Entity.CreatedBy = GetCurrentUser();
                        break;
                    case EntityState.Modified:
                        entry.Entity.ModifiedAt = DateTime.UtcNow;
                        entry.Entity.ModifiedBy = GetCurrentUser();
                        break;
                    case EntityState.Deleted:
                        entry.Entity.DeletedAt = DateTime.UtcNow;
                        entry.Entity.DeletedBy = GetCurrentUser();
                        break;
                }
            }
        }

        private string GetCurrentUser()
        {
            // In a real application, get from HttpContext or security context
            return "system";
        }
    }

    public class SoftDeleteInterceptor : SaveChangesInterceptor
    {
        public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
        {
            UpdateSoftDeleteFields(eventData.Context);
            return base.SavingChanges(eventData, result);
        }

        private void UpdateSoftDeleteFields(DbContext context)
        {
            var entries = context.ChangeTracker.Entries<BaseEntity>()
                .Where(e => e.State == EntityState.Deleted);

            foreach (var entry in entries)
            {
                entry.State = EntityState.Modified;
                entry.Entity.IsDeleted = true;
                entry.Entity.DeletedAt = DateTime.UtcNow;
            }
        }
    }

    public class PerformanceInterceptor : DbCommandInterceptor
    {
        private readonly ILogger _logger;

        public PerformanceInterceptor(ILogger logger)
        {
            _logger = logger;
        }

        public override ValueTask<DbDataReader> ReaderExecutedAsync(DbCommand command, CommandExecutedEventData eventData, DbDataReader result, CancellationToken cancellationToken = default)
        {
            if (eventData.Duration.TotalSeconds > 1.0)
            {
                _logger.LogWarning("Slow query detected: {Query} took {Duration}ms", 
                    command.CommandText, eventData.Duration.TotalMilliseconds);
            }

            return base.ReaderExecutedAsync(command, eventData, result, cancellationToken);
        }
    }

    // Utility classes
    public class PagedResult<T>
    {
        public IEnumerable<T> Items { get; set; } = new List<T>();
        public int TotalCount { get; set; }
        public int Page { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }
        public bool HasPreviousPage => Page > 1;
        public bool HasNextPage => Page < TotalPages;
    }

    // Extension methods for dependency injection
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection AddTuskLangDatabase(this IServiceCollection services, DatabaseConfig config)
        {
            // Register DbContext
            services.AddDbContext<AppDbContext>((serviceProvider, options) =>
            {
                var connectionString = config.Connections.Primary.ConnectionString;
                
                switch (config.Connections.Primary.Provider.ToLowerInvariant())
                {
                    case "sqlserver":
                        options.UseSqlServer(connectionString, sqlOptions =>
                        {
                            sqlOptions.CommandTimeout(config.Connections.Primary.Pool.CommandTimeout);
                            if (!string.IsNullOrEmpty(config.EntityFramework.Migrations.Assembly))
                            {
                                sqlOptions.MigrationsAssembly(config.EntityFramework.Migrations.Assembly);
                            }
                        });
                        break;
                    case "postgresql":
                        options.UseNpgsql(connectionString);
                        break;
                    case "sqlite":
                        options.UseSqlite(connectionString);
                        break;
                    default:
                        throw new NotSupportedException($"Database provider '{config.Connections.Primary.Provider}' is not supported");
                }

                // Configure query tracking
                if (Enum.TryParse<QueryTrackingBehavior>(config.EntityFramework.Settings.QueryTrackingBehavior, out var trackingBehavior))
                {
                    options.UseQueryTrackingBehavior(trackingBehavior);
                }
            });

            // Register repositories
            services.AddScoped<IUserRepository, UserRepository>();
            services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

            // Register configuration
            services.AddSingleton(config);

            return services;
        }
    }
}
</pre>

<h3>Usage Example</h3>
<pre>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Threading.Tasks;
using TuskLang.Database;

class Program
{
    static async Task Main(string[] args)
    {
        Console.WriteLine("=== TuskLang Database & ORM Demo ===");

        // 1. Setup services with TuskLang configuration
        var services = new ServiceCollection();
        
        // Load database configuration from TuskLang
        var databaseConfig = LoadDatabaseConfig();
        
        services.AddLogging(builder => builder.AddConsole());
        services.AddMemoryCache();
        services.AddTuskLangDatabase(databaseConfig);

        var serviceProvider = services.BuildServiceProvider();

        // 2. Initialize database
        await InitializeDatabaseAsync(serviceProvider, databaseConfig);

        // 3. Demonstrate repository patterns
        await DemonstrateRepositoryPatternsAsync(serviceProvider);

        // 4. Demonstrate advanced features
        await DemonstrateAdvancedFeaturesAsync(serviceProvider);

        Console.WriteLine("\n=== Demo Complete ===");
    }

    static DatabaseConfig LoadDatabaseConfig()
    {
        // In a real application, this would be loaded from TuskLang configuration
        return new DatabaseConfig
        {
            Connections = new ConnectionsConfig
            {
                Primary = new ConnectionConfig
                {
                    Provider = "SqlServer",
                    ConnectionString = "Server=(localdb)\\mssqllocaldb;Database=TuskLangDemo;Trusted_Connection=true;",
                    Pool = new PoolConfig
                    {
                        MinConnections = 5,
                        MaxConnections = 100,
                        ConnectionTimeout = 30,
                        CommandTimeout = 60
                    }
                }
            },
            EntityFramework = new EntityFrameworkConfig
            {
                Settings = new EntityFrameworkSettingsConfig
                {
                    QueryTrackingBehavior = "TrackAll",
                    EnableSensitiveDataLogging = true,
                    EnableDetailedErrors = true
                },
                Interceptors = new InterceptorsConfig
                {
                    Audit = new AuditConfig { Enabled = true },
                    SoftDelete = new SoftDeleteConfig { Enabled = true },
                    Performance = new PerformanceConfig { Enabled = true }
                }
            },
            Repositories = new RepositoriesConfig
            {
                Base = new BaseRepositoryConfig
                {
                    Caching = new CachingConfig
                    {
                        Enabled = true,
                        DefaultExpiration = "00:15:00"
                    },
                    Pagination = new PaginationConfig
                    {
                        DefaultPageSize = 20,
                        MaxPageSize = 100
                    }
                }
            }
        };
    }

    static async Task InitializeDatabaseAsync(IServiceProvider serviceProvider, DatabaseConfig config)
    {
        Console.WriteLine("\n1. Database Initialization:");

        using var scope = serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();

        try
        {
            // Ensure database is created
            await context.Database.EnsureCreatedAsync();
            Console.WriteLine("  ✓ Database created/verified");

            // Check if we should run migrations
            if (config.EntityFramework.Migrations.AutoMigrate)
            {
                await context.Database.MigrateAsync();
                Console.WriteLine("  ✓ Migrations applied");
            }

            // Seed data if configured
            if (config.Seeding.Enabled)
            {
                await SeedDataAsync(context);
                Console.WriteLine("  ✓ Data seeded");
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Database initialization failed");
            Console.WriteLine($"  ✗ Database initialization failed: {ex.Message}");
        }
    }

    static async Task SeedDataAsync(AppDbContext context)
    {
        // Check if data already exists
        if (await context.Users.AnyAsync())
            return;

        // Create sample users
        var users = new[]
        {
            new User
            {
                Username = "johndoe",
                Email = "john@example.com",
                FirstName = "John",
                LastName = "Doe",
                IsActive = true,
                Profile = new UserProfile
                {
                    Bio = "Software developer",
                    PhoneNumber = "+1-555-0123",
                    DateOfBirth = new DateTime(1990, 1, 15)
                }
            },
            new User
            {
                Username = "janesmith",
                Email = "jane@example.com", 
                FirstName = "Jane",
                LastName = "Smith",
                IsActive = true,
                Profile = new UserProfile
                {
                    Bio = "Product manager",
                    PhoneNumber = "+1-555-0456",
                    DateOfBirth = new DateTime(1985, 8, 22)
                }
            }
        };

        context.Users.AddRange(users);
        await context.SaveChangesAsync();

        // Create sample products
        var products = new[]
        {
            new Product
            {
                Name = "Wireless Headphones",
                Description = "High-quality wireless headphones",
                SKU = "WH-001",
                Price = 99.99m,
                StockQuantity = 50,
                IsActive = true
            },
            new Product
            {
                Name = "Bluetooth Speaker",
                Description = "Portable bluetooth speaker",
                SKU = "BS-002",
                Price = 49.99m,
                StockQuantity = 25,
                IsActive = true
            }
        };

        context.Products.AddRange(products);
        await context.SaveChangesAsync();
    }

    static async Task DemonstrateRepositoryPatternsAsync(IServiceProvider serviceProvider)
    {
        Console.WriteLine("\n2. Repository Patterns:");

        using var scope = serviceProvider.CreateScope();
        var userRepository = scope.ServiceProvider.GetRequiredService<IUserRepository>();

        // Get all users
        var allUsers = await userRepository.GetAllAsync();
        Console.WriteLine($"  Found {allUsers.Count()} users");

        // Get user by email
        var userByEmail = await userRepository.GetByEmailAsync("john@example.com");
        if (userByEmail != null)
        {
            Console.WriteLine($"  Found user: {userByEmail.FirstName} {userByEmail.LastName}");
        }

        // Get active users
        var activeUsers = await userRepository.GetActiveUsersAsync();
        Console.WriteLine($"  Found {activeUsers.Count()} active users");

        // Pagination example
        var pagedUsers = await userRepository.GetPagedAsync(1, 10);
        Console.WriteLine($"  Page 1 of users: {pagedUsers.Items.Count()} items, {pagedUsers.TotalCount} total");

        // Add new user
        var newUser = new User
        {
            Username = "bobwilson",
            Email = "bob@example.com",
            FirstName = "Bob", 
            LastName = "Wilson",
            IsActive = true
        };

        await userRepository.AddAsync(newUser);
        Console.WriteLine($"  ✓ Added new user: {newUser.Username}");

        // Update user
        newUser.FirstName = "Robert";
        await userRepository.UpdateAsync(newUser);
        Console.WriteLine($"  ✓ Updated user: {newUser.Username}");

        // Count users
        var userCount = await userRepository.CountAsync();
        Console.WriteLine($"  Total users: {userCount}");
    }

    static async Task DemonstrateAdvancedFeaturesAsync(IServiceProvider serviceProvider)
    {
        Console.WriteLine("\n3. Advanced Features:");

        using var scope = serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        var userRepository = scope.ServiceProvider.GetRequiredService<IUserRepository>();

        // Demonstrate caching
        Console.WriteLine("  Caching demonstration:");
        var user1 = await userRepository.GetByIdAsync(1); // First call - hits database
        var user2 = await userRepository.GetByIdAsync(1); // Second call - hits cache
        Console.WriteLine($"    Retrieved user from cache: {user1?.Username}");

        // Demonstrate soft delete
        Console.WriteLine("  Soft delete demonstration:");
        var userToDelete = await userRepository.GetByEmailAsync("bob@example.com");
        if (userToDelete != null)
        {
            await userRepository.DeleteAsync(userToDelete.Id);
            Console.WriteLine($"    ✓ Soft deleted user: {userToDelete.Username}");

            // Verify user is soft deleted (won't appear in normal queries)
            var deletedUser = await userRepository.GetByIdAsync(userToDelete.Id);
            Console.WriteLine($"    User found after soft delete: {deletedUser?.Username ?? "null"}");
        }

        // Demonstrate complex queries with includes
        Console.WriteLine("  Complex query demonstration:");
        var usersWithProfiles = await context.Users
            .Include(u => u.Profile)
            .Include(u => u.Orders)
            .ThenInclude(o => o.Items)
            .Where(u => u.IsActive)
            .ToListAsync();

        Console.WriteLine($"    Found {usersWithProfiles.Count} users with profiles and orders");

        // Demonstrate raw SQL for complex operations
        Console.WriteLine("  Raw SQL demonstration:");
        var userStats = await context.Database
            .SqlQueryRaw<UserStats>("SELECT COUNT(*) as TotalUsers, AVG(DATEDIFF(year, CreatedAt, GETDATE())) as AverageAge FROM Users WHERE IsDeleted = 0")
            .FirstOrDefaultAsync();

        if (userStats != null)
        {
            Console.WriteLine($"    Total users: {userStats.TotalUsers}, Average age: {userStats.AverageAge:F1} years");
        }

        // Demonstrate transaction handling
        Console.WriteLine("  Transaction demonstration:");
        using var transaction = await context.Database.BeginTransactionAsync();
        try
        {
            var newProduct = new Product
            {
                Name = "Smart Watch",
                Description = "Feature-rich smart watch",
                SKU = "SW-003",
                Price = 199.99m,
                StockQuantity = 30,
                IsActive = true
            };

            context.Products.Add(newProduct);
            await context.SaveChangesAsync();

            // Create an order for the product
            var buyer = await userRepository.GetByEmailAsync("jane@example.com");
            if (buyer != null)
            {
                var order = new Order
                {
                    UserId = buyer.Id,
                    OrderNumber = $"ORD-{DateTime.UtcNow:yyyyMMddHHmmss}",
                    Status = OrderStatus.Pending,
                    TotalAmount = newProduct.Price,
                    Items = new List<OrderItem>
                    {
                        new OrderItem
                        {
                            ProductId = newProduct.Id,
                            Quantity = 1,
                            UnitPrice = newProduct.Price,
                            TotalPrice = newProduct.Price
                        }
                    }
                };

                context.Orders.Add(order);
                await context.SaveChangesAsync();
            }

            await transaction.CommitAsync();
            Console.WriteLine("    ✓ Transaction completed successfully");
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            Console.WriteLine($"    ✗ Transaction failed: {ex.Message}");
        }
    }

    // Helper classes for configuration
    public class EntityFrameworkConfig
    {
        public EntityFrameworkSettingsConfig Settings { get; set; } = new();
        public MigrationsConfig Migrations { get; set; } = new();
        public InterceptorsConfig Interceptors { get; set; } = new();
    }

    public class EntityFrameworkSettingsConfig
    {
        public string QueryTrackingBehavior { get; set; } = "TrackAll";
        public bool EnableSensitiveDataLogging { get; set; } = false;
        public bool EnableDetailedErrors { get; set; } = false;
    }

    public class MigrationsConfig
    {
        public string Assembly { get; set; } = "";
        public bool AutoMigrate { get; set; } = false;
    }

    public class InterceptorsConfig
    {
        public AuditConfig Audit { get; set; } = new();
        public SoftDeleteConfig SoftDelete { get; set; } = new();
        public PerformanceConfig Performance { get; set; } = new();
    }

    public class AuditConfig
    {
        public bool Enabled { get; set; } = false;
    }

    public class SoftDeleteConfig
    {
        public bool Enabled { get; set; } = false;
    }

    public class PerformanceConfig
    {
        public bool Enabled { get; set; } = false;
    }

    public class RepositoriesConfig
    {
        public BaseRepositoryConfig Base { get; set; } = new();
    }

    public class BaseRepositoryConfig
    {
        public CachingConfig Caching { get; set; } = new();
        public PaginationConfig Pagination { get; set; } = new();
    }

    public class CachingConfig
    {
        public bool Enabled { get; set; } = false;
        public string DefaultExpiration { get; set; } = "00:15:00";
    }

    public class PaginationConfig
    {
        public int DefaultPageSize { get; set; } = 20;
        public int MaxPageSize { get; set; } = 100;
    }

    public class SeedingConfig
    {
        public bool Enabled { get; set; } = false;
    }

    public class SecurityConfig
    {
        // Security configuration properties
    }

    public class CacheConnectionConfig
    {
        // Cache connection configuration properties
    }

    public class HealthChecksConfig
    {
        // Health checks configuration properties
    }

    public class OptimizationConfig
    {
        // Optimization configuration properties
    }

    public class UserStats
    {
        public int TotalUsers { get; set; }
        public double AverageAge { get; set; }
    }
}
</pre>

<p>TuskLang database integration in C# provides comprehensive ORM configuration with Entity Framework Core, including connection management, repository patterns, caching, auditing, soft deletes, and performance monitoring.</p>