<h1>Security Best Practices with TuskLang in Rust</h1>

<h2>Secure Configuration Management</h2>
<p>TuskLang implements comprehensive security practices leveraging Rust's memory safety, type system, and cryptographic libraries to ensure secure configuration handling, secrets management, and protection against common vulnerabilities.</p>

<h3>Security Configuration</h3>
<pre>
# security-best-practices.tsk
# Comprehensive security configuration
security {
    # Secrets management
    secrets: {
        # Encryption at rest
        encryption: {
            enabled: env_bool("SECRETS_ENCRYPTION", true)
            algorithm: "AES-256-GCM"
            key_derivation: "PBKDF2"
            iterations: 100000
            salt_length: 32
            
            # Key management
            key_source: env("KEY_SOURCE", "env")  # env, file, vault, hsm
            key_rotation: {
                enabled: env_bool("KEY_ROTATION", true)
                interval_days: 90
                auto_rotate: false
            }
        }
        
        # Secret sources
        sources: {
            environment: {
                enabled: true
                prefix_filter: "SECRET_"
                mask_in_logs: true
            }
            
            vault: {
                enabled: env_bool("VAULT_ENABLED", false)
                url: env("VAULT_URL", "")
                auth_method: "token"  # token, aws, kubernetes
                mount_path: "secret"
                version: "v2"
            }
            
            kubernetes: {
                enabled: env_bool("K8S_SECRETS", false)
                namespace: env("K8S_NAMESPACE", "default")
                service_account: env("K8S_SERVICE_ACCOUNT", "")
            }
            
            aws_secrets_manager: {
                enabled: env_bool("AWS_SECRETS", false)
                region: env("AWS_REGION", "us-east-1")
                kms_key_id: env("AWS_KMS_KEY", "")
            }
        }
        
        # Secret validation
        validation: {
            entropy_check: true
            min_entropy_bits: 128
            pattern_validation: true
            common_passwords_check: true
            expiration_tracking: true
        }
    }
    
    # Access control and permissions
    access_control: {
        # Role-based access control
        rbac: {
            enabled: true
            default_role: "reader"
            
            roles: {
                admin: {
                    permissions: ["read", "write", "delete", "manage_users", "manage_secrets"]
                    config_sections: ["*"]
                    sensitive_data: true
                }
                
                operator: {
                    permissions: ["read", "write"]
                    config_sections: ["application", "performance", "monitoring"]
                    sensitive_data: false
                }
                
                reader: {
                    permissions: ["read"]
                    config_sections: ["application.public", "monitoring.metrics"]
                    sensitive_data: false
                }
                
                service: {
                    permissions: ["read"]
                    config_sections: ["application", "database.connection"]
                    sensitive_data: true
                    restrictions: {
                        ip_whitelist: ["10.0.0.0/8", "172.16.0.0/12"]
                        time_based: false
                    }
                }
            }
        }
        
        # Attribute-based access control
        abac: {
            enabled: env_bool("ABAC_ENABLED", false)
            policy_engine: "opa"  # opa, cedar
            
            attributes: {
                user: ["role", "department", "clearance_level"]
                resource: ["classification", "owner", "environment"]
                environment: ["time", "location", "network"]
            }
            
            policies: [
                "allow if user.role == 'admin'",
                "allow if user.department == resource.owner",
                "deny if resource.classification == 'secret' and user.clearance_level < 3",
                "deny if environment.time < '09:00' or environment.time > '17:00'"
            ]
        }
        
        # Authentication
        authentication: {
            methods: ["jwt", "mtls", "api_key"]
            
            jwt: {
                issuer: env("JWT_ISSUER", "")
                audience: env("JWT_AUDIENCE", "")
                algorithm: "RS256"
                public_key_url: env("JWT_PUBLIC_KEY_URL", "")
                token_expiry: 3600
                refresh_enabled: true
            }
            
            mtls: {
                enabled: env_bool("MTLS_ENABLED", false)
                ca_cert_path: env("CA_CERT_PATH", "")
                client_cert_verification: "require"
                ocsp_checking: true
            }
            
            api_key: {
                enabled: true
                header_name: "X-API-Key"
                hash_algorithm: "SHA-256"
                rate_limiting: true
            }
        }
    }
    
    # Input validation and sanitization
    input_validation: {
        enabled: true
        strict_mode: env_bool("STRICT_VALIDATION", true)
        
        # Schema validation
        schema_validation: {
            enabled: true
            reject_unknown_fields: true
            max_nesting_depth: 10
            max_array_length: 1000
            max_string_length: 10000
        }
        
        # Content filtering
        content_filtering: {
            sql_injection_protection: true
            xss_protection: true
            command_injection_protection: true
            path_traversal_protection: true
            
            # Blocked patterns
            blocked_patterns: [
                r"(?i)(\b(union|select|insert|update|delete|drop|exec|script)\b)",
                r"(\.\./|\.\.\\\)",
                r"(\$\(|\`)",
                r"(<script|javascript:|vbscript:)"
            ]
        }
        
        # Data sanitization
        sanitization: {
            html_escape: true
            url_encode: true
            normalize_unicode: true
            trim_whitespace: true
            remove_null_bytes: true
        }
    }
    
    # Audit logging and monitoring
    audit: {
        enabled: true
        log_level: "INFO"
        
        # Events to audit
        events: {
            config_access: true
            config_modification: true
            secret_access: true
            authentication: true
            authorization_failures: true
            system_errors: true
        }
        
        # Audit log format
        format: {
            structured: true
            include_stack_trace: false
            include_request_headers: false
            include_user_agent: true
            timestamp_format: "ISO8601"
        }
        
        # Log destinations
        destinations: {
            file: {
                enabled: true
                path: "/var/log/tusklang/audit.log"
                rotation: {
                    max_size_mb: 100
                    max_files: 10
                    compress: true
                }
            }
            
            syslog: {
                enabled: env_bool("SYSLOG_ENABLED", false)
                facility: "auth"
                severity: "info"
                protocol: "tcp"
                host: env("SYSLOG_HOST", "localhost")
                port: env_int("SYSLOG_PORT", 514)
            }
            
            remote: {
                enabled: env_bool("REMOTE_AUDIT", false)
                endpoint: env("AUDIT_ENDPOINT", "")
                authentication: "bearer_token"
                batch_size: 100
                flush_interval: 30
            }
        }
    }
    
    # Security hardening
    hardening: {
        # Process security
        process: {
            drop_privileges: env_bool("DROP_PRIVILEGES", true)
            user: env("RUN_AS_USER", "tusklang")
            group: env("RUN_AS_GROUP", "tusklang")
            chroot: env("CHROOT_PATH", "")
            
            # Resource limits
            limits: {
                max_memory_mb: env_int("MAX_MEMORY", 512)
                max_cpu_percent: env_int("MAX_CPU", 80)
                max_open_files: env_int("MAX_FILES", 1024)
                max_processes: env_int("MAX_PROCESSES", 100)
            }
        }
        
        # Network security
        network: {
            bind_localhost_only: env_bool("BIND_LOCALHOST", false)
            allowed_interfaces: env("ALLOWED_INTERFACES", "")
            
            tls: {
                min_version: "1.2"
                preferred_version: "1.3"
                cipher_suites: [
                    "TLS_AES_256_GCM_SHA384",
                    "TLS_CHACHA20_POLY1305_SHA256",
                    "TLS_AES_128_GCM_SHA256"
                ]
                require_sni: true
                hsts_enabled: true
                hsts_max_age: 31536000
            }
        }
        
        # File system security
        filesystem: {
            temp_dir: env("TEMP_DIR", "/tmp/tusklang")
            umask: "0077"
            secure_temp_files: true
            
            # Sandboxing
            sandbox: {
                enabled: env_bool("SANDBOX_ENABLED", false)
                type: "seccomp"  # seccomp, apparmor, selinux
                policy_file: env("SANDBOX_POLICY", "")
            }
        }
    }
}

# Vulnerability scanning and compliance
compliance {
    # Security scanning
    vulnerability_scanning: {
        enabled: env_bool("VULN_SCANNING", true)
        schedule: "0 2 * * *"  # Daily at 2 AM
        
        scanners: {
            dependency_check: {
                enabled: true
                database_url: "https://nvd.nist.gov/feeds/json/cve/1.1/"
                fail_on_cvss: 7.0
                exclude_packages: []
            }
            
            static_analysis: {
                enabled: true
                tools: ["clippy", "audit", "geiger"]
                fail_on_warnings: env_bool("FAIL_ON_WARNINGS", false)
            }
            
            container_scanning: {
                enabled: env_bool("CONTAINER_SCAN", false)
                scanner: "trivy"
                ignore_unfixed: false
            }
        }
    }
    
    # Compliance frameworks
    frameworks: {
        pci_dss: {
            enabled: env_bool("PCI_DSS", false)
            version: "4.0"
            requirements: [
                "secure_transmission",
                "encrypt_stored_data",
                "access_controls",
                "vulnerability_management",
                "monitoring_testing"
            ]
        }
        
        sox: {
            enabled: env_bool("SOX_COMPLIANCE", false)
            controls: [
                "segregation_of_duties",
                "change_management",
                "audit_trails",
                "access_reviews"
            ]
        }
        
        gdpr: {
            enabled: env_bool("GDPR_COMPLIANCE", false)
            data_protection: {
                encryption_required: true
                anonymization: true
                right_to_erasure: true
                data_portability: true
            }
        }
    }
}
</pre>

<h3>Rust Security Implementation</h3>
<pre>
use ring::{aead, digest, hkdf, pbkdf2, rand};
use ring::rand::SecureRandom;
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use argon2::password_hash::{PasswordHashString, SaltString};
use zeroize::{Zeroize, ZeroizeOnDrop};
use secrecy::{Secret, SecretString, ExposeSecret};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use rustls::{ServerConfig, ClientConfig, Certificate, PrivateKey};
use std::sync::Arc;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

// Secure secrets management
#[derive(Debug)]
pub struct SecureSecretsManager {
    encryption_key: Secret<[u8; 32]>,
    secrets_cache: Arc<tokio::sync::RwLock<HashMap<String, EncryptedSecret>>>,
    audit_logger: Arc<AuditLogger>,
    access_controller: Arc<AccessController>,
}

#[derive(Debug, Clone, ZeroizeOnDrop)]
struct EncryptedSecret {
    ciphertext: Vec<u8>,
    nonce: [u8; 12],
    created_at: DateTime<Utc>,
    expires_at: Option<DateTime<Utc>>,
    access_count: u64,
    #[zeroize(skip)]
    metadata: SecretMetadata,
}

#[derive(Debug, Clone)]
struct SecretMetadata {
    classification: SecurityClassification,
    owner: String,
    tags: Vec<String>,
    access_policy: AccessPolicy,
}

#[derive(Debug, Clone)]
enum SecurityClassification {
    Public,
    Internal,
    Confidential,
    Secret,
    TopSecret,
}

#[derive(Debug, Clone)]
struct AccessPolicy {
    allowed_roles: Vec<String>,
    ip_restrictions: Vec<String>,
    time_restrictions: Option<TimeRestriction>,
    max_access_count: Option<u64>,
}

#[derive(Debug, Clone)]
struct TimeRestriction {
    start_time: chrono::NaiveTime,
    end_time: chrono::NaiveTime,
    allowed_days: Vec<chrono::Weekday>,
}

impl SecureSecretsManager {
    pub fn new(master_key: &[u8]) -> Result<Self, SecurityError> {
        // Derive encryption key using HKDF
        let salt = hkdf::Salt::new(hkdf::HKDF_SHA256, &[]);
        let prk = salt.extract(master_key);
        let info = b"TuskLang Secrets Encryption Key";
        let mut encryption_key = [0u8; 32];
        prk.expand(&[info], hkdf::HKDF_SHA256)
            .map_err(|_| SecurityError::KeyDerivationFailed)?
            .fill(&mut encryption_key)
            .map_err(|_| SecurityError::KeyDerivationFailed)?;
        
        Ok(SecureSecretsManager {
            encryption_key: Secret::new(encryption_key),
            secrets_cache: Arc::new(tokio::sync::RwLock::new(HashMap::new())),
            audit_logger: Arc::new(AuditLogger::new()),
            access_controller: Arc::new(AccessController::new()),
        })
    }
    
    // Store secret with encryption
    pub async fn store_secret(
        &self,
        key: &str,
        value: &SecretString,
        metadata: SecretMetadata,
        context: &SecurityContext,
    ) -> Result<(), SecurityError> {
        // Check permissions
        self.access_controller.check_write_permission(context, &metadata.access_policy)?;
        
        // Encrypt the secret
        let encrypted = self.encrypt_secret(value.expose_secret().as_bytes())?;
        
        // Store in cache
        let mut cache = self.secrets_cache.write().await;
        cache.insert(key.to_string(), encrypted);
        
        // Audit log
        self.audit_logger.log_secret_stored(key, context).await;
        
        Ok(())
    }
    
    // Retrieve and decrypt secret
    pub async fn get_secret(
        &self,
        key: &str,
        context: &SecurityContext,
    ) -> Result<SecretString, SecurityError> {
        let mut cache = self.secrets_cache.write().await;
        
        if let Some(encrypted_secret) = cache.get_mut(key) {
            // Check access permissions
            self.access_controller.check_read_permission(context, &encrypted_secret.metadata.access_policy)?;
            
            // Check expiration
            if let Some(expires_at) = encrypted_secret.expires_at {
                if Utc::now() > expires_at {
                    cache.remove(key);
                    return Err(SecurityError::SecretExpired);
                }
            }
            
            // Check access count limits
            if let Some(max_count) = encrypted_secret.metadata.access_policy.max_access_count {
                if encrypted_secret.access_count >= max_count {
                    return Err(SecurityError::AccessLimitExceeded);
                }
            }
            
            // Decrypt secret
            let decrypted = self.decrypt_secret(&encrypted_secret.ciphertext, &encrypted_secret.nonce)?;
            let secret_string = SecretString::new(String::from_utf8(decrypted)
                .map_err(|_| SecurityError::InvalidSecretFormat)?);
            
            // Update access count
            encrypted_secret.access_count += 1;
            
            // Audit log
            self.audit_logger.log_secret_accessed(key, context).await;
            
            Ok(secret_string)
        } else {
            Err(SecurityError::SecretNotFound)
        }
    }
    
    // Encrypt secret using AES-GCM
    fn encrypt_secret(&self, plaintext: &[u8]) -> Result<EncryptedSecret, SecurityError> {
        let algorithm = &aead::AES_256_GCM;
        let key = aead::LessSafeKey::new(
            aead::UnboundKey::new(algorithm, self.encryption_key.expose_secret())
                .map_err(|_| SecurityError::EncryptionFailed)?
        );
        
        // Generate random nonce
        let mut nonce = [0u8; 12];
        let rng = rand::SystemRandom::new();
        rng.fill(&mut nonce).map_err(|_| SecurityError::RandomGenerationFailed)?;
        
        // Encrypt
        let mut ciphertext = plaintext.to_vec();
        key.seal_in_place_append_tag(
            aead::Nonce::assume_unique_for_key(nonce),
            aead::Aad::empty(),
            &mut ciphertext,
        ).map_err(|_| SecurityError::EncryptionFailed)?;
        
        Ok(EncryptedSecret {
            ciphertext,
            nonce,
            created_at: Utc::now(),
            expires_at: None,
            access_count: 0,
            metadata: SecretMetadata {
                classification: SecurityClassification::Confidential,
                owner: "system".to_string(),
                tags: Vec::new(),
                access_policy: AccessPolicy {
                    allowed_roles: vec!["admin".to_string()],
                    ip_restrictions: Vec::new(),
                    time_restrictions: None,
                    max_access_count: None,
                },
            },
        })
    }
    
    // Decrypt secret using AES-GCM
    fn decrypt_secret(&self, ciphertext: &[u8], nonce: &[u8; 12]) -> Result<Vec<u8>, SecurityError> {
        let algorithm = &aead::AES_256_GCM;
        let key = aead::LessSafeKey::new(
            aead::UnboundKey::new(algorithm, self.encryption_key.expose_secret())
                .map_err(|_| SecurityError::DecryptionFailed)?
        );
        
        let mut ciphertext = ciphertext.to_vec();
        let plaintext = key.open_in_place(
            aead::Nonce::assume_unique_for_key(*nonce),
            aead::Aad::empty(),
            &mut ciphertext,
        ).map_err(|_| SecurityError::DecryptionFailed)?;
        
        Ok(plaintext.to_vec())
    }
    
    // Rotate encryption keys
    pub async fn rotate_keys(&self, new_master_key: &[u8]) -> Result<(), SecurityError> {
        // This would involve re-encrypting all secrets with the new key
        // Implementation would be more complex in practice
        self.audit_logger.log_key_rotation().await;
        Ok(())
    }
}

// Access control system
#[derive(Debug)]
pub struct AccessController {
    rbac_engine: RbacEngine,
    abac_engine: Option<AbacEngine>,
}

#[derive(Debug)]
struct RbacEngine {
    roles: HashMap<String, Role>,
    user_roles: HashMap<String, Vec<String>>,
}

#[derive(Debug, Clone)]
struct Role {
    name: String,
    permissions: Vec<Permission>,
    config_sections: Vec<String>,
    sensitive_data_access: bool,
}

#[derive(Debug, Clone)]
enum Permission {
    Read,
    Write,
    Delete,
    ManageUsers,
    ManageSecrets,
    Admin,
}

impl AccessController {
    pub fn new() -> Self {
        AccessController {
            rbac_engine: RbacEngine::new(),
            abac_engine: None,
        }
    }
    
    pub fn check_read_permission(
        &self,
        context: &SecurityContext,
        policy: &AccessPolicy,
    ) -> Result<(), SecurityError> {
        // Check role-based permissions
        if !self.rbac_engine.has_permission(&context.user_id, Permission::Read) {
            return Err(SecurityError::InsufficientPermissions);
        }
        
        // Check policy-specific restrictions
        if !policy.allowed_roles.is_empty() {
            let user_roles = self.rbac_engine.get_user_roles(&context.user_id);
            if !policy.allowed_roles.iter().any(|role| user_roles.contains(role)) {
                return Err(SecurityError::RoleNotAllowed);
            }
        }
        
        // Check IP restrictions
        if !policy.ip_restrictions.is_empty() {
            if !self.check_ip_allowed(&context.client_ip, &policy.ip_restrictions) {
                return Err(SecurityError::IpNotAllowed);
            }
        }
        
        // Check time restrictions
        if let Some(time_restriction) = &policy.time_restrictions {
            if !self.check_time_allowed(time_restriction) {
                return Err(SecurityError::TimeRestrictionViolation);
            }
        }
        
        Ok(())
    }
    
    pub fn check_write_permission(
        &self,
        context: &SecurityContext,
        policy: &AccessPolicy,
    ) -> Result<(), SecurityError> {
        // Check base read permission first
        self.check_read_permission(context, policy)?;
        
        // Check write-specific permissions
        if !self.rbac_engine.has_permission(&context.user_id, Permission::Write) {
            return Err(SecurityError::InsufficientPermissions);
        }
        
        Ok(())
    }
    
    fn check_ip_allowed(&self, client_ip: &str, allowed_ips: &[String]) -> bool {
        // Simple IP checking - in practice would use proper CIDR matching
        allowed_ips.iter().any(|ip| ip.contains(client_ip))
    }
    
    fn check_time_allowed(&self, restriction: &TimeRestriction) -> bool {
        let now = chrono::Local::now();
        let current_time = now.time();
        let current_day = now.weekday();
        
        // Check day of week
        if !restriction.allowed_days.contains(&current_day) {
            return false;
        }
        
        // Check time range
        current_time >= restriction.start_time && current_time <= restriction.end_time
    }
}

impl RbacEngine {
    fn new() -> Self {
        let mut roles = HashMap::new();
        
        // Define default roles
        roles.insert("admin".to_string(), Role {
            name: "admin".to_string(),
            permissions: vec![
                Permission::Read,
                Permission::Write,
                Permission::Delete,
                Permission::ManageUsers,
                Permission::ManageSecrets,
                Permission::Admin,
            ],
            config_sections: vec!["*".to_string()],
            sensitive_data_access: true,
        });
        
        roles.insert("operator".to_string(), Role {
            name: "operator".to_string(),
            permissions: vec![Permission::Read, Permission::Write],
            config_sections: vec![
                "application".to_string(),
                "performance".to_string(),
                "monitoring".to_string(),
            ],
            sensitive_data_access: false,
        });
        
        roles.insert("reader".to_string(), Role {
            name: "reader".to_string(),
            permissions: vec![Permission::Read],
            config_sections: vec![
                "application.public".to_string(),
                "monitoring.metrics".to_string(),
            ],
            sensitive_data_access: false,
        });
        
        RbacEngine {
            roles,
            user_roles: HashMap::new(),
        }
    }
    
    fn has_permission(&self, user_id: &str, permission: Permission) -> bool {
        if let Some(user_roles) = self.user_roles.get(user_id) {
            user_roles.iter().any(|role_name| {
                if let Some(role) = self.roles.get(role_name) {
                    role.permissions.contains(&permission)
                } else {
                    false
                }
            })
        } else {
            false
        }
    }
    
    fn get_user_roles(&self, user_id: &str) -> Vec<String> {
        self.user_roles.get(user_id).cloned().unwrap_or_default()
    }
}

// Input validation and sanitization
#[derive(Debug)]
pub struct InputValidator {
    config: ValidationConfig,
    blocked_patterns: Vec<regex::Regex>,
}

#[derive(Debug, Clone)]
struct ValidationConfig {
    strict_mode: bool,
    max_nesting_depth: usize,
    max_array_length: usize,
    max_string_length: usize,
    reject_unknown_fields: bool,
}

impl InputValidator {
    pub fn new(config: ValidationConfig) -> Result<Self, SecurityError> {
        // Compile security patterns
        let pattern_strings = vec![
            r"(?i)(\b(union|select|insert|update|delete|drop|exec|script)\b)",
            r"(\.\./|\.\.\\\)",
            r"(\$\(|\`)",
            r"(<script|javascript:|vbscript:)",
        ];
        
        let blocked_patterns: Result<Vec<_>, _> = pattern_strings
            .iter()
            .map(|pattern| regex::Regex::new(pattern))
            .collect();
        
        let blocked_patterns = blocked_patterns
            .map_err(|_| SecurityError::PatternCompilationFailed)?;
        
        Ok(InputValidator {
            config,
            blocked_patterns,
        })
    }
    
    pub fn validate_config_input(&self, input: &serde_json::Value) -> Result<(), SecurityError> {
        // Validate structure
        self.validate_structure(input, 0)?;
        
        // Validate content
        self.validate_content(input)?;
        
        Ok(())
    }
    
    fn validate_structure(&self, value: &serde_json::Value, depth: usize) -> Result<(), SecurityError> {
        if depth > self.config.max_nesting_depth {
            return Err(SecurityError::MaxNestingDepthExceeded);
        }
        
        match value {
            serde_json::Value::Object(map) => {
                for (_, v) in map {
                    self.validate_structure(v, depth + 1)?;
                }
            }
            serde_json::Value::Array(arr) => {
                if arr.len() > self.config.max_array_length {
                    return Err(SecurityError::MaxArrayLengthExceeded);
                }
                
                for item in arr {
                    self.validate_structure(item, depth + 1)?;
                }
            }
            serde_json::Value::String(s) => {
                if s.len() > self.config.max_string_length {
                    return Err(SecurityError::MaxStringLengthExceeded);
                }
            }
            _ => {}
        }
        
        Ok(())
    }
    
    fn validate_content(&self, value: &serde_json::Value) -> Result<(), SecurityError> {
        match value {
            serde_json::Value::String(s) => {
                // Check for malicious patterns
                for pattern in &self.blocked_patterns {
                    if pattern.is_match(s) {
                        return Err(SecurityError::MaliciousPatternDetected);
                    }
                }
                
                // Check for null bytes
                if s.contains('\0') {
                    return Err(SecurityError::NullByteDetected);
                }
            }
            serde_json::Value::Object(map) => {
                for (key, value) in map {
                    // Validate key
                    for pattern in &self.blocked_patterns {
                        if pattern.is_match(key) {
                            return Err(SecurityError::MaliciousPatternDetected);
                        }
                    }
                    
                    // Recursively validate value
                    self.validate_content(value)?;
                }
            }
            serde_json::Value::Array(arr) => {
                for item in arr {
                    self.validate_content(item)?;
                }
            }
            _ => {}
        }
        
        Ok(())
    }
    
    pub fn sanitize_string(&self, input: &str) -> String {
        let mut output = input.to_string();
        
        // Remove null bytes
        output = output.replace('\0', "");
        
        // Normalize unicode
        output = output.nfc().collect();
        
        // Trim whitespace
        output = output.trim().to_string();
        
        // HTML escape if needed
        output = html_escape::encode_text(&output).to_string();
        
        output
    }
}

// Audit logging system
#[derive(Debug)]
pub struct AuditLogger {
    log_writer: Arc<tokio::sync::Mutex<Box<dyn AuditWriter + Send>>>,
}

#[async_trait::async_trait]
trait AuditWriter {
    async fn write_audit_log(&mut self, entry: &AuditLogEntry) -> Result<(), std::io::Error>;
}

#[derive(Debug, Serialize)]
struct AuditLogEntry {
    timestamp: DateTime<Utc>,
    event_type: AuditEventType,
    user_id: String,
    client_ip: String,
    resource: String,
    action: String,
    result: AuditResult,
    details: serde_json::Value,
    risk_score: u8,
}

#[derive(Debug, Serialize)]
enum AuditEventType {
    ConfigAccess,
    ConfigModification,
    SecretAccess,
    Authentication,
    AuthorizationFailure,
    SystemError,
    SecurityViolation,
}

#[derive(Debug, Serialize)]
enum AuditResult {
    Success,
    Failure,
    Error,
    Blocked,
}

impl AuditLogger {
    pub fn new() -> Self {
        // In practice, this would set up multiple writers (file, syslog, remote, etc.)
        let writer = Box::new(FileAuditWriter::new("/var/log/tusklang/audit.log"));
        
        AuditLogger {
            log_writer: Arc::new(tokio::sync::Mutex::new(writer)),
        }
    }
    
    pub async fn log_secret_stored(&self, key: &str, context: &SecurityContext) {
        let entry = AuditLogEntry {
            timestamp: Utc::now(),
            event_type: AuditEventType::SecretAccess,
            user_id: context.user_id.clone(),
            client_ip: context.client_ip.clone(),
            resource: key.to_string(),
            action: "store".to_string(),
            result: AuditResult::Success,
            details: serde_json::json!({}),
            risk_score: 3,
        };
        
        self.write_log_entry(entry).await;
    }
    
    pub async fn log_secret_accessed(&self, key: &str, context: &SecurityContext) {
        let entry = AuditLogEntry {
            timestamp: Utc::now(),
            event_type: AuditEventType::SecretAccess,
            user_id: context.user_id.clone(),
            client_ip: context.client_ip.clone(),
            resource: key.to_string(),
            action: "access".to_string(),
            result: AuditResult::Success,
            details: serde_json::json!({}),
            risk_score: 2,
        };
        
        self.write_log_entry(entry).await;
    }
    
    pub async fn log_key_rotation(&self) {
        let entry = AuditLogEntry {
            timestamp: Utc::now(),
            event_type: AuditEventType::SystemError,
            user_id: "system".to_string(),
            client_ip: "localhost".to_string(),
            resource: "encryption_keys".to_string(),
            action: "rotate".to_string(),
            result: AuditResult::Success,
            details: serde_json::json!({}),
            risk_score: 8,
        };
        
        self.write_log_entry(entry).await;
    }
    
    async fn write_log_entry(&self, entry: AuditLogEntry) {
        let mut writer = self.log_writer.lock().await;
        if let Err(e) = writer.write_audit_log(&entry).await {
            eprintln!("Failed to write audit log: {}", e);
        }
    }
}

struct FileAuditWriter {
    file_path: String,
}

impl FileAuditWriter {
    fn new(file_path: &str) -> Self {
        FileAuditWriter {
            file_path: file_path.to_string(),
        }
    }
}

#[async_trait::async_trait]
impl AuditWriter for FileAuditWriter {
    async fn write_audit_log(&mut self, entry: &AuditLogEntry) -> Result<(), std::io::Error> {
        use tokio::io::AsyncWriteExt;
        
        let log_line = serde_json::to_string(entry)?;
        let mut file = tokio::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.file_path)
            .await?;
        
        file.write_all(log_line.as_bytes()).await?;
        file.write_all(b"\n").await?;
        file.flush().await?;
        
        Ok(())
    }
}

// Security context and error types
#[derive(Debug, Clone)]
pub struct SecurityContext {
    pub user_id: String,
    pub client_ip: String,
    pub user_agent: String,
    pub timestamp: DateTime<Utc>,
    pub session_id: String,
    pub authentication_method: String,
}

#[derive(Debug, thiserror::Error)]
pub enum SecurityError {
    #[error("Key derivation failed")]
    KeyDerivationFailed,
    #[error("Encryption failed")]
    EncryptionFailed,
    #[error("Decryption failed")]
    DecryptionFailed,
    #[error("Random generation failed")]
    RandomGenerationFailed,
    #[error("Secret not found")]
    SecretNotFound,
    #[error("Secret expired")]
    SecretExpired,
    #[error("Access limit exceeded")]
    AccessLimitExceeded,
    #[error("Invalid secret format")]
    InvalidSecretFormat,
    #[error("Insufficient permissions")]
    InsufficientPermissions,
    #[error("Role not allowed")]
    RoleNotAllowed,
    #[error("IP not allowed")]
    IpNotAllowed,
    #[error("Time restriction violation")]
    TimeRestrictionViolation,
    #[error("Pattern compilation failed")]
    PatternCompilationFailed,
    #[error("Max nesting depth exceeded")]
    MaxNestingDepthExceeded,
    #[error("Max array length exceeded")]
    MaxArrayLengthExceeded,
    #[error("Max string length exceeded")]
    MaxStringLengthExceeded,
    #[error("Malicious pattern detected")]
    MaliciousPatternDetected,
    #[error("Null byte detected")]
    NullByteDetected,
}

// JWT authentication support
#[derive(Debug)]
pub struct JwtAuthenticator {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    validation: Validation,
}

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: usize,
    iat: usize,
    roles: Vec<String>,
    permissions: Vec<String>,
}

impl JwtAuthenticator {
    pub fn new(secret: &[u8]) -> Self {
        let mut validation = Validation::new(Algorithm::HS256);
        validation.set_audience(&["tusklang"]);
        validation.set_issuer(&["tusklang-auth"]);
        
        JwtAuthenticator {
            encoding_key: EncodingKey::from_secret(secret),
            decoding_key: DecodingKey::from_secret(secret),
            validation,
        }
    }
    
    pub fn create_token(&self, user_id: &str, roles: Vec<String>) -> Result<String, SecurityError> {
        let now = chrono::Utc::now().timestamp() as usize;
        let exp = now + 3600; // 1 hour expiration
        
        let claims = Claims {
            sub: user_id.to_string(),
            exp,
            iat: now,
            roles,
            permissions: Vec::new(), // Would be populated based on roles
        };
        
        encode(&Header::default(), &claims, &self.encoding_key)
            .map_err(|_| SecurityError::EncryptionFailed)
    }
    
    pub fn verify_token(&self, token: &str) -> Result<Claims, SecurityError> {
        decode::<Claims>(token, &self.decoding_key, &self.validation)
            .map(|data| data.claims)
            .map_err(|_| SecurityError::DecryptionFailed)
    }
}
</pre>

<h3>Vulnerability Management and Compliance</h3>
<pre>
# Additional security monitoring and compliance
security_monitoring {
    # Real-time threat detection
    threat_detection: {
        enabled: env_bool("THREAT_DETECTION", true)
        
        # Behavioral analysis
        behavioral_analysis: {
            baseline_learning_period: 7  # days
            anomaly_threshold: 2.0  # standard deviations
            
            monitored_metrics: [
                "config_access_frequency",
                "secret_access_patterns",
                "failed_authentication_rate",
                "unusual_ip_addresses",
                "off_hours_access"
            ]
        }
        
        # Rule-based detection
        rules: [
            {
                name: "brute_force_detection"
                condition: "failed_auth_attempts > 10 in 5m"
                severity: "high"
                action: "block_ip"
            },
            {
                name: "privilege_escalation"
                condition: "user_role_change and high_privilege_access in 1h"
                severity: "critical"
                action: "alert_security_team"
            },
            {
                name: "data_exfiltration"
                condition: "secret_access_count > 100 in 1h"
                severity: "high"
                action: "rate_limit_user"
            }
        ]
    }
    
    # Incident response
    incident_response: {
        automated_response: {
            enabled: true
            
            actions: {
                block_ip: {
                    duration: "1h"
                    whitelist_override: true
                }
                
                disable_user: {
                    duration: "24h"
                    require_admin_approval: true
                }
                
                rotate_secrets: {
                    affected_secrets_only: true
                    notify_stakeholders: true
                }
            }
        }
        
        escalation: {
            levels: [
                {
                    level: 1
                    conditions: ["low severity alerts"]
                    notify: ["on_call_engineer"]
                    response_time: "1h"
                },
                {
                    level: 2
                    conditions: ["medium severity alerts", "multiple level 1 alerts"]
                    notify: ["security_team", "team_lead"]
                    response_time: "30m"
                },
                {
                    level: 3
                    conditions: ["high severity alerts", "potential breach"]
                    notify: ["security_team", "ciso", "engineering_manager"]
                    response_time: "15m"
                }
            ]
        }
    }
}

// Vulnerability scanner implementation
use std::process::Command;
use tokio::process::Command as AsyncCommand;

#[derive(Debug)]
pub struct VulnerabilityScanner {
    config: ScannerConfig,
    scanners: Vec<Box<dyn Scanner>>,
}

#[derive(Debug, Clone)]
struct ScannerConfig {
    enabled: bool,
    schedule: String,
    fail_on_cvss: f32,
    exclude_packages: Vec<String>,
}

#[async_trait::async_trait]
trait Scanner: Send + Sync {
    fn name(&self) -> &str;
    async fn scan(&self) -> Result<ScanResult, ScanError>;
}

#[derive(Debug)]
struct ScanResult {
    scanner_name: String,
    vulnerabilities: Vec<Vulnerability>,
    scan_duration: std::time::Duration,
    timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone)]
struct Vulnerability {
    id: String,
    title: String,
    description: String,
    severity: Severity,
    cvss_score: Option<f32>,
    affected_packages: Vec<String>,
    fixed_in: Option<String>,
    references: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
enum Severity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl VulnerabilityScanner {
    pub fn new(config: ScannerConfig) -> Self {
        let mut scanners: Vec<Box<dyn Scanner>> = Vec::new();
        
        // Add available scanners
        scanners.push(Box::new(CargoAuditScanner::new()));
        scanners.push(Box::new(DependencyCheckScanner::new()));
        
        VulnerabilityScanner {
            config,
            scanners,
        }
    }
    
    pub async fn run_full_scan(&self) -> Result<Vec<ScanResult>, ScanError> {
        let mut results = Vec::new();
        
        for scanner in &self.scanners {
            match scanner.scan().await {
                Ok(result) => {
                    // Filter by CVSS score
                    let filtered_vulns: Vec<_> = result.vulnerabilities
                        .into_iter()
                        .filter(|v| {
                            v.cvss_score.unwrap_or(0.0) >= self.config.fail_on_cvss
                        })
                        .collect();
                    
                    let filtered_result = ScanResult {
                        scanner_name: result.scanner_name,
                        vulnerabilities: filtered_vulns,
                        scan_duration: result.scan_duration,
                        timestamp: result.timestamp,
                    };
                    
                    results.push(filtered_result);
                }
                Err(e) => {
                    eprintln!("Scanner {} failed: {}", scanner.name(), e);
                }
            }
        }
        
        Ok(results)
    }
    
    pub fn generate_security_report(&self, results: &[ScanResult]) -> SecurityReport {
        let mut total_vulnerabilities = 0;
        let mut critical_count = 0;
        let mut high_count = 0;
        let mut medium_count = 0;
        let mut low_count = 0;
        
        for result in results {
            total_vulnerabilities += result.vulnerabilities.len();
            
            for vuln in &result.vulnerabilities {
                match vuln.severity {
                    Severity::Critical => critical_count += 1,
                    Severity::High => high_count += 1,
                    Severity::Medium => medium_count += 1,
                    Severity::Low => low_count += 1,
                    Severity::Info => {}
                }
            }
        }
        
        let security_score = self.calculate_security_score(
            critical_count,
            high_count,
            medium_count,
            low_count,
        );
        
        SecurityReport {
            scan_timestamp: Utc::now(),
            total_vulnerabilities,
            critical_count,
            high_count,
            medium_count,
            low_count,
            security_score,
            recommendation: self.generate_recommendations(critical_count, high_count),
            compliance_status: self.check_compliance_status(critical_count, high_count),
        }
    }
    
    fn calculate_security_score(&self, critical: usize, high: usize, medium: usize, low: usize) -> f32 {
        // Simple scoring algorithm - in practice would be more sophisticated
        let base_score = 100.0;
        let penalties = (critical as f32 * 10.0) + 
                       (high as f32 * 5.0) + 
                       (medium as f32 * 2.0) + 
                       (low as f32 * 0.5);
        
        (base_score - penalties).max(0.0)
    }
    
    fn generate_recommendations(&self, critical: usize, high: usize) -> Vec<String> {
        let mut recommendations = Vec::new();
        
        if critical > 0 {
            recommendations.push("URGENT: Address critical vulnerabilities immediately".to_string());
            recommendations.push("Consider emergency patching or temporary mitigations".to_string());
        }
        
        if high > 0 {
            recommendations.push("Update dependencies with high-severity vulnerabilities".to_string());
            recommendations.push("Review security configurations".to_string());
        }
        
        if critical == 0 && high == 0 {
            recommendations.push("Maintain current security practices".to_string());
            recommendations.push("Continue regular vulnerability scanning".to_string());
        }
        
        recommendations
    }
    
    fn check_compliance_status(&self, critical: usize, high: usize) -> ComplianceStatus {
        if critical > 0 {
            ComplianceStatus::NonCompliant
        } else if high > 5 {
            ComplianceStatus::AtRisk
        } else {
            ComplianceStatus::Compliant
        }
    }
}

// Cargo audit scanner implementation
#[derive(Debug)]
struct CargoAuditScanner;

impl CargoAuditScanner {
    fn new() -> Self {
        CargoAuditScanner
    }
}

#[async_trait::async_trait]
impl Scanner for CargoAuditScanner {
    fn name(&self) -> &str {
        "cargo-audit"
    }
    
    async fn scan(&self) -> Result<ScanResult, ScanError> {
        let start_time = std::time::Instant::now();
        
        // Run cargo audit
        let output = AsyncCommand::new("cargo")
            .args(&["audit", "--json"])
            .output()
            .await
            .map_err(|e| ScanError::ExecutionFailed(e.to_string()))?;
        
        let scan_duration = start_time.elapsed();
        
        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(ScanError::ScanFailed(stderr.to_string()));
        }
        
        // Parse JSON output
        let stdout = String::from_utf8_lossy(&output.stdout);
        let audit_data: serde_json::Value = serde_json::from_str(&stdout)
            .map_err(|e| ScanError::ParseFailed(e.to_string()))?;
        
        let vulnerabilities = self.parse_audit_results(&audit_data)?;
        
        Ok(ScanResult {
            scanner_name: "cargo-audit".to_string(),
            vulnerabilities,
            scan_duration,
            timestamp: Utc::now(),
        })
    }
}

impl CargoAuditScanner {
    fn parse_audit_results(&self, data: &serde_json::Value) -> Result<Vec<Vulnerability>, ScanError> {
        let mut vulnerabilities = Vec::new();
        
        if let Some(advisories) = data.get("vulnerabilities").and_then(|v| v.as_array()) {
            for advisory in advisories {
                if let Some(vuln) = self.parse_advisory(advisory) {
                    vulnerabilities.push(vuln);
                }
            }
        }
        
        Ok(vulnerabilities)
    }
    
    fn parse_advisory(&self, advisory: &serde_json::Value) -> Option<Vulnerability> {
        let id = advisory.get("advisory")?.get("id")?.as_str()?.to_string();
        let title = advisory.get("advisory")?.get("title")?.as_str()?.to_string();
        let description = advisory.get("advisory")?.get("description")?.as_str()?.to_string();
        
        // Parse severity
        let severity_str = advisory.get("advisory")?.get("severity")?.as_str()?;
        let severity = match severity_str.to_lowercase().as_str() {
            "critical" => Severity::Critical,
            "high" => Severity::High,
            "medium" => Severity::Medium,
            "low" => Severity::Low,
            _ => Severity::Info,
        };
        
        // Parse affected packages
        let affected_packages = if let Some(packages) = advisory.get("packages") {
            packages.as_array()?
                .iter()
                .filter_map(|p| p.get("name")?.as_str())
                .map(|s| s.to_string())
                .collect()
        } else {
            Vec::new()
        };
        
        Some(Vulnerability {
            id,
            title,
            description,
            severity,
            cvss_score: None, // Cargo audit doesn't provide CVSS scores
            affected_packages,
            fixed_in: None,
            references: Vec::new(),
        })
    }
}

// Security report structures
#[derive(Debug, Serialize)]
struct SecurityReport {
    scan_timestamp: DateTime<Utc>,
    total_vulnerabilities: usize,
    critical_count: usize,
    high_count: usize,
    medium_count: usize,
    low_count: usize,
    security_score: f32,
    recommendation: Vec<String>,
    compliance_status: ComplianceStatus,
}

#[derive(Debug, Serialize)]
enum ComplianceStatus {
    Compliant,
    AtRisk,
    NonCompliant,
}

#[derive(Debug, thiserror::Error)]
enum ScanError {
    #[error("Execution failed: {0}")]
    ExecutionFailed(String),
    #[error("Scan failed: {0}")]
    ScanFailed(String),
    #[error("Parse failed: {0}")]
    ParseFailed(String),
}

// Dependency check scanner (placeholder)
#[derive(Debug)]
struct DependencyCheckScanner;

impl DependencyCheckScanner {
    fn new() -> Self {
        DependencyCheckScanner
    }
}

#[async_trait::async_trait]
impl Scanner for DependencyCheckScanner {
    fn name(&self) -> &str {
        "dependency-check"
    }
    
    async fn scan(&self) -> Result<ScanResult, ScanError> {
        // Placeholder implementation
        Ok(ScanResult {
            scanner_name: "dependency-check".to_string(),
            vulnerabilities: Vec::new(),
            scan_duration: std::time::Duration::from_secs(0),
            timestamp: Utc::now(),
        })
    }
}
</pre>

<p>TuskLang's security implementation in Rust provides comprehensive protection through encrypted secrets management, robust access controls, input validation, audit logging, vulnerability scanning, and compliance monitoring, leveraging Rust's memory safety and type system for maximum security assurance.</p>