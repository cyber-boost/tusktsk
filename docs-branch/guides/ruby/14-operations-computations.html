<h1>Operations and Computations in TuskLang for Ruby</h1>

<h2>Mathematical Operations and Data Processing</h2>
<p>TuskLang provides comprehensive computational capabilities for Ruby applications with mathematical operations, data transformations, and complex calculations.</p>

<h3>operations.tsk</h3>
<pre>
# Basic Mathematical Operations
basic_math: {
    addition: 10 + 5
    subtraction: 20 - 8
    multiplication: 6 * 7
    division: 100 / 4
    modulo: 17 % 5
    exponentiation: 2 ** 8
}

# Advanced Mathematical Functions
advanced_math: {
    square_root: sqrt(64)
    absolute_value: abs(-42)
    ceiling: ceil(3.14159)
    floor: floor(9.99)
    round: round(3.14159, 2)
    logarithm: log(100)
    natural_log: ln(2.718)
    sine: sin(90)
    cosine: cos(0)
    tangent: tan(45)
}

# Statistical Operations
statistics: {
    numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    sum: sum(numbers)
    mean: avg(numbers)
    median: median(numbers)
    mode: mode([1, 2, 2, 3, 3, 3, 4])
    standard_deviation: stddev(numbers)
    variance: variance(numbers)
    min_value: min(numbers)
    max_value: max(numbers)
    range: max(numbers) - min(numbers)
}

# Array Operations
array_ops: {
    original: [1, 2, 3, 4, 5]
    doubled: map(original, x => x * 2)
    filtered: filter(original, x => x > 3)
    reduced: reduce(original, 0, (acc, x) => acc + x)
    sorted: sort([5, 2, 8, 1, 9])
    reversed: reverse([1, 2, 3, 4, 5])
    unique: unique([1, 2, 2, 3, 3, 4])
    flattened: flatten([[1, 2], [3, 4], [5]])
    grouped: group_by(["apple", "banana", "apricot"], x => x[0])
}

# String Operations
string_ops: {
    text: "Hello, TuskLang World!"
    length: length(text)
    uppercase: upper(text)
    lowercase: lower(text)
    reversed: reverse(text)
    words: split(text, " ")
    joined: join(["Hello", "World"], ", ")
    substring: substr(text, 0, 5)
    replaced: replace(text, "World", "Ruby")
    trimmed: trim("  whitespace  ")
    padded: pad("test", 10, "*")
}

# Date and Time Operations
time_ops: {
    current_time: time()
    current_date: date("Y-m-d")
    timestamp: time()
    
    # Date arithmetic
    one_day_ago: time() - 86400
    one_week_from_now: time() + (7 * 86400)
    
    # Date formatting
    formatted_date: date("Y-m-d H:i:s", time())
    iso_date: date("c", time())
    
    # Time zone operations
    utc_time: utc_time()
    local_time: local_time()
    timezone_offset: timezone_offset()
}

# Conditional Operations
conditional_ops: {
    max_workers: env("MAX_WORKERS", 4)
    worker_calculation: if(max_workers > 2, max_workers * 2, 4)
    
    # Ternary operations
    cache_ttl: env("RAILS_ENV") == "production" ? 3600 : 60
    log_level: env("DEBUG") == "true" ? "debug" : "info"
    
    # Null coalescing
    database_pool: env("DB_POOL") || 5
    timeout_value: env("TIMEOUT") || 30
}

# Financial Calculations
financial: {
    # Interest calculations
    principal: 10000
    rate: 0.05
    time: 2
    simple_interest: principal * rate * time
    compound_interest: principal * ((1 + rate) ** time) - principal
    
    # Currency operations
    usd_amount: 100.50
    eur_rate: 0.85
    eur_amount: usd_amount * eur_rate
    
    # Percentage calculations
    total_sales: 50000
    commission_rate: 0.15
    commission: total_sales * commission_rate
    
    # Tax calculations
    gross_amount: 1000
    tax_rate: 0.08
    net_amount: gross_amount * (1 + tax_rate)
}

# Performance Metrics
performance: {
    # Request processing
    requests_per_second: 1000
    average_response_time: 150  # milliseconds
    throughput: requests_per_second * (1000 / average_response_time)
    
    # Memory calculations
    total_memory_mb: 8192
    used_memory_mb: 6144
    memory_usage_percent: (used_memory_mb / total_memory_mb) * 100
    available_memory_mb: total_memory_mb - used_memory_mb
    
    # CPU calculations
    cpu_cores: 8
    cpu_usage_percent: 75
    available_cpu_percent: 100 - cpu_usage_percent
    load_per_core: cpu_usage_percent / cpu_cores
}

# Data Transformation
transformations: {
    # JSON operations
    user_data: {name: "John", age: 30, city: "New York"}
    json_string: json_encode(user_data)
    parsed_data: json_decode('{"status": "success", "count": 42}')
    
    # Base64 encoding
    original_text: "Hello, World!"
    encoded: base64_encode(original_text)
    decoded: base64_decode(encoded)
    
    # URL encoding
    url_params: "name=John Doe&city=New York"
    encoded_url: url_encode(url_params)
    decoded_url: url_decode(encoded_url)
    
    # Hash generation
    password: "secret123"
    md5_hash: md5(password)
    sha256_hash: sha256(password)
    
    # Data validation
    email: "user@example.com"
    is_valid_email: validate_email(email)
    is_valid_url: validate_url("https://example.com")
}

# Algorithm Implementations
algorithms: {
    # Fibonacci sequence
    fibonacci_10: fibonacci(10)
    
    # Prime number checking
    is_prime_17: is_prime(17)
    primes_up_to_50: primes_up_to(50)
    
    # Factorial
    factorial_5: factorial(5)
    
    # GCD and LCM
    gcd_48_18: gcd(48, 18)
    lcm_12_15: lcm(12, 15)
    
    # Sorting algorithms
    unsorted_array: [64, 34, 25, 12, 22, 11, 90]
    bubble_sorted: bubble_sort(unsorted_array)
    quick_sorted: quick_sort(unsorted_array)
    merge_sorted: merge_sort(unsorted_array)
}

# Geospatial Calculations
geospatial: {
    # Coordinate operations
    lat1: 40.7128  # New York
    lon1: -74.0060
    lat2: 34.0522  # Los Angeles
    lon2: -118.2437
    
    # Distance calculation (in miles)
    distance_miles: haversine_distance(lat1, lon1, lat2, lon2, "miles")
    distance_km: haversine_distance(lat1, lon1, lat2, lon2, "km")
    
    # Bounding box calculations
    center_lat: 40.7128
    center_lon: -74.0060
    radius_miles: 10
    bounding_box: calculate_bounding_box(center_lat, center_lon, radius_miles)
}

# Cryptographic Operations
cryptography: {
    # Hash functions
    data: "sensitive_information"
    sha1_hash: sha1(data)
    sha256_hash: sha256(data)
    sha512_hash: sha512(data)
    
    # HMAC
    secret_key: "secret_key_123"
    message: "important_message"
    hmac_signature: hmac_sha256(message, secret_key)
    
    # Random generation
    random_string: random_string(32)
    random_number: random_int(1000, 9999)
    uuid: generate_uuid()
    
    # Password hashing (conceptual - would use proper bcrypt)
    password: "user_password"
    salt: random_string(16)
    hashed_password: hash_password(password, salt)
}

# Network and IP Operations
network: {
    # IP address operations
    ip_address: "192.168.1.100"
    subnet_mask: "255.255.255.0"
    network_address: calculate_network(ip_address, subnet_mask)
    broadcast_address: calculate_broadcast(ip_address, subnet_mask)
    
    # IP validation
    is_valid_ipv4: validate_ipv4("192.168.1.1")
    is_valid_ipv6: validate_ipv6("2001:0db8:85a3::8a2e:0370:7334")
    
    # CIDR operations
    cidr_block: "192.168.1.0/24"
    hosts_in_subnet: calculate_hosts(cidr_block)
    
    # Port calculations
    base_port: 3000
    worker_ports: map(range(1, 4), i => base_port + i)
}

# Business Logic Calculations
business_logic: {
    # E-commerce calculations
    item_price: 29.99
    quantity: 3
    subtotal: item_price * quantity
    
    tax_rate: 0.08
    tax_amount: subtotal * tax_rate
    
    shipping_cost: if(subtotal > 50, 0, 9.99)
    total_cost: subtotal + tax_amount + shipping_cost
    
    # Discount calculations
    discount_percent: 15
    discount_amount: subtotal * (discount_percent / 100)
    discounted_total: total_cost - discount_amount
    
    # Loyalty points
    points_per_dollar: 1.5
    points_earned: subtotal * points_per_dollar
    
    # Subscription calculations
    monthly_rate: 19.99
    annual_rate: monthly_rate * 12 * 0.85  # 15% annual discount
    savings_annual: (monthly_rate * 12) - annual_rate
}

# Machine Learning Calculations
ml_calculations: {
    # Linear regression
    x_values: [1, 2, 3, 4, 5]
    y_values: [2, 4, 6, 8, 10]
    slope: linear_regression_slope(x_values, y_values)
    intercept: linear_regression_intercept(x_values, y_values)
    
    # Prediction
    x_new: 6
    predicted_y: slope * x_new + intercept
    
    # Correlation coefficient
    correlation: correlation_coefficient(x_values, y_values)
    
    # R-squared
    r_squared: r_squared_value(x_values, y_values)
    
    # Mean squared error
    actual: [2, 4, 6, 8, 10]
    predicted: [2.1, 3.9, 6.2, 7.8, 9.9]
    mse: mean_squared_error(actual, predicted)
    rmse: sqrt(mse)
}

# Configuration-driven Calculations
dynamic_calculations: {
    # Environment-based scaling
    base_workers: 2
    environment_multiplier: env("RAILS_ENV") == "production" ? 4 : 1
    calculated_workers: base_workers * environment_multiplier
    
    # Load-based adjustments
    current_load: @metrics("system_load")
    load_factor: if(current_load > 0.8, 1.5, if(current_load < 0.3, 0.7, 1.0))
    adjusted_workers: ceil(calculated_workers * load_factor)
    
    # Time-based calculations
    current_hour: date("G", time())
    peak_hours: [9, 10, 11, 12, 13, 14, 15, 16, 17]
    is_peak_time: includes(peak_hours, current_hour)
    peak_multiplier: is_peak_time ? 1.5 : 1.0
    
    # Final resource allocation
    final_workers: min(max(adjusted_workers * peak_multiplier, 1), 20)
    memory_per_worker: 512  # MB
    total_memory_needed: final_workers * memory_per_worker
}
</pre>

<h3>Ruby Operations Engine</h3>
<pre>
#!/usr/bin/env ruby

require 'digest'
require 'base64'
require 'json'
require 'securerandom'
require 'bigdecimal'
require 'uri'

class TuskLangOperationsEngine
  # Mathematical operations
  def self.add(a, b); a.to_f + b.to_f; end
  def self.subtract(a, b); a.to_f - b.to_f; end
  def self.multiply(a, b); a.to_f * b.to_f; end
  def self.divide(a, b); b.to_f != 0 ? a.to_f / b.to_f : Float::INFINITY; end
  def self.modulo(a, b); a.to_f % b.to_f; end
  def self.power(a, b); a.to_f ** b.to_f; end
  
  def self.sqrt(n); Math.sqrt(n.to_f); end
  def self.abs(n); n.to_f.abs; end
  def self.ceil(n); n.to_f.ceil; end
  def self.floor(n); n.to_f.floor; end
  def self.round(n, precision = 0); n.to_f.round(precision); end
  
  def self.log(n, base = 10); Math.log(n.to_f, base); end
  def self.ln(n); Math.log(n.to_f); end
  def self.sin(degrees); Math.sin(degrees.to_f * Math::PI / 180); end
  def self.cos(degrees); Math.cos(degrees.to_f * Math::PI / 180); end
  def self.tan(degrees); Math.tan(degrees.to_f * Math::PI / 180); end
  
  # Statistical operations
  def self.sum(array)
    Array(array).map(&:to_f).sum
  end
  
  def self.avg(array)
    arr = Array(array).map(&:to_f)
    arr.empty? ? 0 : arr.sum / arr.length
  end
  
  def self.median(array)
    arr = Array(array).map(&:to_f).sort
    len = arr.length
    len.even? ? (arr[len/2 - 1] + arr[len/2]) / 2.0 : arr[len/2]
  end
  
  def self.mode(array)
    arr = Array(array)
    frequency = arr.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }
    frequency.max_by { |k, v| v }&.first
  end
  
  def self.stddev(array)
    arr = Array(array).map(&:to_f)
    mean = avg(arr)
    variance = arr.map { |x| (x - mean) ** 2 }.sum / arr.length
    Math.sqrt(variance)
  end
  
  def self.variance(array)
    arr = Array(array).map(&:to_f)
    mean = avg(arr)
    arr.map { |x| (x - mean) ** 2 }.sum / arr.length
  end
  
  def self.min(array); Array(array).map(&:to_f).min; end
  def self.max(array); Array(array).map(&:to_f).max; end
  
  # Array operations
  def self.map(array, &block)
    Array(array).map(&block)
  end
  
  def self.filter(array, &block)
    Array(array).select(&block)
  end
  
  def self.reduce(array, initial = nil, &block)
    if initial
      Array(array).reduce(initial, &block)
    else
      Array(array).reduce(&block)
    end
  end
  
  def self.sort(array)
    Array(array).sort
  end
  
  def self.reverse(array)
    Array(array).reverse
  end
  
  def self.unique(array)
    Array(array).uniq
  end
  
  def self.flatten(array)
    Array(array).flatten
  end
  
  def self.group_by(array, &block)
    Array(array).group_by(&block)
  end
  
  # String operations
  def self.length(str); str.to_s.length; end
  def self.upper(str); str.to_s.upcase; end
  def self.lower(str); str.to_s.downcase; end
  def self.reverse(str); str.to_s.reverse; end
  
  def self.split(str, delimiter)
    str.to_s.split(delimiter)
  end
  
  def self.join(array, delimiter)
    Array(array).join(delimiter)
  end
  
  def self.substr(str, start, length = nil)
    if length
      str.to_s[start, length]
    else
      str.to_s[start..-1]
    end
  end
  
  def self.replace(str, pattern, replacement)
    str.to_s.gsub(pattern, replacement)
  end
  
  def self.trim(str); str.to_s.strip; end
  
  def self.pad(str, length, char = ' ')
    str.to_s.ljust(length, char)
  end
  
  # Date and time operations
  def self.time(offset = 0)
    (Time.now + offset).to_i
  end
  
  def self.date(format, timestamp = nil)
    time_obj = timestamp ? Time.at(timestamp) : Time.now
    case format
    when 'Y-m-d'
      time_obj.strftime('%Y-%m-%d')
    when 'Y-m-d H:i:s'
      time_obj.strftime('%Y-%m-%d %H:%M:%S')
    when 'c'
      time_obj.iso8601
    when 'G'
      time_obj.hour
    else
      time_obj.strftime(format)
    end
  end
  
  def self.utc_time
    Time.now.utc.to_i
  end
  
  def self.local_time
    Time.now.to_i
  end
  
  def self.timezone_offset
    Time.now.utc_offset / 3600
  end
  
  # Conditional operations
  def self.if(condition, true_value, false_value)
    condition ? true_value : false_value
  end
  
  # Financial calculations
  def self.simple_interest(principal, rate, time)
    principal.to_f * rate.to_f * time.to_f
  end
  
  def self.compound_interest(principal, rate, time, frequency = 1)
    principal.to_f * ((1 + rate.to_f / frequency) ** (frequency * time.to_f)) - principal.to_f
  end
  
  # Data transformation
  def self.json_encode(data)
    JSON.generate(data)
  end
  
  def self.json_decode(json_string)
    JSON.parse(json_string)
  rescue JSON::ParserError
    nil
  end
  
  def self.base64_encode(str)
    Base64.encode64(str.to_s).strip
  end
  
  def self.base64_decode(str)
    Base64.decode64(str.to_s)
  end
  
  def self.url_encode(str)
    URI.encode_www_form_component(str.to_s)
  end
  
  def self.url_decode(str)
    URI.decode_www_form_component(str.to_s)
  end
  
  # Hash functions
  def self.md5(str)
    Digest::MD5.hexdigest(str.to_s)
  end
  
  def self.sha1(str)
    Digest::SHA1.hexdigest(str.to_s)
  end
  
  def self.sha256(str)
    Digest::SHA256.hexdigest(str.to_s)
  end
  
  def self.sha512(str)
    Digest::SHA512.hexdigest(str.to_s)
  end
  
  # Validation functions
  def self.validate_email(email)
    email.to_s.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
  end
  
  def self.validate_url(url)
    uri = URI.parse(url.to_s)
    uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
  rescue URI::InvalidURIError
    false
  end
  
  # Algorithm implementations
  def self.fibonacci(n)
    return n if n <= 1
    fibonacci(n - 1) + fibonacci(n - 2)
  end
  
  def self.is_prime(n)
    return false if n < 2
    (2..Math.sqrt(n)).none? { |i| n % i == 0 }
  end
  
  def self.factorial(n)
    return 1 if n <= 1
    n * factorial(n - 1)
  end
  
  def self.gcd(a, b)
    b == 0 ? a : gcd(b, a % b)
  end
  
  def self.lcm(a, b)
    (a * b) / gcd(a, b)
  end
  
  # Geospatial calculations
  def self.haversine_distance(lat1, lon1, lat2, lon2, unit = 'miles')
    r = unit == 'km' ? 6371 : 3959 # Earth radius
    
    dlat = deg2rad(lat2 - lat1)
    dlon = deg2rad(lon2 - lon1)
    
    a = Math.sin(dlat/2) * Math.sin(dlat/2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dlon/2) * Math.sin(dlon/2)
    
    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
    r * c
  end
  
  def self.deg2rad(deg)
    deg * (Math::PI / 180)
  end
  
  # Random generation
  def self.random_string(length)
    SecureRandom.alphanumeric(length)
  end
  
  def self.random_int(min, max)
    rand(min..max)
  end
  
  def self.generate_uuid
    SecureRandom.uuid
  end
  
  # Utility functions
  def self.range(start, stop, step = 1)
    (start..stop).step(step).to_a
  end
  
  def self.includes(array, value)
    Array(array).include?(value)
  end
  
  # Network operations
  def self.validate_ipv4(ip)
    ip.to_s.match?(/\A(?:[0-9]{1,3}\.){3}[0-9]{1,3}\z/) &&
    ip.split('.').all? { |octet| (0..255).include?(octet.to_i) }
  end
  
  def self.validate_ipv6(ip)
    # Simplified IPv6 validation
    ip.to_s.match?(/\A([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\z/) ||
    ip.to_s.match?(/\A::1\z/) || ip.to_s.match?(/\A::$/)
  end
  
  # Machine learning calculations
  def self.linear_regression_slope(x_values, y_values)
    x_arr = Array(x_values).map(&:to_f)
    y_arr = Array(y_values).map(&:to_f)
    
    x_mean = avg(x_arr)
    y_mean = avg(y_arr)
    
    numerator = x_arr.zip(y_arr).map { |x, y| (x - x_mean) * (y - y_mean) }.sum
    denominator = x_arr.map { |x| (x - x_mean) ** 2 }.sum
    
    denominator != 0 ? numerator / denominator : 0
  end
  
  def self.linear_regression_intercept(x_values, y_values)
    x_arr = Array(x_values).map(&:to_f)
    y_arr = Array(y_values).map(&:to_f)
    
    slope = linear_regression_slope(x_arr, y_arr)
    avg(y_arr) - slope * avg(x_arr)
  end
  
  def self.correlation_coefficient(x_values, y_values)
    x_arr = Array(x_values).map(&:to_f)
    y_arr = Array(y_values).map(&:to_f)
    
    x_mean = avg(x_arr)
    y_mean = avg(y_arr)
    
    numerator = x_arr.zip(y_arr).map { |x, y| (x - x_mean) * (y - y_mean) }.sum
    x_variance = x_arr.map { |x| (x - x_mean) ** 2 }.sum
    y_variance = y_arr.map { |y| (y - y_mean) ** 2 }.sum
    
    denominator = Math.sqrt(x_variance * y_variance)
    denominator != 0 ? numerator / denominator : 0
  end
  
  def self.mean_squared_error(actual, predicted)
    actual_arr = Array(actual).map(&:to_f)
    predicted_arr = Array(predicted).map(&:to_f)
    
    squared_errors = actual_arr.zip(predicted_arr).map { |a, p| (a - p) ** 2 }
    avg(squared_errors)
  end
end

# Expression evaluator for complex operations
class TuskLangExpressionEvaluator
  def self.evaluate(expression, context = {})
    # Simple expression evaluator
    # In a real implementation, this would be more sophisticated
    
    # Replace variables with values
    expression = substitute_variables(expression, context)
    
    # Evaluate mathematical expressions
    evaluate_math_expression(expression)
  end
  
  private
  
  def self.substitute_variables(expression, context)
    expression.gsub(/@(\w+(?:\.\w+)*)/) do |match|
      var_path = $1
      get_nested_value(context, var_path) || match
    end
  end
  
  def self.get_nested_value(hash, path)
    parts = path.split('.')
    current = hash
    
    parts.each do |part|
      if current.is_a?(Hash)
        current = current[part] || current[part.to_sym]
      else
        return nil
      end
    end
    
    current
  end
  
  def self.evaluate_math_expression(expression)
    # This would use a proper expression parser in real implementation
    # For now, using eval (which should be avoided in production)
    begin
      eval(expression)
    rescue
      expression
    end
  end
end

if __FILE__ == $0
  # Example usage
  puts "TuskLang Operations Engine Demo"
  puts "=" * 40
  
  # Mathematical operations
  puts "Addition: #{TuskLangOperationsEngine.add(10, 5)}"
  puts "Square root: #{TuskLangOperationsEngine.sqrt(64)}"
  puts "Average: #{TuskLangOperationsEngine.avg([1, 2, 3, 4, 5])}"
  
  # String operations
  puts "Uppercase: #{TuskLangOperationsEngine.upper('hello world')}"
  puts "Length: #{TuskLangOperationsEngine.length('TuskLang')}"
  
  # Data transformation
  data = {name: 'John', age: 30}
  json = TuskLangOperationsEngine.json_encode(data)
  puts "JSON: #{json}"
  
  # Hash functions
  puts "MD5: #{TuskLangOperationsEngine.md5('test')}"
  
  # Geospatial
  distance = TuskLangOperationsEngine.haversine_distance(40.7128, -74.0060, 34.0522, -118.2437)
  puts "Distance NY to LA: #{distance.round(2)} miles"
end</pre>

<p>TuskLang's operations and computation capabilities provide comprehensive mathematical, statistical, and data processing features for Ruby applications with advanced algorithmic support.</p>