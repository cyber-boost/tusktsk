<h1>Built-in Functions in TuskLang for Ruby</h1>

<h2>Native Function Integration</h2>
<p>TuskLang provides extensive built-in functions that integrate seamlessly with Ruby's standard library and common gems.</p>

<h3>functions.tsk</h3>
<pre>
# Time and Date Functions
current_time: time()
current_timestamp: time()
formatted_date: date("Y-m-d")
formatted_datetime: date("Y-m-d H:i:s")
iso_timestamp: date("c")
unix_timestamp: time()

# String Functions
app_slug: slug("My Ruby Application")
uppercase_name: upper("ruby tusklang")
lowercase_env: lower(env("RAILS_ENV"))
trimmed_value: trim("  whitespace  ")
string_length: length("Hello World")

# Encoding and Hashing
base64_encoded: base64_encode("Hello World")
base64_decoded: base64_decode("SGVsbG8gV29ybGQ=")
md5_hash: md5("password123")
sha256_hash: sha256("secure_data")
sha1_hash: sha1("legacy_data")

# UUID and Random Generation
unique_id: uuid()
random_string: random_string(16)
random_number: random(1, 100)
secure_token: secure_random(32)

# File System Operations
file_exists: file_exists("/etc/hosts")
file_size: file_size("/var/log/app.log")
file_content: file_get_contents("config/settings.yml")
directory_listing: glob("/tmp/*.log")

# JSON Operations
json_encode: json_encode({name: "John", age: 30})
json_decode: json_decode('{"status": "success"}')
json_validate: json_valid('{"key": "value"}')

# Array and Collection Functions
array_length: count([1, 2, 3, 4, 5])
array_join: join(["ruby", "rails", "sinatra"], ", ")
array_unique: unique([1, 2, 2, 3, 3, 4])
array_sort: sort([3, 1, 4, 1, 5, 9])
array_reverse: reverse(["a", "b", "c"])

# Mathematical Functions
math_abs: abs(-42)
math_ceil: ceil(3.14159)
math_floor: floor(3.99999)
math_round: round(3.14159, 2)
math_max: max([10, 5, 15, 3])
math_min: min([10, 5, 15, 3])
math_sum: sum([1, 2, 3, 4, 5])
math_average: avg([10, 20, 30, 40])

# URL and Web Functions
url_encode: urlencode("hello world & special chars")
url_decode: urldecode("hello%20world")
parse_url: parse_url("https://example.com:8080/path?query=value")
build_url: build_url("https", "example.com", 443, "/api/v1")

# Validation Functions
is_email: is_email("user@example.com")
is_url: is_url("https://www.example.com")
is_numeric: is_numeric("12345")
is_alpha: is_alpha("HelloWorld")
is_alphanumeric: is_alphanumeric("Hello123")

# Environment and System
system_hostname: hostname()
system_platform: platform()
ruby_version: ruby_version()
gem_version: gem_version("rails")
process_pid: pid()

# Database Functions (if database configured)
db_query: db_query("SELECT COUNT(*) FROM users")
db_escape: db_escape("user'input")
db_table_exists: db_table_exists("users")

# Cache Functions
cache_get: cache_get("user_count")
cache_set: cache_set("user_count", 1500, 3600)
cache_delete: cache_delete("old_data")
cache_clear: cache_clear("namespace")

# Configuration Helpers
config_get: config("database.host")
config_set: config_set("feature.enabled", true)
config_merge: config_merge({new_feature: true})

# Type Conversion
to_string: string(12345)
to_integer: integer("123")
to_float: float("3.14")
to_boolean: boolean("true")
to_array: array("a,b,c", ",")

# Regular Expressions
regex_match: regex_match("test@example.com", "/\w+@\w+\.\w+/")
regex_replace: regex_replace("Hello World", "/World/", "Ruby")
regex_extract: regex_extract("Version 2.1.0", "/\d+\.\d+\.\d+/")

# Compression
compress_data: gzip_encode("Large data string to compress")
decompress_data: gzip_decode(compressed_string)

# Ruby-specific Functions
ruby_eval: ruby_eval("Time.now.strftime('%Y-%m-%d')")
ruby_require: ruby_require("json")
ruby_defined: ruby_defined?("Rails")
ruby_respond_to: ruby_respond_to("String", "upcase")

# Rails Integration (if Rails is available)
rails_env: rails_env()
rails_root: rails_root()
rails_version: rails_version()
rails_cache: rails_cache_read("key")
rails_logger: rails_log("info", "Message")

# Rack Integration
rack_env: rack_env("REQUEST_METHOD")
rack_session: rack_session("user_id")
rack_params: rack_params("search")

# ActiveRecord Helpers (if ActiveRecord available)
ar_connection: ar_connection_pool_size()
ar_migrate: ar_migration_status()
ar_version: ar_version()

# Sidekiq Integration (if Sidekiq available)
sidekiq_stats: sidekiq_queue_size("default")
sidekiq_enqueue: sidekiq_enqueue("EmailWorker", "send_welcome", user_id)

# Redis Integration (if Redis available)
redis_get: redis_get("session:12345")
redis_set: redis_set("counter", 100, 3600)
redis_exists: redis_exists("key")
redis_del: redis_del("old_key")

# HTTP Client Functions
http_get: http_get("https://api.example.com/users")
http_post: http_post("https://api.example.com/users", {name: "John"})
http_status: http_status("https://www.example.com")

# Image Processing (if ImageMagick/MiniMagick available)
image_resize: image_resize("/uploads/photo.jpg", 800, 600)
image_format: image_format("/uploads/photo.png", "jpg")
image_info: image_info("/uploads/photo.jpg")

# PDF Generation (if Prawn available)
pdf_create: pdf_create("Hello World", "/tmp/document.pdf")
pdf_info: pdf_info("/documents/report.pdf")

# Excel Processing (if Roo available)
excel_read: excel_read("/data/spreadsheet.xlsx", "Sheet1", "A1")
excel_write: excel_write("/tmp/output.xlsx", data_array)

# Email Functions (if Mail gem available)
mail_send: mail_send("test@example.com", "Subject", "Body")
mail_validate: mail_validate_address("user@domain.com")

# Templating (if ERB/Haml available)
template_render: erb_render("template.erb", {name: "John"})
haml_render: haml_render("template.haml", variables)

# Localization (if I18n available)
i18n_translate: t("welcome.message", {name: "John"})
i18n_locale: current_locale()
i18n_available: available_locales()

# Security Functions
sanitize_html: sanitize_html("<script>alert('xss')</script>Hello")
escape_javascript: escape_js("alert('test')")
generate_csrf: csrf_token()
verify_csrf: verify_csrf(token)

# Performance Monitoring
benchmark_start: benchmark_start("operation")
benchmark_end: benchmark_end("operation")
memory_usage: memory_usage()
cpu_usage: cpu_usage()

# Logging Functions
log_debug: log("debug", "Debug message")
log_info: log("info", "Information message")
log_warn: log("warn", "Warning message")
log_error: log("error", "Error message")

# Custom Function Examples
user_avatar_url: avatar_url(user_id, 64)
slugify_title: slugify("My Blog Post Title!")
truncate_text: truncate("Very long text here...", 50)
format_currency: currency(1234.56, "USD")
format_phone: phone_format("+1234567890", "US")
</pre>

<h3>Ruby Function Implementation</h3>
<pre>
#!/usr/bin/env ruby

require 'digest'
require 'securerandom'
require 'base64'
require 'json'
require 'uri'
require 'net/http'
require 'time'
require 'socket'

class TuskLangBuiltinFunctions
  class << self
    # Time and Date Functions
    def time(offset = 0)
      (Time.now + offset).to_i
    end

    def date(format, timestamp = nil)
      time_obj = timestamp ? Time.at(timestamp) : Time.now
      
      case format
      when 'Y-m-d'
        time_obj.strftime('%Y-%m-%d')
      when 'Y-m-d H:i:s'
        time_obj.strftime('%Y-%m-%d %H:%M:%S')
      when 'c'
        time_obj.iso8601
      else
        time_obj.strftime(format)
      end
    end

    # String Functions
    def slug(text)
      text.to_s.downcase.gsub(/[^a-z0-9\-_]/, '-').squeeze('-').chomp('-')
    end

    def upper(text)
      text.to_s.upcase
    end

    def lower(text)
      text.to_s.downcase
    end

    def trim(text)
      text.to_s.strip
    end

    def length(text)
      text.to_s.length
    end

    # Encoding and Hashing
    def base64_encode(text)
      Base64.encode64(text.to_s).strip
    end

    def base64_decode(text)
      Base64.decode64(text.to_s)
    end

    def md5(text)
      Digest::MD5.hexdigest(text.to_s)
    end

    def sha256(text)
      Digest::SHA256.hexdigest(text.to_s)
    end

    def sha1(text)
      Digest::SHA1.hexdigest(text.to_s)
    end

    # UUID and Random
    def uuid
      SecureRandom.uuid
    end

    def random_string(length = 16)
      SecureRandom.alphanumeric(length)
    end

    def random(min = 0, max = 100)
      rand(min..max)
    end

    def secure_random(length = 32)
      SecureRandom.hex(length)
    end

    # File System
    def file_exists(path)
      File.exist?(path)
    end

    def file_size(path)
      File.exist?(path) ? File.size(path) : 0
    end

    def file_get_contents(path)
      File.exist?(path) ? File.read(path) : ""
    end

    def glob(pattern)
      Dir.glob(pattern)
    end

    # JSON Operations
    def json_encode(data)
      JSON.generate(data)
    end

    def json_decode(json_string)
      JSON.parse(json_string)
    rescue JSON::ParserError
      nil
    end

    def json_valid(json_string)
      JSON.parse(json_string)
      true
    rescue JSON::ParserError
      false
    end

    # Array Functions
    def count(array)
      Array(array).length
    end

    def join(array, separator = ',')
      Array(array).join(separator)
    end

    def unique(array)
      Array(array).uniq
    end

    def sort(array)
      Array(array).sort
    end

    def reverse(array)
      Array(array).reverse
    end

    # Mathematical Functions
    def abs(number)
      number.to_f.abs
    end

    def ceil(number)
      number.to_f.ceil
    end

    def floor(number)
      number.to_f.floor
    end

    def round(number, precision = 0)
      number.to_f.round(precision)
    end

    def max(array)
      Array(array).max
    end

    def min(array)
      Array(array).min
    end

    def sum(array)
      Array(array).map(&:to_f).sum
    end

    def avg(array)
      arr = Array(array).map(&:to_f)
      arr.empty? ? 0 : arr.sum / arr.length
    end

    # URL Functions
    def urlencode(text)
      URI.encode_www_form_component(text.to_s)
    end

    def urldecode(text)
      URI.decode_www_form_component(text.to_s)
    end

    def parse_url(url)
      uri = URI.parse(url)
      {
        scheme: uri.scheme,
        host: uri.host,
        port: uri.port,
        path: uri.path,
        query: uri.query,
        fragment: uri.fragment
      }
    rescue URI::InvalidURIError
      {}
    end

    # Validation Functions
    def is_email(email)
      email.to_s.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
    end

    def is_url(url)
      uri = URI.parse(url.to_s)
      uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
    rescue URI::InvalidURIError
      false
    end

    def is_numeric(value)
      value.to_s.match?(/\A\d+(\.\d+)?\z/)
    end

    def is_alpha(value)
      value.to_s.match?(/\A[a-zA-Z]+\z/)
    end

    def is_alphanumeric(value)
      value.to_s.match?(/\A[a-zA-Z0-9]+\z/)
    end

    # System Functions
    def hostname
      Socket.gethostname
    end

    def platform
      RUBY_PLATFORM
    end

    def ruby_version
      RUBY_VERSION
    end

    def pid
      Process.pid
    end

    # Type Conversion
    def string(value)
      value.to_s
    end

    def integer(value)
      value.to_i
    end

    def float(value)
      value.to_f
    end

    def boolean(value)
      case value.to_s.downcase
      when 'true', '1', 'yes', 'on'
        true
      else
        false
      end
    end

    def array(value, separator = ',')
      value.to_s.split(separator).map(&:strip)
    end

    # Regular Expressions
    def regex_match(text, pattern)
      text.to_s.match?(Regexp.new(pattern.gsub(/^\/|\/$/, '')))
    rescue RegexpError
      false
    end

    def regex_replace(text, pattern, replacement)
      regex = Regexp.new(pattern.gsub(/^\/|\/$/, ''))
      text.to_s.gsub(regex, replacement)
    rescue RegexpError
      text.to_s
    end

    def regex_extract(text, pattern)
      regex = Regexp.new(pattern.gsub(/^\/|\/$/, ''))
      match = text.to_s.match(regex)
      match ? match[0] : ""
    rescue RegexpError
      ""
    end

    # HTTP Functions
    def http_get(url, headers = {})
      uri = URI(url)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      
      request = Net::HTTP::Get.new(uri)
      headers.each { |key, value| request[key] = value }
      
      response = http.request(request)
      response.body
    rescue => e
      "Error: #{e.message}"
    end

    def http_post(url, data = {}, headers = {})
      uri = URI(url)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      
      request = Net::HTTP::Post.new(uri)
      request.body = data.is_a?(Hash) ? JSON.generate(data) : data.to_s
      request['Content-Type'] = 'application/json' unless headers['Content-Type']
      
      headers.each { |key, value| request[key] = value }
      
      response = http.request(request)
      response.body
    rescue => e
      "Error: #{e.message}"
    end

    def http_status(url)
      uri = URI(url)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      
      response = http.head(uri.path.empty? ? '/' : uri.path)
      response.code.to_i
    rescue => e
      0
    end

    # Utility Functions
    def truncate(text, length = 50, omission = '...')
      text = text.to_s
      return text if text.length <= length
      text[0...(length - omission.length)] + omission
    end

    def currency(amount, currency_code = 'USD')
      symbol = case currency_code.upcase
               when 'USD' then '$'
               when 'EUR' then '€'
               when 'GBP' then '£'
               when 'JPY' then '¥'
               else currency_code
               end
      "#{symbol}#{sprintf('%.2f', amount.to_f)}"
    end

    def phone_format(phone, country = 'US')
      digits = phone.to_s.gsub(/\D/, '')
      
      case country.upcase
      when 'US'
        if digits.length == 10
          "(#{digits[0..2]}) #{digits[3..5]}-#{digits[6..9]}"
        elsif digits.length == 11 && digits[0] == '1'
          "+1 (#{digits[1..3]}) #{digits[4..6]}-#{digits[7..10]}"
        else
          phone
        end
      else
        phone
      end
    end

    # Memory and Performance
    def memory_usage
      `ps -o rss= -p #{Process.pid}`.to_i * 1024 # Convert KB to bytes
    rescue
      0
    end

    # Integration with popular gems (if available)
    def rails_env
      defined?(Rails) ? Rails.env : ENV['RAILS_ENV'] || 'development'
    end

    def rails_root
      defined?(Rails) ? Rails.root.to_s : Dir.pwd
    end

    def gem_version(gem_name)
      Gem.loaded_specs[gem_name]&.version&.to_s || 'not found'
    rescue
      'not available'
    end
  end
end

# Function registry for dynamic calling
class TuskLangFunctionRegistry
  def self.call_function(name, *args)
    if TuskLangBuiltinFunctions.respond_to?(name)
      TuskLangBuiltinFunctions.send(name, *args)
    else
      "Function '#{name}' not found"
    end
  end

  def self.available_functions
    TuskLangBuiltinFunctions.methods(false).sort
  end
end

if __FILE__ == $0
  # Example usage
  puts "TuskLang Built-in Functions Demo"
  puts "=" * 40
  
  # Test various functions
  puts "UUID: #{TuskLangBuiltinFunctions.uuid}"
  puts "Current time: #{TuskLangBuiltinFunctions.time}"
  puts "Date: #{TuskLangBuiltinFunctions.date('Y-m-d')}"
  puts "Slug: #{TuskLangBuiltinFunctions.slug('My Ruby App!')}"
  puts "MD5: #{TuskLangBuiltinFunctions.md5('test')}"
  puts "Is email: #{TuskLangBuiltinFunctions.is_email('test@example.com')}"
  puts "Random: #{TuskLangBuiltinFunctions.random(1, 100)}"
  puts "Platform: #{TuskLangBuiltinFunctions.platform}"
  puts "Ruby version: #{TuskLangBuiltinFunctions.ruby_version}"
  
  puts "\nAvailable functions: #{TuskLangFunctionRegistry.available_functions.length}"
end</pre>

<p>TuskLang's built-in functions provide comprehensive utility capabilities that integrate seamlessly with Ruby's ecosystem and popular gems.</p>