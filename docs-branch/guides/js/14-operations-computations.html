<h1>Operations & Computations</h1>

<h2>Math, String, and Data Operations in TuskLang</h2>
<p>TuskLang provides comprehensive operators for mathematical calculations, string manipulation, and data transformations in JavaScript.</p>

<h3>operations.tsk</h3>
<pre>
# Mathematical operations
math {
    # Basic arithmetic
    sum: @add(10, 20, 30)
    difference: @subtract(100, 25)
    product: @multiply(5, 8)
    quotient: @divide(100, 4)
    remainder: @modulo(17, 5)
    power: @pow(2, 8)
    
    # Complex calculations
    total_price: @multiply(@var.price, @var.quantity)
    with_tax: @multiply(@var.math.total_price, @add(1, @var.tax_rate))
    discount_amount: @multiply(@var.subtotal, @divide(@var.discount_percent, 100))
    final_price: @subtract(@var.math.with_tax, @var.math.discount_amount)
    
    # Math functions
    square_root: @sqrt(16)
    absolute: @abs(-42)
    rounded: @round(3.14159, 2)
    ceiling: @ceil(4.3)
    floor: @floor(4.7)
    
    # Aggregations
    numbers: [10, 20, 30, 40, 50]
    sum_all: @sum(@var.math.numbers)
    average: @avg(@var.math.numbers)
    minimum: @min(@var.math.numbers)
    maximum: @max(@var.math.numbers)
    
    # Statistical operations
    variance: @variance(@var.math.numbers)
    std_dev: @stdDev(@var.math.numbers)
    median: @median(@var.math.numbers)
}

# String operations
strings {
    # Basic operations
    greeting: @concat("Hello, ", @var.name, "!")
    uppercase: @upper("hello world")
    lowercase: @lower("HELLO WORLD")
    trimmed: @trim("  spaces  ")
    
    # String manipulation
    replaced: @replace("Hello World", "World", "Universe")
    substring: @substring("JavaScript", 0, 4)
    padded: @pad("5", 3, "0", "start")
    repeated: @repeat("*", 10)
    
    # Splitting and joining
    words: @split("one,two,three", ",")
    joined: @join(@var.strings.words, " | ")
    
    # Template operations
    template: @template("Hello, {{name}}! You have {{count}} messages.", {
        name: @var.user.name,
        count: @var.messages.length
    })
    
    # Formatting
    formatted_number: @format(@var.number, "0,0.00")
    formatted_date: @format(@var.date, "YYYY-MM-DD")
    formatted_currency: @currency(1234.56, "USD")
    
    # Parsing
    parsed_int: @parseInt("42")
    parsed_float: @parseFloat("3.14159")
    parsed_json: @parseJSON('{"name": "John"}')
    
    # Regular expressions
    matches: @match(@var.email, /^[^@]+@[^@]+\.[^@]+$/)
    extracted: @extract("Order #12345", /\d+/)
    validated: @test(@var.phone, /^\d{3}-\d{3}-\d{4}$/)
}

# Array operations
arrays {
    data: [1, 2, 3, 4, 5]
    
    # Transformations
    doubled: @map(@var.arrays.data, (x) => x * 2)
    filtered: @filter(@var.arrays.data, (x) => x > 2)
    reduced: @reduce(@var.arrays.data, (sum, x) => sum + x, 0)
    
    # Array methods
    sorted: @sort([3, 1, 4, 1, 5])
    reversed: @reverse(@var.arrays.sorted)
    unique: @unique([1, 2, 2, 3, 3, 3])
    flattened: @flatten([[1, 2], [3, 4], [5]])
    
    # Set operations
    set1: [1, 2, 3, 4]
    set2: [3, 4, 5, 6]
    union: @union(@var.arrays.set1, @var.arrays.set2)
    intersection: @intersect(@var.arrays.set1, @var.arrays.set2)
    difference: @diff(@var.arrays.set1, @var.arrays.set2)
    
    # Searching
    includes: @includes(@var.arrays.data, 3)
    indexOf: @indexOf(@var.arrays.data, 4)
    find: @find(@var.users, (u) => u.role === "admin")
    findIndex: @findIndex(@var.users, (u) => u.active === false)
}

# Object operations
objects {
    # Merging and cloning
    merged: @merge(@var.defaults, @var.overrides)
    deep_merged: @deepMerge(@var.config1, @var.config2)
    cloned: @clone(@var.original)
    deep_cloned: @deepClone(@var.complex_object)
    
    # Property operations
    keys: @keys(@var.user)
    values: @values(@var.user)
    entries: @entries(@var.user)
    picked: @pick(@var.user, ["id", "name", "email"])
    omitted: @omit(@var.user, ["password", "token"])
    
    # Transformations
    mapped_object: @mapValues(@var.scores, (score) => score * 1.1)
    filtered_object: @filterObject(@var.data, (value, key) => value > 0)
    inverted: @invert(@var.lookup)
    
    # Path operations
    nested_value: @get(@var.complex, "user.profile.settings.theme")
    with_default: @get(@var.complex, "user.profile.missing", "default")
    set_value: @set(@var.complex, "user.profile.updated", true)
    has_path: @has(@var.complex, "user.profile.settings")
}

# Date operations
dates {
    # Current time
    now: @now()
    today: @startOfDay(@var.dates.now)
    timestamp: @timestamp()
    
    # Date creation
    specific: @date("2024-01-01")
    from_timestamp: @date(1704067200000)
    
    # Date manipulation
    tomorrow: @addDays(@var.dates.today, 1)
    next_week: @addWeeks(@var.dates.today, 1)
    last_month: @subtractMonths(@var.dates.today, 1)
    
    # Date formatting
    formatted: @formatDate(@var.dates.now, "MMM DD, YYYY")
    iso_string: @toISO(@var.dates.now)
    relative: @fromNow(@var.dates.specific)
    
    # Date comparisons
    is_before: @isBefore(@var.start_date, @var.end_date)
    is_after: @isAfter(@var.dates.now, @var.deadline)
    is_between: @isBetween(@var.date, @var.start, @var.end)
    
    # Date calculations
    diff_days: @diffDays(@var.start_date, @var.end_date)
    diff_hours: @diffHours(@var.start_time, @var.end_time)
    business_days: @businessDaysBetween(@var.start, @var.end)
}

# Type conversions
conversions {
    # To string
    string_from_number: @toString(42)
    string_from_boolean: @toString(true)
    string_from_array: @toString([1, 2, 3])
    
    # To number
    number_from_string: @toNumber("42.5")
    number_from_boolean: @toNumber(true)
    
    # To boolean
    bool_from_string: @toBoolean("true")
    bool_from_number: @toBoolean(1)
    bool_from_empty: @toBoolean("")
    
    # To array
    array_from_string: @toArray("a,b,c", ",")
    array_from_object: @toArray(@var.object)
    
    # Encoding/Decoding
    base64_encoded: @base64Encode("Hello World")
    base64_decoded: @base64Decode(@var.conversions.base64_encoded)
    url_encoded: @urlEncode("hello world & stuff")
    url_decoded: @urlDecode("hello%20world%20%26%20stuff")
    
    # Serialization
    json_string: @stringify(@var.data)
    parsed_data: @parse(@var.json_string)
}

# Utility operations
utils {
    # Validation
    is_empty: @isEmpty(@var.value)
    is_null: @isNull(@var.value)
    is_undefined: @isUndefined(@var.value)
    is_array: @isArray(@var.value)
    is_object: @isObject(@var.value)
    is_string: @isString(@var.value)
    is_number: @isNumber(@var.value)
    
    # Comparison
    equals: @equals(@var.a, @var.b)
    deep_equals: @deepEquals(@var.obj1, @var.obj2)
    
    # Flow control
    default_value: @defaultTo(@var.maybe_null, "default")
    coalesce: @coalesce(@var.a, @var.b, @var.c, "fallback")
    
    # Functional
    pipe: @pipe(
        @var.input,
        @trim,
        @lower,
        @replace(_, " ", "-")
    )
    
    compose: @compose(
        @multiply(_, 2),
        @add(_, 10),
        @toString
    )
}
</pre>

<h3>JavaScript Operations Implementation</h3>
<pre>
class OperationsTuskLang {
    constructor() {
        this.operations = new Map();
        this.registerOperations();
    }
    
    registerOperations() {
        // Math operations
        this.register('add', (...args) => args.reduce((a, b) => a + b, 0));
        this.register('subtract', (a, b) => a - b);
        this.register('multiply', (...args) => args.reduce((a, b) => a * b, 1));
        this.register('divide', (a, b) => b !== 0 ? a / b : NaN);
        this.register('modulo', (a, b) => a % b);
        this.register('pow', Math.pow);
        this.register('sqrt', Math.sqrt);
        this.register('abs', Math.abs);
        this.register('round', (num, decimals = 0) => 
            Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals));
        this.register('ceil', Math.ceil);
        this.register('floor', Math.floor);
        
        // Aggregation operations
        this.register('sum', (arr) => arr.reduce((a, b) => a + b, 0));
        this.register('avg', (arr) => arr.length ? this.operations.get('sum')(arr) / arr.length : 0);
        this.register('min', (arr) => Math.min(...arr));
        this.register('max', (arr) => Math.max(...arr));
        
        // Statistical operations
        this.register('variance', (arr) => {
            const mean = this.operations.get('avg')(arr);
            return arr.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / arr.length;
        });
        this.register('stdDev', (arr) => Math.sqrt(this.operations.get('variance')(arr)));
        this.register('median', (arr) => {
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        });
        
        // String operations
        this.register('concat', (...args) => args.join(''));
        this.register('upper', (str) => String(str).toUpperCase());
        this.register('lower', (str) => String(str).toLowerCase());
        this.register('trim', (str) => String(str).trim());
        this.register('replace', (str, search, replace) => 
            String(str).replace(new RegExp(search, 'g'), replace));
        this.register('substring', (str, start, end) => String(str).substring(start, end));
        this.register('pad', (str, length, char = ' ', side = 'end') => {
            const s = String(str);
            return side === 'start' ? s.padStart(length, char) : s.padEnd(length, char);
        });
        this.register('repeat', (str, count) => String(str).repeat(count));
        this.register('split', (str, separator) => String(str).split(separator));
        this.register('join', (arr, separator = '') => arr.join(separator));
        
        // Template operations
        this.register('template', (template, data) => {
            return template.replace(/\{\{(\w+)\}\}/g, (match, key) => data[key] || match);
        });
        
        // Formatting operations
        this.register('format', (value, format) => {
            if (typeof value === 'number' && format === '0,0.00') {
                return value.toLocaleString('en-US', { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                });
            }
            if (value instanceof Date && format === 'YYYY-MM-DD') {
                return value.toISOString().split('T')[0];
            }
            return String(value);
        });
        
        this.register('currency', (amount, currency = 'USD') => {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: currency
            }).format(amount);
        });
        
        // Parsing operations
        this.register('parseInt', (str, radix = 10) => parseInt(str, radix));
        this.register('parseFloat', parseFloat);
        this.register('parseJSON', JSON.parse);
        
        // Regular expression operations
        this.register('match', (str, pattern) => {
            const regex = pattern instanceof RegExp ? pattern : new RegExp(pattern);
            return str.match(regex);
        });
        this.register('extract', (str, pattern) => {
            const match = this.operations.get('match')(str, pattern);
            return match ? match[0] : null;
        });
        this.register('test', (str, pattern) => {
            const regex = pattern instanceof RegExp ? pattern : new RegExp(pattern);
            return regex.test(str);
        });
        
        // Array operations
        this.register('map', (arr, fn) => arr.map(fn));
        this.register('filter', (arr, fn) => arr.filter(fn));
        this.register('reduce', (arr, fn, initial) => arr.reduce(fn, initial));
        this.register('sort', (arr, compareFn) => [...arr].sort(compareFn));
        this.register('reverse', (arr) => [...arr].reverse());
        this.register('unique', (arr) => [...new Set(arr)]);
        this.register('flatten', (arr) => arr.flat(Infinity));
        
        // Set operations
        this.register('union', (a, b) => [...new Set([...a, ...b])]);
        this.register('intersect', (a, b) => a.filter(x => b.includes(x)));
        this.register('diff', (a, b) => a.filter(x => !b.includes(x)));
        
        // Search operations
        this.register('includes', (arr, item) => arr.includes(item));
        this.register('indexOf', (arr, item) => arr.indexOf(item));
        this.register('find', (arr, fn) => arr.find(fn));
        this.register('findIndex', (arr, fn) => arr.findIndex(fn));
        
        // Object operations
        this.register('merge', (...objects) => Object.assign({}, ...objects));
        this.register('deepMerge', this.deepMerge.bind(this));
        this.register('clone', (obj) => ({ ...obj }));
        this.register('deepClone', (obj) => JSON.parse(JSON.stringify(obj)));
        
        this.register('keys', Object.keys);
        this.register('values', Object.values);
        this.register('entries', Object.entries);
        this.register('pick', (obj, keys) => {
            return keys.reduce((result, key) => {
                if (key in obj) result[key] = obj[key];
                return result;
            }, {});
        });
        this.register('omit', (obj, keys) => {
            const result = { ...obj };
            keys.forEach(key => delete result[key]);
            return result;
        });
        
        this.register('mapValues', (obj, fn) => {
            const result = {};
            for (const [key, value] of Object.entries(obj)) {
                result[key] = fn(value, key);
            }
            return result;
        });
        
        this.register('filterObject', (obj, fn) => {
            const result = {};
            for (const [key, value] of Object.entries(obj)) {
                if (fn(value, key)) result[key] = value;
            }
            return result;
        });
        
        this.register('invert', (obj) => {
            const result = {};
            for (const [key, value] of Object.entries(obj)) {
                result[value] = key;
            }
            return result;
        });
        
        // Path operations
        this.register('get', this.getPath.bind(this));
        this.register('set', this.setPath.bind(this));
        this.register('has', this.hasPath.bind(this));
        
        // Date operations
        this.register('now', () => new Date());
        this.register('timestamp', Date.now);
        this.register('date', (input) => input ? new Date(input) : new Date());
        this.register('startOfDay', (date) => {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            return d;
        });
        
        this.register('addDays', (date, days) => {
            const d = new Date(date);
            d.setDate(d.getDate() + days);
            return d;
        });
        
        this.register('formatDate', (date, format) => {
            const d = new Date(date);
            // Simple format implementation
            return format
                .replace('YYYY', d.getFullYear())
                .replace('MM', String(d.getMonth() + 1).padStart(2, '0'))
                .replace('DD', String(d.getDate()).padStart(2, '0'));
        });
        
        // Type conversions
        this.register('toString', String);
        this.register('toNumber', Number);
        this.register('toBoolean', Boolean);
        this.register('toArray', (value, separator) => {
            if (Array.isArray(value)) return value;
            if (typeof value === 'string' && separator) return value.split(separator);
            return [value];
        });
        
        // Encoding/Decoding
        this.register('base64Encode', (str) => Buffer.from(str).toString('base64'));
        this.register('base64Decode', (str) => Buffer.from(str, 'base64').toString());
        this.register('urlEncode', encodeURIComponent);
        this.register('urlDecode', decodeURIComponent);
        
        // Serialization
        this.register('stringify', JSON.stringify);
        this.register('parse', JSON.parse);
        
        // Validation operations
        this.register('isEmpty', (val) => {
            if (val == null) return true;
            if (Array.isArray(val) || typeof val === 'string') return val.length === 0;
            if (typeof val === 'object') return Object.keys(val).length === 0;
            return false;
        });
        this.register('isNull', (val) => val === null);
        this.register('isUndefined', (val) => val === undefined);
        this.register('isArray', Array.isArray);
        this.register('isObject', (val) => val !== null && typeof val === 'object' && !Array.isArray(val));
        this.register('isString', (val) => typeof val === 'string');
        this.register('isNumber', (val) => typeof val === 'number' && !isNaN(val));
        
        // Comparison operations
        this.register('equals', (a, b) => a === b);
        this.register('deepEquals', (a, b) => JSON.stringify(a) === JSON.stringify(b));
        
        // Flow control operations
        this.register('defaultTo', (value, defaultValue) => 
            value !== null && value !== undefined ? value : defaultValue);
        this.register('coalesce', (...args) => 
            args.find(arg => arg !== null && arg !== undefined));
        
        // Functional operations
        this.register('pipe', (value, ...fns) => 
            fns.reduce((acc, fn) => fn(acc), value));
        this.register('compose', (...fns) => 
            (value) => fns.reduceRight((acc, fn) => fn(acc), value));
    }
    
    register(name, fn) {
        this.operations.set(name, fn);
    }
    
    call(name, ...args) {
        const op = this.operations.get(name);
        if (!op) throw new Error(`Unknown operation: ${name}`);
        return op(...args);
    }
    
    deepMerge(target, ...sources) {
        if (!sources.length) return target;
        const source = sources.shift();
        
        if (this.call('isObject', target) && this.call('isObject', source)) {
            for (const key in source) {
                if (this.call('isObject', source[key])) {
                    if (!target[key]) Object.assign(target, { [key]: {} });
                    this.deepMerge(target[key], source[key]);
                } else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        
        return this.deepMerge(target, ...sources);
    }
    
    getPath(obj, path, defaultValue) {
        const keys = path.split('.');
        let result = obj;
        
        for (const key of keys) {
            if (result == null) return defaultValue;
            result = result[key];
        }
        
        return result !== undefined ? result : defaultValue;
    }
    
    setPath(obj, path, value) {
        const keys = path.split('.');
        const last = keys.pop();
        let current = obj;
        
        for (const key of keys) {
            if (!(key in current) || typeof current[key] !== 'object') {
                current[key] = {};
            }
            current = current[key];
        }
        
        current[last] = value;
        return obj;
    }
    
    hasPath(obj, path) {
        const keys = path.split('.');
        let current = obj;
        
        for (const key of keys) {
            if (current == null || !(key in current)) return false;
            current = current[key];
        }
        
        return true;
    }
}

// Usage example
const ops = new OperationsTuskLang();

// Math operations
console.log(ops.call('add', 10, 20, 30));           // 60
console.log(ops.call('round', 3.14159, 2));         // 3.14
console.log(ops.call('avg', [10, 20, 30, 40, 50])); // 30

// String operations
console.log(ops.call('concat', 'Hello, ', 'World!')); // "Hello, World!"
console.log(ops.call('template', 'Hello, {{name}}!', { name: 'John' })); // "Hello, John!"

// Array operations
console.log(ops.call('map', [1, 2, 3], x => x * 2)); // [2, 4, 6]
console.log(ops.call('unique', [1, 2, 2, 3, 3, 3])); // [1, 2, 3]

// Object operations
const obj = { a: { b: { c: 42 } } };
console.log(ops.call('get', obj, 'a.b.c'));         // 42
console.log(ops.call('pick', { a: 1, b: 2, c: 3 }, ['a', 'c'])); // { a: 1, c: 3 }

// Date operations
console.log(ops.call('formatDate', new Date(), 'YYYY-MM-DD'));

// Functional operations
const pipeline = ops.call('pipe',
    '  Hello World  ',
    (s) => ops.call('trim', s),
    (s) => ops.call('lower', s),
    (s) => ops.call('replace', s, ' ', '-')
);
console.log(pipeline); // "hello-world"
</pre>

<p>TuskLang's operation system provides a comprehensive set of functions for all common programming tasks, from basic math to complex data transformations.</p>