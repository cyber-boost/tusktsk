<h1>Security Best Practices in TuskLang Python</h1>

<h2>Comprehensive Security Framework</h2>
<p>TuskLang provides comprehensive security features for Python applications including encryption, authentication, authorization, input validation, and compliance frameworks.</p>

<h3>security.tsk</h3>
<pre>
# Security Configuration
security {
    # Encryption Configuration
    encryption {
        # Data at rest encryption
        at_rest: {
            algorithm: "AES-256-GCM"
            key_derivation: "PBKDF2"
            key_iterations: 100000
            
            # Key management
            key_management: {
                provider: env("KEY_PROVIDER", "local")  # local, aws_kms, azure_keyvault, hashicorp_vault
                rotation_interval: "90d"
                backup_keys: 3
                
                # Local key storage (for development)
                local: {
                    keyfile_path: env("ENCRYPTION_KEYFILE", "./keys/master.key")
                    permissions: 0o600
                }
                
                # AWS KMS configuration
                aws_kms: {
                    key_id: env("AWS_KMS_KEY_ID")
                    region: env("AWS_REGION", "us-east-1")
                    endpoint_url: env("AWS_KMS_ENDPOINT", null)
                }
                
                # HashiCorp Vault
                vault: {
                    url: env("VAULT_URL", "https://vault.example.com")
                    token: env("VAULT_TOKEN")
                    mount_path: env("VAULT_MOUNT_PATH", "secret")
                    key_path: env("VAULT_KEY_PATH", "encryption-keys")
                }
            }
            
            # Field-level encryption
            field_encryption: {
                enabled: true
                fields: ["password", "ssn", "credit_card", "personal_data"]
                deterministic_fields: ["email"]  # For searchable encryption
            }
        }
        
        # Data in transit encryption
        in_transit: {
            tls_version: "1.3"
            cipher_suites: [
                "TLS_AES_256_GCM_SHA384",
                "TLS_CHACHA20_POLY1305_SHA256",
                "TLS_AES_128_GCM_SHA256"
            ]
            
            # Certificate management
            certificates: {
                auto_renewal: true
                provider: env("CERT_PROVIDER", "letsencrypt")  # letsencrypt, custom, aws_acm
                
                letsencrypt: {
                    email: env("LETSENCRYPT_EMAIL", "admin@example.com")
                    domains: env("SSL_DOMAINS", "").split(",")
                    key_type: "rsa"
                    key_size: 2048
                }
                
                custom: {
                    cert_file: env("SSL_CERT_FILE", "/etc/ssl/certs/server.crt")
                    key_file: env("SSL_KEY_FILE", "/etc/ssl/private/server.key")
                    ca_file: env("SSL_CA_FILE", "/etc/ssl/certs/ca.crt")
                }
            }
            
            # HSTS (HTTP Strict Transport Security)
            hsts: {
                enabled: true
                max_age: 31536000  # 1 year
                include_subdomains: true
                preload: true
            }
        }
    }
    
    # Authentication Configuration
    authentication: {
        # Multi-factor authentication
        mfa: {
            enabled: env("MFA_ENABLED", true)
            required_for_admin: true
            methods: ["totp", "sms", "email", "webauthn"]
            
            totp: {
                issuer: env("TOTP_ISSUER", "TuskLang App")
                validity_window: 1
                algorithm: "SHA1"
            }
            
            sms: {
                provider: env("SMS_PROVIDER", "twilio")
                rate_limit: "5/hour"
                template: "Your verification code is: {code}"
            }
            
            webauthn: {
                enabled: true
                rp_name: env("WEBAUTHN_RP_NAME", "TuskLang App")
                rp_id: env("WEBAUTHN_RP_ID", "example.com")
                require_user_verification: true
            }
        }
        
        # JWT Configuration
        jwt: {
            algorithm: "RS256"
            access_token_expiry: "15m"
            refresh_token_expiry: "7d"
            
            # Key management for JWT
            keys: {
                private_key: env("JWT_PRIVATE_KEY")
                public_key: env("JWT_PUBLIC_KEY")
                key_rotation: "30d"
            }
            
            # Claims configuration
            claims: {
                issuer: env("JWT_ISSUER", "tusklang-app")
                audience: env("JWT_AUDIENCE", "tusklang-users")
                include_user_id: true
                include_roles: true
                include_permissions: true
            }
        }
        
        # OAuth2/OpenID Connect
        oauth2: {
            providers: {
                google: {
                    enabled: env("GOOGLE_OAUTH_ENABLED", false)
                    client_id: env("GOOGLE_CLIENT_ID")
                    client_secret: env("GOOGLE_CLIENT_SECRET")
                    scopes: ["openid", "email", "profile"]
                }
                
                github: {
                    enabled: env("GITHUB_OAUTH_ENABLED", false)
                    client_id: env("GITHUB_CLIENT_ID")
                    client_secret: env("GITHUB_CLIENT_SECRET")
                    scopes: ["user:email"]
                }
                
                microsoft: {
                    enabled: env("MICROSOFT_OAUTH_ENABLED", false)
                    client_id: env("MICROSOFT_CLIENT_ID")
                    client_secret: env("MICROSOFT_CLIENT_SECRET")
                    tenant_id: env("MICROSOFT_TENANT_ID")
                    scopes: ["openid", "email", "profile"]
                }
            }
        }
        
        # Session management
        sessions: {
            backend: "redis"  # redis, database, memory
            secure: env("SESSION_SECURE", true)
            httponly: true
            samesite: "Strict"
            max_age: 3600
            
            # Session security
            regenerate_on_login: true
            invalidate_on_logout: true
            concurrent_sessions: 3
            ip_validation: true
            user_agent_validation: false
        }
    }
    
    # Authorization Configuration
    authorization: {
        # Role-Based Access Control (RBAC)
        rbac: {
            enabled: true
            
            roles: {
                admin: {
                    permissions: ["*"]
                    description: "Full system access"
                }
                
                moderator: {
                    permissions: [
                        "users.read",
                        "users.update",
                        "content.read",
                        "content.update",
                        "content.delete"
                    ]
                    description: "Content moderation access"
                }
                
                user: {
                    permissions: [
                        "profile.read",
                        "profile.update",
                        "content.create",
                        "content.read"
                    ]
                    description: "Standard user access"
                }
                
                readonly: {
                    permissions: ["*.read"]
                    description: "Read-only access"
                }
            }
            
            # Dynamic permissions
            dynamic_permissions: {
                enabled: true
                resource_based: true
                context_aware: true
            }
        }
        
        # Attribute-Based Access Control (ABAC)
        abac: {
            enabled: false
            policy_engine: "open_policy_agent"
            
            policies: [
                {
                    name: "resource_owner_access"
                    rule: "subject.user_id == resource.owner_id"
                    effect: "allow"
                },
                {
                    name: "admin_override"
                    rule: "subject.role == 'admin'"
                    effect: "allow"
                },
                {
                    name: "time_based_access"
                    rule: "time.hour >= 9 AND time.hour <= 17"
                    effect: "allow"
                    resources: ["sensitive_data"]
                }
            ]
        }
    }
    
    # Input Validation and Sanitization
    input_validation: {
        # Global validation settings
        strict_mode: env("VALIDATION_STRICT", true)
        sanitize_html: true
        max_request_size: "10MB"
        
        # Content Security Policy
        csp: {
            enabled: true
            policy: {
                default_src: ["'self'"]
                script_src: ["'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com"]
                style_src: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"]
                img_src: ["'self'", "data:", "https:"]
                font_src: ["'self'", "https://fonts.gstatic.com"]
                connect_src: ["'self'"]
                frame_ancestors: ["'none'"]
            }
            report_uri: "/csp-report"
        }
        
        # Input sanitization rules
        sanitization: {
            html: {
                allowed_tags: ["p", "br", "strong", "em", "ul", "ol", "li"]
                allowed_attributes: {}
                strip_dangerous: true
            }
            
            sql: {
                use_parameterized_queries: true
                escape_special_chars: true
                block_dangerous_keywords: ["DROP", "DELETE", "EXEC", "UNION"]
            }
            
            xss_protection: {
                enabled: true
                escape_html: true
                validate_urls: true
                content_type_validation: true
            }
        }
        
        # Rate limiting
        rate_limiting: {
            enabled: true
            
            global: {
                requests_per_minute: 1000
                burst_capacity: 100
            }
            
            per_user: {
                requests_per_minute: 100
                burst_capacity: 20
            }
            
            per_endpoint: {
                "/api/auth/login": "10/minute",
                "/api/auth/register": "5/minute",
                "/api/upload": "50/hour"
            }
            
            # Advanced rate limiting
            adaptive: {
                enabled: true
                base_rate: 100
                penalty_multiplier: 0.5
                recovery_time: "5m"
            }
        }
    }
    
    # Audit and Compliance
    audit: {
        # Audit logging
        logging: {
            enabled: true
            level: "INFO"
            include_request_body: false
            include_response_body: false
            
            events: [
                "authentication",
                "authorization", 
                "data_access",
                "data_modification",
                "admin_actions",
                "security_events"
            ]
            
            # Audit log storage
            storage: {
                backend: "database"  # database, file, syslog, elasticsearch
                retention_period: "7y"
                encryption: true
                immutable: true
                
                # Compliance requirements
                integrity_verification: true
                digital_signatures: true
                tamper_detection: true
            }
        }
        
        # Compliance frameworks
        compliance: {
            frameworks: ["SOC2", "GDPR", "HIPAA", "PCI_DSS", "ISO27001"]
            
            gdpr: {
                enabled: env("GDPR_COMPLIANCE", true)
                data_protection_officer: env("DPO_EMAIL", "dpo@example.com")
                
                # Data subject rights
                rights: {
                    right_to_access: true
                    right_to_rectification: true
                    right_to_erasure: true
                    right_to_portability: true
                    right_to_object: true
                }
                
                # Data processing lawfulness
                lawful_basis: "consent"  # consent, contract, legal_obligation, vital_interests, public_task, legitimate_interests
                consent_management: true
                data_retention_policies: true
            }
            
            hipaa: {
                enabled: env("HIPAA_COMPLIANCE", false)
                covered_entity: true
                
                # Security safeguards
                safeguards: {
                    administrative: true
                    physical: true
                    technical: true
                }
                
                # PHI protection
                phi_protection: {
                    encryption: true
                    access_controls: true
                    audit_logs: true
                    data_backup: true
                }
            }
            
            pci_dss: {
                enabled: env("PCI_DSS_COMPLIANCE", false)
                merchant_level: env("PCI_MERCHANT_LEVEL", "4")
                
                requirements: {
                    firewall_configuration: true
                    default_passwords: false
                    cardholder_data_protection: true
                    encrypted_transmission: true
                    antivirus_software: true
                    secure_systems: true
                    access_restrictions: true
                    unique_user_ids: true
                    physical_access_restrictions: true
                    network_monitoring: true
                    regular_testing: true
                    information_security_policy: true
                }
            }
        }
    }
    
    # Security Monitoring and Incident Response
    monitoring: {
        # Intrusion detection
        intrusion_detection: {
            enabled: true
            
            # Signature-based detection
            signatures: {
                sql_injection: true
                xss_attacks: true
                csrf_attacks: true
                brute_force: true
                directory_traversal: true
            }
            
            # Anomaly detection
            anomaly_detection: {
                enabled: true
                machine_learning: true
                baseline_period: "7d"
                sensitivity: "medium"
                
                # Behavioral analysis
                user_behavior: {
                    login_patterns: true
                    access_patterns: true
                    geographical_analysis: true
                    device_fingerprinting: true
                }
            }
        }
        
        # Security alerts
        alerting: {
            enabled: true
            
            channels: {
                email: {
                    enabled: true
                    recipients: env("SECURITY_ALERTS_EMAIL", "security@example.com").split(",")
                    severity_threshold: "medium"
                }
                
                slack: {
                    enabled: env("SLACK_ALERTS_ENABLED", false)
                    webhook_url: env("SLACK_WEBHOOK_URL")
                    channel: env("SLACK_SECURITY_CHANNEL", "#security")
                }
                
                pagerduty: {
                    enabled: env("PAGERDUTY_ENABLED", false)
                    service_key: env("PAGERDUTY_SERVICE_KEY")
                    escalation_policy: env("PAGERDUTY_ESCALATION_POLICY")
                }
            }
            
            # Alert rules
            rules: {
                failed_login_attempts: {
                    threshold: 5
                    window: "5m"
                    severity: "medium"
                }
                
                privilege_escalation: {
                    threshold: 1
                    window: "1m"
                    severity: "high"
                }
                
                data_exfiltration: {
                    threshold: "100MB"
                    window: "10m"
                    severity: "critical"
                }
                
                suspicious_api_usage: {
                    threshold: 1000
                    window: "1m"
                    severity: "medium"
                }
            }
        }
        
        # Incident response
        incident_response: {
            enabled: true
            
            # Automated responses
            automated_responses: {
                account_lockout: {
                    trigger: "failed_login_attempts"
                    duration: "30m"
                    escalation: true
                }
                
                ip_blocking: {
                    trigger: "suspicious_activity"
                    duration: "24h"
                    whitelist_override: true
                }
                
                rate_limit_increase: {
                    trigger: "potential_ddos"
                    multiplier: 0.1
                    duration: "1h"
                }
            }
            
            # Manual response procedures
            procedures: {
                data_breach: {
                    notification_timeline: "72h"
                    affected_users_notification: true
                    regulatory_reporting: true
                    forensic_analysis: true
                }
                
                security_incident: {
                    escalation_matrix: true
                    evidence_preservation: true
                    communication_plan: true
                    recovery_procedures: true
                }
            }
        }
    }
    
    # Security Testing and Vulnerability Management
    testing: {
        # Automated security testing
        automated_testing: {
            enabled: true
            
            sast: {  # Static Application Security Testing
                enabled: true
                tools: ["bandit", "semgrep", "codeql"]
                fail_on_high: true
                fail_on_medium: false
            }
            
            dast: {  # Dynamic Application Security Testing
                enabled: env("DAST_ENABLED", false)
                tools: ["zap", "w3af"]
                baseline_scan: true
                full_scan_schedule: "weekly"
            }
            
            iast: {  # Interactive Application Security Testing
                enabled: false
                runtime_protection: true
                real_time_feedback: true
            }
            
            dependency_scanning: {
                enabled: true
                tools: ["safety", "pip-audit", "snyk"]
                auto_update: false
                vulnerability_database: "nvd"
            }
        }
        
        # Penetration testing
        penetration_testing: {
            schedule: "quarterly"
            scope: ["web_application", "api", "infrastructure"]
            methodology: "owasp"
            reporting: true
            remediation_tracking: true
        }
        
        # Vulnerability management
        vulnerability_management: {
            scanning_frequency: "daily"
            
            severity_levels: {
                critical: {
                    sla: "24h"
                    auto_notify: true
                    emergency_patch: true
                }
                
                high: {
                    sla: "7d"
                    auto_notify: true
                    priority_patch: true
                }
                
                medium: {
                    sla: "30d"
                    auto_notify: false
                    scheduled_patch: true
                }
                
                low: {
                    sla: "90d"
                    auto_notify: false
                    optional_patch: true
                }
            }
            
            # Exception management
            exceptions: {
                approval_required: true
                time_limited: true
                risk_assessment: true
                compensating_controls: true
            }
        }
    }
}

# Environment-specific Security Overrides
security_overrides {
    development: {
        # Relaxed security for development
        security.authentication.mfa.enabled: false
        security.encryption.at_rest.algorithm: "AES-128-GCM"
        security.input_validation.strict_mode: false
        security.audit.logging.level: "DEBUG"
    }
    
    staging: {
        # Staging-specific security
        security.authentication.mfa.enabled: true
        security.monitoring.intrusion_detection.enabled: true
        security.testing.automated_testing.enabled: true
    }
    
    production: {
        # Maximum security for production
        security.authentication.mfa.required_for_admin: true
        security.encryption.in_transit.tls_version: "1.3"
        security.monitoring.alerting.enabled: true
        security.incident_response.enabled: true
        security.testing.penetration_testing.schedule: "quarterly"
    }
}
</pre>

<h3>Python Security Implementation</h3>
<pre>
import os
import hashlib
import hmac
import secrets
import time
import jwt
import bcrypt
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Union, Tuple
from dataclasses import dataclass
import logging
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import redis
import sqlalchemy as sa
from functools import wraps
import ipaddress
from urllib.parse import urlparse
import re
import bleach

@dataclass
class SecurityConfig:
    """Security configuration container."""
    encryption_key: bytes
    jwt_secret: str
    mfa_enabled: bool
    rate_limiting: Dict[str, Any]
    audit_enabled: bool

class EncryptionManager:
    """Comprehensive encryption management for TuskLang."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.cipher_suite = self._init_cipher_suite()
        self.key_manager = KeyManager(config.get('encryption', {}).get('key_management', {}))
        
    def _init_cipher_suite(self) -> Fernet:
        """Initialize encryption cipher suite."""
        encryption_config = self.config.get('encryption', {}).get('at_rest', {})
        
        # Get or generate encryption key
        key = self.key_manager.get_master_key()
        return Fernet(key)
    
    def encrypt_data(self, data: Union[str, bytes], field_name: Optional[str] = None) -> bytes:
        """Encrypt data with optional field-level encryption."""
        if isinstance(data, str):
            data = data.encode('utf-8')
        
        # Check if field requires deterministic encryption
        field_encryption_config = self.config.get('encryption', {}).get('at_rest', {}).get('field_encryption', {})
        if field_name and field_name in field_encryption_config.get('deterministic_fields', []):
            return self._deterministic_encrypt(data, field_name)
        
        return self.cipher_suite.encrypt(data)
    
    def decrypt_data(self, encrypted_data: bytes, field_name: Optional[str] = None) -> bytes:
        """Decrypt data."""
        field_encryption_config = self.config.get('encryption', {}).get('at_rest', {}).get('field_encryption', {})
        if field_name and field_name in field_encryption_config.get('deterministic_fields', []):
            return self._deterministic_decrypt(encrypted_data, field_name)
        
        return self.cipher_suite.decrypt(encrypted_data)
    
    def _deterministic_encrypt(self, data: bytes, field_name: str) -> bytes:
        """Deterministic encryption for searchable fields."""
        # Use HMAC-based deterministic encryption
        field_key = self.key_manager.derive_field_key(field_name)
        return hmac.new(field_key, data, hashlib.sha256).digest()
    
    def _deterministic_decrypt(self, encrypted_data: bytes, field_name: str) -> bytes:
        """Deterministic decryption (not possible - return hash for comparison)."""
        # Deterministic encryption is one-way for searching
        return encrypted_data

class KeyManager:
    """Cryptographic key management."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.provider = config.get('provider', 'local')
        self.master_key = None
        
    def get_master_key(self) -> bytes:
        """Get master encryption key."""
        if self.master_key is None:
            if self.provider == 'local':
                self.master_key = self._get_local_key()
            elif self.provider == 'aws_kms':
                self.master_key = self._get_aws_kms_key()
            elif self.provider == 'vault':
                self.master_key = self._get_vault_key()
            else:
                raise ValueError(f"Unsupported key provider: {self.provider}")
        
        return self.master_key
    
    def _get_local_key(self) -> bytes:
        """Get key from local file."""
        keyfile_path = self.config.get('local', {}).get('keyfile_path', './keys/master.key')
        
        try:
            with open(keyfile_path, 'rb') as f:
                return f.read()
        except FileNotFoundError:
            # Generate new key
            key = Fernet.generate_key()
            os.makedirs(os.path.dirname(keyfile_path), exist_ok=True)
            
            with open(keyfile_path, 'wb') as f:
                f.write(key)
            
            # Set secure permissions
            os.chmod(keyfile_path, 0o600)
            
            return key
    
    def _get_aws_kms_key(self) -> bytes:
        """Get key from AWS KMS."""
        import boto3
        
        kms_config = self.config.get('aws_kms', {})
        key_id = kms_config.get('key_id')
        region = kms_config.get('region', 'us-east-1')
        
        client = boto3.client('kms', region_name=region)
        
        # Generate data key
        response = client.generate_data_key(
            KeyId=key_id,
            KeySpec='AES_256'
        )
        
        return response['Plaintext']
    
    def _get_vault_key(self) -> bytes:
        """Get key from HashiCorp Vault."""
        import hvac
        
        vault_config = self.config.get('vault', {})
        client = hvac.Client(
            url=vault_config.get('url'),
            token=vault_config.get('token')
        )
        
        mount_path = vault_config.get('mount_path', 'secret')
        key_path = vault_config.get('key_path', 'encryption-keys')
        
        secret = client.secrets.kv.v2.read_secret_version(
            path=key_path,
            mount_point=mount_path
        )
        
        return secret['data']['data']['master_key'].encode()
    
    def derive_field_key(self, field_name: str) -> bytes:
        """Derive field-specific key."""
        master_key = self.get_master_key()
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=field_name.encode('utf-8'),
            iterations=100000,
        )
        
        return kdf.derive(master_key)
    
    def rotate_keys(self) -> bool:
        """Rotate encryption keys."""
        # Implementation depends on provider
        if self.provider == 'local':
            return self._rotate_local_key()
        elif self.provider == 'aws_kms':
            return self._rotate_aws_kms_key()
        elif self.provider == 'vault':
            return self._rotate_vault_key()
        
        return False
    
    def _rotate_local_key(self) -> bool:
        """Rotate local key file."""
        # Backup current key
        keyfile_path = self.config.get('local', {}).get('keyfile_path', './keys/master.key')
        backup_path = f"{keyfile_path}.{int(time.time())}"
        
        if os.path.exists(keyfile_path):
            os.rename(keyfile_path, backup_path)
        
        # Generate new key
        new_key = Fernet.generate_key()
        with open(keyfile_path, 'wb') as f:
            f.write(new_key)
        
        os.chmod(keyfile_path, 0o600)
        
        # Update master key
        self.master_key = new_key
        
        return True
    
    def _rotate_aws_kms_key(self) -> bool:
        """Rotate AWS KMS key."""
        # AWS KMS handles key rotation automatically
        return True
    
    def _rotate_vault_key(self) -> bool:
        """Rotate Vault key."""
        # Implementation would depend on Vault configuration
        return True

class AuthenticationManager:
    """Comprehensive authentication management."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.mfa_enabled = config.get('mfa', {}).get('enabled', True)
        self.jwt_config = config.get('jwt', {})
        self.session_manager = SessionManager(config.get('sessions', {}))
        
    def authenticate_user(self, username: str, password: str, mfa_code: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Authenticate user with optional MFA."""
        # Verify password
        user = self._verify_password(username, password)
        if not user:
            self._log_failed_login(username)
            return None
        
        # Check MFA if enabled
        if self.mfa_enabled and user.get('mfa_enabled', True):
            if not mfa_code or not self._verify_mfa(user['user_id'], mfa_code):
                return None
        
        # Generate session
        session_data = self.session_manager.create_session(user)
        
        # Generate JWT token
        token = self._generate_jwt_token(user)
        
        self._log_successful_login(user)
        
        return {
            'user': user,
            'session_id': session_data['session_id'],
            'access_token': token['access_token'],
            'refresh_token': token['refresh_token']
        }
    
    def _verify_password(self, username: str, password: str) -> Optional[Dict[str, Any]]:
        """Verify user password."""
        # This would typically query a database
        # Simplified implementation for demonstration
        users_db = {
            'admin': {
                'user_id': 1,
                'username': 'admin',
                'password_hash': '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4X4Y2Kd.oG',  # 'password'
                'roles': ['admin'],
                'mfa_enabled': True
            }
        }
        
        user = users_db.get(username)
        if not user:
            return None
        
        # Verify password hash
        if bcrypt.checkpw(password.encode('utf-8'), user['password_hash'].encode('utf-8')):
            return user
        
        return None
    
    def _verify_mfa(self, user_id: int, mfa_code: str) -> bool:
        """Verify MFA code."""
        mfa_methods = self.config.get('mfa', {}).get('methods', [])
        
        if 'totp' in mfa_methods:
            return self._verify_totp(user_id, mfa_code)
        elif 'sms' in mfa_methods:
            return self._verify_sms_code(user_id, mfa_code)
        
        return False
    
    def _verify_totp(self, user_id: int, totp_code: str) -> bool:
        """Verify TOTP code."""
        import pyotp
        
        # Get user's TOTP secret (would be stored in database)
        totp_secret = self._get_user_totp_secret(user_id)
        if not totp_secret:
            return False
        
        totp = pyotp.TOTP(totp_secret)
        return totp.verify(totp_code, valid_window=self.config.get('mfa', {}).get('totp', {}).get('validity_window', 1))
    
    def _verify_sms_code(self, user_id: int, sms_code: str) -> bool:
        """Verify SMS code."""
        # This would verify against stored SMS codes
        # Simplified implementation
        stored_codes = self._get_user_sms_codes(user_id)
        return sms_code in stored_codes
    
    def _generate_jwt_token(self, user: Dict[str, Any]) -> Dict[str, str]:
        """Generate JWT access and refresh tokens."""
        now = datetime.utcnow()
        
        # Access token payload
        access_payload = {
            'user_id': user['user_id'],
            'username': user['username'],
            'roles': user.get('roles', []),
            'iat': now,
            'exp': now + timedelta(minutes=15),  # 15 minutes
            'type': 'access'
        }
        
        # Refresh token payload
        refresh_payload = {
            'user_id': user['user_id'],
            'iat': now,
            'exp': now + timedelta(days=7),  # 7 days
            'type': 'refresh'
        }
        
        algorithm = self.jwt_config.get('algorithm', 'HS256')
        secret = self.jwt_config.get('secret', 'default-secret')
        
        access_token = jwt.encode(access_payload, secret, algorithm=algorithm)
        refresh_token = jwt.encode(refresh_payload, secret, algorithm=algorithm)
        
        return {
            'access_token': access_token,
            'refresh_token': refresh_token
        }
    
    def _log_failed_login(self, username: str):
        """Log failed login attempt."""
        logging.warning(f"Failed login attempt for user: {username}")
    
    def _log_successful_login(self, user: Dict[str, Any]):
        """Log successful login."""
        logging.info(f"Successful login for user: {user['username']}")
    
    def _get_user_totp_secret(self, user_id: int) -> Optional[str]:
        """Get user's TOTP secret."""
        # Would query database for user's TOTP secret
        return "JBSWY3DPEHPK3PXP"  # Example secret
    
    def _get_user_sms_codes(self, user_id: int) -> List[str]:
        """Get valid SMS codes for user."""
        # Would query database for valid SMS codes
        return ["123456"]  # Example codes

class SessionManager:
    """Session management with security features."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.backend = config.get('backend', 'memory')
        self.redis_client = self._init_redis() if self.backend == 'redis' else None
        self.memory_store = {} if self.backend == 'memory' else None
        
    def _init_redis(self) -> Optional[redis.Redis]:
        """Initialize Redis client for session storage."""
        try:
            return redis.Redis(
                host=os.getenv('REDIS_HOST', 'localhost'),
                port=int(os.getenv('REDIS_PORT', '6379')),
                decode_responses=True
            )
        except Exception:
            return None
    
    def create_session(self, user: Dict[str, Any]) -> Dict[str, Any]:
        """Create new session."""
        session_id = secrets.token_urlsafe(32)
        
        session_data = {
            'session_id': session_id,
            'user_id': user['user_id'],
            'username': user['username'],
            'roles': user.get('roles', []),
            'created_at': datetime.utcnow().isoformat(),
            'last_activity': datetime.utcnow().isoformat(),
            'ip_address': None,  # Would be set from request
            'user_agent': None   # Would be set from request
        }
        
        # Store session
        max_age = self.config.get('max_age', 3600)
        
        if self.backend == 'redis' and self.redis_client:
            self.redis_client.setex(
                f"session:{session_id}",
                max_age,
                json.dumps(session_data)
            )
        elif self.backend == 'memory':
            self.memory_store[session_id] = session_data
        
        return session_data
    
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get session data."""
        if self.backend == 'redis' and self.redis_client:
            session_data = self.redis_client.get(f"session:{session_id}")
            return json.loads(session_data) if session_data else None
        elif self.backend == 'memory':
            return self.memory_store.get(session_id)
        
        return None
    
    def update_session(self, session_id: str, updates: Dict[str, Any]) -> bool:
        """Update session data."""
        session_data = self.get_session(session_id)
        if not session_data:
            return False
        
        session_data.update(updates)
        session_data['last_activity'] = datetime.utcnow().isoformat()
        
        if self.backend == 'redis' and self.redis_client:
            max_age = self.config.get('max_age', 3600)
            self.redis_client.setex(
                f"session:{session_id}",
                max_age,
                json.dumps(session_data)
            )
        elif self.backend == 'memory':
            self.memory_store[session_id] = session_data
        
        return True
    
    def delete_session(self, session_id: str) -> bool:
        """Delete session."""
        if self.backend == 'redis' and self.redis_client:
            return bool(self.redis_client.delete(f"session:{session_id}"))
        elif self.backend == 'memory' and session_id in self.memory_store:
            del self.memory_store[session_id]
            return True
        
        return False

class AuthorizationManager:
    """Role-based and attribute-based authorization."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.rbac_enabled = config.get('rbac', {}).get('enabled', True)
        self.abac_enabled = config.get('abac', {}).get('enabled', False)
        self.roles = config.get('rbac', {}).get('roles', {})
        
    def check_permission(self, user: Dict[str, Any], permission: str, resource: Optional[Dict[str, Any]] = None) -> bool:
        """Check if user has permission."""
        if self.rbac_enabled and self._check_rbac_permission(user, permission):
            return True
        
        if self.abac_enabled and self._check_abac_permission(user, permission, resource):
            return True
        
        return False
    
    def _check_rbac_permission(self, user: Dict[str, Any], permission: str) -> bool:
        """Check RBAC permission."""
        user_roles = user.get('roles', [])
        
        for role in user_roles:
            role_permissions = self.roles.get(role, {}).get('permissions', [])
            
            # Check wildcard permissions
            if '*' in role_permissions:
                return True
            
            # Check specific permission
            if permission in role_permissions:
                return True
            
            # Check wildcard patterns
            for role_permission in role_permissions:
                if role_permission.endswith('*'):
                    prefix = role_permission[:-1]
                    if permission.startswith(prefix):
                        return True
        
        return False
    
    def _check_abac_permission(self, user: Dict[str, Any], permission: str, resource: Optional[Dict[str, Any]]) -> bool:
        """Check ABAC permission."""
        policies = self.config.get('abac', {}).get('policies', [])
        
        for policy in policies:
            if self._evaluate_policy(policy, user, permission, resource):
                return policy.get('effect') == 'allow'
        
        return False
    
    def _evaluate_policy(self, policy: Dict[str, Any], user: Dict[str, Any], permission: str, resource: Optional[Dict[str, Any]]) -> bool:
        """Evaluate ABAC policy."""
        rule = policy.get('rule', '')
        
        # Simple rule evaluation (in production, use a proper policy engine)
        context = {
            'subject': user,
            'permission': permission,
            'resource': resource or {},
            'time': datetime.utcnow()
        }
        
        try:
            # WARNING: eval is dangerous - use a proper policy engine in production
            return eval(rule, {"__builtins__": {}}, context)
        except Exception:
            return False

class InputValidator:
    """Comprehensive input validation and sanitization."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.strict_mode = config.get('strict_mode', True)
        self.csp_config = config.get('csp', {})
        
    def validate_and_sanitize(self, data: Any, data_type: str = 'string') -> Any:
        """Validate and sanitize input data."""
        if data_type == 'html':
            return self._sanitize_html(data)
        elif data_type == 'sql':
            return self._sanitize_sql(data)
        elif data_type == 'url':
            return self._validate_url(data)
        elif data_type == 'email':
            return self._validate_email(data)
        else:
            return self._sanitize_string(data)
    
    def _sanitize_html(self, html_content: str) -> str:
        """Sanitize HTML content."""
        sanitization_config = self.config.get('sanitization', {}).get('html', {})
        
        allowed_tags = sanitization_config.get('allowed_tags', [])
        allowed_attributes = sanitization_config.get('allowed_attributes', {})
        
        return bleach.clean(
            html_content,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=sanitization_config.get('strip_dangerous', True)
        )
    
    def _sanitize_sql(self, sql_input: str) -> str:
        """Sanitize SQL input."""
        sanitization_config = self.config.get('sanitization', {}).get('sql', {})
        
        # Block dangerous keywords
        dangerous_keywords = sanitization_config.get('block_dangerous_keywords', [])
        for keyword in dangerous_keywords:
            if keyword.upper() in sql_input.upper():
                raise ValueError(f"Dangerous SQL keyword detected: {keyword}")
        
        # Escape special characters
        if sanitization_config.get('escape_special_chars', True):
            sql_input = sql_input.replace("'", "''")
            sql_input = sql_input.replace('"', '""')
            sql_input = sql_input.replace(';', '\\;')
        
        return sql_input
    
    def _validate_url(self, url: str) -> str:
        """Validate URL."""
        try:
            parsed = urlparse(url)
            
            # Check scheme
            if parsed.scheme not in ['http', 'https']:
                raise ValueError("Invalid URL scheme")
            
            # Check for dangerous protocols
            if parsed.scheme in ['javascript', 'data', 'file']:
                raise ValueError("Dangerous URL protocol")
            
            return url
        except Exception as e:
            raise ValueError(f"Invalid URL: {e}")
    
    def _validate_email(self, email: str) -> str:
        """Validate email address."""
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        
        if not re.match(email_pattern, email):
            raise ValueError("Invalid email format")
        
        return email.lower()
    
    def _sanitize_string(self, text: str) -> str:
        """General string sanitization."""
        # Remove null bytes
        text = text.replace('\x00', '')
        
        # Remove control characters
        text = ''.join(char for char in text if ord(char) >= 32 or char in '\t\n\r')
        
        # XSS protection
        xss_config = self.config.get('sanitization', {}).get('xss_protection', {})
        if xss_config.get('escape_html', True):
            text = text.replace('<', '&lt;').replace('>', '&gt;')
        
        return text

class RateLimiter:
    """Advanced rate limiting implementation."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.redis_client = self._init_redis()
        self.memory_store = defaultdict(list)
        
    def _init_redis(self) -> Optional[redis.Redis]:
        """Initialize Redis for distributed rate limiting."""
        try:
            return redis.Redis(
                host=os.getenv('REDIS_HOST', 'localhost'),
                port=int(os.getenv('REDIS_PORT', '6379')),
                decode_responses=True
            )
        except Exception:
            return None
    
    def check_rate_limit(self, identifier: str, limit_type: str = 'global') -> Tuple[bool, Dict[str, Any]]:
        """Check if request is within rate limits."""
        limits = self._get_limits(limit_type)
        
        current_time = time.time()
        window_size = 60  # 1 minute window
        
        if self.redis_client:
            return self._check_redis_rate_limit(identifier, limits, current_time, window_size)
        else:
            return self._check_memory_rate_limit(identifier, limits, current_time, window_size)
    
    def _get_limits(self, limit_type: str) -> Dict[str, int]:
        """Get rate limits for type."""
        if limit_type == 'global':
            return {'requests_per_minute': self.config.get('global', {}).get('requests_per_minute', 1000)}
        elif limit_type == 'per_user':
            return {'requests_per_minute': self.config.get('per_user', {}).get('requests_per_minute', 100)}
        else:
            return {'requests_per_minute': 100}
    
    def _check_redis_rate_limit(self, identifier: str, limits: Dict[str, int], current_time: float, window_size: int) -> Tuple[bool, Dict[str, Any]]:
        """Check rate limit using Redis."""
        key = f"rate_limit:{identifier}"
        
        # Get current count
        pipe = self.redis_client.pipeline()
        pipe.zcount(key, current_time - window_size, current_time)
        pipe.zadd(key, {str(current_time): current_time})
        pipe.zremrangebyscore(key, 0, current_time - window_size)
        pipe.expire(key, window_size)
        
        results = pipe.execute()
        current_count = results[0]
        
        requests_per_minute = limits.get('requests_per_minute', 100)
        
        return current_count < requests_per_minute, {
            'current_count': current_count,
            'limit': requests_per_minute,
            'window_size': window_size,
            'reset_time': current_time + window_size
        }
    
    def _check_memory_rate_limit(self, identifier: str, limits: Dict[str, int], current_time: float, window_size: int) -> Tuple[bool, Dict[str, Any]]:
        """Check rate limit using memory store."""
        requests = self.memory_store[identifier]
        
        # Clean old requests
        requests[:] = [req_time for req_time in requests if current_time - req_time < window_size]
        
        # Add current request
        requests.append(current_time)
        
        requests_per_minute = limits.get('requests_per_minute', 100)
        current_count = len(requests)
        
        return current_count <= requests_per_minute, {
            'current_count': current_count,
            'limit': requests_per_minute,
            'window_size': window_size,
            'reset_time': current_time + window_size
        }

# Security decorators for Flask/FastAPI integration
def require_authentication(f):
    """Decorator to require authentication."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Implementation would check for valid JWT token
        # This is a simplified example
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return {'error': 'Authentication required'}, 401
        
        token = auth_header[7:]  # Remove 'Bearer ' prefix
        
        try:
            # Verify JWT token
            payload = jwt.decode(token, 'secret', algorithms=['HS256'])
            request.user = payload
        except jwt.InvalidTokenError:
            return {'error': 'Invalid token'}, 401
        
        return f(*args, **kwargs)
    
    return decorated_function

def require_permission(permission: str):
    """Decorator to require specific permission."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not hasattr(request, 'user'):
                return {'error': 'Authentication required'}, 401
            
            # Check permission (simplified)
            user_roles = request.user.get('roles', [])
            if 'admin' not in user_roles:
                return {'error': 'Insufficient permissions'}, 403
            
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator

def rate_limit(limit_type: str = 'global'):
    """Decorator for rate limiting."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Get identifier (IP address, user ID, etc.)
            identifier = request.remote_addr
            
            # Check rate limit
            rate_limiter = RateLimiter({})  # Would use actual config
            allowed, info = rate_limiter.check_rate_limit(identifier, limit_type)
            
            if not allowed:
                return {
                    'error': 'Rate limit exceeded',
                    'retry_after': info['reset_time']
                }, 429
            
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator

# Example usage demonstration
def demonstrate_security_features():
    """Demonstrate security features."""
    
    config = {
        'encryption': {
            'at_rest': {
                'algorithm': 'AES-256-GCM',
                'key_management': {
                    'provider': 'local',
                    'local': {'keyfile_path': './keys/master.key'}
                }
            }
        },
        'authentication': {
            'mfa': {'enabled': True},
            'jwt': {'algorithm': 'HS256', 'secret': 'test-secret'},
            'sessions': {'backend': 'memory', 'max_age': 3600}
        },
        'authorization': {
            'rbac': {
                'enabled': True,
                'roles': {
                    'admin': {'permissions': ['*']},
                    'user': {'permissions': ['profile.read', 'profile.update']}
                }
            }
        },
        'input_validation': {
            'strict_mode': True,
            'sanitization': {
                'html': {'allowed_tags': ['p', 'br']},
                'xss_protection': {'escape_html': True}
            }
        },
        'rate_limiting': {
            'global': {'requests_per_minute': 1000},
            'per_user': {'requests_per_minute': 100}
        }
    }
    
    print("Security Features Demo")
    print("=" * 50)
    
    # Encryption
    enc_manager = EncryptionManager(config)
    sensitive_data = "This is sensitive information"
    encrypted = enc_manager.encrypt_data(sensitive_data)
    decrypted = enc_manager.decrypt_data(encrypted)
    print(f"Encryption: {sensitive_data} -> {len(encrypted)} bytes -> {decrypted.decode()}")
    
    # Authentication
    auth_manager = AuthenticationManager(config['authentication'])
    # Would authenticate with real user credentials
    
    # Authorization
    authz_manager = AuthorizationManager(config['authorization'])
    user = {'user_id': 1, 'roles': ['user']}
    can_read = authz_manager.check_permission(user, 'profile.read')
    can_admin = authz_manager.check_permission(user, 'admin.delete')
    print(f"Authorization: user can read profile: {can_read}, can admin: {can_admin}")
    
    # Input validation
    validator = InputValidator(config['input_validation'])
    malicious_html = "<script>alert('xss')</script><p>Safe content</p>"
    sanitized = validator.validate_and_sanitize(malicious_html, 'html')
    print(f"Input validation: {malicious_html} -> {sanitized}")
    
    # Rate limiting
    rate_limiter = RateLimiter(config['rate_limiting'])
    allowed, info = rate_limiter.check_rate_limit('192.168.1.1', 'global')
    print(f"Rate limiting: allowed={allowed}, current_count={info['current_count']}")

if __name__ == "__main__":
    demonstrate_security_features()
</pre>

<p>TuskLang's comprehensive security framework provides enterprise-grade protection for Python applications with advanced encryption, authentication, authorization, and compliance capabilities.</p>