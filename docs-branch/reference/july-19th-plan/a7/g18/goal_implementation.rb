#!/usr/bin/env ruby
require 'digest';require 'json';require 'time'
class Block;attr_reader :index,:timestamp,:data,:previous_hash,:hash,:nonce;def initialize(index,data,previous_hash);@index=index;@timestamp=Time.now.to_f;@data=data;@previous_hash=previous_hash;@nonce=0;@hash=calculate_hash;end;def calculate_hash;Digest::SHA256.hexdigest("#{@index}#{@timestamp}#{@data}#{@previous_hash}#{@nonce}");end;def mine_block(difficulty);target="0"*difficulty;while @hash[0,difficulty]!=target;@nonce+=1;@hash=calculate_hash;end;puts "Block mined: #{@hash}";end;end
class Blockchain;def initialize;@chain=[create_genesis_block];@difficulty=2;@mining_reward=100;@pending_transactions=[];end;def create_genesis_block;Block.new(0,"Genesis Block","0");end;def get_latest_block;@chain.last;end;def add_transaction(transaction);@pending_transactions<<transaction;end;def mine_pending_transactions(mining_reward_address);reward_transaction={from:nil,to:mining_reward_address,amount:@mining_reward};@pending_transactions<<reward_transaction;block=Block.new(@chain.length,@pending_transactions,get_latest_block.hash);block.mine_block(@difficulty);@chain<<block;@pending_transactions=[];end;def get_balance(address);balance=0;@chain.each{|block|next if block.data=="Genesis Block";block.data.each{|tx|balance-=tx[:amount] if tx[:from]==address;balance+=tx[:amount] if tx[:to]==address}};balance;end;def is_chain_valid?;(1...@chain.length).each{|i|current_block=@chain[i];previous_block=@chain[i-1];return false if current_block.hash!=current_block.calculate_hash;return false if current_block.previous_hash!=previous_block.hash};true;end;end
class Cryptocurrency;def initialize(name,symbol);@name=name;@symbol=symbol;@blockchain=Blockchain.new;@wallets={};end;def create_wallet(address);@wallets[address]={address:address,balance:0,private_key:Digest::SHA256.hexdigest("#{address}#{Time.now}")};end;def transfer(from,to,amount);return false if get_balance(from)<amount;@blockchain.add_transaction({from:from,to:to,amount:amount,timestamp:Time.now});true;end;def mine_block(miner_address);@blockchain.mine_pending_transactions(miner_address);end;def get_balance(address);@blockchain.get_balance(address);end;end
class SmartContract;def initialize(code,address);@code=code;@address=address;@state={};@gas_limit=1000000;end;def execute(method,params={},gas=100000);return {error:"Insufficient gas"} if gas>@gas_limit;case method;when 'transfer';transfer_tokens(params[:from],params[:to],params[:amount]);when 'get_balance';{balance:@state[params[:address]]||0};when 'mint';@state[params[:to]]=(@state[params[:to]]||0)+params[:amount];{success:true};else;{error:"Unknown method"};end;end;private;def transfer_tokens(from,to,amount);from_balance=@state[from]||0;return {error:"Insufficient balance"} if from_balance<amount;@state[from]=from_balance-amount;@state[to]=(@state[to]||0)+amount;{success:true,from_balance:@state[from],to_balance:@state[to]};end;end
class BlockchainFramework;attr_reader :blockchain,:cryptocurrency,:contracts;def initialize;@blockchain=Blockchain.new;@cryptocurrency=Cryptocurrency.new("RubyCoin","RBC");@contracts={};end;def deploy_contract(name,code);contract=SmartContract.new(code,"contract_#{name}");@contracts[name]=contract;end;def execute_contract(name,method,params={});@contracts[name]&.execute(method,params)||{error:"Contract not found"};end;def full_transaction(from,to,amount);@cryptocurrency.transfer(from,to,amount);@cryptocurrency.mine_block(from);end;end
puts "G18 DONE!" if __FILE__==$0 