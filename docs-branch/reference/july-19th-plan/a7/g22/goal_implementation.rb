#!/usr/bin/env ruby
require 'matrix';require 'json'
class RobotKinematics;def initialize;@joints=[];@links=[];@dh_params=[];end;def add_joint(type,axis,limits={});@joints<<{type:type,axis:axis,limits:limits,angle:0,position:[0,0,0]};end;def add_link(length,offset=0);@links<<{length:length,offset:offset};end;def forward_kinematics(joint_angles);transforms=[];joint_angles.each_with_index{|angle,i|link=@links[i]||{length:1,offset:0};cos_a,sin_a=Math.cos(angle),Math.sin(angle);transform=Matrix[[cos_a,-sin_a,0,link[:length]*cos_a],[sin_a,cos_a,0,link[:length]*sin_a],[0,0,1,link[:offset]],[0,0,0,1]];transforms<<transform};end_effector=transforms.reduce(Matrix.identity(4)){|acc,t|acc*t};{position:[end_effector[0,3],end_effector[1,3],end_effector[2,3]],orientation:end_effector[0..2,0..2]};end;def inverse_kinematics(target_pos,target_orient=nil);angles=Array.new(@joints.length,0.0);10.times{current=forward_kinematics(angles);error=[target_pos[0]-current[:position][0],target_pos[1]-current[:position][1],target_pos[2]-current[:position][2]];break if error.map(&:abs).max<0.01;angles.each_with_index{|a,i|angles[i]+=error[i%3]*0.1}};angles;end;end
class PathPlanner;def initialize;@obstacles=[];@waypoints=[];end;def add_obstacle(center,radius);@obstacles<<{center:center,radius:radius};end;def a_star_search(start,goal,grid_size=100);open_set=[{pos:start,g:0,h:distance(start,goal),f:distance(start,goal),parent:nil}];closed_set=[];while !open_set.empty?;current=open_set.min_by{|n|n[:f]};return reconstruct_path(current) if current[:pos]==goal;open_set.delete(current);closed_set<<current;neighbors(current[:pos],grid_size).each{|neighbor|next if closed_set.any?{|n|n[:pos]==neighbor}||collision?(neighbor);g_score=current[:g]+distance(current[:pos],neighbor);existing=open_set.find{|n|n[:pos]==neighbor};if !existing||g_score<existing[:g];h_score=distance(neighbor,goal);node={pos:neighbor,g:g_score,h:h_score,f:g_score+h_score,parent:current};existing ? (existing.merge!(node)) : (open_set<<node);end}end;[];end;def rrt_planning(start,goal,max_iterations=1000);tree=[start];max_iterations.times{random_point=[rand*100,rand*100];nearest=tree.min_by{|p|distance(p,random_point)};direction=[(random_point[0]-nearest[0]),(random_point[1]-nearest[1])];magnitude=Math.sqrt(direction[0]**2+direction[1]**2);next if magnitude==0;step_size=5;new_point=[nearest[0]+direction[0]/magnitude*step_size,nearest[1]+direction[1]/magnitude*step_size];next if collision?(new_point);tree<<new_point;return tree if distance(new_point,goal)<step_size};tree;end;private;def distance(p1,p2);Math.sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2);end;def neighbors(pos,grid_size);[[pos[0]+1,pos[1]],[pos[0]-1,pos[1]],[pos[0],pos[1]+1],[pos[0],pos[1]-1]].select{|p|p[0]>=0&&p[0]<grid_size&&p[1]>=0&&p[1]<grid_size};end;def collision?(point);@obstacles.any?{|obs|distance(point,obs[:center])<=obs[:radius]};end;def reconstruct_path(node);path=[];while node;path.unshift(node[:pos]);node=node[:parent];end;path;end;end
class SensorFusion;def initialize;@sensors={};@kalman_filter={x:0,P:1,Q:0.1,R:1};end;def add_sensor(name,type,accuracy,update_rate);@sensors[name]={type:type,accuracy:accuracy,update_rate:update_rate,last_reading:nil,timestamp:Time.now};end;def update_sensor(name,value);return unless @sensors[name];@sensors[name][:last_reading]=value;@sensors[name][:timestamp]=Time.now;end;def fuse_sensor_data;fused_data={};@sensors.each{|name,sensor|next unless sensor[:last_reading];weight=1.0/sensor[:accuracy];fused_data[sensor[:type]]||={value:0,total_weight:0};fused_data[sensor[:type]][:value]+=sensor[:last_reading]*weight;fused_data[sensor[:type]][:total_weight]+=weight};fused_data.transform_values{|data|data[:value]/data[:total_weight]};end;def kalman_filter_update(measurement);prediction=@kalman_filter[:x];prediction_covariance=@kalman_filter[:P]+@kalman_filter[:Q];innovation=measurement-prediction;innovation_covariance=prediction_covariance+@kalman_filter[:R];kalman_gain=prediction_covariance/innovation_covariance;@kalman_filter[:x]=prediction+kalman_gain*innovation;@kalman_filter[:P]=(1-kalman_gain)*prediction_covariance;@kalman_filter[:x];end;def imu_integration(accel,gyro,dt=0.01);@velocity||=[0,0,0];@position||=[0,0,0];@orientation||=[0,0,0];@velocity[0]+=accel[0]*dt;@velocity[1]+=accel[1]*dt;@velocity[2]+=accel[2]*dt;@position[0]+=@velocity[0]*dt;@position[1]+=@velocity[1]*dt;@position[2]+=@velocity[2]*dt;@orientation[0]+=gyro[0]*dt;@orientation[1]+=gyro[1]*dt;@orientation[2]+=gyro[2]*dt;{position:@position.dup,velocity:@velocity.dup,orientation:@orientation.dup};end;end
class AutonomousNavigation;def initialize;@current_pose={x:0,y:0,theta:0};@goal_pose=nil;@path=[];@path_index=0;end;def set_goal(x,y,theta=0);@goal_pose={x:x,y:y,theta:theta};end;def update_pose(x,y,theta);@current_pose={x:x,y:y,theta:theta};end;def pure_pursuit_control(lookahead_distance=2.0);return {linear:0,angular:0} if @path.empty?||@path_index>=@path.length;target_point=@path[@path_index];distance_to_target=Math.sqrt((@current_pose[:x]-target_point[0])**2+(@current_pose[:y]-target_point[1])**2);@path_index+=1 if distance_to_target<0.5&&@path_index<@path.length-1;target_point=@path[@path_index] if @path_index<@path.length;angle_to_target=Math.atan2(target_point[1]-@current_pose[:y],target_point[0]-@current_pose[:x]);angle_error=angle_to_target-@current_pose[:theta];angle_error=((angle_error+Math::PI)%(2*Math::PI))-Math::PI;curvature=2*Math.sin(angle_error)/lookahead_distance;linear_velocity=[1.0,distance_to_target].min;angular_velocity=curvature*linear_velocity;{linear:linear_velocity,angular:angular_velocity};end;def dwa_planning(obstacles,dt=0.1);best_velocity={linear:0,angular:0};best_score=-Float::INFINITY;linear_velocities=(0..2).step(0.2);angular_velocities=(-1..1).step(0.2);linear_velocities.each{|v_lin|angular_velocities.each{|v_ang|trajectory=simulate_trajectory(v_lin,v_ang,dt,20);next if collision_check(trajectory,obstacles);score=evaluate_trajectory(trajectory);if score>best_score;best_score=score;best_velocity={linear:v_lin,angular:v_ang};end}};best_velocity;end;def obstacle_avoidance(obstacles,safety_distance=1.0);forces={x:0,y:0};obstacles.each{|obs|dx=@current_pose[:x]-obs[:x];dy=@current_pose[:y]-obs[:y];distance=Math.sqrt(dx**2+dy**2);next if distance>safety_distance*2;repulsion_strength=safety_distance/distance;forces[:x]+=repulsion_strength*dx/distance;forces[:y]+=repulsion_strength*dy/distance};if @goal_pose;gdx=@goal_pose[:x]-@current_pose[:x];gdy=@goal_pose[:y]-@current_pose[:y];goal_distance=Math.sqrt(gdx**2+gdy**2);attraction_strength=0.5;forces[:x]+=attraction_strength*gdx/goal_distance if goal_distance>0;forces[:y]+=attraction_strength*gdy/goal_distance if goal_distance>0;end;angle=Math.atan2(forces[:y],forces[:x]);magnitude=[Math.sqrt(forces[:x]**2+forces[:y]**2),2.0].min;{linear:magnitude,angular:angle-@current_pose[:theta]};end;private;def simulate_trajectory(v_lin,v_ang,dt,steps);trajectory=[];x,y,theta=@current_pose[:x],@current_pose[:y],@current_pose[:theta];steps.times{x+=v_lin*Math.cos(theta)*dt;y+=v_lin*Math.sin(theta)*dt;theta+=v_ang*dt;trajectory<<[x,y,theta]};trajectory;end;def collision_check(trajectory,obstacles);trajectory.any?{|point|obstacles.any?{|obs|Math.sqrt((point[0]-obs[:x])**2+(point[1]-obs[:y])**2)<=obs[:radius]}};end;def evaluate_trajectory(trajectory);return 0 if trajectory.empty?;end_point=trajectory.last;goal_distance=@goal_pose ? Math.sqrt((end_point[0]-@goal_pose[:x])**2+(end_point[1]-@goal_pose[:y])**2) : 0;1.0/(1.0+goal_distance);end;end
class RoboticsFramework;attr_reader :kinematics,:planner,:sensors,:navigation;def initialize;@kinematics=RobotKinematics.new;@planner=PathPlanner.new;@sensors=SensorFusion.new;@navigation=AutonomousNavigation.new;setup_default_robot;end;def setup_default_robot;@kinematics.add_joint('revolute',[0,0,1],{min:-Math::PI,max:Math::PI});@kinematics.add_joint('revolute',[0,0,1],{min:-Math::PI/2,max:Math::PI/2});@kinematics.add_joint('prismatic',[0,0,1],{min:0,max:2});@kinematics.add_link(1.0);@kinematics.add_link(0.8);@kinematics.add_link(0.5);@sensors.add_sensor('lidar','distance',0.1,10);@sensors.add_sensor('camera','vision',0.2,30);@sensors.add_sensor('imu','orientation',0.05,100);end;def autonomous_mission(start_pos,goal_pos,obstacles=[]);@navigation.update_pose(start_pos[0],start_pos[1],start_pos[2]||0);@navigation.set_goal(goal_pos[0],goal_pos[1],goal_pos[2]||0);obstacles.each{|obs|@planner.add_obstacle(obs[:center],obs[:radius])};path=@planner.a_star_search(start_pos[0..1],goal_pos[0..1]);@navigation.instance_variable_set(:@path,path);control_commands=[];20.times{sensor_data=@sensors.fuse_sensor_data;control=@navigation.pure_pursuit_control;avoidance=@navigation.obstacle_avoidance(obstacles);final_control={linear:[control[:linear],avoidance[:linear]].min,angular:control[:angular]+avoidance[:angular]*0.3};control_commands<<final_control};control_commands;end;def manipulator_task(target_position,target_orientation=nil);joint_angles=@kinematics.inverse_kinematics(target_position,target_orientation);end_effector_pose=@kinematics.forward_kinematics(joint_angles);{joint_angles:joint_angles,end_effector:end_effector_pose,success:true};end;end
puts "G22 ROBOTICS DONE!" if __FILE__==$0 